----strat of file D:\projects\cg\cg-min\src\main\java\app\Main.java---
package app;
import codegen.complexobj.CodeGenContext;
import codegen.eclipseRobot.UIController;
import java.io.*;
public class Main {
	public static byte[] bytes = null;
	public static void setBytes(byte[] abytes) throws FileNotFoundException {
		bytes = abytes;
	}
	public static void write(File f, String fileStr) throws IOException {
		FileOutputStream fos = new FileOutputStream(f);
		fos.write(fileStr.getBytes());
		fos.flush();
		fos.close();
	}
	public static void main(String[] args) throws FileNotFoundException {
		StringBuilder sb = new StringBuilder();
		if (null != args && args.length > 0) {
			System.out.println(args[0]);
			for (String p : args) {
				String sArray[] = p.split("=");
				if (sArray[0].startsWith("-D")) {
					String propName = sArray[0].replaceFirst("-D", "");
					System.setProperty(propName, sArray[1]);
				}
				sb.append(String.format("set property %s, %s", sArray[0], sArray[1]));
			}
		}
		if (bytes != null) {
			CodeGenContext codeGenContext = CodeGenContext.getInstance();
			codeGenContext.setAppBytes(bytes);
		}
		String s = System.getProperty(codegen.Const.OUTPUT_SYS_PROPERTY_NAME);
		if (s != null) {
			File f = new File(s);
			File parentFile = f.getParentFile();
			if (!parentFile.exists()) {
				parentFile.mkdirs();
			}
			if (!f.exists()) {
			}
			if (parentFile.exists()) {
				FileOutputStream fileOutputStream = new FileOutputStream(f);
				BufferedOutputStream bufferedOutputStream = new BufferedOutputStream(fileOutputStream);
				PrintStream printStream = new PrintStream(bufferedOutputStream, true);
				System.setOut(printStream);
				System.setErr(printStream);
				System.out.println(String.format("setting log file as %s", f.getAbsolutePath()));
			}
		}
		UIController c = new UIController();
		c.start();
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\clipboardclient\AbstractClipboardMonitor.java---
package clipboardclient;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.ServerSocket;
import java.net.Socket;
public abstract class AbstractClipboardMonitor {
	private String host;
	private int port;
	private static int defaultPort = 8888;
	public String getHost() {
		return host;
	}
	public void setHost(String host) {
		this.host = host;
	}
	public int getPort() {
		return port;
	}
	public void setPort(int port) {
		this.port = port;
	}
	ServerSocket ss;
	public AbstractClipboardMonitor() {
		super();
	}
	public AbstractClipboardMonitor(int port) {
		super();
		this.port = port;
	}
	protected abstract void onChange(String content) throws Exception;
	public synchronized void start() {
		while (true) {
			try {
				try {
					ss = new ServerSocket(defaultPort);
				} catch (Exception e1) {
					ss = new ServerSocket(0);
				}
				this.port = ss.getLocalPort();
				Socket s = ss.accept();
				InputStream is = s.getInputStream();
				OutputStream os = s.getOutputStream();
				ByteArrayOutputStream bos = new ByteArrayOutputStream();
				try {
					do {
						byte[] buffer = new byte[1024];
						is.read(buffer);
						bos.write(buffer);
					} while (is.available() > 0);
					byte[] allBy = bos.toByteArray();
					String content = new String(allBy, "UTF-8");
					os.write(new byte[] { 1 });
					os.flush();
					try {
						onChange(content);
					} catch (Exception e) {
						System.out.println("clipboard content change handle throws exception");
					}
				} catch (IOException e) {
				}
			} catch (IOException e) {
				e.printStackTrace();
			} finally {
				close();
			}
		}
	}
	public synchronized void close() {
		if (ss != null) {
			try {
				ss.close();
			} catch (IOException e) {
				e.printStackTrace();
			}
		}
	}
	public static void main(String[] args) {
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\clipboardclient\ClientSocketManager.java---
package clipboardclient;
import java.net.Socket;
import java.util.ArrayList;
import java.util.List;
public class ClientSocketManager implements Runnable {
  List<Socket> socketClientList = new ArrayList<>();
  @Override
  public void run() {
  }
}
----strat of file D:\projects\cg\cg-min\src\main\java\clipboardclient\ConcreteClipboardMonitor.java---
package clipboardclient;
import java.util.ArrayList;
public class ConcreteClipboardMonitor extends AbstractClipboardMonitor implements Runnable {
  private ArrayList<IClipboardObserver> observers;
  public ConcreteClipboardMonitor() {
    super();
    observers = new ArrayList<IClipboardObserver>();
  }
  public ConcreteClipboardMonitor(int port) {
    super(port);
    observers = new ArrayList<IClipboardObserver>();
  }
  /**
   * Register an observer.
   * 
   * @param observer
   */
  public void addObserver(IClipboardObserver observer) {
    observers.add(observer);
  }
  /**
   * Remove an observer from list.
   * 
   * @param observer
   */
  public void removeObserver(IClipboardObserver observer) {
    int i = observers.indexOf(observer);
    if (i >= 0)
      observers.remove(i);
  }
  @Override
  protected void onChange(String content) {
    if (observers != null) {
      for (IClipboardObserver observer : observers) {
        observer.onUpdate(content);
      }
    }
  }
  @Override
  public synchronized void start() {
    Thread t1 = new Thread(this, "clip board monitor");
    t1.start();
  }
  @Override
  public void run() {
    super.start();
  }
}
----strat of file D:\projects\cg\cg-min\src\main\java\clipboardclient\IClipboardObserver.java---
package clipboardclient;
public interface IClipboardObserver {
  public void onUpdate(String content);
}
----strat of file D:\projects\cg\cg-min\src\main\java\codegen\AbstractConcreteClassMapping.java---
package codegen;
import java.lang.reflect.Method;
public class AbstractConcreteClassMapping {
	Class abstractClass;
	String abstractClassInstanceName;
	Class concreteClass;
	String concreteClassInstanceName;
	Method concreteCFactoryMethod;
	/** support $ symbol **/
	String methodParamVariables[];
	public Class getAbstractClass() {
		return abstractClass;
	}
	public void setAbstractClass(Class abstractClass) {
		this.abstractClass = abstractClass;
	}
	public String getAbstractClassInstanceName() {
		return abstractClassInstanceName;
	}
	public void setAbstractClassInstanceName(String abstractClassInstanceName) {
		this.abstractClassInstanceName = abstractClassInstanceName;
	}
	public Class getConcreteClass() {
		return concreteClass;
	}
	public void setConcreteClass(Class concreteClass) {
		this.concreteClass = concreteClass;
	}
	public String getConcreteClassInstanceName() {
		return concreteClassInstanceName;
	}
	public void setConcreteClassInstanceName(String concreteClassInstanceName) {
		this.concreteClassInstanceName = concreteClassInstanceName;
	}
	public Method getConcreteCFactoryMethod() {
		return concreteCFactoryMethod;
	}
	public void setConcreteCFactoryMethod(Method concreteCFactoryMethod) {
		this.concreteCFactoryMethod = concreteCFactoryMethod;
	}
	public String[] getMethodParamVariables() {
		return methodParamVariables;
	}
	public void setMethodParamVariables(String[] methodParamVariables) {
		this.methodParamVariables = methodParamVariables;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\codegen\complexobj\CodeGenContext.java---
package codegen.complexobj;
import codegen.AbstractConcreteClassMapping;
import codegen.MethodMatcher;
import codegen.unittest.MethodCallingVariable;
import codegen.util.Common;
import codegen.util.MethodCallingKey;
import qj.util.lang.ReloadableDynamicClassLoaderOwner;
import java.io.BufferedReader;
import java.io.File;
import java.io.IOException;
import java.io.InputStreamReader;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.net.URL;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
public class CodeGenContext {
	public byte[] appBytes;
	boolean genFullQualifierName;
	private static String mavenHome = System.getProperty("mavenHome");
	private static String localRepoDir = System.getProperty("repositoryPath");
	private static String CGKeyAppPath;
	private static String IDEProcNameKeyword;
	File pomFile;
	List<String> jrePrimitiveTypes;
	List<String> jreClasses;
	ReloadableDynamicClassLoaderOwner reloadableDynamicClassLoaderOwner;
	StringBuilder packageSB;
	StringBuilder importSB;
	StringBuilder fieldsSB;
	StringBuilder setupSB;
	StringBuilder allTestCaseSB;
	StringBuilder createdComplexTypeMethod;
	StringBuilder addtionalMethods;
	List<String> createdMethodName;
	Map<String, String> variableMap;
	List<Class> alreadyImportClasses;
	Map<Class, String> classSimpleNameMap;
	Map<Class<?>, Short> sameTypeCreatedTimesMap;
	Map<MethodCallingKey, MethodCallingVariable> complexTypeCreateMapping;
	public List<Field> allFieldList;
	/**
	 * global param
	 **/
	private Map<Class<?>, AbstractConcreteClassMapping> abstractConcreteClassMap;
	Map<Class, MethodMatcher> methodMatchers;
	List<URL> loadedJarList = new ArrayList<>();
	List<Class> attachedClzList;
	private static CodeGenContext codeGenContext;
	private int clipBoardMonitorServerPort;
	private static List<String> memoryAreas;
	Map<Class<?>, Object> uiModelMap;
	private Map<String, Object> paramPossibleValsMap;
	public CodeGenContext() {
		init();
	}
	public static CodeGenContext getInstance() {
		if (codeGenContext == null) {
			return newInstance();
		} else {
			return codeGenContext;
		}
	}
	public static CodeGenContext newInstance() {
		CodeGenContext context = new CodeGenContext();
		context.init();
		codeGenContext = context;
		return context;
	}
	public void init() {
		packageSB = new StringBuilder();
		importSB = new StringBuilder();
		fieldsSB = new StringBuilder();
		setupSB = new StringBuilder();
		allTestCaseSB = new StringBuilder();
		createdComplexTypeMethod = new StringBuilder();
		addtionalMethods = new StringBuilder();
		createdMethodName = new ArrayList<>();
		variableMap = Common.createVariableMap();
		alreadyImportClasses = new ArrayList<Class>();
		classSimpleNameMap = new HashMap<>();
		complexTypeCreateMapping = new HashMap<>();
		allFieldList = new ArrayList<>();
		abstractConcreteClassMap = new HashMap<>();
		methodMatchers = new HashMap<>();
		sameTypeCreatedTimesMap = new HashMap<>();
		attachedClzList = new ArrayList<Class>();
		reloadableDynamicClassLoaderOwner = new ReloadableDynamicClassLoaderOwner();
		jreClasses = new ArrayList<>();
		jrePrimitiveTypes = Arrays
				.asList("int", "boolean", "long", "double", "short", "float",
						"byte", "char");
		uiModelMap = new HashMap<>();
		paramPossibleValsMap = new HashMap<String, Object>();
		memoryAreas = new ArrayList<>();
	}
	public void clearExceptGlobalParam() {
		packageSB.delete(0, packageSB.length());
		importSB.delete(0, importSB.length());
		fieldsSB.delete(0, fieldsSB.length());
		setupSB.delete(0, setupSB.length());
		allTestCaseSB.delete(0, allTestCaseSB.length());
		createdComplexTypeMethod.delete(0, createdComplexTypeMethod.length());
		addtionalMethods.delete(0, addtionalMethods.length());
		createdMethodName.clear();
		variableMap = Common.createVariableMap();
		alreadyImportClasses.clear();
		classSimpleNameMap.clear();
		complexTypeCreateMapping.clear();
		allFieldList.clear();
		methodMatchers.clear();
		sameTypeCreatedTimesMap.clear();
		paramPossibleValsMap.clear();
	}
	public void clear() {
		clearExceptGlobalParam();
		/** global param **/
		abstractConcreteClassMap.clear();
		methodMatchers.clear();
		attachedClzList.clear();
	}
	public void extractJREClassesByJavaVerbose() {
		try {
			Process p = Runtime.getRuntime()
					.exec("java -verbose --show-version");
			StringBuilder sb = new StringBuilder();
			BufferedReader in = null;
			try {
				in = new BufferedReader(
						new InputStreamReader(p.getInputStream()));
				String line = null;
				while ((line = in.readLine()) != null) {
					sb.append(line).append("\r\n");
				}
			} catch (IOException e) {
				e.printStackTrace();
				throw e;
			} finally {
				if (in != null)
					try {
						in.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
			}
			String output = sb.toString();
			Pattern pattern = Pattern
					.compile("\\[class,load\\]\\s*([\\w\\.\\$]+)[ ]+source:");
			Matcher matcher = pattern.matcher(output);
			while (matcher.find()) {
				String className = matcher.group(1);
				try {
					Class c = Class.forName(className, false,
							this.getClass().getClassLoader());
					if (null == c.getCanonicalName()) {
						System.out.print(c);
					} else {
						jreClasses.add(c.getCanonicalName());
					}
				} catch (ClassNotFoundException e) {
					e.printStackTrace();
				}
			}
		} catch (IOException e) {
			e.printStackTrace();
		}
		System.out.print(jreClasses.size());
	}
	public void renewSameTypeCreatedTimesMap() {
		sameTypeCreatedTimesMap.clear();
	}
	public void registerAbstractConcreteClassMappingSimple(
			Class<?> abstractClass, Class<?> concreteClass) {
		registerAbstractConcreteClassMappingSimple(abstractClass, concreteClass,
				(Method) null, null);
	}
	public void registerAbstractConcreteClassMappingSimple(
			Class<?> abstractClass, Class<?> concreteClass,
			String factoryMethodName) {
		registerAbstractConcreteClassMappingSimple(abstractClass, concreteClass,
				factoryMethodName, null);
	}
	public void registerAbstractConcreteClassMappingSimple(
			Class<?> abstractClass, Class<?> concreteClass,
			String factoryMethodName, String methodParamVariables[]) {
		Method ms[] = Common.getAllDeclaredPublicMethodsForTest(concreteClass);
		for (Method m : ms) {
			if (m.getName().equals(factoryMethodName)) {
				registerAbstractConcreteClassMappingSimple(abstractClass,
						concreteClass, m, methodParamVariables);
				break;
			}
		}
	}
	public void registerAbstractConcreteClassMappingSimple(
			Class<?> abstractClass, Class<?> concreteClass,
			Method factoryMethod, String methodParamVariables[]) {
		AbstractConcreteClassMapping mapping = new AbstractConcreteClassMapping();
		mapping.setAbstractClass(abstractClass);
		mapping.setConcreteClass(concreteClass);
		if (factoryMethod != null) {
			mapping.setConcreteCFactoryMethod(factoryMethod);
			if (factoryMethod.getParameterCount() > 0)
				mapping.setMethodParamVariables(methodParamVariables);
		}
		register(mapping);
	}
	public void register(
			AbstractConcreteClassMapping abstractConcreteClassMapping) {
		abstractConcreteClassMap
				.put(abstractConcreteClassMapping.getAbstractClass(),
						abstractConcreteClassMapping);
	}
	public void resetVariableMap() {
		variableMap = Common.createVariableMap();
	}
	public Map<Class<?>, AbstractConcreteClassMapping> getAbstractConcreteClassMap() {
		return abstractConcreteClassMap;
	}
	public void setAbstractConcreteClassMap(
			Map<Class<?>, AbstractConcreteClassMapping> abstractConcreteClassMap) {
		this.abstractConcreteClassMap = abstractConcreteClassMap;
	}
	public List<String> getCreatedMethodName() {
		return createdMethodName;
	}
	public void setCreatedMethodName(List<String> createdMethodName) {
		this.createdMethodName = createdMethodName;
	}
	public Map<String, String> getVariableMap() {
		return variableMap;
	}
	public void setVariableMap(Map<String, String> variableMap) {
		this.variableMap = variableMap;
	}
	public List<Class> getAlreadyImportClasses() {
		return alreadyImportClasses;
	}
	public void setAlreadyImportClasses(List<Class> alreadyImportClasses) {
		this.alreadyImportClasses = alreadyImportClasses;
	}
	public Map<Class, String> getClassSimpleNameMap() {
		return classSimpleNameMap;
	}
	public void setClassSimpleNameMap(Map<Class, String> classSimpleNameMap) {
		this.classSimpleNameMap = classSimpleNameMap;
	}
	public Map<MethodCallingKey, MethodCallingVariable> getComplexTypeCreateMapping() {
		return complexTypeCreateMapping;
	}
	public void setComplexTypeCreateMapping(
			Map<MethodCallingKey, MethodCallingVariable> complexTypeCreateMapping) {
		this.complexTypeCreateMapping = complexTypeCreateMapping;
	}
	public List<Field> getAllFieldList() {
		return allFieldList;
	}
	public void setAllFieldList(List<Field> allFieldList) {
		this.allFieldList = allFieldList;
	}
	public StringBuilder getPackageSB() {
		return packageSB;
	}
	public void setPackageSB(StringBuilder packageSB) {
		this.packageSB = packageSB;
	}
	public StringBuilder getImportSB() {
		return importSB;
	}
	public void setImportSB(StringBuilder importSB) {
		this.importSB = importSB;
	}
	public StringBuilder getFieldsSB() {
		return fieldsSB;
	}
	public void setFieldsSB(StringBuilder fieldsSB) {
		this.fieldsSB = fieldsSB;
	}
	public StringBuilder getSetupSB() {
		return setupSB;
	}
	public void setSetupSB(StringBuilder setupSB) {
		this.setupSB = setupSB;
	}
	public StringBuilder getAllTestCaseSB() {
		return allTestCaseSB;
	}
	public void setAllTestCaseSB(StringBuilder allTestCaseSB) {
		this.allTestCaseSB = allTestCaseSB;
	}
	public StringBuilder getCreatedComplexTypeMethod() {
		return createdComplexTypeMethod;
	}
	public void setCreatedComplexTypeMethod(
			StringBuilder createdComplexTypeMethod) {
		this.createdComplexTypeMethod = createdComplexTypeMethod;
	}
	public StringBuilder getAddtionalMethods() {
		return addtionalMethods;
	}
	public void setAddtionalMethods(StringBuilder addtionalMethods) {
		this.addtionalMethods = addtionalMethods;
	}
	public Map<Class, MethodMatcher> getMethodMatchers() {
		return methodMatchers;
	}
	public Map<Class<?>, Short> getSameTypeCreatedTimesMap() {
		return sameTypeCreatedTimesMap;
	}
	public void setSameTypeCreatedTimesMap(
			Map<Class<?>, Short> sameTypeCreatedTimesMap) {
		this.sameTypeCreatedTimesMap = sameTypeCreatedTimesMap;
	}
	public boolean isGenFullQualifierName() {
		return genFullQualifierName;
	}
	public void setGenFullQualifierName(boolean genFullQualifierName) {
		this.genFullQualifierName = genFullQualifierName;
	}
	public void setMethodMatchers(Map<Class, MethodMatcher> methodMatchers) {
		this.methodMatchers = methodMatchers;
	}
	public static String getLocalRepoDir() {
		return localRepoDir;
	}
	public static void setLocalRepoDir(String localRepoDir) {
		CodeGenContext.localRepoDir = localRepoDir;
	}
	public static String getPathRegex() {
		String pathRegex = File.separator;
		if ("\\".equals(pathRegex)) {
			pathRegex = "\\\\";
		}
		return pathRegex;
	}
	public List<String> getLoadedClassesName() {
		List<String> loadedClassesName = new ArrayList<>();
		loadedClassesName.add("");
		loadedClassesName.addAll(this.jrePrimitiveTypes);
		if (null != this.reloadableDynamicClassLoaderOwner
				.getDirDynamicClassLoader()) {
			loadedClassesName.addAll(this.reloadableDynamicClassLoaderOwner
					.getDirDynamicClassLoader().getAllClassNamesInDir());
		}
		loadedClassesName.addAll(this.jreClasses);
		if (null != this.reloadableDynamicClassLoaderOwner
				.getJarDynamicClassLoader()) {
			loadedClassesName.addAll(this.reloadableDynamicClassLoaderOwner
					.getJarDynamicClassLoader().getAllClassNamesInJar());
		} else {
		}
		return loadedClassesName;
	}
	public int getClipBoardMonitorServerPort() {
		return clipBoardMonitorServerPort;
	}
	public void setClipBoardMonitorServerPort(int clipBoardMonitorServerPort) {
		this.clipBoardMonitorServerPort = clipBoardMonitorServerPort;
	}
	public List<Class> getAttachedClzList() {
		return attachedClzList;
	}
	public Map<Class<?>, Object> getUiModelMap() {
		return uiModelMap;
	}
	public static String getMavenHome() {
		return mavenHome;
	}
	public static void setMavenHome(String mavenHome) {
		CodeGenContext.mavenHome = mavenHome;
	}
	public byte[] getAppBytes() {
		return appBytes;
	}
	public void setAppBytes(byte[] appBytes) {
		this.appBytes = appBytes;
	}
	public ReloadableDynamicClassLoaderOwner getReloadableDynamicClassLoaderOwner() {
		return reloadableDynamicClassLoaderOwner;
	}
	public void setReloadableDynamicClassLoaderOwner(
			ReloadableDynamicClassLoaderOwner reloadableDynamicClassLoaderOwner) {
		this.reloadableDynamicClassLoaderOwner = reloadableDynamicClassLoaderOwner;
	}
	public List<String> getJreClasses() {
		return jreClasses;
	}
	public void setJreClasses(List<String> jreClasses) {
		this.jreClasses = jreClasses;
	}
	public File getPomFile() {
		return pomFile;
	}
	public void setPomFile(File pomFile) {
		this.pomFile = pomFile;
	}
	public List<String> getJrePrimitiveTypes() {
		return jrePrimitiveTypes;
	}
	public static List<String> getMemoryAreas() {
		return memoryAreas;
	}
	public Map<String, Object> getParamPossibleValsMap() {
		return paramPossibleValsMap;
	}
	public static void setCGKeyAppPath(String cgKeyAppPath) {
		CodeGenContext.CGKeyAppPath = cgKeyAppPath;
	}
	public static String getCGKeyAppPath() {
		return CGKeyAppPath;
	}
	public static String getIDEProcNameKeyword() {
		return IDEProcNameKeyword;
	}
	public static void setIDEProcNameKeyword(String IDEProcNameKeyword) {
		CodeGenContext.IDEProcNameKeyword = IDEProcNameKeyword;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\codegen\complexobj\PojoSetterGenerator.java---
package codegen.complexobj;
import codegen.AbstractConcreteClassMapping;
import codegen.Replacement;
import codegen.Syntax;
import codegen.util.Common;
import objinit.ObjWithDefaultValCreator;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.lang.reflect.Parameter;
import java.util.*;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Collectors;
public class PojoSetterGenerator {
	private static StringBuilder allSetSB = new StringBuilder();
	private static final int START_DEEP_INDEX = 1;
	private static List<String> concernedPackageNames = new ArrayList<String>();
	private static List<ClzRefDeep> deepList = new ArrayList<ClzRefDeep>();
	public static List<String> allFieldList = new ArrayList<String>();
	private static CodeGenContext context;
	public static List<Class> calcedList = new ArrayList<>();
	public static Map<Class, AtomicInteger> circularDependencyClz = new HashMap<>();
	public static void init() {
	}
	public static void clear() {
		allSetSB = new StringBuilder();
		calcedList.clear();
		circularDependencyClz.clear();
		concernedPackageNames.clear();
		deepList.clear();
		allFieldList.clear();
		context.getSameTypeCreatedTimesMap().clear();
	}
	public static String getInstanceName(Class c) {
		return Common.getInstanceName(c);
	}
	public static String printAllListFields(Class c) {
		if (c.getSimpleName().equals("String") || c.getSimpleName().equals("Integer")
				|| c.getSimpleName().equals("Long")) {
			return "";
		}
		String instanceName = getInstanceName(c);
		StringBuilder sb = new StringBuilder();
		Field fArray[] = c.getDeclaredFields();
		List<Field> fList = (List) Arrays.asList(fArray);
		fList.forEach(f -> {
			String simpleName = f.getType().getSimpleName();
			String genericTypeName = f.getGenericType().getTypeName();
			if (genericTypeName.startsWith("java.util.List")) {
				String genericType = null;
				String genericTypeNameForPrint = null;
				int start = genericTypeName.indexOf("<");
				int end = genericTypeName.indexOf(">");
				genericType = genericTypeName.substring(start + 1, end);
				genericTypeNameForPrint = genericType.replaceAll("\\$", "\\.");
				String listName = null;
				try {
					listName = getInstanceName(CodeGenContext.getInstance().getReloadableDynamicClassLoaderOwner()
							.loadClass(genericType, true)) + "List";
				} catch (Exception e1) {
					e1.printStackTrace();
				}
				StringBuilder refType = new StringBuilder();
				refType.append("List<").append(genericTypeNameForPrint).append("> ").append(listName).append("=")
						.append(" new ").append(" ArrayList<").append(genericTypeNameForPrint).append(">();\r\n");
				allSetSB.append(refType.toString());
			}
		});
		return sb.toString();
	}
	public class ClzRefDeep<T> {
		int i;
		Class<T> c;
		Class genericTypes[];
		boolean hasCollectionReturn;
		public int getI() {
			return i;
		}
		public void setI(int i) {
			this.i = i;
		}
		public Class<T> getC() {
			return c;
		}
		public void setC(Class<T> c) {
			this.c = c;
		}
		public boolean isHasCollectionReturn() {
			return hasCollectionReturn;
		}
		public void setHasCollectionReturn(boolean hasCollectionReturn) {
			this.hasCollectionReturn = hasCollectionReturn;
		}
		public Class[] getGenericTypes() {
			return genericTypes;
		}
		public void setGenericTypes(Class[] genericTypes) {
			this.genericTypes = genericTypes;
		}
		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;
			result = prime * result + ((c == null) ? 0 : c.hashCode());
			result = prime * result + Arrays.hashCode(genericTypes);
			result = prime * result + i;
			return result;
		}
		@Override
		public boolean equals(Object obj) {
			if (this == obj)
				return true;
			if (obj == null)
				return false;
			if (getClass() != obj.getClass())
				return false;
			ClzRefDeep other = (ClzRefDeep) obj;
			/*
			 * if (!getOuterType().equals(other.getOuterType())) return false;
			 */
			if (c == null) {
				if (other.c != null)
					return false;
			} else if (!c.equals(other.c))
				return false;
			if (!Arrays.equals(genericTypes, other.genericTypes))
				return false;
			if (i != other.i)
				return false;
			return true;
		}
		/*
		 * private ObjSetCodeGenAfterCreateMethod getOuterType() { return
		 * ObjSetCodeGenAfterCreateMethod.this; }
		 */
	}
	public static boolean containsIgnoreCase(Collection<String> coll, final String val) {
		return coll.stream().anyMatch(e -> {
			boolean b = e.equalsIgnoreCase(val);
			return b;
		});
	}
	public static String getClassCreateStr(Class c) {
		if (c.isEnum()) {
			return Common.getEnumCreateStr(c);
		} else if (c.isArray()) {
			return getObjCreateStrWithNew(c);
		} else {
			return getObjCreateStrWithNew(c);
		}
	}
	public static String getObjCreateStrWithNew(Class c) {
		StringBuilder sb = new StringBuilder();
		String classNameForPrint = Common.getClassName(c, context);
		if (classNameForPrint.indexOf("$") != -1) {
			classNameForPrint = classNameForPrint.replaceAll("\\$", "\\.");
		}
		sb.append(" new ").append(classNameForPrint).append("()");
		return sb.toString();
	}
	public static  String genNewClz(Class c) {
		StringBuilder sb = new StringBuilder();
		String classNameForPrint = Common.getClassName(c, context);
		if (classNameForPrint.indexOf("$") != -1) {
			classNameForPrint = classNameForPrint.replaceAll("\\$", "\\.");
		}
		String instanceName = Common.getInstanceName(c, context.getSameTypeCreatedTimesMap());
		sb.append(classNameForPrint).append(" ").append(instanceName).append(" = ").append(getClassCreateStr(c))
				.append(";\r\n");
	    return sb.toString();
	}
	public static String printAllSet(Class c, CodeGenContext context) {
		return printAllSet(c, new HashMap(), null, context);
	}
	public static String printAllSet(Class c, Map<Class, String> typeInstanceNames, Class genericTypes[],
			CodeGenContext context) {
		if (!Common.isComplexType(c)) {
			return "";
		}
		String instanceName = Common.getInstanceName(c);
		StringBuilder sb = new StringBuilder();
		typeInstanceNames.put(c, instanceName);
		allFieldList.clear();
		Common.getAllFieldNames(c, concernedPackageNames, allFieldList);
		List<String> incompleteFieldNames = allFieldList;
		Method methods[] = c.getMethods();
		List<Method> methodList = (List) Arrays.asList(methods);
		List<Method> allSetMethods = methodList.stream().filter(m -> {
			boolean isFieldSet = false;
			if (m.getName().startsWith("set") || m.getName().startsWith("is") || m.getName().startsWith("has")) {
				int paramCount = m.getParameterCount();
				if (paramCount == 1) {
					isFieldSet = true;
					String fieldName = null;
					if (m.getName().startsWith("set") || m.getName().startsWith("has")) {
						fieldName = m.getName().substring(3, m.getName().length());
					} else if (m.getName().startsWith("is")) {
						fieldName = m.getName().substring(2, m.getName().length());
					}
					incompleteFieldNames.remove(Common.makeFirstCharInLowercase(fieldName));
				}
			}
			return isFieldSet;
		}).collect(Collectors.toList());
		allSetMethods.forEach(m -> {
			Parameter p[] = m.getParameters();
			if (p != null) {
				Parameter p1 = p[0];
				String typeName = null;
				typeName = p1.getParameterizedType().getTypeName();
				if (typeName.startsWith("java.util.List")) {
					String genericType = null;
					int start = typeName.indexOf("<");
					int end = typeName.indexOf(">");
					genericType = typeName.substring(start + 1, end);
					String listName = null;
					String listItemName = null;
					Class pClass = null;
					try {
						pClass = CodeGenContext.getInstance().getReloadableDynamicClassLoaderOwner()
								.loadClass(genericType, true);
						listItemName = Common.getInstanceName(pClass, context.getSameTypeCreatedTimesMap());
						listName = listItemName + "List";
					} catch (Exception e1) {
						e1.printStackTrace();
					}
					StringBuilder refType = new StringBuilder();
					String genericTypeForPrint = genericType.replaceAll("\\$", "\\.");
					refType.append("List<").append(genericTypeForPrint).append("> ").append(listName).append("=")
							.append(" new ").append(" ArrayList<").append(genericTypeForPrint).append(">();\r\n");
					String defaultVal = null;
					if (typeInstanceNames.containsKey(pClass)) {
						defaultVal = typeInstanceNames.get(pClass);
					} else {
						defaultVal = Common.getDefaultVal(pClass);
					}
					refType.append(listName).append(".add(").append(defaultVal).append(");\r\n");
					allSetSB.append(refType.toString());
					sb.append(instanceName).append(".").append(m.getName()).append("(").append(listName)
							.append(");\r\n");
				} else {
					if (Common.isComplexType(p1.getType())) {
						if (context.getAbstractConcreteClassMap().containsKey(p1.getType())) {
							AbstractConcreteClassMapping cm = context.getAbstractConcreteClassMap().get(p1.getType());
							Class cc = cm.getConcreteClass();
							sb.append(instanceName).append(".").append(m.getName()).append("(")
									.append(Common.getInstanceName(cc)).append(");\r\n");
						} else {
							sb.append(instanceName).append(".").append(m.getName()).append("(")
									.append(Common.getDefaultVal(p1)).append(");\r\n");
						}
					} else {
						sb.append(instanceName).append(".").append(m.getName()).append("(")
								.append(Common.getDefaultVal(p1)).append(");\r\n");
					}
				}
			}
		});
		if (incompleteFieldNames.size() > 0) {
			List<Method> listGetMethods = methodList.stream().filter(m -> {
				boolean isListFieldGet = false;
				if (m.getName().startsWith("get")) {
					int paramCount = m.getParameterCount();
					if (paramCount == 0) {
						String fieldNameInMethod = m.getName().substring(3);
						String fieldInstanceName = Common.makeFirstCharInLowercase(fieldNameInMethod);
						if (containsIgnoreCase(incompleteFieldNames, fieldInstanceName)
								&& Common.isMethodReturnCollectionType(m)) {
							isListFieldGet = true;
							incompleteFieldNames.remove(fieldInstanceName);
						}
					}
				}
				return isListFieldGet;
			}).collect(Collectors.toList());
			listGetMethods.forEach(m -> {
				String fieldNameInMethod = m.getName().substring(3);
				String fieldInstanceName = Common.makeFirstCharInLowercase(fieldNameInMethod);
				String typeName = m.getGenericReturnType().getTypeName();
				String genericType = null;
				int start = typeName.indexOf("<");
				int end = typeName.indexOf(">");
				genericType = typeName.substring(start + 1, end);
				Class listGenericType = null;
				try {
					listGenericType = CodeGenContext.getInstance().getReloadableDynamicClassLoaderOwner()
							.loadClass(genericType, true);
				} catch (Exception e1) {
					e1.printStackTrace();
				}
				if (!Common.isComplexType(listGenericType)) {
					sb.append(instanceName).append(".").append(m.getName()).append("().add(")
							.append(Common.getDefaultVal(listGenericType)).append(");\r\n");
				} else {
					String defaultVal = null;
					if (typeInstanceNames.containsKey(listGenericType)) {
						defaultVal = typeInstanceNames.get(listGenericType);
					} else {
						defaultVal = fieldInstanceName;
					}
					sb.append(instanceName).append(".").append(m.getName()).append("().add(").append(defaultVal)
							.append(");\r\n");
				}
			});
		}
		if (Common.isACollection(c) && genericTypes != null && genericTypes[0] != null) {
			Class gt = genericTypes[0];
			if (Common.isComplexType(gt)) {
				String gtInstanceName = Common.getInstanceName(gt);
				sb.append(instanceName).append(".").append("add").append("(").append(gtInstanceName).append(");\r\n");
			} else {
				sb.append(instanceName).append(".").append("add").append("(").append(Common.getDefaultVal(gt))
						.append(");\r\n");
			}
		}
		allSetSB.append(sb.toString());
		return sb.toString();
	}
	public static String generateCode(Class c, Class genericTypes[], CodeGenContext context) {
		if (null == c) {
			return "";
		}
		if (c.isInterface() || c.getEnclosingClass() != null) {
			return "";
		}
		if (c.isArray()) {
			c = c.getClass().getComponentType();
		}
		List<String> concernedPacks = Common.getDefaultConcernedPacks(c);
		if (genericTypes != null) {
			for (Class gt : genericTypes) {
				if (gt != null) {
					concernedPacks.addAll(Common.getDefaultConcernedPacks(gt));
				}
			}
		}
		return generateCode(c, genericTypes, concernedPacks, context);
	}
	public static String generateCode(Class c, CodeGenContext context) {
		return generateCode(c, (Class[]) null, context);
	}
	public static String generateCode(Class c, List<String> concernedPacks, CodeGenContext context) {
		return generateCode(c, (Class[]) null, concernedPacks, context);
	}
	public static String generateCode(Class c, Class genericTypes[], List<String> concernedPacks,
			CodeGenContext context) {
		return generateCodeWithoutRecursive(c, concernedPacks, context, true);
	}
	public static String generateCodeold(Class c, Class genericTypes[], List<String> concernedPacks,
			CodeGenContext context) {
		ObjWithDefaultValCreator obf = new ObjWithDefaultValCreator();
		List<Class<?>> allComplextTypes = new ArrayList<>();
		concernedPackageNames = concernedPacks;
		deepList.clear();
		String code = "";
		try {
			PojoSetterGenerator.context = context;
			Map<Class, String> typeInstanceNames = new HashMap<>();
			allComplextTypes.addAll(obf.getAllReferComplexType(c));
			if (genericTypes != null) {
				for (Class gt : genericTypes) {
					allComplextTypes.addAll(obf.getAllReferComplexType(gt));
				}
			}
			deepList=allComplextTypes.stream().map(e-> {
				ClzRefDeep cdf = new PojoSetterGenerator().new ClzRefDeep();
				cdf.setC(e);
				cdf.setI(0);
				cdf.setHasCollectionReturn(false);
				return cdf;
			}).collect(Collectors.toList());
			StringBuilder allNewClzCodeLines = new StringBuilder();
			allComplextTypes.stream().forEach(e-> {
				allNewClzCodeLines.append(PojoSetterGenerator.genNewClz(e)); 
			});
			deepList.forEach(cd -> {
				Class clzTmp = cd.getC();
				try {
					Common.importC(clzTmp, context);
					printAllSet(clzTmp, typeInstanceNames, cd.getGenericTypes(), context);
				} catch (Exception e) {
					e.printStackTrace();
				}
				;
			});
			allSetSB.insert(0, allNewClzCodeLines.toString());
			code = allSetSB.toString();
			allSetSB = new StringBuilder();
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			clear();
		}
		return code;
	}
	public static String generateCodeWithoutRecursive(Class c, CodeGenContext context, boolean clearAfterFinish) {
		List<String> concernedPacks = Common.getDefaultConcernedPacks(c);
		return generateCodeWithoutRecursive(c, concernedPacks, context, clearAfterFinish);
	}
	public static String generateCodeWithoutRecursive(Class c, CodeGenContext context) {
		List<String> concernedPacks = Common.getDefaultConcernedPacks(c);
		return generateCodeWithoutRecursive(c, concernedPacks, context);
	}
	public static String generateCodeWithoutRecursive(Class c, List<String> concernedPacks, CodeGenContext context) {
		return generateCodeWithoutRecursive(c, concernedPacks, context, true);
	}
	public static String generateCodeWithoutRecursive(Class c, List<String> concernedPacks, CodeGenContext context,
			boolean clearAfterFinish) {
		context.getVariableMap().put(Replacement.TMP_CLASS_NAME.name(), c.getSimpleName());
		context.getVariableMap().put(Replacement.TMP_INSTANCE_NAME.name(), Common.getInstanceName(c));
		String str;
		try {
			str = Common.replaceAllKeyWord(Syntax.PODAM_INIT_POJO, context.getVariableMap());
		} catch (Exception e) {
			e.printStackTrace();
			str="";
		}
		return str;
	}
	public static String generateCodeWithoutRecursiveOld(Class c, List<String> concernedPacks, CodeGenContext context,
			boolean clearAfterFinish) {
		concernedPackageNames = concernedPacks;
		PojoSetterGenerator.context = context;
		StringBuilder sb = new StringBuilder();
		try {
			sb.append(PojoSetterGenerator.genNewClz(c)); 
			String str = printAllSet(c, context);
			sb.append(str);
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (clearAfterFinish) {
				clear();
			}
		}
		return sb.toString();
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\codegen\Const.java---
package codegen;
public final class Const {
	public static String CLASS_SIMPLE_NAME_KEY = "ClassSimpleName";
	public static String CLASS_NAME_KEY = "ClassName";
	public static final int MIN_FONT_SIZE = 10;
	public static final int MAX_FONT_SIZE = 45;
	public static final int MIN_BACK_COLOR_UNMATCH = 3;
	public static final double MAX_BACKGROUND_COLOR_UNMATCH_PERCENTAGE = 0.02;
	public static final double MAX_FONT_COLOR_UNMATCH_PERCENTAGE = 0.02;
	public static final int MIN_FONT_COLOR_UNMATCH = 3;
	public static final String SPECIFY_CLASS = "specify a class";
	public static final String OUTPUT_SYS_PROPERTY_NAME = "output";
	public static final String MEMORY_FILE_PATH_NAME = "botbrain";
	public static final String BRAIN_LOCAL_REPO_PROPERTY_KEYWORD = "local_repository";
	public static final String BRAIN_LOCAL_REPO_KEYWORD = "local repository";
	public static final String BRAIN_MVN_HOME_KEYWORD = "maven home";
	public static final String CLIPBOARD_CLIENT_APP_PATH_KEYWORD = "clipboard app path";
	public static final String BRAIN_LAST_PROJECT_KEYWORD = "last project";
	public static final String BRAIN_CG_KEY_APP_KEYWORD = "cgkey_app";
	public static final String BRAIN_IDE_PROC_KEYWORD = "ide_proc_name_keyword";
	public static final int MAX_WAIT_TIME = 3;
	public static final String MEMORY_KEYWORD_MAPPING_KEY = "memoryKeywords";
	public static final String MEMORY_AREA_KEY = "table";
}
----strat of file D:\projects\cg\cg-min\src\main\java\codegen\DBNameEnum.java---
package codegen;
public enum DBNameEnum {
	CODING_LOGIC_TABLE("coding logic", "codearea");
	private String uiName = "";
	private String tableName = "";
	DBNameEnum(String uiName, String tableName) {
		this.uiName = uiName;
		this.tableName = tableName;
	}
	public String getUiName() {
		return uiName;
	}
	public String getTableName() {
		return tableName;
	}
	public static String getTableNameByUiName(String uiName) {
		String s = "";
		DBNameEnum[] des = DBNameEnum.values();
		for (int i = 0; i < des.length; i++) {
			if (des[i].getUiName().equalsIgnoreCase(uiName)) {
				s = des[i].getTableName();
			}
		}
		return s;
	}
	public static String getUiNameByTableName(String tableName) {
		String s = "";
		DBNameEnum[] des = DBNameEnum.values();
		for (int i = 0; i < des.length; i++) {
			if (des[i].getTableName().equalsIgnoreCase(tableName)) {
				s = des[i].getUiName();
			}
		}
		return s;
	}
	public static String[] getAllUiName() {
		String[] names = new String[DBNameEnum.values().length];
		DBNameEnum[] des = DBNameEnum.values();
		for (int i = 0; i < des.length; i++) {
			names[i] = des[i].getUiName();
		}
		return names;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\codegen\eclipseRobot\Const.java---
package codegen.eclipseRobot;
import java.io.File;
import java.util.Arrays;
import java.util.List;
public class Const {
	public static final int MAX_FONT_SIZE = 20;
	public static final int MIN_FONT_SIZE = 10;
	public static final double MAX_FONT_COLOR_UNMATCH_PERCENTAGE = 0.02;
	public static final int MIN_FONT_COLOR_UNMATCH = 3;
	public static final int MIN_BACK_COLOR_UNMATCH = 2;
	public static final double MAX_BACKGROUND_COLOR_UNMATCH_PERCENTAGE = 0.01;
	public static final String CHECKBOX_FOR_CREATE_CONSTRUCTOR_WHEN_NEW_CLASS_RS_NAME = null;
	public static final String BTN_ADD_INTERFACE_WHEN_NEW_CLASS_RS_NAME = null;
	public static final String TEXT_FIELD_SUPER_CLASS_WHEN_NEW_CLASS_RS_NAME = null;
	public static final String CLASS_NAME_WHEN_NEW_CLASS_RS_NAME = null;
	public static final String PACKNAME_WHEN_NEW_CLASS_RS_NAME = null;
	public static final String NEW_CLASS_IN_POP_MENU_RS_NAME = null;
	public static final List<Class<?>> primitiveClz = Arrays.asList(
			new Class[] { String.class, int.class, boolean.class, long.class, double.class, short.class,
					float.class, byte.class, char.class, Integer.class, Boolean.class, Long.class, Double.class,
					Short.class, Float.class, Byte.class, Character.class, java.sql.Date.class, java.util.Date.class,
					java.sql.Timestamp.class, java.math.BigInteger.class, java.math.BigDecimal.class,
					javax.xml.datatype.XMLGregorianCalendar.class, File.class, Object.class });
	public static final List<Class<?>> returnTypePrimitiveClz = Arrays.asList(
			new Class[] { String.class, int.class, boolean.class, long.class, double.class, short.class,
					float.class, byte.class, char.class, Integer.class, Boolean.class, Long.class, Double.class,
					Short.class, Float.class, Byte.class, Character.class, java.sql.Date.class, java.util.Date.class,
					java.sql.Timestamp.class, java.math.BigInteger.class, java.math.BigDecimal.class,
					javax.xml.datatype.XMLGregorianCalendar.class, File.class, Object.class, void.class });
	public static final String ECLIPSE_WINDOW_TITLE_KEYWORD = "eclipse";
	public static enum WinOperationEnum {
		RESIZE("resize"), SWITCH_ECLIPSE("switchProcess"), GET_ACTIVE_WINDOW("getActiveWindow");
		String value;
		private WinOperationEnum(String value) {
			this.value = value;
		}
		public void setValue(String value) {
			this.value = value;
		}
		public String getValue() {
			return value;
		}
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\codegen\eclipseRobot\Converter.java---
package codegen.eclipseRobot;
import codegen.complexobj.CodeGenContext;
import codegen.util.Common;
import javax.xml.datatype.DatatypeConfigurationException;
import javax.xml.datatype.DatatypeFactory;
import javax.xml.datatype.XMLGregorianCalendar;
import java.io.File;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.GregorianCalendar;
public class Converter {
	static SimpleDateFormat sdf = new SimpleDateFormat("yyyyMMdd");
	private static DatatypeFactory df = null;
	static {
		try {
			df = DatatypeFactory.newInstance();
		} catch (DatatypeConfigurationException dce) {
			throw new IllegalStateException("Exception", dce);
		}
	}
	public static XMLGregorianCalendar toXMLGregorianCalendar(Date date) {
		if (date == null) {
			return null;
		} else {
			return toXMLGregorianCalendar(date.getTime());
		}
	}
	public static XMLGregorianCalendar toXMLGregorianCalendar(long timeInMillis) {
		GregorianCalendar gc = new GregorianCalendar();
		gc.setTimeInMillis(timeInMillis);
		return df.newXMLGregorianCalendar(gc);
	}
	public static Object convert(Object source, Class targetType) throws Exception {
		return convert(source, targetType, ",");
	}
	public static Object convert(Object source, Class targetType, String delimiter) throws Exception {
		Object o = null;
		if (targetType == Class.class) {
			o = Common.getClzByName(source.toString());
		} else if (targetType == Boolean.class || targetType == boolean.class) {
			o = source;
		} else if (targetType == Long.class || targetType == long.class) {
			o = Long.parseLong(source.toString().trim());
		} else if (targetType == Double.class || targetType == double.class) {
			o = Double.parseDouble(source.toString().trim());
		} else if (targetType == int.class || targetType == Integer.class) {
			o = Integer.parseInt(source.toString().trim());
		} else if (targetType == Short.class || targetType == short.class) {
			o = Short.parseShort(source.toString().trim());
		} else if (targetType == Float.class || targetType == float.class) {
			o = Float.parseFloat(source.toString().trim());
		} else if (targetType == Byte.class || targetType == byte.class) {
			o = Byte.parseByte(source.toString().trim());
		} else if (targetType == Date.class) {
			o = sdf.parse(source.toString().trim());
		} else if (targetType == BigInteger.class) {
			o = new BigInteger(source.toString().trim());
		} else if (targetType == BigDecimal.class) {
			o = new BigDecimal(source.toString().trim());
		} else if (targetType == XMLGregorianCalendar.class) {
			Date d = sdf.parse(source.toString().trim());
			o = toXMLGregorianCalendar(d);
		} else if (targetType == File.class) {
			File file = new File(source.toString().trim());
			o = file;
		} else if (targetType.isArray()) {
			if (targetType.getComponentType() == Class.class) {
				String classNames[] = (source == null || source.toString().trim().equals("")) ? new String[] {}
						: source.toString().trim().split(delimiter, -1);
				Class c[] = new Class[classNames.length];
				for (int i = 0; i < classNames.length; i++) {
					String s = classNames[i];
					c[i] = Common.getClzByName(s.trim());
				}
				o = c;
			} else if (targetType.getComponentType() == File.class) {
				String names[] = (source == null || source.toString().trim().equals("")) ? new String[] {}
						: source.toString().trim().split(delimiter, -1);
				File fs[] = new File[names.length];
				for (int i = 0; i < names.length; i++) {
					String s = names[i];
					fs[i] = new File(s);
				}
				o = fs;
			} else {
				o = source.toString().equals("") ? null : source.toString().trim().split(delimiter, -1);
			}
		} else if (targetType == CodeGenContext.class) {
			try {
				Class contextC = CodeGenContext.getInstance().getReloadableDynamicClassLoaderOwner()
						.loadClass(source.toString(), true);
				o = contextC.newInstance();
			} catch (Exception e) {
			}
		} else {
			o = source.toString();
		}
		return o;
	}
	public static void main(String[] args) {
		try {
			convert("java.lang.Exception", Class[].class);
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\codegen\eclipseRobot\DataModel.java---
package codegen.eclipseRobot;
import codegen.complexobj.CodeGenContext;
import codegen.util.Common;
import com.dgs.annotation.ServiceMethodAnn;
import java.io.File;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
public class DataModel {
	private EventObject eventObject;
	Method methods[];
	private String selectedItem;
	Method selectedMethod;
	private Object params[];
	private Object paramPossibleVals[];
	CodeGenContext context;
	Class selectedClz;
	public static int DEFAULT_TEXTAREA_COLS = 8;
	public static int DEFAULT_TEXTAREA_ROWS = 5;
	public String getSelectedItem() {
		return selectedItem;
	}
	public void setSelectedItem(String selectedItem) {
		this.selectedItem = selectedItem;
	}
	public List<String> getItems() {
		List<String> list = new ArrayList<>();
		if (methods != null && methods.length > 0) {
			for (Method m : methods) {
				ServiceMethodAnn annotation = m.getAnnotation(ServiceMethodAnn.class);
				if (annotation != null && annotation.visible()) {
				}
				list.add(annotation.keyword()[0]);
			}
		}
		return list;
	}
	public void resetMs(Class... serviceClazz) {
		List<Method> allMethods = new ArrayList<>();
		Method[] ms = null;
		for(Class serviceClz : serviceClazz) {
			ms = Common.getAllPublicMethods(serviceClz);
			Collections.addAll(allMethods, ms);
		}
		if(null==ms) {
			ms = new Method[] {};
		}
		for (Class<?> c : context.getAttachedClzList()) {
			Method[] tmpms = Common.getAllPublicMethods(c);
			Collections.addAll(allMethods, tmpms);
		}
		List<Method> list = allMethods.stream().filter(m -> {
			ServiceMethodAnn annotation = m.getAnnotation(ServiceMethodAnn.class);
			if (annotation == null || !annotation.visible()) {
				return false;
			}
			if (!m.getName().equals("main") && m.getDeclaringClass() != Object.class) {
				if (m.getName().equals("genBatchCreateMethods")) {
					String NEW_FIELD_MATCH_WORD = "newfield";
				}
				Class pc[] = m.getParameterTypes();
				boolean allPrimitiveType = true;
				for (Class c : pc) {
					if (c.isArray()) {
						c = c.getComponentType();
					}
					if (c != CodeGenContext.class && c != Class.class && c != File.class && Common.isComplexType(c)) {
						return false;
					}
				}
				return allPrimitiveType;
			} else
				return false;
		}).distinct().collect(Collectors.toList());
		final String highestPriorityMethodNameRegex = "(?i)genCode";
		final String highPriorityMethodNameRegex = "(?i)gen.+";
		Pattern hp = Pattern.compile(highestPriorityMethodNameRegex);
		Pattern p1 = Pattern.compile(highPriorityMethodNameRegex);
		list.sort(new Comparator<Method>() {
			@Override
			public int compare(Method o1, Method o2) {
				Matcher m1 = hp.matcher(o1.getName());
				Matcher m2 = hp.matcher(o2.getName());
				Matcher m3 = p1.matcher(o1.getName());
				Matcher m4 = p1.matcher(o2.getName());
				boolean m1Find = m1.find();
				boolean m2Find = m2.find();
				boolean m3Find = m3.find();
				boolean m4Find = m4.find();
				if (m1Find || m2Find) {
					if (m1Find && m2Find) {
						return 0;
					} else if (m1Find && !m2Find) {
						return -1;
					} else {
						return 1;
					}
				} else if (m3Find || m4Find) {
					if (m3Find && m4Find) {
						return 0;
					} else if (m3Find && !m4Find) {
						return -1;
					} else {
						return 1;
					}
				} else {
					if (o1.getDeclaringClass() == o2.getDeclaringClass()) {
						return o1.getName().compareTo(o2.getName());
					} else {
						return o1.getDeclaringClass().getSimpleName().compareTo(o2.getDeclaringClass().getSimpleName());
					}
				}
			}
		});
		ms = list.toArray(new Method[] {});
		this.setMethods(ms);
	}
	public Method[] getMethods() {
		return methods;
	}
	public void setMethods(Method[] methods) {
		this.methods = methods;
	}
	public Method getSelectedMethod() {
		Method m = null;
		if (methods == null) {
			return m;
		}
		try {
			for (Method m1 : this.methods) {
				ServiceMethodAnn annotation = m1.getAnnotation(ServiceMethodAnn.class);
				if (annotation.keyword()[0].equals(this.selectedItem)) {
					m = m1;
					break;
				}
			}
		} catch (Exception e) {
		}
		return m;
	}
	public Object[] getParams() {
		return params;
	}
	public void setParams(Object... params) {
		this.params = params;
	}
	public CodeGenContext getContext() {
		return context;
	}
	public void setContext(CodeGenContext context) {
		this.context = context;
	}
	public Object[] getParamPossibleVals() {
		return paramPossibleVals;
	}
	public void setParamPossibleVals(Object... paramPossibleVals) {
		this.paramPossibleVals = paramPossibleVals;
	}
	public static void main(String[] args) {
		QualifierName qualifierName = DataModel.extractQualifierName("model.Profile");
	}
	public static QualifierName extractQualifierName(String string) {
		QualifierName qn = new QualifierName();
		if("".equals(string)) {
			return qn;
		}
		try {
			qn.setOrigContent(string);
			Pattern p1 = Pattern.compile("^(?:[\\w]+\\.)+");
			Matcher m1 = p1.matcher(string);
			if (m1.find()) {
				QualifierName.QualifierPart qp = qn.new QualifierPart();
				qp.setQualifierHead(m1.group());
				String lastPart = string.substring(qp.getQualifierHead().length());
				qp.setQualifierLastPart(lastPart);
				qn.setQp(qp);
				String packName = getByRegex(qn.getQp().getQualifierHead(), "^(?:[a-z0-9]+\\.)+");
				qn.setPackName(packName);
				String classQualifierNameRegex = "^(?:[a-z]+[\\w]*\\.)+(?:[A-Z]+[\\w]*\\.*)+";
				String classQualifierName = getByRegex(qn.getQp().getQualifierHead(), classQualifierNameRegex);
				if (classQualifierName == null || "".equals(classQualifierName)) {
					classQualifierName = getByRegex(qn.getOrigContent(), classQualifierNameRegex);
				}
				qn.setClassQualifierName(classQualifierName);
				if (classQualifierName != null && !"".equals(classQualifierName)) {
					qn.setClassQualifierName(classQualifierName);
					Class c = tryGetClass(qn.getClassQualifierName());
					if (c != null) {
						qn.setClz(c);
					}
					String nameSplit[] = classQualifierName.split("\\.");
					if (nameSplit.length > 0) {
						qn.setClzSimpleName(nameSplit[nameSplit.length - 1]);
					}
					if (qn.getQp().getQualifierLastPart() == null) {
						/*
						 * if(classQualifierName.toUpperCase().equals( classQualifierName) &&
						 * !classQualifierName.contains("_")){ }else{
						 * qn.setFieldName(classQualifierName); }
						 */
					} else {
						if (qn.getQp().getQualifierLastPart().contains("(")
								&& qn.getQp().getQualifierLastPart().contains(")")) {
							String methodName = getByRegex(qn.getQp().getQualifierLastPart(), "^([\\w\\d]+)\\(.+", 1);
							int firstBrace = string.indexOf("(");
							int closeBrace = string.indexOf(")");
							String params = string.substring(firstBrace + 1, closeBrace);
							String paramArray[] = splitParam(params);
							if (methodName.equals(qn.getClzSimpleName())) {
								qn.setConstructParam(paramArray);
								qn.setConstructor(true);
							} else {
								qn.setMethodName(methodName);
								qn.setMethodParam(paramArray);
							}
						} else {
							String fieldName = getByRegex(qn.getQp().getQualifierLastPart(), "^[a-z]+\\w*$");
							if (fieldName == null) {
								fieldName = getByRegex(qn.getQp().getQualifierLastPart(), "^(?:[A-Z]+_+)+[A-Z]*$");
							}
							qn.setFieldName(fieldName);
						}
					}
				}
			}
			if (string.endsWith(".class")) {
				String name = string.replaceAll(".class", "");
				qn.setClassQualifierName(name);
			} else if (string.contains("(")) {
			} else {
				Class c = qn.getClz();
				if (c != null) {
					Field f = tryGetField(c, qn.getQp().getQualifierLastPart());
					if (f != null) {
						qn.setField(f);
					}
				}
			}
		} catch (Exception e) {
		}
		return qn;
	}
	public static String getByRegex(String string, String regex, int groupIndex) {
		String matchedQualifierPart = "";
		Pattern p = Pattern.compile(regex);
		Matcher m = p.matcher(string);
		if (m.find()) {
			matchedQualifierPart = m.group(groupIndex);
			if (matchedQualifierPart.endsWith(".")) {
				matchedQualifierPart = matchedQualifierPart.substring(0, matchedQualifierPart.length() - 1);
			}
		}
		return matchedQualifierPart;
	}
	public static String getByRegex(String string, String regex) {
		return getByRegex(string, regex, 0);
	}
	public void setIfClassQualifier(String string, QualifierName qn) {
	}
	public void setIfMethodQualifier(String string, QualifierName qn) {
	}
	public void setIfFieldQualifier(String string, QualifierName qn) {
	}
	public static String[] splitParam(String paramStr) {
		int commaValidPos[] = DataModel.getCommaPositionInParamStr(paramStr);
		if (commaValidPos.length > 0) {
			String[] params = new String[commaValidPos.length + 1];
			int lastCommaP = 0;
			for (int i = 0; i < commaValidPos.length; i++) {
				int commaP = commaValidPos[i];
				String p = paramStr.substring(lastCommaP == 0 ? 0 : lastCommaP + 1, commaP);
				params[i] = p.trim();
				lastCommaP = commaP;
			}
			String lastP = paramStr.substring(commaValidPos[commaValidPos.length - 1] + 1);
			params[params.length - 1] = lastP.trim();
			return params;
		} else if (paramStr != null && !"".equals(paramStr.trim())) {
			return new String[] { paramStr.trim() };
		} else {
			return new String[] {};
		}
	}
	public static int[] getCommaPositionInParamStr(String paramStr) {
		int leftBraketCount = 0;
		int rightBraketCount = 0;
		List<Integer> list = new ArrayList<>();
		char[] chs = paramStr.toCharArray();
		for (int i = 0; i < chs.length; i++) {
			char ch = chs[i];
			if (ch == ',') {
				if (leftBraketCount == 0 && rightBraketCount == 0) {
					list.add(i);
				}
			} else if (ch == '<') {
				leftBraketCount++;
			} else if (ch == '>') {
				rightBraketCount++;
				if (rightBraketCount == leftBraketCount) {
					leftBraketCount = 0;
					rightBraketCount = 0;
				}
			}
		}
		int[] ps = list.stream().mapToInt(e -> e).toArray();
		return ps;
	}
	public static Class getOuterClass(String string) {
		Class c = null;
		try {
			c = CodeGenContext.getInstance().getReloadableDynamicClassLoaderOwner().loadClass(string, true);
		} catch (Exception e1) {
			e1.printStackTrace();
		}
		return c;
	}
	public static Class getOuterClass1(String string) {
		Class c = null;
		if (string.endsWith(">") && string.contains("<")) {
			string = string.replaceAll("<.+>", "");
		}
		try {
			c = CodeGenContext.getInstance().getReloadableDynamicClassLoaderOwner().loadClass(string, true);
			return c;
		} catch (ClassNotFoundException e) {
			try {
				c = CodeGenContext.getInstance().getReloadableDynamicClassLoaderOwner().loadClass(string, true);
			} catch (Exception e1) {
				e.printStackTrace();
			}
			int lastDot = string.lastIndexOf(".");
			String className = lastDot != -1 ? string.substring(0, lastDot) : string;
			if (lastDot != -1) {
				className = string.substring(0, lastDot);
			} else {
				return c;
			}
			return getOuterClass(className);
		}
	}
	public static Class tryGetInnerClz(Class outerClz, String string) {
		Class c = null;
		String outCName = outerClz.getName();
		if (string.endsWith(">") && string.contains("<")) {
			string = string.replaceAll("<.+>", "");
		}
		String remainingPart = string.replaceFirst(outCName, "");
		if (!"".equals(remainingPart.trim())) {
			try {
				String restPart = remainingPart.replaceAll("\\.", "\\$");
				c = CodeGenContext.getInstance().getReloadableDynamicClassLoaderOwner().loadClass(outCName + restPart,
						true);
				return c;
			} catch (ClassNotFoundException e) {
				int lastDot = remainingPart.lastIndexOf(".");
				String classPart = remainingPart.substring(0, lastDot);
				classPart = classPart.replaceAll("\\.", "\\$");
				if (classPart.length() > 0) {
					try {
						c = CodeGenContext.getInstance().getReloadableDynamicClassLoaderOwner()
								.loadClass(outCName + classPart, true);
						return c;
					} catch (ClassNotFoundException e1) {
					}
				}
			}
		}
		return c;
	}
	public static Class tryGetClass(String string) {
		Class outerClz = getOuterClass(string);
		return outerClz;
	}
	public static Class tryGetClass1(String string) {
		Class outerClz = getOuterClass(string);
		Class innerClz = null;
		if (outerClz != null)
			innerClz = tryGetInnerClz(outerClz, string);
		return innerClz != null ? innerClz : outerClz;
	}
	public static Field tryGetField(Class c, String fieldPart) {
		if (c != null) {
			if (fieldPart.length() > 0) {
				try {
					Field field = c.getDeclaredField(fieldPart);
					return field;
				} catch (NoSuchFieldException | SecurityException e) {
				}
			}
		}
		return null;
	}
	public Class getSelectedClz() {
		return selectedClz;
	}
	public void setSelectedClz(Class selectedClz) {
		this.selectedClz = selectedClz;
	}
	public void setSelectedMethod(Method selectedMethod) {
		this.selectedMethod = selectedMethod;
	}
	public EventObject getEventObject() {
		return eventObject;
	}
	public void setEventObject(EventObject eventObject) {
		this.eventObject = eventObject;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\codegen\eclipseRobot\EclipseCodeGenContext.java---
package codegen.eclipseRobot;
import codegen.complexobj.CodeGenContext;
public class EclipseCodeGenContext extends CodeGenContext {
	private EclipseService eclipseService;
	private H2JDBCService databaseService;
	private static EclipseCodeGenContext eclipseCodeGenContext;
	public EclipseCodeGenContext() {
		init();
	}
	public static EclipseCodeGenContext getInstance() {
		if (eclipseCodeGenContext == null) {
			return newInstance();
		} else {
			return eclipseCodeGenContext;
		}
	}
	public static EclipseCodeGenContext newInstance() {
		EclipseCodeGenContext context = new EclipseCodeGenContext();
		context.init();
		eclipseCodeGenContext = context;
		return context;
	}
	public EclipseService getEclipseService() {
		return eclipseService;
	}
	public void setEclipseService(EclipseService eclipseService) {
		this.eclipseService = eclipseService;
	}
	public H2JDBCService getDatabaseService() {
		return databaseService;
	}
	public void setDatabaseService(H2JDBCService databaseService) {
		this.databaseService = databaseService;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\codegen\eclipseRobot\EclipseService.java---
package codegen.eclipseRobot;
import codegen.MethodCallParamVariableCode;
import codegen.Replacement;
import codegen.Syntax;
import codegen.complexobj.CodeGenContext;
import codegen.complexobj.PojoSetterGenerator;
import codegen.eclipseRobot.Const.WinOperationEnum;
import codegen.robot.PixelMatchResult;
import codegen.util.ClipBoard;
import codegen.util.Common;
import codegen.util.PomUtil;
import codegen.winsys.WinSysService;
import com.dgs.annotation.FileChooserAnnotation;
import com.dgs.annotation.ParamAnno;
import com.dgs.annotation.ServiceMethodAnn;
import com.dgs.annotation.UIAnno;
import com.dgs.jnaforwin32.WindowService;
import com.github.gemba.artifactresolver.DependencyResolver;
import com.github.gemba.artifactresolver.RepositorySystemHelper;
import org.apache.maven.model.Model;
import org.eclipse.aether.artifact.DefaultArtifact;
import ui.validation.ValidationAnn;
import javax.sql.DataSource;
import javax.xml.datatype.XMLGregorianCalendar;
import java.awt.*;
import java.awt.event.KeyEvent;
import java.awt.image.BufferedImage;
import java.io.*;
import java.lang.annotation.Annotation;
import java.lang.reflect.*;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.net.MalformedURLException;
import java.net.URI;
import java.net.URL;
import java.security.MessageDigest;
import java.sql.Connection;
import java.sql.Driver;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.util.List;
import java.util.*;
import java.util.jar.JarEntry;
import java.util.jar.JarFile;
import java.util.jar.JarInputStream;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import java.util.stream.Stream;
/**
 * note the method parameter names is useful when showing in UI, thus need
 * change java compiler preference, by doing below
 * Window->preference->Compiler->check "Store information about method
 * parameters(usable via reflection)"
 *
 */
public class EclipseService extends WinSysService {
	public static final String SPRING_BOOT_TEMPLATE_JAR_NAME = "springbootsimpletemplate-1.0.jar";
	public static String ECLIPSE_TITLE_KEYWORD = "Eclipse";
	public static String SPECIAL_DIALOG_FONT_NAME = "Segoe UI";
	public static String DIALOG_FONT_NAME = "Khmer UI";
	public static Color ECLIPSE_TITLE_DISABLE_FONT = new Color(151, 151, 151);
	public static Color DISABLE_MENU_ITEM_COLOR = new Color(109, 109, 109);
	public static int MENU_ITEM_SIZE = 12;
	public static String COPY_QUALIFIER_NAME_MENU_LABEL = "Copy Qualified Name";
	public static String COPY_QUALIFIER_NAME_HOTKEY = "Ctrl+`";
	private WindowService windowService;
	private H2JDBCService h2JDBCService;	
	@ServiceMethodAnn(keyword = "checksum return byte")
	public static byte[] createChecksum(@ParamAnno(description = "file for check sum") @ValidationAnn(validations = {
			"codegen.eclipseRobot.MandatoryCheck" }) File file) throws Exception {
		InputStream fis = new FileInputStream(file);
		byte[] buffer = new byte[1024];
		MessageDigest complete = MessageDigest.getInstance("MD5");
		int numRead;
		do {
			numRead = fis.read(buffer);
			if (numRead > 0) {
				complete.update(buffer, 0, numRead);
			}
		} while (numRead != -1);
		fis.close();
		return complete.digest();
	}
	@ServiceMethodAnn(keyword = "checksum return string")
	public static String getMD5Checksum(
			@ParamAnno(description = "file") @ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) File file)
			throws Exception {
		byte[] b = createChecksum(file);
		String result = "";
		for (int i = 0; i < b.length; i++) {
			result += Integer.toString((b[i] & 0xff) + 0x100, 16).substring(1);
		}
		return result;
	}
	/**
	 * 
	 * @param targetDirectory consider add a file or directory annotation to make a
	 *                        difference
	 * @param folderName
	 */
	@ServiceMethodAnn(keyword = "create project folder")
	public void createNewProjFolder(@FileChooserAnnotation(chooseDirOnly = true) @ValidationAnn(validations = {
			"codegen.eclipseRobot.MandatoryCheck" }) File targetDirectory, String folderName) {
		String projDir = targetDirectory.getAbsolutePath();
		boolean b = Common.isBlank(folderName);
		if (!b) {
			projDir = projDir + File.separator + folderName;
		}
		File codingLogicFolder = new File(projDir + File.separator + "coding logic");
		File businessLogicFolder = new File(projDir + File.separator + "business logic");
		File functionLogicFolder = new File(projDir + File.separator + "function logic");
		File testingFolder = new File(projDir + File.separator + "testing");
		File projectMgtFolder = new File(projDir + File.separator + "project management");
		File deploymentFolder = new File(projDir + File.separator + "deployment");
		File productionFolder = new File(projDir + File.separator + "production");
		if (!codingLogicFolder.exists()) {
			codingLogicFolder.mkdirs();
		}
		if (!businessLogicFolder.exists()) {
			businessLogicFolder.mkdirs();
		}
		if (!functionLogicFolder.exists()) {
			functionLogicFolder.mkdirs();
		}
		if (!testingFolder.exists()) {
			testingFolder.mkdirs();
		}
		if (!projectMgtFolder.exists()) {
			projectMgtFolder.mkdirs();
		}
		if (!deploymentFolder.exists()) {
			deploymentFolder.mkdirs();
		}
		if (!productionFolder.exists()) {
			productionFolder.mkdirs();
		}
		return;
	}
	public void setCopyQualifierKey() throws Exception {
		this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_E);
		boolean hotKeyStrFound = false;
		try {
			blockUntilFound(COPY_QUALIFIER_NAME_HOTKEY, DIALOG_FONT_NAME, MENU_ITEM_SIZE, Font.PLAIN, Color.BLACK,
					false, true);
			hotKeyStrFound = true;
		} catch (Exception e) {
			try {
				blockUntilFound(COPY_QUALIFIER_NAME_HOTKEY, DIALOG_FONT_NAME, MENU_ITEM_SIZE, Font.PLAIN,
						DISABLE_MENU_ITEM_COLOR, false, true);
				hotKeyStrFound = true;
			} catch (Exception e1) {
				e1.printStackTrace();
			}
		}
		if (!hotKeyStrFound) {
			this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_W, KeyEvent.VK_P);
			this.blockUntilFound("Preferences", DIALOG_FONT_NAME, Color.BLACK);
			this.getkRobot().typeStr("Keys");
			this.blockUntilFound("Keys", DIALOG_FONT_NAME, Color.BLACK);
			blockUntilFound("Keys", DIALOG_FONT_NAME, Font.BOLD, Color.BLACK, false, true);
			this.getmRobot().mouseClick();
			this.blockUntilFound("type filter text", DIALOG_FONT_NAME, Font.PLAIN, new Color(87, 87, 87), false, true);
			this.getmRobot().mouseClick();
			this.getkRobot().typeStr("Copy Qualified Na");
			this.blockUntilFound("Copy Qualified Name", DIALOG_FONT_NAME, Color.BLACK);
			PixelMatchResult pmr = this.tryFindText("Ctrl+`", DIALOG_FONT_NAME, Font.PLAIN, Color.BLACK, false);
			if (pmr != null) {
				this.getkRobot().clickKey(KeyEvent.VK_ESCAPE);
				return;
			} else {
				this.getkRobot().arrowDown();
				this.getkRobot().end();
				this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_B);
				this.getkRobot().clickCompositeKey(KeyEvent.VK_CONTROL, KeyEvent.VK_BACK_QUOTE);
				this.getkRobot().tab();
				this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_A);
				this.getkRobot().clickKey(KeyEvent.VK_ESCAPE);
			}
		}
		return;
	}
	public void clickProjByName(String name, boolean matchExactly) throws Exception {
		this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_SHIFT, KeyEvent.VK_Q);
		Thread.sleep(1000);
		this.getkRobot().clickKey(KeyEvent.VK_P);
		Thread.sleep(500);
		this.collapseAll();
		Thread.sleep(500);
		this.getkRobot().home();
		String lastProjName = null;
		String nameInQualifiedFormat = "/" + name;
		boolean reachLastProj = false;
		while (!reachLastProj) {
			this.copyQualifiedName();
			Thread.sleep(500);
			try {
				String data = ClipBoard.getString();
				if (data != null) {
					System.out.println(String.format("nameInQualifiedFormat=%s,data=%s", nameInQualifiedFormat, data));
					if (data.equals(lastProjName)) {
						reachLastProj = true;
					}
					if (matchExactly) {
						if (nameInQualifiedFormat.equalsIgnoreCase(data)) {
							return;
						}
					} else {
						String nameRegex = "(?i)" + name;
						Pattern hp = Pattern.compile(nameRegex);
						Matcher m = hp.matcher(data);
						if (m.find()) {
							System.out.println("match data " + data);
							return;
						}
					}
					lastProjName = data;
				} else {
					return;
				}
				System.out.println("arrow down ");
				this.getkRobot().arrowDown();
			} catch (Exception e) {
				throw e;
			}
		}
	}
	public void clickProjLikeName(String name) throws Exception {
		clickProjByName(name, false);
	}
	@ServiceMethodAnn(keyword = "new class")
	public void createNewClass(
			@ParamAnno(description = "Class Name")  String className, 
			int modifier,
			@ParamAnno(description = "Package Name") String packName, 
			@ParamAnno(description = "Super Class") Class superC, 
			@ParamAnno(description = "Interface Class") Class interfaceC) throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		Common.setModifier(modifier, context);
		createNewClass(className, modifier, packName, superC != null ? superC.getName() : null,
				interfaceC != null ? interfaceC.getName() : null);
	}
	@ServiceMethodAnn(keyword = "new classes")
	public void createManyClasses(@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) String classNames[],
			int modifier, 
			@ParamAnno(description = "Package Name") String packName, 
			@ParamAnno(description = "Super Class Name") String superClassName, String interfaceName) {
		for (String className : classNames) {
			try {
				this.createNewClass(className, modifier, packName, superClassName, interfaceName);
			} catch (Exception e) {
				e.printStackTrace();
			}
		}
		return;
	}
	public void createNewClass(@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) String className, int modifier,
			String packName, String superClassName, String interfaceName) throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		Common.setModifier(modifier, context);
		if(!this.isActiveEclipseWindow())
			return;
		if(!this.openWizard())
			return;
		Thread.sleep(1500);
		this.getkRobot().typeStr("class");
		Thread.sleep(500);
		this.getkRobot().enter();
		Thread.sleep(500);
		this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_M);
		Thread.sleep(500);
		this.getkRobot().typeStr(className);
		Thread.sleep(500);
		if (superClassName != null && !"".equals(superClassName.trim())) {
			this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_S);
			this.getkRobot().end();
			this.getkRobot().selectAll();
			this.getkRobot().backSace();
			Thread.sleep(500);
			this.getkRobot().typeStr(superClassName);
		}
		if (interfaceName != null && !"".equals(interfaceName.trim())) {
			this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_A);
			Thread.sleep(500);
			this.getkRobot().typeStr(interfaceName);
			Thread.sleep(1000);
			this.getkRobot().enter();
			Thread.sleep(500);
		}
		boolean specifyPack = packName != null && !"".equals(packName.trim()) ? true : false;
		if (specifyPack) {
			this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_K);
			this.getkRobot().end();
			this.getkRobot().selectAll();
			this.getkRobot().backSace();
			Thread.sleep(500);
			this.getkRobot().typeStr(packName);
		}
		this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_U);
		this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_F);
	}
	@ServiceMethodAnn(keyword = { "new interface", "create interface with super interface name" })
	public void createNewInterface(@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) String interfaceName,
			int modifier, String packName, String... superInterfaceNames) throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		if(!this.isActiveEclipseWindow())
			return;
		Common.setModifier(modifier, context);
		if(!this.openWizard())
			return;
		Thread.sleep(1500);
		this.getkRobot().typeStr("interface");
		Thread.sleep(500);
		this.getkRobot().enter();
		Thread.sleep(500);
		this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_M);
		this.getkRobot().typeStr(interfaceName);
		if (superInterfaceNames != null && superInterfaceNames.length>0) {
			for(String superInterfaceName : superInterfaceNames) {
				this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_A);
				this.getkRobot().end();
				Thread.sleep(500);
				this.getkRobot().selectAll();
				this.getkRobot().backSace();
				this.getkRobot().typeStr(superInterfaceName);
				Thread.sleep(500);
				this.getkRobot().enter();
			}
		}
		boolean specifyPack = packName != null && !"".equals(packName.trim()) ? true : false;
		if (specifyPack) {
			this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_K);
			this.getkRobot().end();
			this.getkRobot().selectAll();
			this.getkRobot().backSace();
			Thread.sleep(500);
			this.getkRobot().typeStr(packName);
		}
		this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_F);
	}
	@ServiceMethodAnn(keyword = { "new interface with super interface", "create interface with super interface" })
	public void createNewInterfaceWithSuperC(
			@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) String interfaceName, int modifier, String packName,
			Class superInterface) throws Exception {
		createNewInterface(interfaceName, modifier, packName, superInterface != null ? superInterface.getName() : null);
	}
	@ServiceMethodAnn(keyword = "new enum")
	public void createNewEnum(@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) String name, String packName)
			throws Exception {
		if(!this.isActiveEclipseWindow())
			return;
		if(!this.openWizard())
			return;
		Thread.sleep(1500);
		this.getkRobot().typeStr("enum");
		Thread.sleep(500);
		this.getkRobot().enter();
		Thread.sleep(500);
		this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_M);
		this.getkRobot().typeStr(name);
		boolean specifyPack = packName != null && !"".equals(packName.trim()) ? true : false;
		if (specifyPack) {
			this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_K);
			this.getkRobot().end();
			this.getkRobot().selectAll();
			this.getkRobot().backSace();
			Thread.sleep(500);
			this.getkRobot().typeStr(packName);
		}
		this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_F);
	}
	public void createNewAnnotation(@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) String name, String packName)
			throws Exception {
		if(!this.openWizard())
			return;
		Thread.sleep(500);
		this.getkRobot().typeStr("annotation");
		Thread.sleep(500);
		this.getkRobot().enter();
		Thread.sleep(500);
		this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_M);
		this.getkRobot().typeStr(name);
		boolean specifyPack = packName != null && !"".equals(packName.trim()) ? true : false;
		if (specifyPack) {
			this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_K);
			this.getkRobot().end();
			this.getkRobot().selectAll();
			Thread.sleep(500);
			this.getkRobot().backSace();
			Thread.sleep(500);
			this.getkRobot().typeStr(packName);
		}
		this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_R);
		this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_U);
		this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_F);
	}
	@ServiceMethodAnn(keyword = "new package")
	public void createNewPackage(String packName) throws Exception {
		if(!this.openWizard())
			return;
		Thread.sleep(500);
		this.getkRobot().typeStr("package");
		Thread.sleep(500);
		this.getkRobot().enter();
		Thread.sleep(500);
		this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_M);
		this.getkRobot().typeStr(packName);
		boolean specifyPack = packName != null && !"".equals(packName.trim()) ? true : false;
		if (specifyPack) {
			this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_K);
			this.getkRobot().end();
			this.getkRobot().selectAll();
			this.getkRobot().backSace();
			Thread.sleep(500);
			this.getkRobot().typeStr(packName);
		}
		this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_F);
	}
	@ServiceMethodAnn(keyword = "new annotation")
	public void createAnnotation(@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) String name, String packName)
			throws Exception {
		if(!this.openWizard())
			return;
		Thread.sleep(500);
		this.getkRobot().typeStr("Annotation");
		Thread.sleep(500);
		this.getkRobot().enter();
		Thread.sleep(500);
		this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_M);
		this.getkRobot().typeStr(name);
		boolean specifyPack = packName != null && !"".equals(packName.trim()) ? true : false;
		if (specifyPack) {
			this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_K);
			this.getkRobot().end();
			this.getkRobot().selectAll();
			this.getkRobot().backSace();
			Thread.sleep(500);
			this.getkRobot().typeStr(packName);
		}
		this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_F);
	}
	public void updateMavenDependency() throws Exception {
		this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_F5);
		this.getmRobot().delay(500);
		this.getkRobot().clickKey(KeyEvent.VK_TAB);
		this.getkRobot().clickKey(KeyEvent.VK_SPACE);
		this.getkRobot().clickKey(KeyEvent.VK_TAB);
		this.getkRobot().clickKey(KeyEvent.VK_TAB);
		this.getkRobot().clickKey(KeyEvent.VK_TAB);
		this.getkRobot().clickKey(KeyEvent.VK_TAB);
		this.getkRobot().clickKey(KeyEvent.VK_TAB);
		this.getkRobot().clickKey(KeyEvent.VK_TAB);
		this.getkRobot().clickKey(KeyEvent.VK_SPACE);
		this.getkRobot().enter();
	}
	@ServiceMethodAnn(keyword = { "gen service interface", "create service interface" })
	public void createServiceInterface(@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) String interfaceName, int modifier, String packName,
			Class superInterface) throws Exception {
	    this.createNewInterfaceWithSuperC(interfaceName, modifier, packName, superInterface);
	}
	@ServiceMethodAnn(keyword = { "gen service class", "create service class" })
	public void createServiceClz(@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) String className, int modifier, @ParamAnno(description = "as Component")boolean asComponent,@ParamAnno(description = "as Service")boolean asService,
			String packName, Class superC, Class interfaceC) throws Exception {
	    this.createNewClass(className, modifier, packName, superC, interfaceC);
	}
	@ServiceMethodAnn(keyword = { "gen jpa repository class", "create jpa repository class" })
	public void createRepository(@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) String interfaceName, int modifier, String packName,
			boolean extendsJpaSpecificationExecutor) throws Exception {
		if(extendsJpaSpecificationExecutor) {
			this.createNewInterface(interfaceName, modifier, packName, "org.springframework.data.jpa.repository.JpaRepository","org.springframework.data.jpa.repository.JpaSpecificationExecutor");
		}else {
			this.createNewInterface(interfaceName, modifier, packName, "org.springframework.data.jpa.repository.JpaRepository");
		}
	}
	@ServiceMethodAnn(keyword = { "gen JPA Specification class", "create JPA Specification class" })
	public void createJPASpecification(@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) String className, int modifier,
			String packName, Class superC, Class interfaceC) throws Exception {
	    this.createNewClass(className, modifier, packName, superC, interfaceC);
	}
	@ServiceMethodAnn(keyword = { "gen data class", "create data class" })
	public void createDataClass(@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) String className, int modifier,
			String packName, Class superC, Class interfaceC, boolean dataAnnotation
			, boolean getterAnnotation, boolean setterAnnotation, boolean toStringAnnotation, boolean withEqualsAndHashCode) throws Exception {
	    this.createNewClass(className, modifier, packName, superC, interfaceC);
	    if(dataAnnotation) {
	    }
	}
	@ServiceMethodAnn(keyword = { "gen entity class", "create entity class" })
	public void createEntityClass(@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) String className, int modifier,
			String packName, Class superC, Class interfaceC) throws Exception {
	    this.createNewClass(className, modifier, packName, superC, interfaceC);
	}
	@ServiceMethodAnn(keyword = { "gen config bean class", "create config bean class" })
	public void createConfigClass(@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) String className, int modifier,
			String packName, Class superC, Class interfaceC) throws Exception {
	    this.createNewClass(className, modifier, packName, superC, interfaceC);
	}
	public void quickFix() throws Exception {
		this.getkRobot().clickCompositeKey(KeyEvent.VK_CONTROL, KeyEvent.VK_1);
		Thread.sleep(500);
		this.getkRobot().enter();
		Thread.sleep(1000);
	}
	public void gotoLine(@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) int line) throws Exception {
		this.getkRobot().clickCompositeKey(KeyEvent.VK_CONTROL, KeyEvent.VK_L);
		Thread.sleep(1000);
		this.getkRobot().typeStr(Integer.toString(line));
		Thread.sleep(1000);
		this.getkRobot().enter();
	}
	public void popOpenTypeDialog() {
		this.getkRobot().clickCompositeKey(KeyEvent.VK_CONTROL, KeyEvent.VK_SHIFT, KeyEvent.VK_T);
	}
	public void outline(Class c) throws Exception {
		this.editClass(c);
		Thread.sleep(500);
		this.getmRobot().mouseClick();
		this.getkRobot().clickCompositeKey(KeyEvent.VK_CONTROL, KeyEvent.VK_O);
	}
	public void hightLightMethod(Class c, String methodNameStr) throws Exception {
		this.outline(c);
		Thread.sleep(1000);
		this.getkRobot().typeStr(methodNameStr);
		Thread.sleep(1000);
		this.getkRobot().enter();
		Thread.sleep(1000);
		this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_SHIFT, KeyEvent.VK_RIGHT);
		Thread.sleep(1000);
	}
	public String copyMethod(Class c, String methodNameStr) throws Exception {
		hightLightMethod(c, methodNameStr);
		this.getkRobot().copy();
		this.getkRobot().arrowleft();
		return ClipBoard.getString();
	}
	public void findStr(@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) String find) throws Exception {
		findStr(find, false);
	}
	public void findStr(@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) String find, boolean isBack)
			throws Exception {
		this.getkRobot().clickCompositeKey(KeyEvent.VK_CONTROL, KeyEvent.VK_F);
		this.blockUntilFound("Find/Replace", SPECIAL_DIALOG_FONT_NAME, MENU_ITEM_SIZE, Color.BLACK);
		this.getkRobot().typeStr(find);
		this.blockUntilFound(find, DIALOG_FONT_NAME, Color.BLACK);
		if (isBack) {
			this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_B);
		}
		this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_X);
		this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_N);
		try {
			Thread.sleep(500L);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		this.getkRobot().copy();
		String copiedData = ClipBoard.getString();
		if (copiedData != null && !"".equals(copiedData)) {
			Pattern pattern = Pattern.compile(find);
			Matcher matcher = pattern.matcher(copiedData);
			if (matcher.find()) {
				this.getkRobot().clickKey(KeyEvent.VK_ESCAPE);
				return;
			}
		}
		this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_X);
		this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_N);
		this.getkRobot().clickKey(KeyEvent.VK_ESCAPE);
		this.blockUntilNotFound("Find/Replace", SPECIAL_DIALOG_FONT_NAME, MENU_ITEM_SIZE, Color.BLACK);
		return;
	}
	public void replaceStrInAllTabs(@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) String find,
			@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) String replacement) throws Exception {
		replaceStr(find, replacement, false);
		boolean back = true;
		switchFile(back);
	}
	public void replaceStr(@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) String find,
			@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) String replacement) throws Exception {
		replaceStr(find, replacement, false);
	}
	public void replaceStr(@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) String find,
			@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) String replacement, boolean isBack)
			throws Exception {
		this.getkRobot().clickCompositeKey(KeyEvent.VK_CONTROL, KeyEvent.VK_F);
		this.blockUntilFound("Find/Replace", SPECIAL_DIALOG_FONT_NAME, MENU_ITEM_SIZE, Color.BLACK);
		this.getkRobot().clickCompositeKey(KeyEvent.VK_CONTROL, KeyEvent.VK_F);
		this.getkRobot().typeStr(find);
		if (isBack) {
			this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_B);
		}
		this.blockUntilFound(find, DIALOG_FONT_NAME, Color.BLACK);
		this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_E);
		this.getkRobot().typeStr(replacement);
		this.blockUntilFound(replacement, DIALOG_FONT_NAME, Color.BLACK);
		this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_X);
		this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_N);
		this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_R);
		try {
			Thread.sleep(500L);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_X);
		this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_N);
		this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_R);
		this.getkRobot().clickKey(KeyEvent.VK_ESCAPE);
		this.blockUntilNotFound("Find/Replace", SPECIAL_DIALOG_FONT_NAME, MENU_ITEM_SIZE, Color.BLACK);
		return;
	}
	public void replaceMethodText(@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) Class c, String methodNameStr,
			String newMethodText) throws Exception {
		hightLightMethod(c, methodNameStr);
		this.getkRobot().del();
		this.getkRobot().paste();
		Thread.sleep(1000);
		this.saveFile();
	}
	public void editMethod(Class c, String methodNameStr) throws Exception {
		this.outline(c);
		Thread.sleep(500);
		this.getkRobot().typeStr(methodNameStr);
		Thread.sleep(1000);
		this.getkRobot().enter();
		Thread.sleep(1000);
		this.getkRobot().end();
		this.getkRobot().arrowDown();
	}
	public void editClass(Class c) throws Exception {
		this.editClass(c.getName(), -1);
	}
	@Deprecated
	public void blockUntilFound(String expectedStrOnScreen, String fontName, boolean b) {
		blockUntilFound(expectedStrOnScreen, fontName, Font.PLAIN, Color.WHITE, b);
	}
	public void blockUntilFound(String expectedStrOnScreen, String fontName, Color fontColor) {
		blockUntilFound(expectedStrOnScreen, fontName, Font.PLAIN, fontColor, false);
	}
	public void blockUntilNotFound(String expectedStrOnScreen, String fontName, Color fontColor) {
		blockUntilFound(expectedStrOnScreen, fontName, Font.PLAIN, fontColor, true);
	}
	public void blockUntilFoundBold(String expectedStrOnScreen, String fontName, Color fontColor) {
		blockUntilFound(expectedStrOnScreen, fontName, Font.BOLD, fontColor, false);
	}
	public void blockUntilNotFoundBold(String expectedStrOnScreen, String fontName, Color fontColor) {
		blockUntilFound(expectedStrOnScreen, fontName, Font.BOLD, fontColor, true);
	}
	public void blockUntilFound(String expectedStrOnScreen, String fontName, int fontStyle, Color fontColor,
			boolean untilNotFound) {
		blockUntilFound(expectedStrOnScreen, fontName, fontStyle, fontColor, untilNotFound, false);
	}
	public void blockUntilFound(String expectedStrOnScreen, String fontName, int size, Color fontColor)
			throws Exception {
		blockUntilFound(expectedStrOnScreen, fontName, size, Font.PLAIN, fontColor, false);
	}
	public void blockUntilNotFound(String expectedStrOnScreen, String fontName, int size, Color fontColor)
			throws Exception {
		blockUntilFound(expectedStrOnScreen, fontName, size, Font.PLAIN, fontColor, true);
	}
	public void blockUntilFoundBold(String expectedStrOnScreen, String fontName, int size, Color fontColor)
			throws Exception {
		blockUntilFound(expectedStrOnScreen, fontName, size, Font.BOLD, fontColor, false);
	}
	public void blockUntilNotFoundBold(String expectedStrOnScreen, String fontName, int size, Color fontColor)
			throws Exception {
		blockUntilFound(expectedStrOnScreen, fontName, size, Font.BOLD, fontColor, true);
	}
	public void blockUntilFound(String expectedStrOnScreen, String fontName, int size, int fontStyle, Color fontColor,
			boolean untilNotFound) throws Exception {
		blockUntilFound(expectedStrOnScreen, fontName, size, fontStyle, fontColor, untilNotFound, false);
	}
	static int TRY_MAX_TIMES = 3;
	public boolean blockUntilFound(String expectedStrOnScreen, String fontName, int fontStyle, Color fontColor,
			boolean untilNotFound, boolean moveMouse) {
		PixelMatchResult pixelMatchResult = null;
		int times = 0;
		boolean b = false;
		return b;
	}
	public void blockUntilFound(String expectedStrOnScreen, String fontName, int size, int fontStyle, Color fontColor,
			boolean untilNotFound, boolean moveMouse) throws Exception {
	}
	public PixelMatchResult tryFindText(String expectedStrOnScreen, String fontName, int fontStyle, Color fontColor,
			boolean moveMouse) throws Exception {
		PixelMatchResult pixelMatchResult = null;
		return pixelMatchResult;
	}
	public void editClass(@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) String name, int maxTimes)
			throws Exception {
		for (int i = 0; maxTimes == -1 || i < maxTimes; i++) {
			this.popOpenTypeDialog();
			this.blockUntilFound("Open Type", SPECIAL_DIALOG_FONT_NAME, MENU_ITEM_SIZE, Color.BLACK);
			this.getkRobot().typeStr(name);
			this.blockUntilFound(name, DIALOG_FONT_NAME, Color.BLACK);
			this.getkRobot().enter();
			this.blockUntilNotFound("Open Type", SPECIAL_DIALOG_FONT_NAME, MENU_ITEM_SIZE, Color.BLACK);
			String nameFragements[] = name.split("\\.");
			if (nameFragements.length > 0) {
				/*
				 * this.getkRobot().clickCompositeKey(KeyEvent.VK_CONTROL, KeyEvent.VK_F);
				 * this.blockUntilFound("Find/Replace", "Khmer UI", Color.BLACK);
				 * this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_F); String
				 * strToFind = "class\\s+" + nameFragements[nameFragements.length-1];
				 * this.getkRobot().typeStr(strToFind); this.blockUntilFound(strToFind,
				 * "Khmer UI", Color.BLACK); this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT,
				 * KeyEvent.VK_X); this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT,
				 * KeyEvent.VK_N); Thread.sleep(500L); //in case the regular expression checkbox
				 * chosen already this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT,
				 * KeyEvent.VK_X); this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT,
				 * KeyEvent.VK_N); Thread.sleep(500L);
				 * this.getkRobot().clickCompositeKey(KeyEvent.VK_ESCAPE);
				 * this.blockUntilNotFound("Find/Replace", "Khmer UI", Color.BLACK);
				 */
				this.copyQualifiedName();
				String actualQualifiedName = ClipBoard.getString();
				if (actualQualifiedName.equalsIgnoreCase(name)) {
					return;
				}
			}
		}
	}
	public void editClass(@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) String name) throws Exception {
		editClass(name, 3);
	}
	public void orginizeImports() throws Exception {
		this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_S);
		Thread.sleep(1000);
		this.getkRobot().arrowDown(10);
		Thread.sleep(1000);
		this.getkRobot().enter();
		Thread.sleep(1000);
		this.saveFile();
	}
	public void copyQualifiedName() {
		this.getkRobot().clickCompositeKey(KeyEvent.VK_CONTROL, KeyEvent.VK_BACK_QUOTE);
		this.getkRobot().clickKey(KeyEvent.VK_ESCAPE);// escape for case of no
		/*
		 * try { PixelMatchResult pmr = this.tryFindText( "No Element to qualify found",
		 * DIALOG_FONT_NAME, Font.PLAIN, Color.BLACK, false); if(pmr!=null){
		 * this.getkRobot().clickKey(KeyEvent.VK_ESCAPE); } } catch (Exception e) {
		 * e.printStackTrace(); }
		 */
	}
	public void copyClassQualifiedName(@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) String className)
			throws Exception {
		this.editClass(className);
		Thread.sleep(500);
		this.linkExplorer();
		this.copyQualifiedName();
	}
	public void selectAllClassCode(@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) String classname)
			throws Exception {
		this.editClass(classname);
		this.getkRobot().selectAll();
	}
	public String copyAllClassCode(@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) String classname)
			throws Exception {
		this.selectAllClassCode(classname);
		Thread.sleep(1000);
		this.getkRobot().copy();
		Thread.sleep(1000);
		return ClipBoard.getString();
	}
	@ServiceMethodAnn(keyword = "gen new ArrayList")
	public String genNewArrayList(@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) Class genericType)
			throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		Class c = List.class;
		Class cc = Common.getDefaultConcreteClass(c);
		Common.importC(cc, context);
		context.getVariableMap().put(Replacement.TMP_CLASS_NAME.name(), cc.getSimpleName());
		context.getVariableMap().put(Replacement.GENERIC_TYPE_NAME.name(), Common.getClassName(genericType, context));
		String instanceName = Common.getInstanceName(c);
		context.getVariableMap().put(Replacement.TMP_INSTANCE_NAME.name(), instanceName);
		String str = Common.replaceAllKeyWord(Syntax.INIT_LIST, context.getVariableMap());
		return str;
	}
	@ServiceMethodAnn(keyword = "gen new map")
	public String genNewMap(@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) Class genericTypeKey,
			@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) Class genericTypeValue) throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		Class c = Map.class;
		Class cc = Common.getConcreteClass(c, context);
		Common.importC(cc, context);
		context.getVariableMap().put(Replacement.TMP_CLASS_NAME.name(), cc.getSimpleName());
		context.getVariableMap().put(Replacement.GENERIC_TYPE_KEY.name(), genericTypeKey.getSimpleName());
		context.getVariableMap().put(Replacement.GENERIC_TYPE_VAL.name(), genericTypeValue.getSimpleName());
		String instanceName = Common.getInstanceName(c);
		context.getVariableMap().put(Replacement.TMP_INSTANCE_NAME.name(), instanceName);
		String str = Common.replaceAllKeyWord(Syntax.INIT_Map, context.getVariableMap());
		return str;
	}
	public void formatCode(Class c) throws Exception {
		this.editClass(c);
		Thread.sleep(1000);
		this.format();
	}
	public void format() throws Exception {
		this.getmRobot().mouseClick();
		getkRobot().clickCompositeKey(KeyEvent.VK_CONTROL, KeyEvent.VK_SHIFT, KeyEvent.VK_F);
		Thread.sleep(1000);
	}
	public String genCastViaTargetClass(Class targetC, String targetCName, String value, boolean hasTargetClassDeclare)
			throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		if (hasTargetClassDeclare) {
			context.getVariableMap().put(Replacement.TARGET_CLASS_NAME.name(), targetC.getSimpleName());
			context.getVariableMap().put(Replacement.SEPERATOR.name(), " ");
		} else {
			context.getVariableMap().put(Replacement.TARGET_CLASS_NAME.name(), "");
			context.getVariableMap().put(Replacement.SEPERATOR.name(), "");
		}
		context.getVariableMap().put(Replacement.TARGET_INSTANCE_NAME.name(), targetCName);
		context.getVariableMap().put(Replacement.TMP_CLASS_NAME.name(), targetC.getSimpleName());
		context.getVariableMap().put(Replacement.TMP_INSTANCE_VALUE.name(), value);
		String lineStr = Common.replaceAllKeyWord(Syntax.CAST_LINE, context.getVariableMap());
		return lineStr;
	}
	public String genCastExplicitly(String value, boolean hasTargetClassDeclare, Class targetC, String targetCName)
			throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		if (hasTargetClassDeclare) {
			context.getVariableMap().put(Replacement.TARGET_CLASS_NAME.name(), targetC.getSimpleName());
			context.getVariableMap().put(Replacement.SEPERATOR.name(), " ");
		} else {
			context.getVariableMap().put(Replacement.TARGET_CLASS_NAME.name(), "");
			context.getVariableMap().put(Replacement.SEPERATOR.name(), "");
		}
		context.getVariableMap().put(Replacement.TARGET_INSTANCE_NAME.name(), targetCName);
		context.getVariableMap().put(Replacement.TMP_CLASS_NAME.name(), targetC.getSimpleName());
		context.getVariableMap().put(Replacement.TMP_INSTANCE_VALUE.name(), value);
		String lineStr = Common.replaceAllKeyWord(Syntax.CAST_EXPLICIT_LINE, context.getVariableMap());
		return lineStr;
	}
	@UIAnno(uiClz="ui.GenAnnotationPane")
	@ServiceMethodAnn(keyword = { "declare annotation" })
	public void declareAnnotation() {
	}
	public String genAnnotation(Class<Annotation> c, String... params) {
		if (!c.isAnnotation()) {
			return "";
		}
		if ("org.springframework.beans.factory.annotation.Autowired".equals(c.getCanonicalName())) {
			return "@Autowired";
		}
		else if (params == null || params[0] == null || "".equals(params[0])) {
			return String.format("@%s", c.getSimpleName());
		} else {
			return String.format("@%s(\"%s\")", c.getSimpleName(), params[0]);
		}
	}
	public String genManyFieldsDeclare(@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) Class classes[],
			int modifier, boolean withAutowiredAnnotation, boolean withQualifierAnnotation, String qualifierName, String value) throws Exception {
		StringBuilder sb = new StringBuilder();
		for (Class c : classes) {
			String str = genFieldDeclare(c, Common.getInstanceName(c), modifier, withAutowiredAnnotation,  qualifierName, value);
			sb.append(str).append(Syntax.NEW_LINE);
		}
		return sb.toString();
	}
	@ServiceMethodAnn(keyword = { "gen field declaration" })
	public String genFieldDeclare(@ParamAnno(description = "Field type") @ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) Class c,
			@ParamAnno(description = "Field Name") @ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) String fieldName, int modifier,
			@ParamAnno(description = "Is Autowired") boolean withAutowiredAnnotation,
			@ParamAnno(description = "Qualifier Name") String qualifierName,
			@ParamAnno(description = "Value")String value) throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		Common.setModifier(modifier, context);
		context.getVariableMap().put(Replacement.FIELD_CLASS_NAME.name(), c.getSimpleName());
		context.getVariableMap().put(Replacement.FIELD_INSTANCE_NAME.name(),
				fieldName == null ? Common.getInstanceName(c) : fieldName);
		String str = Common.replaceAllKeyWord(Syntax.FIELD_DECLARE, context.getVariableMap());
		StringBuilder sb = new StringBuilder();
		if(withAutowiredAnnotation){
			sb.append("@Autowired").append(Syntax.NEW_LINE);
		}
		if(null!=qualifierName && !"".equals(qualifierName)){
			sb.append(String.format("@Qualifier(\"%s\")", qualifierName)).append(Syntax.NEW_LINE);
		}
		if(null!=value && !"".equals(value)){
			sb.append(String.format("@Value(\"${%s}\")", value)).append(Syntax.NEW_LINE);
		}
		sb.append(str);
		return sb.toString();
	}
	public String genShortDeclare(String defaultVal, boolean isPrimitiveWrapper) throws Exception {
		return genVariableDeclare(isPrimitiveWrapper ? Short.class : short.class, defaultVal);
	}
	public String genIntDeclare(String defaultVal, boolean isPrimitiveWrapper) throws Exception {
		return genVariableDeclare(isPrimitiveWrapper ? Integer.class : int.class, defaultVal);
	}
	public String genLongDeclare(String defaultVal, boolean isPrimitiveWrapper) throws Exception {
		return genVariableDeclare(isPrimitiveWrapper ? Long.class : long.class, defaultVal);
	}
	public String genByteDeclare(String defaultVal, boolean isPrimitiveWrapper) throws Exception {
		return genVariableDeclare(isPrimitiveWrapper ? Byte.class : byte.class, defaultVal);
	}
	public String genStrDeclare(String defaultVal) throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		return genVariableDeclare(String.class, defaultVal);
	}
	public String genBooleanDeclare(String defaultVal, boolean isPrimitiveWrapper) throws Exception {
		return genVariableDeclare(isPrimitiveWrapper ? Boolean.class : boolean.class, defaultVal);
	}
	public String genVariableDeclare(Class clz, String defaultVal) throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		boolean isComplexType = Common.isComplexType(clz);
		if (!isComplexType) {
			return genPrimitiveVariables(clz);
		} else {
			boolean hasDefaultVal = defaultVal == null ? false : true;
			context.getVariableMap().put(Replacement.TMP_CLASS_NAME.name(), clz.getSimpleName());
			context.getVariableMap().put(Replacement.TMP_INSTANCE_NAME.name(), Common.getInstanceName(clz));
			if (defaultVal != null) {
				context.getVariableMap().put(Replacement.TMP_INSTANCE_VALUE.name(), defaultVal);
			} else if (isComplexType) {
				context.getVariableMap().put(Replacement.TMP_INSTANCE_VALUE.name(), "null");
			}
			hasDefaultVal = context.getVariableMap().get(Replacement.TMP_INSTANCE_VALUE.name()) != null;
			String lineStr = Common.replaceAllKeyWord(hasDefaultVal ? Syntax.ASSIGN_LINE : Syntax.DECLARE_LINE,
					context.getVariableMap());
			return lineStr;
		}
	}
	@ServiceMethodAnn(keyword = { "gen return"})
	public String genReturn(String returnVal) throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		if (returnVal != null) {
			context.getVariableMap().put(Replacement.TMP_INSTANCE_VALUE.name(), returnVal);
		} else {
			context.getVariableMap().put(Replacement.TMP_INSTANCE_VALUE.name(), "");
		}
		String lineStr = Common.replaceAllKeyWord(Syntax.RETURN, context.getVariableMap());
		return lineStr;
	}
	@ServiceMethodAnn(keyword = { "gen string format"})
	public String genStringFormat(String format) throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		context.getVariableMap().put(Replacement.METHOD_PARAMS_VARIABLE.name(), "\"" + format + "\"");
		String lineStr = Common.replaceAllKeyWord(Syntax.STRING_FORMAT, context.getVariableMap());
		return lineStr;
	}
	@ServiceMethodAnn(keyword = { "gen sys out", "system.out" })
	public String genSysOut(String format, boolean withoutStringFormat, boolean printNotInNewLine) throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		String formatStr = null;
		if (!withoutStringFormat) {
			context.getVariableMap().put(Replacement.METHOD_PARAMS_VARIABLE.name(), "\"" + format + "\"");
			formatStr = Common.replaceAllKeyWord(Syntax.STRING_FORMAT, context.getVariableMap()).trim();
			boolean b = formatStr.endsWith(";");
			if (b) {
				formatStr = formatStr.substring(0, formatStr.length() - 1);
			}
		} else {
			formatStr = "";
		}
		if (printNotInNewLine) {
			context.getVariableMap().put(Replacement.METHOD_NAME.name(), "print");
		} else {
			context.getVariableMap().put(Replacement.METHOD_NAME.name(), "println");
		}
		context.getVariableMap().put(Replacement.METHOD_PARAMS_VARIABLE.name(), formatStr);
		String lineStr = Common.replaceAllKeyWord(Syntax.SYS_OUT, context.getVariableMap());
		return lineStr;
	}
	@ServiceMethodAnn(keyword = { "gen sys out", "system.out" })
	public String genSysOut(String format) throws Exception {
		return genSysOut(format, false, false);
	}
	public MethodCallParamVariableCode getConstructorParamVariablesWithDefaultVal(Constructor ct, Map<Class, String> types) throws Exception {
		MethodCallParamVariableCode mcp;
		Class ps[] = ct.getParameterTypes();
		Parameter pts[] = ct.getParameters();
		StringBuilder sb = new StringBuilder();
		List<String> params = new ArrayList<>();
		for (int i = 0; i < ps.length; i++) {
			Class p = ps[i];
			if (types.containsKey(p)) {
				params.add(types.get(p));
			} else {
				boolean b = Common.isComplexType(p);
				if (b) {
					String s = this.genVariableDeclare(p, null);
					sb.append(s);
					String instanceName = Common.getInstanceName(p);
					types.put(p, instanceName);
					params.add(instanceName);
				} else {
					/*
					 * Parameter pt = pts[i]; params.add(pt.getName());
					 */
					Parameter pt = pts[i];
					types.put(p, pt.getName());
					params.add(pt.getName());
					String s = this.genPrimitiveVariable(p, pt.getName());
					sb.append(s);
				}
			}
		}
		String paramArray[] = params.toArray(new String[params.size()]);
		mcp = new MethodCallParamVariableCode(sb.toString(), paramArray);
		return mcp;
	}
	public String genConstructorStr(@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) Class c, Constructor ct,  Map<Class, String> types) throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		StringBuilder codeLine = new StringBuilder();
		MethodCallParamVariableCode mcp = getConstructorParamVariablesWithDefaultVal(ct, types);
		String[] params = mcp.getParamvariables();
		codeLine.append(mcp.getParamVariableDeclareWithDefaultVal());
		String simpleName = c.getSimpleName();
		context.getVariableMap().put(Replacement.ABSTRACT_CLASS_NAME.name(), simpleName);
		context.getVariableMap().put(Replacement.ABSTRACT_INSTANCE_NAME.name(), Common.getInstanceName(c));
		context.getVariableMap().put(Replacement.TMP_CLASS_NAME.name(),simpleName);
		context.getVariableMap().put(Replacement.SEPERATOR.name()," ");
		String paramVariables = Common.genMethodParamsVariable(params);
		context.getVariableMap().put(Replacement.METHOD_PARAMS_VARIABLE.name(), paramVariables);
		String initLine = Common.replaceAllKeyWord(Syntax.ABSTRACT_NEW_INSTANCE_LINE_WITH_DECLARE_OR_NOT,
				context.getVariableMap());
		codeLine.append(initLine);
		return codeLine.toString();
	}
	public MethodCallParamVariableCode getMethodParamVariablesWithDefaultVal(Method method, Map<Class, String> types) throws Exception {
		MethodCallParamVariableCode mcp;
		Class ps[] = method.getParameterTypes();
		Parameter pts[] = method.getParameters();
		StringBuilder sb = new StringBuilder();
		List<String> params = new ArrayList<>();
		for (int i = 0; i < ps.length; i++) {
			Class p = ps[i];
			if (types.containsKey(p)) {
				params.add(types.get(p));
			} else {
				boolean b = Common.isComplexType(p);
				if (b) {
					String s = this.genVariableDeclare(p, null);
					sb.append(s);
					String instanceName = Common.getInstanceName(p);
					types.put(p, instanceName);
					params.add(instanceName);
				} else {
					/*
					 * Parameter pt = pts[i]; params.add(pt.getName());
					 */
					Parameter pt = pts[i];
					types.put(p, pt.getName());
					params.add(pt.getName());
					String s = this.genPrimitiveVariable(p, pt.getName());
					sb.append(s);
				}
			}
		}
		String paramArray[] = params.toArray(new String[params.size()]);
		mcp = new MethodCallParamVariableCode(sb.toString(), paramArray);
		return mcp;
	}
	public String genCallInstanceMethodStr(@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) Class c,
			String objName, String methodName, boolean omitReturn, String... params) throws Exception {
		Method[] ms = Common.getAllMethods(c);
		Method m = null;
		for (Method m1 : ms) {
			if (m1.getName().equals(methodName) && m1.getParameterCount() == (params != null ? params.length : 0)) {
				m = m1;
				break;
			}
		}
		return genCallInstanceMethodStr(c, objName, m, omitReturn, params);
	}
	public String genCallInstanceMethodStr(@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) Class c, Method m,
			boolean omitReturn, String... params) throws Exception {
		return genCallInstanceMethodStr(c, null, m, omitReturn, params);
	}
	public String genCallInstanceMethodStr1(@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) Class c,
			String objName, Method m, boolean omitReturn, Map<Class, String> types) throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		StringBuilder codeLine = new StringBuilder();
		MethodCallParamVariableCode mcp = getMethodParamVariablesWithDefaultVal(m, types);
		String[] params = mcp.getParamvariables();
		codeLine.append(mcp.getParamVariableDeclareWithDefaultVal());
		String instanceName = Common.getInstanceName(c);
		boolean isVoidMethod = omitReturn || Common.isVoid(m);
		context.getVariableMap().put(Replacement.METHOD_RETURN_VALUE.name(), instanceName);
		if (m.getParameterCount() > 0) {
			String paramVariables = null;
			Class t[] = m.getParameterTypes();
			if (t.length == 1 && Common.isFunctionInterface(t[0])) {
				paramVariables = Common.genFunctionImplementation(t[0], params);
			} else {
				paramVariables = Common.genMethodParamsVariable(params);
			}
			context.getVariableMap().put(Replacement.METHOD_PARAMS_VARIABLE.name(), paramVariables);
		} else {
			context.getVariableMap().put(Replacement.METHOD_PARAMS_VARIABLE.name(), "");
		}
		if (!isVoidMethod) {
			Class returnType = m.getReturnType();
			if (returnType.isArray()) {
				Class eType = returnType.getComponentType();
				String clzName = Common.getClassName(eType, context);
				context.getVariableMap().put(Replacement.RETURN_TYPE.name(), clzName);
				String returnInstanceName = Common.getInstanceName(eType) + "Array[]";
				context.getVariableMap().put(Replacement.RETURN_TYPE_INSTANCE.name(), returnInstanceName);
			} else {
				String clzName = Common.getClassName(returnType, context);
				context.getVariableMap().put(Replacement.RETURN_TYPE.name(), clzName);
				String returnInstanceName = Common.getInstanceName(returnType);
				context.getVariableMap().put(Replacement.RETURN_TYPE_INSTANCE.name(), returnInstanceName);
			}
		}
		if (Common.isStatic(m)) {
			context.getVariableMap().put(Replacement.TMP_INSTANCE_NAME.name(), c.getSimpleName());
		} else {
			context.getVariableMap().put(Replacement.TMP_INSTANCE_NAME.name(),
					objName == null ? Common.getInstanceName(c) : objName);
		}
		context.getVariableMap().put(Replacement.METHOD_NAME.name(), m.getName());
		String methodCallingStr = Common.replaceAllKeyWord(
				isVoidMethod ? Syntax.VOID_METHOD_CALLING : Syntax.METHOD_WITH_RETURN_CALLING,
				context.getVariableMap());
		codeLine.append(methodCallingStr);
		if (!omitReturn && Common.isMethodReturnBoolean(m)) {
			codeLine.append(this.genIfElseBlock(false, "b")).append(Syntax.NEW_LINE);
		}
		return codeLine.toString();
	}
	@ServiceMethodAnn(keyword = "gen call method string")
	public String genCallInstanceMethodStr(@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) Class c,
			String objName, Method m, boolean omitReturn, String... params) throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		String instanceName = Common.getInstanceName(c);
		boolean isVoidMethod = omitReturn || Common.isVoid(m);
		context.getVariableMap().put(Replacement.METHOD_RETURN_VALUE.name(), instanceName);
		if (m.getParameterCount() > 0) {
			String paramVariables = null;
			Class t[] = m.getParameterTypes();
			if (t.length == 1 && Common.isFunctionInterface(t[0])) {
				paramVariables = Common.genFunctionImplementation(t[0], params);
			} else {
				paramVariables = Common.genMethodParamsVariable(params);
			}
			context.getVariableMap().put(Replacement.METHOD_PARAMS_VARIABLE.name(), paramVariables);
		} else {
			context.getVariableMap().put(Replacement.METHOD_PARAMS_VARIABLE.name(), "");
		}
		if (!isVoidMethod) {
			Class returnType = m.getReturnType();
			if (returnType.isArray()) {
				Class eType = returnType.getComponentType();
				String clzName = Common.getClassName(eType, context);
				context.getVariableMap().put(Replacement.RETURN_TYPE.name(), clzName);
				String returnInstanceName = Common.getInstanceName(eType) + "Array[]";
				context.getVariableMap().put(Replacement.RETURN_TYPE_INSTANCE.name(), returnInstanceName);
			} else {
				String clzName = Common.getClassName(returnType, context);
				context.getVariableMap().put(Replacement.RETURN_TYPE.name(), clzName);
				String returnInstanceName = Common.getInstanceName(returnType);
				context.getVariableMap().put(Replacement.RETURN_TYPE_INSTANCE.name(), returnInstanceName);
			}
		}
		if (Common.isStatic(m)) {
			context.getVariableMap().put(Replacement.TMP_INSTANCE_NAME.name(), c.getSimpleName());
		} else {
			context.getVariableMap().put(Replacement.TMP_INSTANCE_NAME.name(),
					objName == null ? Common.getInstanceName(c) : objName);
		}
		context.getVariableMap().put(Replacement.METHOD_NAME.name(), m.getName());
		String methodCallingStr = Common.replaceAllKeyWord(
				isVoidMethod ? Syntax.VOID_METHOD_CALLING : Syntax.METHOD_WITH_RETURN_CALLING,
				context.getVariableMap());
		return methodCallingStr;
	}
	public String genInitAClass(Class c) throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		return Common.initAClass(c, Common.getInstanceName(c), false, context);
	}
	public String genInitAClass(Class c, String instanceName) throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		return Common.initAClass(c, instanceName, false, context);
	}
	public String genInitAClassWithNameDeclare(Class c, boolean hasClassNameDeclare) throws Exception {
		return genInitAClassWithNameDeclare(c, Common.getInstanceName(c), hasClassNameDeclare);
	}
	public String genInitAClassWithNameDeclare(Class c, String instanceName, boolean hasClassNameDeclare)
			throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		return Common.initAClass(c, instanceName, hasClassNameDeclare, context);
	}
	@ServiceMethodAnn(keyword = "gen if else")
	public String genIfElseBlock(boolean withoutElse,
			@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) String... expressions) throws Exception {
		StringBuilder sb = new StringBuilder();
		CodeGenContext context = CodeGenContext.getInstance();
		for (int i = 0; i < expressions.length; i++) {
			if (i > 0 && i <= expressions.length - 1) {
				context.getVariableMap().put(Replacement.PREFIX_STR.name(), "else ");
			} else {
				context.getVariableMap().put(Replacement.PREFIX_STR.name(), "");
			}
			context.getVariableMap().put(Replacement.IF_EXPRESSION.name(), expressions[i]);
			String str = Common.replaceAllKeyWord(Syntax.IF_ELSE_BLOCK, context.getVariableMap());
			sb.append(str);
		}
		if (sb.length() > 0 && !withoutElse) {
			String elseStr = Common.replaceAllKeyWord(Syntax.ELSE_BLOCK, context.getVariableMap());
			sb.append(elseStr);
		}
		return sb.toString();
	}
	@ServiceMethodAnn(keyword = "gen try catch")
	public String genTryCatchBlock(Class... exceptions) throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		context.getVariableMap().put(Replacement.TRY_BODY.name(), "");
		StringBuilder sb = new StringBuilder();
		for (Class c : exceptions) {
			sb.append(c.getSimpleName()).append(" | ");
		}
		if (sb.length() > 0) {
			sb.delete(sb.length() - 2, sb.length());
		}
		context.getVariableMap().put(Replacement.EXCEPTIONS_DECLARE.name(), sb.append(" e").toString());
		context.getVariableMap().put(Replacement.CATCH_BODY.name(), "");
		context.getVariableMap().put(Replacement.FINALLY_BODY.name(), "");
		String str = Common.replaceAllKeyWord(Syntax.TRY_CATCH_BLOCK, context.getVariableMap());
		return str;
	}
	@ServiceMethodAnn(keyword = "gen switch block")
	public String genSwitchBlock(@ParamAnno(description = "variable name for switch") @ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) String switchVariable,
			@ParamAnno(description = "case values(seperate by comma)") @ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) String... caseValues) throws Exception {
		StringBuilder sb = new StringBuilder();
		StringBuilder caseSb = new StringBuilder();
		CodeGenContext context = CodeGenContext.getInstance();
		for (int i = 0; i < caseValues.length; i++) {
			context.getVariableMap().put(Replacement.TMP_INSTANCE_NAME.name(), caseValues[i]);
			String casePart = Common.replaceAllKeyWord(Syntax.SWITCH_CASE_BLOCK, context.getVariableMap());
			caseSb.append(casePart).append(Syntax.NEW_LINE);
		}
		String defaultPart = Common.replaceAllKeyWord(Syntax.SWITCH_DEFAULT_BLOCK, context.getVariableMap());
		caseSb.append(defaultPart).append(Syntax.NEW_LINE);
		context.getVariableMap().put(Replacement.TMP_INSTANCE_NAME.name(), switchVariable);
		context.getVariableMap().put(Replacement.BLOCK_BODY.name(), caseSb.toString());
		String str = Common.replaceAllKeyWord(Syntax.SWITCH_BLOCK, context.getVariableMap());
		sb.append(str);
		return sb.toString();
	}
	public String genField(int modifier, @ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) Class pt,
			boolean withDefaultVal) throws Exception {
		StringBuilder stringBuilder = new StringBuilder();
		CodeGenContext context = CodeGenContext.getInstance();
		if (!Common.isComplexType(pt)) {
			Common.setModifier(modifier, context);
			context.getVariableMap().put(Replacement.FIELD_CLASS_NAME.name(), pt.getSimpleName());
			context.getVariableMap().put(Replacement.FIELD_INSTANCE_NAME.name(), Common.getInstanceName(pt));
			context.getVariableMap().put(Replacement.TMP_INSTANCE_VALUE.name(), Common.getDefaultVal(pt));
			String str = Common.replaceAllKeyWord(Syntax.FIELD_DECLARE_WITH_ASSIGN, context.getVariableMap());
			stringBuilder.append(str);
		}
		return stringBuilder.toString();
	}
	public String genPrimitiveFields(boolean intVariable, boolean booleanVariable, boolean stringVariable,
			boolean longVariable, boolean doubleVariable, boolean floatVariable, boolean charVariable,
			boolean shortVariable, boolean byteVariable, boolean bigIntegerVariable, boolean bigDecimalVariable,
			boolean xmlGregorianCalendarVariable, int modifier) throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		List<Class<?>> list = new ArrayList<>();
		if (intVariable) {
			list.add(int.class);
		}
		if (booleanVariable) {
			list.add(boolean.class);
		}
		if (stringVariable) {
			list.add(String.class);
		}
		if (longVariable) {
			list.add(long.class);
		}
		if (doubleVariable) {
			list.add(double.class);
		}
		if (floatVariable) {
			list.add(float.class);
		}
		if (charVariable) {
			list.add(char.class);
		}
		if (shortVariable) {
			list.add(short.class);
		}
		if (byteVariable) {
			list.add(byte.class);
		}
		if (bigIntegerVariable) {
			list.add(BigInteger.class);
		}
		if (bigDecimalVariable) {
			list.add(BigDecimal.class);
		}
		if (xmlGregorianCalendarVariable) {
			list.add(XMLGregorianCalendar.class);
		}
		StringBuilder stringBuilder = new StringBuilder();
		for (Class pt : list) {
			if (!Common.isComplexType(pt)) {
				Common.setModifier(modifier, context);
				context.getVariableMap().put(Replacement.FIELD_CLASS_NAME.name(), pt.getSimpleName());
				context.getVariableMap().put(Replacement.FIELD_INSTANCE_NAME.name(), Common.getInstanceName(pt));
				context.getVariableMap().put(Replacement.TMP_INSTANCE_VALUE.name(), Common.getDefaultVal(pt));
				String str = Common.replaceAllKeyWord(Syntax.FIELD_DECLARE_WITH_ASSIGN, context.getVariableMap());
				stringBuilder.append(str);
			}
		}
		return stringBuilder.toString();
	}
	@ServiceMethodAnn(keyword = "gen primitive wrapper fields")
	public String genPrimitiveWrapperFields(boolean IntegerVariable, boolean BooleanVariable, boolean StringVariable,
			boolean LongVariable, boolean DoubleVariable, boolean FloatVariable, boolean CharacterVariable,
			boolean ShortVariable, boolean ByteVariable, boolean BigIntegerVariable, boolean BigDecimalVariable,
			boolean xmlGregorianCalendarVariable) throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		List<Class> list = new ArrayList<>();
		if (IntegerVariable) {
			list.add(Integer.class);
		}
		if (BooleanVariable) {
			list.add(Boolean.class);
		}
		if (StringVariable) {
			list.add(String.class);
		}
		if (LongVariable) {
			list.add(Long.class);
		}
		if (DoubleVariable) {
			list.add(Double.class);
		}
		if (FloatVariable) {
			list.add(Float.class);
		}
		if (CharacterVariable) {
			list.add(Character.class);
		}
		if (ShortVariable) {
			list.add(Short.class);
		}
		if (ByteVariable) {
			list.add(Byte.class);
		}
		if (BigIntegerVariable) {
			list.add(BigInteger.class);
		}
		if (BigDecimalVariable) {
			list.add(BigDecimal.class);
		}
		if (xmlGregorianCalendarVariable) {
			list.add(XMLGregorianCalendar.class);
		}
		StringBuilder stringBuilder = new StringBuilder();
		for (Class pt : list) {
			context.getVariableMap().put(Replacement.PRIVILEDGE_MODIFIER.name(), "private");
			context.getVariableMap().put(Replacement.STATIC_MODIFIER.name(), "");
			context.getVariableMap().put(Replacement.FIELD_CLASS_NAME.name(), pt.getSimpleName());
			context.getVariableMap().put(Replacement.FIELD_INSTANCE_NAME.name(), Common.getInstanceName(pt));
			context.getVariableMap().put(Replacement.TMP_INSTANCE_VALUE.name(), Common.getDefaultVal(pt));
			String str = Common.replaceAllKeyWord(Syntax.FIELD_DECLARE_WITH_ASSIGN, context.getVariableMap());
			stringBuilder.append(str);
		}
		return stringBuilder.toString();
	}
	public String genPrimitiveVariables(@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) Class... primitiveClz)
			throws Exception {
		StringBuilder stringBuilder = new StringBuilder();
		for (Class pt : primitiveClz) {
			if (!Common.isComplexType(pt)) {
				CodeGenContext context = CodeGenContext.getInstance();
				context.getVariableMap().put(Replacement.TMP_CLASS_NAME.name(), pt.getSimpleName());
				context.getVariableMap().put(Replacement.TMP_INSTANCE_NAME.name(), Common.getInstanceName(pt));
				context.getVariableMap().put(Replacement.TMP_INSTANCE_VALUE.name(), Common.getDefaultVal(pt));
				String str = Common.replaceAllKeyWord(Syntax.ASSIGN_LINE, context.getVariableMap());
				stringBuilder.append(str);
			}
		}
		return stringBuilder.toString();
	}
	@Deprecated
	public String genPrimitiveVariable(@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) Class primitiveClz,
			String instanceName) throws Exception {
		StringBuilder stringBuilder = new StringBuilder();
		if (!Common.isComplexType(primitiveClz)) {
			CodeGenContext context = CodeGenContext.getInstance();
			context.getVariableMap().put(Replacement.TMP_CLASS_NAME.name(), primitiveClz.getSimpleName());
			context.getVariableMap().put(Replacement.TMP_INSTANCE_NAME.name(),
					!Common.isBlank(instanceName) ? instanceName : Common.getInstanceName(primitiveClz));
			context.getVariableMap().put(Replacement.TMP_INSTANCE_VALUE.name(), Common.getDefaultVal(primitiveClz));
			String str = Common.replaceAllKeyWord(Syntax.ASSIGN_LINE, context.getVariableMap());
			stringBuilder.append(str);
		}
		return stringBuilder.toString();
	}
	@ServiceMethodAnn(keyword = "new prmitive variables")
	public String genPrimitiveVariables(boolean intVariable, boolean booleanVariable, boolean stringVariable,
			boolean longVariable, boolean doubleVariable, boolean floatVariable, boolean charVariable,
			boolean shortVariable, boolean byteVariable, boolean bigIntegerVariable, boolean bigDecimalVariable,
			boolean xmlGregorianCalendarVariable) throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		List<Class> list = new ArrayList<>();
		if (intVariable) {
			list.add(int.class);
		}
		if (booleanVariable) {
			list.add(boolean.class);
		}
		if (stringVariable) {
			list.add(String.class);
		}
		if (longVariable) {
			list.add(long.class);
		}
		if (doubleVariable) {
			list.add(double.class);
		}
		if (floatVariable) {
			list.add(float.class);
		}
		if (charVariable) {
			list.add(char.class);
		}
		if (shortVariable) {
			list.add(short.class);
		}
		if (byteVariable) {
			list.add(byte.class);
		}
		if (bigIntegerVariable) {
			list.add(BigInteger.class);
		}
		if (bigDecimalVariable) {
			list.add(BigDecimal.class);
		}
		if (xmlGregorianCalendarVariable) {
			list.add(XMLGregorianCalendar.class);
		}
		Class clz[] = list.toArray(new Class[] {});
		return genPrimitiveVariables(clz);
	}
	@ServiceMethodAnn(keyword = "new prmitive wrapper variables")
	public String genPrimitiveWrapperVariables(boolean IntegerVariable, boolean BooleanVariable, boolean StringVariable,
			boolean LongVariable, boolean DoubleVariable, boolean FloatVariable, boolean CharacterVariable,
			boolean ShortVariable, boolean ByteVariable, boolean BigIntegerVariable, boolean BigDecimalVariable,
			boolean xmlGregorianCalendarVariable) throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		List<Class> list = new ArrayList<>();
		if (IntegerVariable) {
			list.add(Integer.class);
		}
		if (BooleanVariable) {
			list.add(Boolean.class);
		}
		if (StringVariable) {
			list.add(String.class);
		}
		if (LongVariable) {
			list.add(Long.class);
		}
		if (DoubleVariable) {
			list.add(Double.class);
		}
		if (FloatVariable) {
			list.add(Float.class);
		}
		if (CharacterVariable) {
			list.add(Character.class);
		}
		if (ShortVariable) {
			list.add(Short.class);
		}
		if (ByteVariable) {
			list.add(Byte.class);
		}
		if (BigIntegerVariable) {
			list.add(BigInteger.class);
		}
		if (BigDecimalVariable) {
			list.add(BigDecimal.class);
		}
		if (xmlGregorianCalendarVariable) {
			list.add(XMLGregorianCalendar.class);
		}
		Class clz[] = list.toArray(new Class[] {});
		return genPrimitiveVariables(clz);
	}
	@ServiceMethodAnn(keyword = "gen loop with int variable")
	public String genForLoopWithIntBlock() throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		Class c = int.class;
		context.getVariableMap().put(Replacement.TMP_CLASS_NAME.name(), c.getSimpleName());
		context.getVariableMap().put(Replacement.TMP_INSTANCE_NAME.name(), Common.getInstanceName(c));
		String str = Common.replaceAllKeyWord(Syntax.FOR_LOOP_INCREMENT_BLOCK, context.getVariableMap());
		return str;
	}
	@ServiceMethodAnn(keyword = "gen loop with double variable")
	public String genForLoopWithDoubleBlock() throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		Class c = double.class;
		context.getVariableMap().put(Replacement.TMP_CLASS_NAME.name(), c.getSimpleName());
		context.getVariableMap().put(Replacement.TMP_INSTANCE_NAME.name(), Common.getInstanceName(c));
		String str = Common.replaceAllKeyWord(Syntax.FOR_LOOP_INCREMENT_BLOCK, context.getVariableMap());
		return str;
	}
	@ServiceMethodAnn(keyword = "gen loop with int variable in desc order")
	public String genForLoopWithIntDecrementBlock() throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		Class c = int.class;
		context.getVariableMap().put(Replacement.TMP_CLASS_NAME.name(), c.getSimpleName());
		context.getVariableMap().put(Replacement.TMP_INSTANCE_NAME.name(), Common.getInstanceName(c));
		String str = Common.replaceAllKeyWord(Syntax.FOR_LOOP_DECREMENT_BLOCK, context.getVariableMap());
		return str;
	}
	@ServiceMethodAnn(keyword = "gen loop with double variable in desc order")
	public String genForLoopWithDoubleDecrementBlock() throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		Class c = double.class;
		context.getVariableMap().put(Replacement.TMP_CLASS_NAME.name(), c.getSimpleName());
		context.getVariableMap().put(Replacement.TMP_INSTANCE_NAME.name(), Common.getInstanceName(c));
		String str = Common.replaceAllKeyWord(Syntax.FOR_LOOP_DECREMENT_BLOCK, context.getVariableMap());
		return str;
	}
	@ServiceMethodAnn(keyword = "gen while")
	public String genWhileBlock(String expression) throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		context.getVariableMap().put(Replacement.TMP_INSTANCE_NAME.name(), expression);
		context.getVariableMap().put(Replacement.BLOCK_BODY.name(), "");
		String str = Common.replaceAllKeyWord(Syntax.WHILE_BLOCK, context.getVariableMap());
		return str;
	}
	@ServiceMethodAnn(keyword = "gen do while")
	public String genDoWhileBlock(String expression) throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		context.getVariableMap().put(Replacement.TMP_INSTANCE_NAME.name(), expression);
		context.getVariableMap().put(Replacement.BLOCK_BODY.name(), "");
		String str = Common.replaceAllKeyWord(Syntax.DO_WHILE_BLOCK, context.getVariableMap());
		return str;
	}
	@ServiceMethodAnn(keyword = "gen synchronized block")
	public String genSynchronizedBlock(String objMonitor) throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		context.getVariableMap().put(Replacement.TMP_INSTANCE_NAME.name(), objMonitor);
		context.getVariableMap().put(Replacement.BLOCK_BODY.name(), "");
		String str = Common.replaceAllKeyWord(Syntax.SYNCHRONIZED_BLOCK, context.getVariableMap());
		return str;
	}
	public void importC(Class c) throws Exception {
		this.getkRobot().clickCompositeKey(KeyEvent.VK_CONTROL, KeyEvent.VK_SHIFT, KeyEvent.VK_T);
		Thread.sleep(500);
		this.getkRobot().typeStr(c.getName());
		Thread.sleep(500);
		this.getkRobot().enter();
		Thread.sleep(500);
	}
	public void moveCusorToBeforeLastMethod() throws Exception {
		this.getkRobot().clickCompositeKey(KeyEvent.VK_CONTROL, KeyEvent.VK_O);
		Thread.sleep(500);
		this.getkRobot().arrowDown();
		this.getkRobot().end();
		this.getkRobot().enter();
		this.getkRobot().arrowUp();
		this.getkRobot().end();
		this.getkRobot().enter();
	}
	public void moveCusorToFieldArea() throws Exception {
		this.getkRobot().clickCompositeKey(KeyEvent.VK_CONTROL, KeyEvent.VK_O);
		Thread.sleep(500);
		this.getkRobot().arrowDown();
		this.getkRobot().home();
		this.getkRobot().arrowDown();
		this.getkRobot().enter();
		this.getkRobot().arrowDown();
		this.getkRobot().end();
		this.getkRobot().enter();
	}
	@SuppressWarnings("rawtypes")
	public String genNewMethod(String methodName, Class<?> returnType, int modifier, Class[] exceptions,
			Map.Entry<Class, String>... params) throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		Common.setModifier(modifier, context);
		context.getVariableMap().put(Replacement.METHOD_RETURN_TYPE.name(),
				returnType == Void.class ? "void" : returnType.getSimpleName());
		context.getVariableMap().put(Replacement.METHOD_NAME.name(), methodName);
		context.getVariableMap().put(Replacement.METHOD_RETURN_VALUE.name(), "");
		context.getVariableMap().put(Replacement.METHOD_BODY.name(), "");
		context.getVariableMap().put(Replacement.METHOD_PARAMS_DECLARE.name(),
				Common.genMethodParamDeclareVariable(params));
		context.getVariableMap().put(Replacement.THROWS_EXCEPTION.name(), Common.genExceptionThrows(exceptions));
		String str = Common.replaceAllKeyWord(Syntax.NORMAL_METHOD, context.getVariableMap());
		return str;
	}
	@ServiceMethodAnn(keyword = "new method")
	public String genNewMethod(@ParamAnno(description = "Method Name") @ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) String methodName, int modifier,
			@ParamAnno(description = "Return Type") Class rt,
			@ParamAnno(description = "Method Parameter Types") Class[] params,
			@ParamAnno(description = "Method Exception Types") Class... exceptions) throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		Common.setModifier(modifier, context);
		if(null!=rt) {
			context.getVariableMap().put(Replacement.METHOD_RETURN_TYPE.name(),
					rt == void.class ? "void" : rt.getSimpleName());
		}
		context.getVariableMap().put(Replacement.METHOD_NAME.name(), methodName);
		context.getVariableMap().put(Replacement.METHOD_RETURN_VALUE.name(),
				rt == void.class ? "" : Common.getInstanceName(rt));
		context.getVariableMap().put(Replacement.METHOD_BODY.name(), "");
		String paramDeclare = Common.genMethodParamsDeclaration(params);
		context.getVariableMap().put(Replacement.METHOD_PARAMS_DECLARE.name(), paramDeclare);
		context.getVariableMap().put(Replacement.THROWS_EXCEPTION.name(), Common.genExceptionThrows(exceptions));
		String str = Common.replaceAllKeyWord(Syntax.NORMAL_METHOD, context.getVariableMap());
		return str;
	}
	@ServiceMethodAnn(keyword = "new controller method,spring mvc endpoint")
	public String genControllerMethod(
			@ParamAnno(description = "Method Name") @ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) String methodName, boolean post,
			@ParamAnno(description = "Request Path") String path,
			@ParamAnno(description = "Path variable name") String pathVariableName,
			@ParamAnno(description = "Request parameter name") String requestParamName,
			@ParamAnno(description = "Is Application Form Media Type") boolean consumeUrlEncodeEntireFormData, @ParamAnno(description = "RequestBody Generic Class") Class<?> reqBodyClz,
			@ParamAnno(description = "Contain Response Body Annotation") boolean withResponseBodyAnnotation, int modifier) throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		Common.setModifier(modifier, context);
		context.getVariableMap().put(Replacement.PATH.name(), path);
		context.getVariableMap().put(Replacement.METHOD_STR.name(),
				String.format(",method=RequestMethod.%s", post ? "POST" : "GET"));
		context.getVariableMap().put(Replacement.HEADERS.name(), "");
		context.getVariableMap().put(Replacement.CONSUMERS.name(), consumeUrlEncodeEntireFormData ? ", consumes=MediaType.APPLICATION_FORM_URLENCODED_VALUE" : "");
		StringBuilder produceSb = new StringBuilder();
		context.getVariableMap().put(Replacement.PRODUCES.name(), produceSb.toString());
		context.getVariableMap().put(Replacement.RESPONSE_BODY.name(),
				withResponseBodyAnnotation ? "@ResponseBody ResponseEntity<?>" : "");
		context.getVariableMap().put(Replacement.METHOD_RETURN_TYPE.name(), withResponseBodyAnnotation ? "@ResponseBody ResponseEntity<?>" : "String");
		context.getVariableMap().put(Replacement.METHOD_NAME.name(), methodName);
		context.getVariableMap().put(Replacement.METHOD_RETURN_VALUE.name(), withResponseBodyAnnotation ? "new ResponseEntity(HttpStatus.OK)" : "\"\"");
		context.getVariableMap().put(Replacement.METHOD_BODY.name(), "");
		String paramDeclareJoinStr = "";
		if(!"".equals(pathVariableName.trim())) {
			context.getVariableMap().put(Replacement.TMP_INSTANCE_VALUE.name(), pathVariableName);
			String pathVariable = Common.replaceAllKeyWord("@PathVariable(value=\"$TMP_INSTANCE_VALUE$\") String $TMP_INSTANCE_VALUE$", context.getVariableMap());
			paramDeclareJoinStr += pathVariable;
		}
		if(paramDeclareJoinStr.length()>0) {
			paramDeclareJoinStr +=",";
		}
		if(!"".equals(requestParamName.trim())) {
			context.getVariableMap().put(Replacement.TMP_INSTANCE_VALUE.name(), requestParamName);
			String pathVariable = Common.replaceAllKeyWord("@RequestParam(value=\"$TMP_INSTANCE_VALUE$\", required=true) String $TMP_INSTANCE_VALUE$", context.getVariableMap());
			paramDeclareJoinStr += pathVariable;
		}
		if(paramDeclareJoinStr.length()>0) {
			paramDeclareJoinStr +=",";
		}
		paramDeclareJoinStr = paramDeclareJoinStr + "HttpServletRequest request,HttpServletResponse response";
		if(consumeUrlEncodeEntireFormData) {
			if(paramDeclareJoinStr.length()>0) {
				paramDeclareJoinStr +=",";
			}
			paramDeclareJoinStr =paramDeclareJoinStr+ "@RequestBody MultiValueMap<String, String> formData";
		} else if(null!=reqBodyClz) {
			if(paramDeclareJoinStr.length()>0) {
				paramDeclareJoinStr +=",";
			}
			paramDeclareJoinStr =paramDeclareJoinStr+ "@RequestBody "+reqBodyClz.getSimpleName();
		}
		context.getVariableMap().put(Replacement.METHOD_PARAMS_DECLARE.name(), paramDeclareJoinStr);
		context.getVariableMap().put(Replacement.THROWS_EXCEPTION.name(), "");
		String str = Common.replaceAllKeyWord(Syntax.CONTROLLER_METHOD, context.getVariableMap());
		context.getVariableMap().remove(Replacement.TMP_INSTANCE_VALUE.name());
		return str;
	}
	public String genControllerMethod(@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) String methodName,
			String path, boolean isPostMethod, Class returnType,
			boolean withPathVariableAnnotation, Class[] methodParams, boolean withResponseBodyAnnotation,
			boolean produceXml, boolean produceJson, boolean produceTextHtml, String headers, int modifier,
			Class[] exceptions) throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		Common.setModifier(modifier, context);
		context.getVariableMap().put(Replacement.PATH.name(), path);
		context.getVariableMap().put(Replacement.METHOD_STR.name(),
				String.format(",method=RequestMethod.%s", isPostMethod ? "POST" : "GET"));
		String sArray[] = !"".equals(headers.trim()) ? headers.split(",") : new String[] {};
		String headersJoinStr = sArray.length > 0 ? Stream.of(sArray).collect(Collectors.joining("\",\"", "\"", "\""))
				: "";
		if (headersJoinStr.length() > 0) {
			headersJoinStr = ", headers={" + headersJoinStr + "}";
		}
		context.getVariableMap().put(Replacement.HEADERS.name(), headersJoinStr);
		context.getVariableMap().put(Replacement.CONSUMERS.name(), "");
		StringBuilder produceSb = new StringBuilder();
		boolean b = false;
		if (produceJson) {
			produceSb.append("\"MediaType.APPLICATION_JSON_VALUE\"");
			b = true;
		}
		if (produceXml) {
			if (b) {
				produceSb.append(",");
			}
			produceSb.append("\"MediaType.APPLICATION_XML_VALUE\"");
			b = true;
		}
		if (produceTextHtml) {
			if (b) {
				produceSb.append(",");
			}
			produceSb.append("\"MediaType.TEXT_HTML_VALUE\"");
		}
		if (produceSb.length() > 0) {
			produceSb.insert(0, ", produces={");
			produceSb.append("}");
		}
		context.getVariableMap().put(Replacement.PRODUCES.name(), produceSb.toString());
		context.getVariableMap().put(Replacement.RESPONSE_BODY.name(),
				withResponseBodyAnnotation ? "@ResponseBody" : "");
		context.getVariableMap().put(Replacement.METHOD_RETURN_TYPE.name(),
				returnType == Void.class ? "void" : returnType.getSimpleName());
		context.getVariableMap().put(Replacement.METHOD_NAME.name(), methodName);
		context.getVariableMap().put(Replacement.METHOD_RETURN_VALUE.name(), Common.getInstanceName(returnType));
		context.getVariableMap().put(Replacement.METHOD_BODY.name(), "");
		String paramDeclare = Common.genMethodParamsDeclaration(methodParams);
		String sArray1[] = !"".equals(paramDeclare.trim()) ? paramDeclare.split(",") : new String[] {};
		String paramDeclareJoinStr = sArray1.length > 0
				? Stream.of(sArray1).collect(Collectors.joining(",", "@PathVariable(\"\")", ""))
				: "";
		context.getVariableMap().put(Replacement.METHOD_PARAMS_DECLARE.name(), paramDeclareJoinStr);
		context.getVariableMap().put(Replacement.THROWS_EXCEPTION.name(), Common.genExceptionThrows(exceptions));
		String str = Common.replaceAllKeyWord(Syntax.CONTROLLER_METHOD, context.getVariableMap());
		return str;
	}
	private String genNewMethod(String methodName, String methodBody, Class returnType, int modifier, Class[] params,
			Class... exceptions) throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		Common.setModifier(modifier, context);
		context.getVariableMap().put(Replacement.METHOD_RETURN_TYPE.name(),
				returnType == Void.class ? "void" : returnType.getSimpleName());
		context.getVariableMap().put(Replacement.METHOD_NAME.name(), methodName);
		context.getVariableMap().put(Replacement.METHOD_RETURN_VALUE.name(), Common.getInstanceName(returnType));
		context.getVariableMap().put(Replacement.METHOD_BODY.name(), methodBody);
		String paramDeclare = Common.genMethodParamsDeclaration(params);
		context.getVariableMap().put(Replacement.METHOD_PARAMS_DECLARE.name(), paramDeclare);
		context.getVariableMap().put(Replacement.THROWS_EXCEPTION.name(), Common.genExceptionThrows(exceptions));
		String str = Common.replaceAllKeyWord(Syntax.NORMAL_METHOD, context.getVariableMap());
		return str;
	}
	public String genNewMethodReturnVoid(String methodName, int modifier, Class[] params, Class... exceptions)
			throws Exception {
		return genNewMethod(methodName, modifier, Void.class, params, exceptions);
	}
	public String genNewMethodReturnVoid(String methodName, int modifier, Class[] exceptions,
			Map.Entry<Class, String>... params) throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		Common.setModifier(modifier, context);
		context.getVariableMap().put(Replacement.METHOD_PARAMS_DECLARE.name(),
				Common.genMethodParamDeclareVariable(params));
		context.getVariableMap().put(Replacement.METHOD_RETURN_TYPE.name(), "");
		context.getVariableMap().put(Replacement.METHOD_NAME.name(), methodName);
		context.getVariableMap().put(Replacement.METHOD_RETURN_VALUE.name(), "");
		context.getVariableMap().put(Replacement.METHOD_BODY.name(), "");
		context.getVariableMap().put(Replacement.THROWS_EXCEPTION.name(), Common.genExceptionThrows(exceptions));
		String str = Common.replaceAllKeyWord(Syntax.NORMAL_METHOD, context.getVariableMap());
		return str;
	}
	public String genNewExceptionThrow(Class<? extends Exception> c, String... strings) throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		strings = strings == null ? new String[] { "" } : strings;
		context.getVariableMap().put(Replacement.METHOD_PARAMS_VARIABLE.name(),
				Common.genMethodParamsVariable(strings));
		context.getVariableMap().put(Replacement.TMP_CLASS_NAME.name(), c.getSimpleName());
		String str = Common.replaceAllKeyWord(Syntax.NEW_EXCEPTION_THROW, context.getVariableMap());
		return str;
	}
	@ServiceMethodAnn(keyword = "switch Process")
	public boolean switchProcess() throws Exception {
		return sendKeys(CodeGenContext.getIDEProcNameKeyword(), "");
	}
	@ServiceMethodAnn(keyword = "paste")
	public boolean paste() throws IOException {
		return sendKeys(CodeGenContext.getIDEProcNameKeyword(),"^(v)");
	}
	public boolean sendKeys(String processNameContain, String keys)
			throws IOException {
		boolean b = false;
		keys = "\""+ keys +"\"";
		String path = CodeGenContext.getCGKeyAppPath();
		Process proc = Runtime.getRuntime().exec(String.format("%s %s %s",path, processNameContain, keys));
		BufferedReader stdInput = new BufferedReader(new
				InputStreamReader(proc.getInputStream()));
		BufferedReader stdError = new BufferedReader(new
				InputStreamReader(proc.getErrorStream()));
		String s = null;
		while ((s = stdInput.readLine()) != null) {
			if("0".equalsIgnoreCase(s)){
				return true;
			}else{
				return false;
			}
		}
		System.out.println("Here is the standard error of the command (if any):\n");
		while ((s = stdError.readLine()) != null) {
			if("0".equalsIgnoreCase(s)){
				return true;
			}else{
				return false;
			}
		}
		return b;
	}
	public static void tryActiveEclipseWindow(boolean blockUtilActive) throws Exception {
		return;
	}
	public boolean isActiveEclipseWindow() {
		boolean b = false;
		String activeWindow = null;
		int maxTime = 3;
		do {
			try {
				activeWindow = getActiveWindow();
			} catch (Exception e) {
			}
			maxTime--;
			b=activeWindow.toLowerCase().contains(Const.ECLIPSE_WINDOW_TITLE_KEYWORD);
			if(!b) {
				try {
					Thread.sleep(300L);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
			}
		} while (activeWindow != null && !b
				&& maxTime > 0);
		return b;
	}
	@ServiceMethodAnn(keyword = "get active window")
	public String getActiveWindow() throws Exception {
		return windowService.getActiveWindowText();
	}
	public boolean isActiveWindowTitleContainIgnoreCase(String title) throws Exception {
		String currentActiveWindow = this.windowService.getActiveWindowText();
		currentActiveWindow = currentActiveWindow.toLowerCase();
		return currentActiveWindow.contains(title);
	}
	public static boolean isActiveWindowTitleEqualsIgnoreCase(String title) throws Exception {
		return false;
	}
	public void deleteLine() {
		this.getkRobot().clickCompositeKey(KeyEvent.VK_CONTROL, KeyEvent.VK_D);
	}
	@ServiceMethodAnn(keyword = "gen main method")
	public String genMain() {
		return Syntax.MAIN_BLOCK;
	}
	public void newSthHotKey() {
		this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_SHIFT, KeyEvent.VK_N);
	}
	public void saveFile() {
		this.getkRobot().clickCompositeKey(KeyEvent.VK_CONTROL, KeyEvent.VK_S);
	}
	public void fixProb() {
		this.getkRobot().clickCompositeKey(KeyEvent.VK_CONTROL, KeyEvent.VK_1);
	}
	public void closeTab() {
		this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_MINUS);
		this.getkRobot().clickKey(KeyEvent.VK_C);
	}
	public void closeAllTab() {
		this.getkRobot().clickCompositeKey(KeyEvent.VK_CONTROL, KeyEvent.VK_SHIFT, KeyEvent.VK_W);
	}
	public void linkExplorer() {
		this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_SHIFT, KeyEvent.VK_W);
		this.getkRobot().arrowDown();
		this.getkRobot().enter();
	}
	@ServiceMethodAnn(keyword = "new file wizard")
	public void createFileByOtherWizard(String jspFileName, String fileType) throws Exception {
		if(!this.openWizard())
			return;
		Thread.sleep(500);
		this.getkRobot().typeStr("jsp file");
		this.getkRobot().enter();
		Thread.sleep(500);
		this.getkRobot().typeStr(fileType);
		this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_N);
		Thread.sleep(500);
		this.getkRobot().typeStr(jspFileName);
		this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_N);
		Thread.sleep(500);
		this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_F);
	}
	@ServiceMethodAnn(keyword = "new jsp file")
	public void createJspFileByOtherWizard(String fileName, String fileType) throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		createFileByOtherWizard(fileName, "jsp file");
	}
	@ServiceMethodAnn(keyword = "new css file")
	public void createCssFileByOtherWizard(String fileName, String fileType) throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		createFileByOtherWizard(fileName, "css file");
	}
	@ServiceMethodAnn(keyword = "new html file")
	public void createHtmlFileByOtherWizard(String fileName, String fileType) throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		createFileByOtherWizard(fileName, "html file");
	}
	@ServiceMethodAnn(keyword = "create maven project by template")
	public void createNewMavenProjByTemplate(String groupId, String artifactroyId, String version, String pack,
			@ParamAnno(description = "Target Directory")
			@FileChooserAnnotation(chooseDirOnly = true) @ValidationAnn(validations = {
					"codegen.eclipseRobot.MandatoryCheck" }) File baseDirectory)
			throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		String baseDir = baseDirectory.getAbsolutePath();
		InputStream is = this.getClass().getClassLoader().getResourceAsStream("pom.xml.template2");
		String pomTemplate = Common.readAsStr(is);
		context.getVariableMap().put(MoreReplacement.GROUP_ID.name(), groupId);
		context.getVariableMap().put(MoreReplacement.ARTIFACT_ID.name(), artifactroyId);
		context.getVariableMap().put(MoreReplacement.ARTIFACT_VERSION.name(),
				version != null && !"".equals(version.trim()) ? version : "1.0-SNAPSHOT");
		context.getVariableMap().put(MoreReplacement.ARTIFACT_PACK.name(),
				pack != null && !"".equals(pack.trim()) ? pack : "jar");
		String pomStr = Common.replaceAllKeyWord(pomTemplate, context.getVariableMap());
		File file = new File(baseDir + "/src/test/java");
		file.mkdirs();
		File mainDir = new File(baseDir + "/src/main/java");
		mainDir.mkdirs();
		File rsDir = new File(baseDir + "/src/main/resources");
		rsDir.mkdirs();
		File pomFile = new File(baseDir + File.separatorChar + "pom.xml");
		Common.write(pomFile, pomStr);
		if(!this.isActiveEclipseWindow())
			return;
		this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_F);
		this.getkRobot().clickKey(KeyEvent.VK_I);
		Thread.sleep(100);
		this.getkRobot().typeStr("existing maven project");
		Thread.sleep(500);
		this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_N);
		Thread.sleep(500);
		this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_R);
		Thread.sleep(500);
		this.getkRobot().typeStr(baseDir);
		this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_A);
		Thread.sleep(500);
		this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_F);
	}
	@ServiceMethodAnn(keyword = { "run cp monitor" })
	public void runClipboardMonitor(File targetFile) {
		runExternalApp(targetFile, " host localhost port 8888");
	}
	@ServiceMethodAnn(keyword = { "run app" })
	public void runExternalApp(File targetFile,
			String args) {
		Runtime runtime = Runtime.getRuntime();
		String path = targetFile.getAbsolutePath() + " " + args;
		Process process = null;
		try {
			process = runtime.exec(path);
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
	@ServiceMethodAnn(keyword = { "gen maven dependency"})
	public static String genMavenDependency(String groupId, String arttifactorId, String version, String scope) throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		context.getVariableMap().put(Replacement.GROUP_ID.name(), groupId);
		context.getVariableMap().put(Replacement.ARTIFACTOR_ID.name(), arttifactorId);
		context.getVariableMap().put(Replacement.VERSION.name(), version);
		context.getVariableMap().put(Replacement.SCOPE.name(), scope);
		String str = Common.replaceAllKeyWord(Syntax.MAVEN_DEPENDENCY, context.getVariableMap());
		str = str.replaceAll("\\s*<version></version>\\s*","");
		str = str.replaceAll("\\s*<scope>\\s*</scope>","");
		return str;
	}
	@ServiceMethodAnn(keyword = { "string append", "string builder", "string buffer" })
	public static String genStringAppend(boolean stringBuilder, boolean stringBuffer) {
		StringBuilder sb = new StringBuilder();
		String str = stringBuilder ? "StringBuilder" : "StringBuffer";
		sb.append(String.format("%s sb = new %s();", str, str)).append(Syntax.NEW_LINE);
		sb.append(String.format("sb.append();"));
		return sb.toString();
	}
	@ServiceMethodAnn(keyword = { "string split", "string join" })
	public static String genStringSplitThenJoin(String delimiterWhenSplit, String delimiter, String prefix,
			String suffix) {
		StringBuilder sb = new StringBuilder();
		sb.append(String.format("String sArray[] = str.split(\"%s\");", delimiterWhenSplit)).append(Syntax.NEW_LINE);
		sb.append(
				String.format("String joinStr = Stream.of(sArray).collect(Collectors.joining(\"%s\", \"%s\", \"%s\"));",
						delimiter, prefix, suffix));
		return sb.toString();
	}
	public void collapseAll() {
		this.getkRobot().clickCompositeKey(KeyEvent.VK_CONTROL, KeyEvent.VK_SHIFT, KeyEvent.VK_DIVIDE);
	}
	public void runApp() throws Exception {
		this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_SHIFT, KeyEvent.VK_X);
		this.getkRobot().clickKey(KeyEvent.VK_J);
	}
	public void debugApp() throws Exception {
		this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_SHIFT, KeyEvent.VK_D);
		this.getkRobot().clickKey(KeyEvent.VK_J);
	}
	@ServiceMethodAnn(keyword = { "Lambda filter for Collection", "lambda tolist", "lambda tomap" })
	public String genCollStream(@ParamAnno(description = "Collection Name") String collectionName,
			@ParamAnno(description = "With for each") boolean needForEach,
			@ParamAnno(description = "With Filter") boolean needFilter,
			@ParamAnno(description = "With Distinct") boolean needDistinct,
			@ParamAnno(description = "With Sort") boolean needSort,
			@ParamAnno(description = "With Map") boolean needMap,
			@ParamAnno(description = "Collect As List") boolean collectAsList,
			@ParamAnno(description = "Collect As Set") boolean collectAsSet,
			@ParamAnno(description = "Collect As Map") boolean collectAsMap) throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		context.getVariableMap().put(Replacement.TMP_INSTANCE_VALUE.name(), collectionName);
		if (collectAsList) {
			context.getVariableMap().put(Replacement.TMP_CLASS_NAME.name(), "List");
			context.getVariableMap().put(Replacement.TMP_INSTANCE_NAME.name(), "list");
		} else if (collectAsMap) {
			context.getVariableMap().put(Replacement.TMP_CLASS_NAME.name(), "Map");
			context.getVariableMap().put(Replacement.TMP_INSTANCE_NAME.name(), "map");
		} else {
			context.getVariableMap().put(Replacement.TMP_CLASS_NAME.name(), "");
			context.getVariableMap().put(Replacement.TMP_INSTANCE_NAME.name(), "");
			context.getVariableMap().put(Replacement.ASSIGN_SYMBOL.name(), "");
		}
		StringBuilder sb = new StringBuilder(
				Common.replaceAllKeyWord(Syntax.COLLECTION_STREAM, context.getVariableMap()));
		if (needForEach) {
			sb.append(Common.replaceAllKeyWord(Syntax.STREAM_FOREACH, context.getVariableMap()));
		}
		if (needFilter) {
			sb.append(Common.replaceAllKeyWord(Syntax.STREAM_FILTER, context.getVariableMap()));
		}
		if (needDistinct) {
			sb.append(Common.replaceAllKeyWord(Syntax.STREAM_DISTINCT, context.getVariableMap()));
		}
		if (needSort) {
			sb.append(Common.replaceAllKeyWord(Syntax.STREAM_SORT, context.getVariableMap()));
		}
		if (needMap) {
			sb.append(Common.replaceAllKeyWord(Syntax.STREAM_MAP, context.getVariableMap()));
		}
		if (collectAsList) {
			sb.append(Common.replaceAllKeyWord(Syntax.STREAM_COLLECT_AS_LIST, context.getVariableMap()));
		} else if (collectAsSet) {
			sb.append(Common.replaceAllKeyWord(Syntax.STREAM_COLLECT_AS_SET, context.getVariableMap()));
		} else if (collectAsMap) {
			context.getVariableMap().put(Replacement.GENERIC_TYPE_KEY.name(), "");
			context.getVariableMap().put(Replacement.GENERIC_TYPE_VAL.name(), "");
			sb.append(Common.replaceAllKeyWord(Syntax.STREAM_COLLECT_AS_CONCURRENTMAP, context.getVariableMap()));
		} else {
			context.getVariableMap().put(Replacement.TMP_CLASS_NAME.name(), "");
			context.getVariableMap().put(Replacement.TMP_INSTANCE_NAME.name(), "");
		}
		sb.append(Syntax.END_OF_LINE);
		context.getVariableMap().put(Replacement.ASSIGN_SYMBOL.name(), Syntax.ASSIGN_SYMBOL);
		return sb.toString();
	}
	@ServiceMethodAnn(keyword = "Lambda filter for Map")
	public String genMapStream(String mapName, boolean keySetStream, boolean entryStream, boolean valueStream,
			boolean needForEach, boolean needFilter, boolean needDistinct, boolean needSort, boolean needMap, boolean collectAsList,boolean collectAsSet, boolean collectAsMap)
			throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		StringBuilder sb = new StringBuilder();
		context.getVariableMap().put(Replacement.TMP_INSTANCE_NAME.name(), mapName);
		String syntax = null;
		if (keySetStream) {
			syntax = Syntax.MAP_KEY_SET;
		} else if (entryStream) {
			syntax = Syntax.MAP_ENTRY_SET;
		} else if (valueStream) {
			syntax = Syntax.MAP_VALUES;
		}
		sb.append(Common.replaceAllKeyWord(syntax, context.getVariableMap()));
		String collStr = genCollStream("", needForEach, needFilter,needDistinct, needSort, needMap, collectAsList, collectAsSet, collectAsMap);
		sb.append(collStr);
		return sb.toString();
	}
	@ServiceMethodAnn(keyword = "print pixel color")
	public void printPixelColor() {
		java.awt.PointerInfo pointerInfo = MouseInfo.getPointerInfo();
		java.awt.Point point = pointerInfo.getLocation();
		Rectangle rect = new Rectangle((int) point.getX(), (int) point.getY(), 2, 2);
		BufferedImage img = this.getkRobot().getRobot().createScreenCapture(rect);
		int i = img.getRGB(0, 0);
		this.getmRobot().breakAlphaAndRGB(i);
		return;
	}
	public void switchFile(boolean back) {
		if (back)
			this.getkRobot().clickCompositeKey(KeyEvent.VK_CONTROL, KeyEvent.VK_F6);
		else
			this.getkRobot().clickCompositeKey(KeyEvent.VK_CONTROL, KeyEvent.VK_SHIFT, KeyEvent.VK_F6);
		return;
	}
	@ServiceMethodAnn(keyword = {"regex","regular expression match"})
	public String genRegexRelated(String regex, boolean notWithFind) throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		StringBuilder sb = new StringBuilder();
		String patternInstanceName = Common.getInstanceName(Pattern.class);
		String matcherInstanceName = Common.getInstanceName(Matcher.class);
		context.getVariableMap().put(Replacement.TMP_INSTANCE_VALUE.name(), patternInstanceName);
		context.getVariableMap().put(Replacement.TMP_INSTANCE_NAME.name(), "\"" + regex + "\"");
		String patternCompile = Common.replaceAllKeyWord(Syntax.PATTERN_COMPILE, context.getVariableMap());
		context.getVariableMap().put(Replacement.TMP_INSTANCE_VALUE.name(), matcherInstanceName);
		context.getVariableMap().put(Replacement.TMP_INSTANCE_NAME.name(), patternInstanceName);
		context.getVariableMap().put(Replacement.METHOD_PARAMS_VARIABLE.name(), "\"\"");
		String createMatchor = Common.replaceAllKeyWord(Syntax.PATTERN_CREATE_MATCHER, context.getVariableMap());
		sb.append(patternCompile).append(Syntax.NEW_LINE);
		sb.append(createMatchor).append(Syntax.NEW_LINE);
		String booleanName = Common.getInstanceName(boolean.class);
		if (!notWithFind) {
			context.getVariableMap().put(Replacement.TMP_INSTANCE_VALUE.name(), booleanName);
			context.getVariableMap().put(Replacement.TMP_INSTANCE_NAME.name(), matcherInstanceName);
			String findStr = Common.replaceAllKeyWord(Syntax.MATCHER_FIND, context.getVariableMap());
			sb.append(findStr).append(Syntax.NEW_LINE);
		} else {
			context.getVariableMap().put(Replacement.TMP_INSTANCE_VALUE.name(), booleanName);
			context.getVariableMap().put(Replacement.TMP_INSTANCE_NAME.name(), matcherInstanceName);
			String etireMatches = Common.replaceAllKeyWord(Syntax.MATCHER_MATCHES, context.getVariableMap());
			sb.append(etireMatches).append(Syntax.NEW_LINE);
		}
		return sb.toString();
	}
	@ServiceMethodAnn(keyword = { "gen code line", "generate code line" })
	public String genCallInstanceMethodStrByQualifierNames(
			@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) String[] qualifierNames, boolean genConstructor) {
		List<QualifierName> list = new ArrayList<>();
		for (String qn : qualifierNames) {
			QualifierName qualifierName = DataModel.extractQualifierName(qn);
			list.add(qualifierName);
		}
		String s = this.genCodeByQualifierNames(list, genConstructor);
		return s;
	}
	public String genCodeByMethods(Class<?>[] c, String[] ms) {
		StringBuilder sb = new StringBuilder();
		return sb.toString();
	}
	@ServiceMethodAnn(keyword = "gen one pojo class initlization code")
	public String genCode(@ParamAnno(description = "Class") Class c) {
		return "";
	}
	@ServiceMethodAnn(keyword = { "gen code"})
	@UIAnno(uiClz="ui.GenCodePane")
	public void genCode() {
	}
	/**
	 * copy qualifier name by a qualifier name and give parameter types followed
	 *
	 * @param list
	 *
	 * @return
	 */
	public String genCodeByQualifierNames(List<QualifierName> list, boolean genConstructor) {
		CodeGenContext context = CodeGenContext.getInstance();
		StringBuilder sb = new StringBuilder();
		Map<Class, String> types = new HashMap<>();
		list.forEach(qn -> {
			try {
				Method method = QualifierName.getMethodByQualifierName(qn);
				if (method != null) {
					boolean isClassCast = qn.isClassCastMethod(method);
					if (!isClassCast) {
						boolean isMethodVariable = qn.isMethodVariable();
						if (!isMethodVariable) {
							Class rt = method.getReturnType();
							if (!rt.equals(Void.TYPE) && !types.containsKey(rt)) {
								types.put(rt, Common.getInstanceName(rt));
							}
						} else {
						}
						Class ps[] = method.getParameterTypes();
						Parameter pts[] = method.getParameters();
						List<String> params = new ArrayList<>();
						for (int i = 0; i < ps.length; i++) {
							Class p = ps[i];
							boolean isComplex = Common.isComplexType(p);
							if (!isComplex && !types.containsKey(p)) {
							}
						}
					} else {
					}
				} else if (qn.getClassQualifierName() != null) {
					boolean isConstructor = qn.isConstructor();
					Class c = null;
					try {
						c = context.getReloadableDynamicClassLoaderOwner().loadClass(qn.getClassQualifierName(), true);
					} catch (Exception e) {
						e.printStackTrace();
					}
					if (c != null) {
						if (!isConstructor) {
							boolean isField = qn.isField();
							if (isField) {
								try {
									Field f = c.getField(qn.getFieldName());
									if (!types.containsKey(f.getDeclaringClass())) {
										types.put(f.getDeclaringClass(), qn.getFieldName());
									}
								} catch (Exception e) {
									e.printStackTrace();
								}
							} else {
								try {
									if (!types.containsKey(c)) {
										types.put(c, Common.getInstanceName(c));
									}
								} catch (Exception e) {
									e.printStackTrace();
								}
							}
						} else {
							if (!types.containsKey(c)) {
								types.put(c, Common.getInstanceName(c));
							}
						}
					}
				}
			} catch (Exception e) {
				e.printStackTrace();
			}
		});
		list.forEach(qn -> {
			try {
				if (qn.getClz() != null) {
					Method method = QualifierName.getMethodByQualifierName(qn);
					if (method != null) {
						boolean isClassCast = qn.isClassCastMethod(method);
						if (!isClassCast) {
							boolean isMethodVariable = qn.isMethodVariable();
							if (!isMethodVariable) {
								Class ps[] = method.getParameterTypes();
								Parameter pts[] = method.getParameters();
								List<String> params = new ArrayList<>();
								for (int i = 0; i < ps.length; i++) {
									Class p = ps[i];
									if (types.containsKey(p)) {
										params.add(types.get(p));
									} else {
										boolean b = Common.isComplexType(p);
										if (b) {
											String s = this.genVariableDeclare(p, null);
											sb.append(s);
											params.add(Common.getInstanceName(p));
										} else {
											/*
											 * Parameter pt = pts[i]; params.add(pt.getName());
											 */
											Parameter pt = pts[i];
											params.add(pt.getName());
											String s = this.genPrimitiveVariable(p, pt.getName());
											sb.append(s);
										}
									}
								}
								String paramArray[] = params.toArray(new String[params.size()]);
								String methodCallStr = this.genCallInstanceMethodStr(method.getDeclaringClass(), method,
										false, paramArray);
								sb.append(methodCallStr);
								if (Common.isMethodReturnBoolean(method)) {
									sb.append(this.genIfElseBlock(false, "b")).append(Syntax.NEW_LINE);
								}
							}
						} else {
						}
					} else if (qn.getClassQualifierName() != null) {
						boolean isConstructor = qn.isConstructor();
						Class c = null;
						try {
							c = context.getReloadableDynamicClassLoaderOwner().loadClass(qn.getClassQualifierName(),
									true);
						} catch (Exception e) {
							e.printStackTrace();
						}
						if (c != null) {
							if (isConstructor) {
								Constructor<?> ct = QualifierName.getConstructorByQualifierName(qn);
								String str = Common.initAClass(c, ct, Common.getInstanceName(c), true, context);
								sb.append(str);
							}
						}
					}
				} else {
					boolean isConstructor = qn.isConstructor();
					if (isConstructor) {
						String clzForPrint = !context.isGenFullQualifierName() ? qn.getClzSimpleName()
								: qn.getClassQualifierName();
						String params = (qn.getConstructParam() != null && !"".equals(qn.getConstructParam()))
								? String.join(",", qn.getConstructParam())
								: "";
						/*
						 * String instanceName = Common.makeFirstCharInLowercase(qn.getClzSimpleName()
						 * ); sb.append(clzForPrint).append(" " ).append(instanceName).append(" = new "
						 * ).append(qn.getClzSimpleName()).append("(").append( params).append(")");
						 */
						context.getVariableMap().put(Replacement.ABSTRACT_CLASS_NAME.name(), clzForPrint);
						context.getVariableMap().put(Replacement.SEPERATOR.name(), " ");
						String instanceName = Common.makeFirstCharInLowercase(qn.getClzSimpleName());
						context.getVariableMap().put(Replacement.ABSTRACT_INSTANCE_NAME.name(), instanceName);
						context.getVariableMap().put(Replacement.TMP_CLASS_NAME.name(), clzForPrint);
						context.getVariableMap().put(Replacement.METHOD_PARAMS_VARIABLE.name(), params);
						String initLine = Common.replaceAllKeyWord(
								Syntax.ABSTRACT_NEW_INSTANCE_LINE_WITH_DECLARE_OR_NOT, context.getVariableMap());
						sb.append(initLine);
					}
					boolean isMethodQualifier = qn.isMethodQualifier();
					if (isMethodQualifier) {
						String instanceName = Common.makeFirstCharInLowercase(qn.getClzSimpleName());
						String params = (qn.getMethodParam() != null && !"".equals(qn.getMethodParam()))
								? String.join(",", qn.getMethodParam())
								: "";
						context.getVariableMap().put(Replacement.METHOD_PARAMS_VARIABLE.name(), params);
						context.getVariableMap().put(Replacement.TMP_INSTANCE_NAME.name(), instanceName);
						context.getVariableMap().put(Replacement.METHOD_NAME.name(), qn.getMethodName());
						String methodCallingStr = Common.replaceAllKeyWord(Syntax.VOID_METHOD_CALLING,
								context.getVariableMap());
						sb.append(methodCallingStr);
					}
				}
			} catch (Exception e) {
				e.printStackTrace();
			}
		});
		return sb.toString();
	}
	@Deprecated
	public void gitPull1() throws Exception {
		this.popupContextMenu();
		int i = 14;
		this.getkRobot().arrowDown(i);
		this.getkRobot().arrowRight();
		String s = "Pull";
		this.blockUntilFound(s, DIALOG_FONT_NAME, Color.BLACK);
		this.getkRobot().enter();
		return;
	}
	public void gitPull(String basePath) throws Exception {
		this.openExplorer();
		this.popupContextMenu();
		int i = 14;
		this.getkRobot().arrowDown(i);
		this.getkRobot().arrowRight();
		String s = "Pull";
		this.blockUntilFound(s, DIALOG_FONT_NAME, Color.BLACK);
		this.getkRobot().enter();
		return;
	}
	@ServiceMethodAnn(keyword = { "gen log trace", "log trace" })
	public String genLoggerTrace() {
		return Syntax.LOGGER_TRACE;
	}
	@ServiceMethodAnn(keyword = { "log debug" })
	public String genLoggerDebug() {
		return Syntax.LOGGER_DEBUG;
	}
	@ServiceMethodAnn(keyword = { "log info" })
	public String genLoggerInfo() {
		return Syntax.LOGGER_INFO;
	}
	@ServiceMethodAnn(keyword = { "log error" })
	public String genLoggerError() {
		return Syntax.LOGGER_ERROR;
	}
	@ServiceMethodAnn(keyword = { "log fatal" })
	public String genLoggerFatal() {
		return Syntax.LOGGER_FATAL;
	}
	public String getBaseDir() {
		File file = new File(".");
		String s = file.getAbsolutePath();
		return s;
	}
	public void openPom() throws Exception {
		this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_F);
		this.getkRobot().clickKey(KeyEvent.VK_PERIOD);
		this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_N);
		String s = this.getBaseDir() + "\\pom.xml";
		this.getkRobot().typeStr(s);
		this.blockUntilFound(s, SPECIAL_DIALOG_FONT_NAME, MENU_ITEM_SIZE, Color.BLACK);
		this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_O);
		return;
	}
	@ServiceMethodAnn(keyword = "gen sys input")
	public String genSysInput() throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		String str = Common.replaceAllKeyWord(Syntax.SYS_IN, context.getVariableMap());
		return str;
	}
	@ServiceMethodAnn(keyword = "gen methods by qualifier names")
	public String genBatchCreateMethodsByQualifierNames(String[] qualifierNames, boolean genFullQualifierName,
			int modifier) throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		List<Class> clist = new ArrayList<>();
		for (String qn : qualifierNames) {
			QualifierName qualifierName = DataModel.extractQualifierName(qn);
			if (qualifierName.getClz() != null)
				clist.add(qualifierName.getClz());
		}
		String s = this.genBatchCreateMethods(clist, modifier, genFullQualifierName, new Class[] {});
		return s;
	}
	@ServiceMethodAnn(keyword = "gen methods")
	public String genBatchCreateMethods(List<Class> clzs, int modifier, boolean genFullQualifierName,
			Class... exceptions) throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		StringBuilder stringBuilder = new StringBuilder();
		context.setGenFullQualifierName(genFullQualifierName);
		for (Class c : clzs) {
			String defaultCreateMethodName = Common.getDefaultCreateMethodName(c);
			String s = genCode(c);
			Class rt = c;
			String entireMethodCode = genNewMethod(defaultCreateMethodName, s, rt, modifier, exceptions);
			stringBuilder.append(entireMethodCode).append(Syntax.NEW_LINE);
		}
		return stringBuilder.toString();
	}
	@ServiceMethodAnn(keyword = "gen foreach")
	public String genForEach(Class itemClz, String collName) throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		String itemName = Common.getInstanceName(itemClz);
		return genForEach(itemClz, itemName, collName);
	}
	@ServiceMethodAnn(keyword = "gen foreach 2")
	public String genForEach(Class itemClz, String itemName, String collName) throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		context.getVariableMap().put(Replacement.TMP_CLASS_NAME.name(), itemClz.getSimpleName());
		context.getVariableMap().put(Replacement.ITEM_NAME.name(), itemName);
		context.getVariableMap().put(Replacement.TMP_INSTANCE_NAME.name(), collName);
		String str = Common.replaceAllKeyWord(Syntax.FOR_EACH_BLOCK, context.getVariableMap());
		return str;
	}
	@ServiceMethodAnn(keyword = "set mvn home")
	public void setMvnHome(@FileChooserAnnotation(chooseDirOnly = true) @ValidationAnn(validations = {
			"codegen.eclipseRobot.MandatoryCheck" }) File mvnHome) throws Exception {
		String path = mvnHome.getAbsolutePath();
		CodeGenContext.setMavenHome(path);
		try {
		    EclipseCodeGenContext.getInstance().getDatabaseService().saveOrUpdate(H2JDBCService.CONFIG_TABLE, codegen.Const.BRAIN_MVN_HOME_KEYWORD, path);
		} catch (Exception e) {
			throw new Exception("memorize maven home failed");
		}
	}
	@ServiceMethodAnn(keyword = "set local repository")
	public void setLocalRepoDir(@FileChooserAnnotation(chooseDirOnly = true) @ValidationAnn(validations = {
			"codegen.eclipseRobot.MandatoryCheck" }) File localRepoDir) throws Exception {
		String path = localRepoDir.getAbsolutePath();
		CodeGenContext.setLocalRepoDir(path);
		try {
		    EclipseCodeGenContext.getInstance().getDatabaseService().saveOrUpdate(H2JDBCService.CONFIG_TABLE, codegen.Const.BRAIN_LOCAL_REPO_KEYWORD, path);
		} catch (Exception e) {
			throw new Exception("memorize local repository failed");
		}
	}
	@ServiceMethodAnn(keyword = "gen mvn cmd file")
	public static File genMvnCommandBuild(File pomFile, boolean clean, boolean compile, boolean install, boolean deploy, boolean pack,
			boolean skipTest, boolean debug, boolean isForUnix) throws IOException {
		Runtime runtime = Runtime.getRuntime();
		String path = pomFile.getAbsolutePath();
		String properties = "";
		if (skipTest) {
			properties = "-Dmaven.test.skip=true";
		}
		String debugParam = "";
		if (debug) {
			debugParam = " -X";
		}
		String cleanArg = clean ? "clean" : "";
		String installArg = clean ? "install" : "";
		String compileArg = clean ? "compile" : "";
		String deployArg = deploy ? "deploy" : "";
		if (pack) {
			installArg = "";
		}
		String packArg = pack ? "package" : "";
		if (compile) {
			installArg = "";
			packArg = "";
		}
		String cmd = "mvn %s%s -U %s %s %s %s %s";
		String command = String.format(cmd, properties, debugParam, cleanArg, compileArg, installArg, deployArg, packArg)
				+ ">fulllog.txt";
		if(isForUnix)
		    command = "#!/bin/bash" + System.lineSeparator() + command;
		String fileName = isForUnix ? "mvncmd.sh" : "mvncmd.bat";
		File file = new File(pomFile.getParent() + File.separator + fileName);
		try {
			Common.write(file, command);
		} catch (IOException e) {
			throw e;
		}
		return file;
	}
	private File findMavenHome() throws IOException {
		String mavenHome = CodeGenContext.getMavenHome();
		if (mavenHome == null) {
			throw new IllegalStateException("Cannot find Maven application "
					+ "directory. Either specify \'maven.home\' system property, or M2_HOME environment variable.");
		}
		return new File(mavenHome);
	}
	public void registerAbstractConcreteClassMappingSimple(Class<?> abstractClass, Class<?> concreteClass,
			String factoryMethodName) {
		CodeGenContext context = CodeGenContext.getInstance();
		context.registerAbstractConcreteClassMappingSimple(abstractClass, concreteClass, factoryMethodName);
	}
	public void registerAbstractConcreteClassMappingSimple(Class<?> abstractClass, Class<?> concreteClass,
			String factoryMethodName, String methodParamVariables[]) {
		CodeGenContext context = CodeGenContext.getInstance();
		context.registerAbstractConcreteClassMappingSimple(abstractClass, concreteClass, factoryMethodName,
				methodParamVariables);
	}
	public void registerAbstractConcreteClassMappingSimple(Class<?> abstractClass, Class<?> concreteClass) {
		CodeGenContext context = CodeGenContext.getInstance();
		context.registerAbstractConcreteClassMappingSimple(abstractClass, concreteClass, (Method) null, null);
		System.out.println(String.format("register abstract class, concrete class method pair [%s, %s]",
				abstractClass.getName(), concreteClass.getName()));
	}
	public void registerAbstractConcreteClassMappingSimple(Class<?> abstractClass, String qualifierName) {
		CodeGenContext context = CodeGenContext.getInstance();
		QualifierName qn = DataModel.extractQualifierName(qualifierName);
		Method method = QualifierName.getMethodByQualifierName(qn);
		if (method != null) {
			context.registerAbstractConcreteClassMappingSimple(abstractClass, method.getDeclaringClass(), method, null);
			System.out.println(String.format("register abstract class, concrete class method pair [%s, %s, %s]",
					abstractClass.getName(), method.getDeclaringClass().getName(), method.getName()));
		} else if (qn.getClz() != null) {
			context.registerAbstractConcreteClassMappingSimple(abstractClass, qn.getClz(), (Method) null, null);
			System.out.println(String.format("register abstract class, concrete class method pair [%s, %s]",
					abstractClass.getName(), qn.getClz().getName()));
		} else {
			System.out.println(String.format("cannot get class for qualifiername %s", qualifierName));
		}
	}
	@ServiceMethodAnn(keyword = "gen write file as text")
	public String genWriteFile() throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		StringBuilder sb = new StringBuilder(Common.replaceAllKeyWord(Syntax.WRITE_FILE, context.getVariableMap()));
		return sb.toString();
	}
	@ServiceMethodAnn(keyword = "read file as string")
	public String genReadFile() throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		StringBuilder sb = new StringBuilder(Common.replaceAllKeyWord(Syntax.READ_FILE, context.getVariableMap()));
		return sb.toString();
	}
	@ServiceMethodAnn(keyword = "thread pool")
	public static String genThreadPoolRunTaskMethod(int modifier, int corePoolSize, int maximumPoolSize,
			boolean isCallable, boolean defineThreadFactory, Class returnType) throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		Common.setModifier(modifier, context);
		StringBuilder sb = new StringBuilder();
		context.getVariableMap().put(Replacement.CORE_POOL_SIZE.name(), Integer.toString(corePoolSize));
		context.getVariableMap().put(Replacement.MAX_POOL_SIZE.name(), Integer.toString(maximumPoolSize));
		String newThreadFactory = null;
		if (defineThreadFactory) {
			newThreadFactory = ", " + Common.replaceAllKeyWord(Syntax.NEW_THREAD_FACTORY, context.getVariableMap());
		} else {
			newThreadFactory = "";
		}
		context.getVariableMap().put(Replacement.NEW_THREAD_FACTORY.name(), newThreadFactory);
		String str = Common.replaceAllKeyWord(Syntax.THREAD_POOL_EXECUTOR, context.getVariableMap());
		String submitTaskStr = null;
		if (isCallable) {
			context.getVariableMap().put(Replacement.RETURN_TYPE.name(), returnType.getSimpleName());
			submitTaskStr = Common.replaceAllKeyWord(Syntax.SUBMIT_CALLABLE_TASK, context.getVariableMap());
		} else {
			submitTaskStr = Common.replaceAllKeyWord(Syntax.SUBMIT_RUNNABLE_TASK, context.getVariableMap());
		}
		sb.append(str).append(Syntax.NEW_LINE);
		sb.append(submitTaskStr);
		return sb.toString();
	}
	@ServiceMethodAnn(keyword = "running jar")
	public String getRunningJar() {
		return Common.getRunningJar();
	}
	@ServiceMethodAnn(keyword = "working dir")
	public String getWorkingDir() {
		return Common.getWorkingDir();
	}
	private void createSpringBootProj(String baseDir, JarFile jarFile, String groupId,
			String artifactroyId, String pack, String webContext, int port) throws IOException, Exception {
		File testJavaDir = new File(baseDir + "/src/test/java");
		testJavaDir.mkdirs();
		File javaDir = new File(baseDir + "/src/main/java");
		javaDir.mkdirs();
		File resourceDir = new File(baseDir + "/src/main/resources");
		resourceDir.mkdirs();
		CodeGenContext context = CodeGenContext.getInstance();
		context.getVariableMap().put(MoreReplacement.WEB_CONTEXT.name(), webContext);
		context.getVariableMap().put(MoreReplacement.WEB_PORT.name(), Integer.toString(port));
		Enumeration<JarEntry> enumJar = jarFile.entries();
		while (enumJar.hasMoreElements()) {
			JarEntry e = enumJar.nextElement();
			String name = e.getName();
			System.out.println("get JarEntry which name is " + name);
			if (name.contains("webapps/css") || name.contains("webapps/js") || name.contains("webapps/img")
					|| name.contains("webapps/image")
					|| (name.contains("META-INF") && name.endsWith("spring.factories"))) {
				if (!name.endsWith("/")) {
					InputStream is = jarFile.getInputStream(e);
					String templateStr = Common.readAsStr(is);
					String fileStr = Common.replaceAllKeyWord(templateStr, context.getVariableMap());
					File file = new File(baseDir + File.separatorChar + name);
					Common.write(file, fileStr);
				} else {
					File file = new File(baseDir + File.separatorChar + name);
					file.mkdirs();
				}
			}
			if (name.endsWith(".template")) {
				InputStream is = jarFile.getInputStream(e);
				String newFileName = name.replace(".template", "");
				String templateStr = Common.readAsStr(is);
				if ("pom.xml.template".equals(name.toLowerCase())) {
					context.getVariableMap().put(MoreReplacement.GROUP_ID.name(), groupId);
					context.getVariableMap().put(MoreReplacement.ARTIFACT_ID.name(), artifactroyId);
					context.getVariableMap().put(MoreReplacement.ARTIFACT_VERSION.name(), "1.0-SNAPSHOT");
					context.getVariableMap().put(MoreReplacement.ARTIFACT_PACK.name(),
							pack != null && !"".equals(pack.trim()) ? pack : "jar");
					String pomStr = Common.replaceAllKeyWord(templateStr, context.getVariableMap());
					File pomFile = new File(baseDir + File.separatorChar + newFileName);
					Common.write(pomFile, pomStr);
				} else {
					String fileStr = Common.replaceAllKeyWord(templateStr, context.getVariableMap());
					File file = new File(baseDir + File.separatorChar + newFileName);
					Common.write(file, fileStr);
				}
			}
		}
		this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_F);
		this.getkRobot().clickKey(KeyEvent.VK_I);
		Thread.sleep(600);
		try {
			blockUntilFound("Import E", DIALOG_FONT_NAME, MENU_ITEM_SIZE, Font.PLAIN, Color.BLACK, false, true);
		} catch (Exception e) {
			e.printStackTrace();
		}
		this.getkRobot().typeStr("maven");
		Thread.sleep(500);
		try {
			blockUntilFound("maven", DIALOG_FONT_NAME, MENU_ITEM_SIZE, Font.PLAIN, Color.BLACK, false, false);
		} catch (Exception e) {
			e.printStackTrace();
		}
		this.getkRobot().arrowDown();
		Thread.sleep(500);
		this.getkRobot().home();
		Thread.sleep(500);
		this.getkRobot().arrowDown(2);
		this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_N);
		this.blockUntilFound("Select Maven", DIALOG_FONT_NAME, Color.BLACK);
		this.getkRobot().typeStr(baseDir);
		this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_A);
		Thread.sleep(500);
		this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_F);
	}
	public void createSpringBootProj(String groupId, String artifactroyId, String pack,
			@ParamAnno(description = "base directory") @FileChooserAnnotation(chooseDirOnly = true) @ValidationAnn(validations = {
					"codegen.eclipseRobot.MandatoryCheck" }) File baseDirectory,
			String webContext, int port) throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		String baseDir = baseDirectory.getAbsolutePath();
		String runningJarPath = Common.getRunningJar();
		JarFile jarFile = null;
		JarEntry jarEntry = null;
		JarInputStream jarInputStream = null;
		try {
			jarFile = new JarFile(runningJarPath);
			System.out.println("get jar file" + runningJarPath);
			jarEntry = jarFile.getJarEntry(SPRING_BOOT_TEMPLATE_JAR_NAME);
			InputStream inputStream = jarFile.getInputStream(jarEntry);
			System.out.println("get jar inputStream" + inputStream);
			jarInputStream = new JarInputStream(inputStream);
			jarFile = new JarFile(
					String.format("%s/codegen/springbootsimpletemplate/1.0/springbootsimpletemplate-1.0.jar",
							context.getLocalRepoDir()));
			createSpringBootProj(baseDirectory.getAbsolutePath(), jarFile, groupId, artifactroyId, pack,
					webContext, port);
		} catch (IOException e2) {
			e2.printStackTrace();
			throw e2;
		}
		try {
			jarInputStream.close();
			jarFile.close();
		} catch (IOException e1) {
			e1.printStackTrace();
		}
		return;
	}
	public static void registerDataSource(Class<?> driverClass, String jdbcurl, String user, String password) {
		return;
	}
	public static String talk() {
		return "";
	}
	/**
	 * for testing seek text on screen 1 setting window
	 * desktop->personalality->window color->dialog->font change as "Segeo UI" 2
	 * disable font smooth
	 * set font size as 100%,otherwise may mouse move will not work properly
	 * 
	 * @param text
	 * @throws Exception
	 */
	@ServiceMethodAnn(keyword = "seek text on screen")
	public boolean seekText(@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) String text) throws Exception {
		long arg0 = 3000L;
		Thread.sleep(arg0);
		boolean b =blockUntilFound(text, SPECIAL_DIALOG_FONT_NAME, Font.PLAIN, Color.BLACK, false, true);
		if(!b) {
			b = blockUntilFound(text, SPECIAL_DIALOG_FONT_NAME, Font.PLAIN, this.ECLIPSE_TITLE_DISABLE_FONT, false, true);
		}
		return b;
	}
	public String genGetClipBoardMonitorServerPort() {
		CodeGenContext context = CodeGenContext.getInstance();
		return Integer.toString(context.getClipBoardMonitorServerPort());
	}
	public String genGenJarPlugin() {
		CodeGenContext context = CodeGenContext.getInstance();
		return "            <plugin>" + "                <groupId>org.apache.maven.plugins</groupId>"
				+ "                <artifactId>maven-jar-plugin</artifactId>" + "                <executions>"
				+ "                    <execution>" + "                        <id>make-a-jar</id>"
				+ "                        <phase>compile</phase>" + "                        <goals>"
				+ "                            <goal>jar</goal>" + "                        </goals>"
				+ "                    </execution>" + "                </executions>" + "            </plugin>";
	}
	private boolean openWizard() {
		CodeGenContext context = CodeGenContext.getInstance();
		int i=0;
		String currentWintitle;
		boolean b = false;
		do {
			i++;
			try {
				this.getkRobot().clickCompositeKey(KeyEvent.VK_CONTROL, KeyEvent.VK_N);
				currentWintitle=this.getActiveWindow();
			} catch (Exception e) {
				currentWintitle="";
			}
			b = "new".equalsIgnoreCase(currentWintitle);
			b=true;
			if(!b) {
				try {
					Thread.sleep(200L);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
			}
		}while(!b && i<codegen.Const.MAX_WAIT_TIME);
		return b;
	}
	public void attacheServiceClz(Class<?> c) {
		CodeGenContext context = CodeGenContext.getInstance();
		context.getAttachedClzList().add(c);
		return;
	}
	public DataSource createDataSource(Class driverClz, String jdbcUrl, String userName, String password) {
		String s = "";
		try {
			Connection connection = DriverManager.getConnection(s, s, s);
		} catch (SQLException e) {
			e.printStackTrace();
		}
		DataSource dataSource = null;
		return dataSource;
	}
	public String genSingleMethodUnitTestCase() {
		return null;
	}
	@ServiceMethodAnn(keyword = "gen test SpringJunitRunner")
	public String genTestWithSpringJunitRunnerPart() {
		StringBuilder sb = new StringBuilder();
		sb.append("@RunWith(SpringJUnit4ClassRunner.class)").append(Syntax.NEW_LINE);
		sb.append("@TestPropertySource(\"classpath:app.properties\")").append(Syntax.NEW_LINE);
		sb.append("@ContextConfiguration(value={\"classpath:config.xml\"}, classes={Config.class})")
				.append(Syntax.NEW_LINE);
		sb.append("@WebAppConfiguration");
		return sb.toString();
	}
	@ServiceMethodAnn(keyword = "gen Object Json app")
	public String genJsonWriteApp(Class c) {
		StringBuilder sb = new StringBuilder();
		String code = this.genCode(c);
		sb.append(code).append(Syntax.NEW_LINE).append("ObjectMapper om=new ObjectMapper();").append(Syntax.NEW_LINE)
				.append("String jsonStr = om.writeValueAsString(obj);\r\nSystem.out.println(jsonStr);");
		return sb.toString();
	}
	List<String> list = new ArrayList<>();
	@ServiceMethodAnn(keyword = "connect database")
	public Connection connectDb(Class driverClz, String jdbcUrl, String userName, String password) throws InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException, NoSuchMethodException, SecurityException, SQLException {
		Connection conn = null;
		if(null!=driverClz) {
			Driver driver = (Driver) driverClz.getDeclaredConstructor().newInstance();
			DriverManager.registerDriver(driver);
			conn = DriverManager.getConnection(jdbcUrl, userName, password);
		}
	    return conn;
	}
	@ServiceMethodAnn(keyword = "gen html table")
	public String genHtmlTable(int howManyColumns, int howManyRows, boolean hasHeader, boolean withInDiv) throws Exception {
		StringBuilder sb = new StringBuilder();
		if(withInDiv){
			sb.append("<div>").append(Syntax.NEW_LINE);
		}
		sb.append("<table>").append(Syntax.NEW_LINE);
		if(hasHeader){
			sb.append("<tr>").append(Syntax.NEW_LINE);
			for(int c=0;c<howManyColumns;c++){
				sb.append("<th></th>");
			}
			sb.append(Syntax.NEW_LINE).append("</tr>").append(Syntax.NEW_LINE);
		}
		for(int r=0;r<howManyRows;r++){
			sb.append("<tr>").append(Syntax.NEW_LINE);
			for(int c=0;c<howManyColumns;c++){
				sb.append("<td></td>");
			}
			sb.append(Syntax.NEW_LINE).append("</tr>").append(Syntax.NEW_LINE);
		}
		sb.append("</table>").append(Syntax.NEW_LINE);
		if(withInDiv){
			sb.append("</div>").append(Syntax.NEW_LINE);
		}
		return sb.toString();
	}
	@ServiceMethodAnn(keyword = "gen html href, tag a")
	public String genHtmlTagHref(String id, String link) throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		String trimId = id.trim();
		context.getVariableMap().put(Replacement.ID.name(),  !"".equals(trimId) ? " id="+trimId : "");
		context.getVariableMap().put(Replacement.LINK.name(), "\""+link+"\"");
		String str = Common.replaceAllKeyWord(Syntax.HTML_TAG_A, context.getVariableMap());
		return str;
	}
	@ServiceMethodAnn(keyword = "gen html input text, tag input")
	public String genHtmlTagInputText(String id, String name) throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		String trimId = id.trim();
		context.getVariableMap().put(Replacement.ID.name(), !"".equals(trimId) ? " id="+trimId : "");
		context.getVariableMap().put(Replacement.TAG_NAME.name(), name);
		String str = Common.replaceAllKeyWord(Syntax.HTML_TAG_TEXT, context.getVariableMap());
		return str;
	}
	@ServiceMethodAnn(keyword = "gen html input hidden, tag input hidden")
	public String genHtmlTagInputHidden(String id, String name) throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		String trimId = id.trim();
		context.getVariableMap().put(Replacement.ID.name(),  !"".equals(trimId) ? " id="+trimId : "");
		context.getVariableMap().put(Replacement.TAG_NAME.name(), name);
		String str = Common.replaceAllKeyWord(Syntax.HTML_TAG_TEXT, context.getVariableMap());
		return str;
	}
	@ServiceMethodAnn(keyword = "gen html input button, tag input button")
	public String genHtmlTagInputBtn(String id, String name) throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		String trimId = id.trim();
		context.getVariableMap().put(Replacement.ID.name(),  !"".equals(trimId) ? " id="+trimId : "");
		context.getVariableMap().put(Replacement.TAG_NAME.name(), name);
		String str = Common.replaceAllKeyWord(Syntax.HTML_TAG_BTN, context.getVariableMap());
		return str;
	}
	@ServiceMethodAnn(keyword = "gen html input file, tag input file")
	public String genHtmlTagInputFile(String id, String name) throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		String trimId = id.trim();
		context.getVariableMap().put(Replacement.ID.name(),  !"".equals(trimId) ? " id="+trimId : "");
		context.getVariableMap().put(Replacement.TAG_NAME.name(), name);
		String str = Common.replaceAllKeyWord(Syntax.HTML_TAG_FILE, context.getVariableMap());
		return str;
	}
	@ServiceMethodAnn(keyword = "gen html input select, tag input select")
	public String genHtmlTagInputSelect(String id, String name) throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		String trimId = id.trim();
		context.getVariableMap().put(Replacement.ID.name(),  !"".equals(trimId) ? " id="+trimId : "");
		context.getVariableMap().put(Replacement.TAG_NAME.name(), name);
		String str = Common.replaceAllKeyWord(Syntax.HTML_TAG_SELECT, context.getVariableMap());
		return str;
	}
	@ServiceMethodAnn(keyword = "gen html form, tag html form")
	public String genHtmlTagForm(String id, String name, boolean get, String action, boolean newWindow) throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		String trimId = id.trim();
		context.getVariableMap().put(Replacement.ID.name(),  !"".equals(trimId) ? " id="+trimId : "");
		context.getVariableMap().put(Replacement.TAG_NAME.name(), name);
		context.getVariableMap().put(Replacement.LINK.name(), action);
		context.getVariableMap().put(Replacement.REQUEST_METHOD.name(), get ? "get": "post");
		context.getVariableMap().put(Replacement.TARGET.name(), newWindow ? "_blank": "");
		String str = Common.replaceAllKeyWord(Syntax.HTML_TAG_FORM, context.getVariableMap());
		return str;
	}
	public H2JDBCService getH2JDBCService() {
        return h2JDBCService;
    }
    public void setH2JDBCService(H2JDBCService h2jdbcService) {
        h2JDBCService = h2jdbcService;
    }
    public WindowService getWindowService() {
		return windowService;
	}
	public void setWindowService(WindowService windowService) {
		this.windowService = windowService;
	}
	@ServiceMethodAnn(keyword = "load project dependency")
	public List<String> loadProjDepependcies(@ParamAnno(description = "Pom File") File pomFile) throws Exception {
		Model model = PomUtil.parsePom(pomFile);
		String parentGroupId = null;
		String parentversion = null;
		if (model.getParent() != null) {
			parentGroupId = model.getParent().getGroupId();
			parentversion = model.getParent().getVersion();
		}
		String artifactId = model.getArtifactId();
		String groupId = model.getGroupId() == null ? parentGroupId : model.getGroupId();
		String version = model.getVersion() == null ? parentversion : model.getVersion();
		String pack = model.getPackaging();
		File file = new File(pomFile.getParent() + File.separator + "target" + File.separator + "classes");
		URL targetClassDir = null;
		if (file.exists()) {
			URI uRI = file.toURI();
			targetClassDir = uRI.toURL();
		}
		URL targetTestClassDir = null;
		file = new File(pomFile.getParent() + File.separator + "target" + File.separator + "test-classes");
		if (file.exists()) {
			URI uRI = file.toURI();
			targetTestClassDir = uRI.toURL();
		}
		CodeGenContext.getInstance().setPomFile(pomFile);
		List<String> dependencies = this.loadProjDepependcies(groupId, artifactId, version, pack, targetClassDir, targetTestClassDir);
		this.h2JDBCService.saveOrUpdateLastProject( pomFile.getAbsolutePath());
		return dependencies;
	}
	@ServiceMethodAnn(keyword = "load project dependency 2")
	public List<String> loadProjDepependcies(String groupId, String artifactId, String version, String pack,
			URL... targetDirURLs) throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		System.out.println("loading artifact under " + CodeGenContext.getLocalRepoDir());
		DefaultArtifact artifact = new DefaultArtifact(groupId, artifactId, pack, version);
		boolean isWarPack = false;
		if ("war".equalsIgnoreCase(pack)) {
			isWarPack = true;
		} else if ("pom".equalsIgnoreCase(pack)) {
		}
		if (targetDirURLs != null) {
			for (URL url : targetDirURLs) {
				if (null != url) {
					context.getReloadableDynamicClassLoaderOwner().addDirUrl(url);
				}
			}
		}
		RepositorySystemHelper repoSystemHelper = new RepositorySystemHelper(CodeGenContext.getLocalRepoDir(),
				new HashMap());
		DependencyResolver dependencyResolver = new DependencyResolver(repoSystemHelper);
		List<String> list = null;
		try {
			list = dependencyResolver.getProjDepArtifactFilePath(artifact);
		} catch (Exception e1) {
		}
		if (list.size() == 0) {
			throw new Exception("failed when load project dependencies");
		}
		for (String str : list) {
			File file = new File(str);
			URI uRI = file.toURI();
			URL uRL = uRI.toURL();
			if (Common.isJarFile(file)) {
				context.getReloadableDynamicClassLoaderOwner().addJarUrl(uRL);
			}
		}
		context.getReloadableDynamicClassLoaderOwner().loadAllJar(this.getClass().getClassLoader());
		context.getReloadableDynamicClassLoaderOwner()
				.loadAllClzInDirectory(context.getReloadableDynamicClassLoaderOwner().getJarDynamicClassLoader());
		return list;
	}
	@ServiceMethodAnn(keyword = "reload all dependencies")
	public void reloadAll() {
		File pomFile = CodeGenContext.getInstance().getPomFile();
		if(null!=pomFile) {
			try {
				this.loadProjDepependcies(pomFile);
			} catch (Exception e) {
				e.printStackTrace();
			}
		}
	}
	@ServiceMethodAnn(keyword = "reload target directory dependencies")
	public void reloadAllTargetDirDependencies() throws Exception {
		CodeGenContext.getInstance().getReloadableDynamicClassLoaderOwner().reloadAllClzInDirectory();
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\codegen\eclipseRobot\FilterCombBox.java---
package codegen.eclipseRobot;
import javax.swing.*;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.ArrayList;
import java.util.List;
public class FilterCombBox extends JComboBox {
	private List<Object> array;
	private static final int maxShowingItems = 50;
	public FilterCombBox(List<Object> array) {
		super(array.subList(0, array.size()>maxShowingItems? maxShowingItems: array.size()).toArray());
		this.array = array;
		this.setEditable(true);
		addEditorListener();
	}
	public void addEditorListener(){
		final JTextField tf = (JTextField) this.getEditor().getEditorComponent();
		tf.addKeyListener(new KeyAdapter() {
			public void keyReleased(KeyEvent e) {
				if (e.getKeyCode() == 38 || e.getKeyCode() == 40 || e.getKeyCode() == 9 || e.getKeyCode() == 18
						|| e.getKeyCode() == KeyEvent.VK_ENTER) {
					return;
				}
				SwingUtilities.invokeLater(new Runnable() {
					@Override
					public void run() {
						if(!"".equals(tf.getText())) {
							comboFilter(tf.getText());
						}
					}
				});
			}
		});
		tf.addMouseListener(new MouseAdapter() {
			public void mouseClicked(MouseEvent e) {
				SwingUtilities.invokeLater(new Runnable() {
					@Override
					public void run() {
						comboFilter("");
					}
				});
			}
		});
	}
	public void comboFilter(String enteredText) {
		List<Object> filterArray = new ArrayList<>();
		for (int i = 0; i < array.size(); i++) {
			if (array.get(i).toString().toLowerCase().contains(enteredText.toLowerCase())) {
				filterArray.add(array.get(i));
			}
		}
		if (filterArray.size() > 0) {
			if (filterArray.size() < 4 && array.size() > 2) {
				filterArray.add(array.get(0));
				filterArray.add(array.get(1));
			}
			this.setModel(new DefaultComboBoxModel(filterArray.subList(0, filterArray.size()> maxShowingItems ? maxShowingItems : filterArray.size()).toArray()));
			this.showPopup();
			this.setSelectedItem(enteredText);
		} else {
			this.hidePopup();
		}
	}
	public boolean isValidSelectedItem(Object obj) {
		return array.contains(obj);
	}
	public synchronized void addCustomItem(Object... items) {
		for (Object i : items) {
			addItem(i);
			array.add(i);
		}
	}
	public synchronized void resetArray(List<Object> array) {
		this.array = array;
	}
	public List<Object> getArray() {
		return array;
	}
	public void cleanModelData() {
		this.removeAllItems();
		this.removeAll();
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\codegen\eclipseRobot\H2JDBCService.java---
package codegen.eclipseRobot;
import codegen.Syntax;
import codegen.eclipseRobot.model.MemoryArea;
import codegen.eclipseRobot.model.MemoryItem;
import codegen.eclipseRobot.model.MemoryItemKey;
import codegen.robot.Service;
import com.dgs.annotation.ParamAnno;
import com.dgs.annotation.ServiceMethodAnn;
import com.dgs.annotation.UIAnno;
import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import org.apache.commons.lang3.StringUtils;
import ui.validation.NotVisibleInUI;
import ui.validation.ValidationAnn;
import java.io.File;
import java.lang.reflect.Type;
import java.sql.*;
import java.util.Date;
import java.util.*;
import java.util.stream.Collectors;
public class H2JDBCService extends Service {
	private File file;
	private String userName="sa";
	private String pwd;
	public static final String CREATE_TABLE = "CREATE TABLE %s(ID VARCHAR(255) PRIMARY KEY, keywords VARCHAR_IGNORECASE(255), content LONGVARCHAR, comment VARCHAR(255), createTime TIMESTAMP, updateTime TIMESTAMP);";
	public static final String MEMORY_AREAS_KEY_WORDS = "MEMORY_AREAS_KEY_WORDS";
	private List<String> memoryAreas;
	private Map<String, List<MemoryItemKey>> tableKeywordsMapping = new HashMap<>();
	public static final String CONFIG_TABLE = "config";
	public static final String COLUMN_ID = "ID";
	public static final String COLUMN_KEYWORDS = "keywords";
	public static final String COLUMN_CONTENT = "content";
	public static final String COLUMN_COMMENT = "comment";
	public static final String JRE8_RTJAR_JAVA_JAVAX_ORG_KEYWORD = "jre8_rtjar_java_javax_org";
	public H2JDBCService() {
	}
	public String testConnection(@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) File dbfile, String user, String password)throws Exception {
		Connection conn = getConnection(dbfile, user, password);
		if(null!=conn) {
			conn.close();
		}else {
			return "failed";
		}
		return "ok";
	}
	public Connection getConnection(@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) File dbfile, String user, String password) throws Exception {
		this.file = dbfile;
		String driverClzName = "org.h2.Driver";
		String dbFilepath = dbfile.getAbsolutePath();
		dbFilepath = dbFilepath.replaceFirst(".mv.db", "");
		String url = "jdbc:h2:file:"+dbFilepath;
		Connection connection = null;
		try {
			Class.forName(driverClzName);
			connection = DriverManager.getConnection(url, user, password);
		} catch (SQLException | ClassNotFoundException e) {
			e.printStackTrace();
			throw e;
		} finally {
		}
		return connection;
	}
	@ServiceMethodAnn(keyword = "memorize config")
	public void memorizeConfig(@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) String keywords,
			@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) String content) throws Exception {
		memorizeInTable(CONFIG_TABLE, keywords,content);
	}
	@ServiceMethodAnn(keyword = "memorize in area")
	public void memorizeInTable(
	        @UIAnno(uiClz = "ui.ClassCombBoxpane")
	        @ParamAnno(description = "memory area") 
	        String areaName, @ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) String keywords,
			@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) String content) throws Exception {
		insert(areaName, keywords, content);
	}
	@ServiceMethodAnn(keyword = "create memory area")
	public void createTable(
	        @ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) String areaName, boolean disable)
			throws Exception {
		String sql = String.format(CREATE_TABLE, areaName);
		executeUpdate(sql, new String[]{});
		String areaJson = this.showConfigMemory(MEMORY_AREAS_KEY_WORDS);
		Gson gson = new Gson();
		Type type = new TypeToken<List<MemoryArea>>(){}.getType();
		List<MemoryArea> list1 = gson.fromJson(areaJson, type);
		MemoryArea ma = new MemoryArea(areaName, disable);
		list1.add(ma);
		areaJson = gson.toJson(list1);
		this.saveOrUpdate(CONFIG_TABLE, MEMORY_AREAS_KEY_WORDS, areaJson);
		return;
	}
	public String showMemoryById(String tableName, @ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) String id)
			throws Exception {
		MemoryItem item = this.findById(tableName, id);
		StringBuilder sb = new StringBuilder();
		if(null != item) {
			sb.append(item.getContent()).append(Syntax.NEW_LINE).append(Syntax.NEW_LINE);
		}
		return sb.toString();
	}
	@ServiceMethodAnn(keyword = "show all memory")
	public String showAllMemory(String tableName) throws Exception {
		List<MemoryItem> list = this.findAll(tableName);
		StringBuilder sb = new StringBuilder();
		for(MemoryItem item : list) {
			sb.append(item.getKey().getId()).append("-").append(item.getKey().getKeywords()).append(Syntax.NEW_LINE)
					.append(item.getContent()).append(Syntax.NEW_LINE).append(Syntax.NEW_LINE);
			sb.append("---------------------------------");
		}
		return sb.toString();
	}
	public List<MemoryItemKey> getAllItemKeys(String tableName) throws Exception {
	    List<MemoryItemKey> keyList = new ArrayList<>();
	    Connection connection = null;
        Statement statement=null;
        ResultSet resultSet=null;
        try {
            connection = getConnection(file, this.userName, this.pwd);
            connection.setAutoCommit(false);
            String sql = String.format("select %s, %s from %s", COLUMN_ID, COLUMN_KEYWORDS, tableName);
            statement = connection.createStatement();
            resultSet = statement.executeQuery(sql);
            ResultSetMetaData resultSetMetaData = resultSet.getMetaData();
            int cc = resultSetMetaData.getColumnCount();
            while(resultSet.next()){
                MemoryItemKey memoryItemKey =  new MemoryItemKey();
                memoryItemKey.setTable(tableName);
                for(int i=1;i<=cc;i++){
                    String cl = null;
                    try {
                        cl = resultSetMetaData.getColumnLabel(i);
                    } catch (Exception e) {
                        cl = resultSetMetaData.getColumnName(i);
                    }
                    Object o = resultSet.getObject(i);
                    if(COLUMN_ID.equalsIgnoreCase(cl)) {
                        memoryItemKey.setId(o.toString());
                    }else if(COLUMN_KEYWORDS.equalsIgnoreCase(cl)) {
                        memoryItemKey.setKeywords(o.toString());
                    }
                }
                keyList.add(memoryItemKey);
            }
        } catch (Exception e) {
            e.printStackTrace();
            throw e;
        } finally {
            if(null!=statement){
                statement.close();
            }
            if(null!=connection){
                connection.close();
            }
        }
        return keyList;
	}
	private Map<MemoryItemKey, MemoryItem> getAllItems(String tableName) throws Exception {
		Map<MemoryItemKey, MemoryItem> map = new HashMap<>();
		Connection connection = null;
		Statement statement=null;
		ResultSet resultSet=null;
		try {
			connection = getConnection(file, this.userName, this.pwd);
			connection.setAutoCommit(false);
			String sql = String.format("select * from %s", tableName);
			statement = connection.createStatement();
			resultSet = statement.executeQuery(sql);
			ResultSetMetaData resultSetMetaData = resultSet.getMetaData();
			int cc = resultSetMetaData.getColumnCount();
			while(resultSet.next()){
				MemoryItemKey memoryItemKey =  new MemoryItemKey();
				memoryItemKey.setTable(tableName);
				MemoryItem memoryItem =  new MemoryItem();
				memoryItem.setKey(memoryItemKey);
				for(int i=1;i<=cc;i++){
					String cl = null;
					try {
						cl = resultSetMetaData.getColumnLabel(i);
					} catch (Exception e) {
						cl = resultSetMetaData.getColumnName(i);
					}
					Object o = resultSet.getObject(i);
					if(COLUMN_ID.equalsIgnoreCase(cl)) {
                        memoryItemKey.setId(o.toString());
                    }else if(COLUMN_KEYWORDS.equalsIgnoreCase(cl)) {
                        memoryItemKey.setKeywords(o.toString());
                    }else if(COLUMN_CONTENT.equalsIgnoreCase(cl)) {
                        memoryItem.setContent(o.toString());
                    }else if(COLUMN_COMMENT.equalsIgnoreCase(cl)) {
                        memoryItem.setComment("");
                    }
				}
				map.put(memoryItemKey, memoryItem);
			}
		} catch (Exception e) {
			e.printStackTrace();
			throw e;
		} finally {
			if(null!=statement){
				statement.close();
			}
			if(null!=connection){
				connection.close();
			}
		}
		return map;
	}
	public void loadAllKeywordsMappings() throws Exception {
		for(String table : memoryAreas) {
		    List<MemoryItemKey> keyList = this.getAllItemKeys(table);
		    tableKeywordsMapping.putIfAbsent(table, keyList);
		}
	    return ;
	}
	public Map<String, List<MemoryItemKey>> getTableKeywordsMapping() {
        return tableKeywordsMapping;
    }
    public List<String> loadAllEnabledMemoryAreas() throws Exception {
		List<MemoryArea> list = getAllMemoryAreas();
		List<String> list1=list.stream().filter(e -> !e.isDisable()).map(e->e.getTable()).collect(Collectors.toList());
		memoryAreas = list1;
		return list1;
	}
	public List<MemoryArea> getAllMemoryAreas() throws Exception {
		String areaJson = this.showConfigMemory(MEMORY_AREAS_KEY_WORDS);
		if(Objects.isNull(areaJson)) {
			System.out.print(String.format("cannot find memory area row"));
			return new ArrayList<MemoryArea>();
		}else{
			Gson gson = new Gson();
			Type type = new TypeToken<List<MemoryArea>>(){}.getType();
			List<MemoryArea> list1 = gson.fromJson(areaJson, type);
			return list1;
		}
	}
	@UIAnno(uiClz="ui.MemoryPane")
	@ServiceMethodAnn(keyword = "show memory")
	public String showMemory(String table, String keyword) throws Exception {
		MemoryItem item = findOneByKeyword(table, keyword);
		if(null!=item) {
			return item.getContent();
		}
		System.out.print(String.format("cannot find row by table %s and keyword %s", table, keyword));
		return "";
	}
	public String showConfigMemory(String keyword) throws Exception {
		return showMemory(this.CONFIG_TABLE, keyword);
	}
	public List<String> getJREClzNames() throws Exception {
		String name = showMemory(this.CONFIG_TABLE, JRE8_RTJAR_JAVA_JAVAX_ORG_KEYWORD);
		List<String> list = new ArrayList<>();
		Scanner scanner = new Scanner(name);
		try {
			while (scanner.hasNextLine()) {
				String line = scanner.nextLine();
				if (line != null && !"".equals(line.trim())) {
					list.add(line);
				}
			}
		} catch (Exception e) {
		} finally {
			scanner.close();
		}
		return list;
	}
	@NotVisibleInUI
	public int insert(String tableName, String keywords, String content) throws Exception {
		UUID uuid = UUID.randomUUID();
		String id = uuid.toString();
		return insert(tableName, id, keywords, content); 
	}
	@NotVisibleInUI
    public int insert(String tableName,String id, String keywords, String content) throws Exception {
        String sql = String.format("insert into %s (keywords, content, id, createTime, updateTime) values (?, ?, ?, ?, ?)", tableName);
        long now = new Date().getTime();
        Timestamp nowTimestamp = new Timestamp(now);
        int i = executeUpdate(sql,new Object[] {  keywords, content, id, nowTimestamp, nowTimestamp});
        if(i>0){
            MemoryItemKey key = new MemoryItemKey();
            key.setId(id);
            key.setKeywords(keywords);
            key.setTable(tableName);
            MemoryItem mi = new MemoryItem();
            mi.setKey(key);
            mi.setContent(content);
            List<MemoryItemKey> keys;
            if(tableKeywordsMapping.containsKey(tableName)) {
                keys = tableKeywordsMapping.get(tableName);
            }else {
                keys = new ArrayList<>();
                tableKeywordsMapping.put(tableName, keys);
            }
            keys.add(key);
        }
        return i; 
    }
	public void reloadMapping(String tableName) throws Exception{
	}
	public void updateMapping(MemoryItemKey oldkey, MemoryItemKey key, MemoryItem mi) throws Exception{
	    List<MemoryItemKey> keys;
        if(tableKeywordsMapping.containsKey(key.getTable())) {
            keys = tableKeywordsMapping.get(key.getTable());
        }else {
            keys = new ArrayList<>();
        }
        MemoryItemKey existingKey = null;
        for(MemoryItemKey tempKey : keys) {
            if(tempKey.equals(oldkey)) {
                existingKey = tempKey;
            }
        }
        if(null!=existingKey) {
            existingKey.setId(oldkey.getId());
            existingKey.setTable(oldkey.getTable());
            existingKey.setKeywords(oldkey.getKeywords());
        }
	}
	public void removeMapping(MemoryItemKey key) throws Exception{
	    List<MemoryItemKey> keys;
        if(tableKeywordsMapping.containsKey(key.getTable())) {
            keys = tableKeywordsMapping.get(key.getTable());
        }else {
            keys = new ArrayList<>();
        }
        for(int i=0;i<keys.size();i++) {
            MemoryItemKey tempKey = keys.get(i);
            if(tempKey.equals(key)) {
                keys.set(i, null);
            }
        }
        List<MemoryItemKey> newKeys= new ArrayList<>();
        for(MemoryItemKey tempKey : keys) {
            if(tempKey != null) {
                newKeys.add(tempKey);
            }
        }
        tableKeywordsMapping.remove(key.getTable());
        tableKeywordsMapping.putIfAbsent(key.getTable(), newKeys);
	}
	public MemoryItemKey getOldMemoryItemFromKeywordsMapping(String table, String id) throws Exception{
		List<MemoryItemKey> keys;
        if(tableKeywordsMapping.containsKey(table)) {
            keys = tableKeywordsMapping.get(table);
        }else {
            keys = new ArrayList<>();
        }
        MemoryItemKey existingKey = null;
        for(MemoryItemKey tempKey : keys) {
            if(tempKey.getId().equals(id)) {
                existingKey = tempKey;
            }
        }
		return existingKey;
	}
	public void saveOrUpdateLastProject(String content) throws Exception{
		saveOrUpdate(CONFIG_TABLE, codegen.Const.BRAIN_LAST_PROJECT_KEYWORD, content);
	}
	public void saveOrUpdate(String tableName, String keywords, String content) throws Exception{
		List<MemoryItem> itemList;
		String id;
		try {
			itemList = this.findByKeyword(tableName, keywords);
		} catch (Exception e) {
			itemList=null;
		}
		if(!Objects.isNull(itemList) && !itemList.isEmpty()){
			id =itemList.get(0).getKey().getId();
			String oldContent = itemList.get(0).getContent();
			if(!StringUtils.equalsIgnoreCase(oldContent, content)){
				int i= this.updateById(tableName, id, keywords, content);
				if(i>0){
				}else{
				}
			}
		}else{
			this.memorizeInTable(tableName, keywords, content);
		}
		return ;
	}
	@NotVisibleInUI
	public int updateById(String tableName,@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) String id, String keywords,
			String content) throws Exception {
		String sql = String.format("update %s set keywords=?,content=?,updateTime=? where id=?", tableName);
		long now = new Date().getTime();
        Timestamp nowTimestamp = new Timestamp(now);
		int i = 0;
		try {
			i = executeUpdate(sql,new Object[] { keywords, content,nowTimestamp, id});
		} catch (Exception e) {
			System.out.println(e.getMessage());
		}
		if(i>0){
			MemoryItemKey key = new MemoryItemKey();
			key.setId(id);
			key.setKeywords(keywords);
			key.setTable(tableName);
			MemoryItem mi = new MemoryItem();
			mi.setKey(key);
			mi.setContent(content);
			MemoryItemKey oldKey = getOldMemoryItemFromKeywordsMapping(tableName, id);
			if(null!=oldKey)
				updateMapping(oldKey, key, mi );
		}
		return i; 
	}
	@NotVisibleInUI
	public int removeById(String tableName,@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) String id) throws Exception {
		String sql = String.format("delete from %s where id=?", tableName);
		int i=0;
		try {
			i = executeUpdate(sql,new Object[] { id});
		} catch (Exception e) {
		    System.out.println(e.getMessage());
		} 
		if(i>0){
		    MemoryItemKey oldKey = getOldMemoryItemFromKeywordsMapping(tableName, id);
			if(null!=oldKey)
				removeMapping(oldKey);
		}
		return i; 
	}
	public MemoryItem findOneByKeyword(String tableName,String keywords) throws Exception {
		Connection connection = null;
		Statement statement=null;
		ResultSet resultSet=null;
		MemoryItem memoryItem =  new MemoryItem();
		try {
			connection = getConnection(file, this.userName, this.pwd);
			connection.setAutoCommit(false);
			String sql = String.format("select top 1 * from %s where keywords like '%%%s%%'", tableName, keywords);
			statement = connection.createStatement();
			resultSet = statement.executeQuery(sql);
			ResultSetMetaData resultSetMetaData = resultSet.getMetaData();
			int cc = resultSetMetaData.getColumnCount();
			while(resultSet.next()){
				MemoryItemKey memoryItemKey =  new MemoryItemKey();
				memoryItem.setKey(memoryItemKey);
				for(int i=1;i<=cc;i++){
					String cl = resultSetMetaData.getColumnLabel(i);
					Object o = resultSet.getObject(i);
					if(cl.equalsIgnoreCase("id")) {
						memoryItemKey.setId(o.toString());
					}else if(cl.equalsIgnoreCase("keywords")) {
						memoryItemKey.setKeywords(o.toString());
					}else if(cl.equalsIgnoreCase("content")) {
						memoryItem.setContent(o.toString());
					}else if(cl.equalsIgnoreCase("comment")) {
						memoryItem.setComment("");
					}
				}
			}
		} catch (Exception e) {
			e.printStackTrace();
			throw e;
		} finally {
			if(null!=statement){
				statement.close();
			}
			if(null!=connection){
				connection.close();
			}
		}
		if(memoryItem.getKey()==null) {
			throw new Exception("cannot find item by "+keywords);
		}
		return memoryItem;
	}
	public List<MemoryItem> findByKeyword(String tableName,String keywords) throws Exception {
		List<MemoryItem> list = new ArrayList<>();
		Connection connection = null;
		Statement statement=null;
		ResultSet resultSet=null;
		try {
			connection = getConnection(file, this.userName, this.pwd);
			connection.setAutoCommit(false);
			String sql = String.format("select * from %s where keywords like '%%%s%%'", tableName, keywords);
			statement = connection.createStatement();
			resultSet = statement.executeQuery(sql);
			ResultSetMetaData resultSetMetaData = resultSet.getMetaData();
			int cc = resultSetMetaData.getColumnCount();
			while(resultSet.next()){
				MemoryItemKey memoryItemKey =  new MemoryItemKey();
				MemoryItem memoryItem =  new MemoryItem();
				memoryItem.setKey(memoryItemKey);
				for(int i=1;i<=cc;i++){
					String cl = resultSetMetaData.getColumnLabel(i);
					Object o = resultSet.getObject(i);
					if(cl.equalsIgnoreCase("id")) {
						memoryItemKey.setId(o.toString());
					}else if(cl.equalsIgnoreCase("keywords")) {
						memoryItemKey.setKeywords(o.toString());
					}else if(cl.equalsIgnoreCase("content")) {
						memoryItem.setContent(o.toString());
					}else if(cl.equalsIgnoreCase("comment")) {
						memoryItem.setComment("");
					}
				}
				list.add(memoryItem);
			}
		} catch (Exception e) {
			e.printStackTrace();
			throw e;
		} finally {
			if(null!=statement){
				statement.close();
			}
			if(null!=connection){
				connection.close();
			}
		}
		return list;
	}
	public int executeUpdate(String sql, Object... args) throws Exception {
		int i;
		Connection connection = null;
		PreparedStatement statement=null;
		try {
			connection = getConnection(file, this.userName, this.pwd);
			connection.setAutoCommit(false);
			statement = connection.prepareStatement(sql);
			for(int j=1;j<=args.length;j++){
				statement.setString(j, args[j-1].toString());
			}
			i = statement.executeUpdate();
			connection.commit();
		} catch (Exception e) {
			e.printStackTrace();
			throw e;
		} finally {
			if(null!=statement){
				statement.close();
			}
			if(null!=connection){
				connection.close();
			}
		}
		return i;
	}
	public MemoryItem findById(String tableName,String id) throws Exception {
		Connection connection = null;
		Statement statement=null;
		ResultSet resultSet=null;
		MemoryItem memoryItem =  new MemoryItem();
		try {
			connection = getConnection(file, this.userName, this.pwd);
			connection.setAutoCommit(false);
			String sql = String.format("select * from %s where id='%s'", tableName, id);
			statement = connection.createStatement();
			resultSet = statement.executeQuery(sql);
			ResultSetMetaData resultSetMetaData = resultSet.getMetaData();
			int cc = resultSetMetaData.getColumnCount();
			while(resultSet.next()){
				MemoryItemKey memoryItemKey =  new MemoryItemKey();
				memoryItem.setKey(memoryItemKey);
				for(int i=1;i<=cc;i++){
					String cl = resultSetMetaData.getColumnLabel(i);
					Object o = resultSet.getObject(i);
					if(cl.equalsIgnoreCase("id")) {
						memoryItemKey.setId(o.toString());
					}else if(cl.equalsIgnoreCase("keywords")) {
						memoryItemKey.setKeywords(o.toString());
					}else if(cl.equalsIgnoreCase("content")) {
						memoryItem.setContent(o.toString());
					}else if(cl.equalsIgnoreCase("comment")) {
						memoryItem.setComment("");
					}
				}
			}
		} catch (Exception e) {
			e.printStackTrace();
			throw e;
		} finally {
			if(null!=statement){
				statement.close();
			}
			if(null!=connection){
				connection.close();
			}
		}
		if(memoryItem.getKey()==null) {
			throw new Exception("cannot find item by id "+id);
		}
		return memoryItem;
	}
	public List<MemoryItem> findAll(String tableName) throws Exception {
		List<MemoryItem> list = new ArrayList<>();
		Connection connection = null;
		Statement statement=null;
		ResultSet resultSet=null;
		try {
			connection = getConnection(file, this.userName, this.pwd);
			connection.setAutoCommit(false);
			String sql = String.format("select * from %s", tableName);
			statement = connection.createStatement();
			resultSet = statement.executeQuery(sql);
			ResultSetMetaData resultSetMetaData = resultSet.getMetaData();
			int cc = resultSetMetaData.getColumnCount();
			while(resultSet.next()){
				MemoryItemKey memoryItemKey =  new MemoryItemKey();
				MemoryItem memoryItem =  new MemoryItem();
				memoryItem.setKey(memoryItemKey);
				for(int i=1;i<=cc;i++){
					String cl = resultSetMetaData.getColumnLabel(i);
					Object o = resultSet.getObject(i);
					if(cl.equalsIgnoreCase("id")) {
						memoryItemKey.setId(o.toString());
					}else if(cl.equalsIgnoreCase("keywords")) {
						memoryItemKey.setKeywords(o.toString());
					}else if(cl.equalsIgnoreCase("content")) {
						memoryItem.setContent(o.toString());
					}else if(cl.equalsIgnoreCase("comment")) {
						memoryItem.setComment("");
					}
				}
				list.add(memoryItem);
			}
		} catch (Exception e) {
			e.printStackTrace();
			throw e;
		} finally {
			if(null!=statement){
				statement.close();
			}
			if(null!=connection){
				connection.close();
			}
		}
		return list;
	}
	public File getFile() {
		return file;
	}
	public void setFile(File file) {
		this.file = file;
	}
	public String getUserName() {
		return userName;
	}
	public void setUserName(String userName) {
		this.userName = userName;
	}
	public String getPwd() {
		return pwd;
	}
	public void setPwd(String pwd) {
		this.pwd = pwd;
	}
	public List<String> getMemoryAreas() {
		return memoryAreas;
	}
	public static void main(String[] args){
		Connection connection = null;
		Statement statement=null;
		ResultSet resultSet=null;
		try {
			H2JDBCService ds = new H2JDBCService();
			File f = new File("D:\\projects\\cg\\cg-5.6\\bb");
			ds.testConnection(f, "sa", "");
			ds.loadAllEnabledMemoryAreas();
			ds.loadAllKeywordsMappings();
			List<MemoryItem> list = ds.findByKeyword(ds.CONFIG_TABLE, codegen.Const.BRAIN_LOCAL_REPO_KEYWORD);
			MemoryItem mi = ds.findOneByKeyword(ds.CONFIG_TABLE, codegen.Const.BRAIN_LOCAL_REPO_KEYWORD);
			int r = ds.executeUpdate("update config set keywords=?,content=? where id=?",  mi.getKey().getKeywords(), "test", mi.getKey().getId());
			r = ds.executeUpdate("delete from config where keywords=?",  mi.getKey().getKeywords());
			mi = ds.findOneByKeyword(ds.CONFIG_TABLE, codegen.Const.BRAIN_LOCAL_REPO_KEYWORD);
			ds.removeById(ds.CONFIG_TABLE, mi.getKey().getId());
			statement = connection.createStatement();
			String sql = "select * from commandsyntax";
			resultSet = statement.executeQuery(sql);
			ResultSetMetaData resultSetMetaData = resultSet.getMetaData();
			int cc = resultSetMetaData.getColumnCount();
			while(resultSet.next()){
				for(int i=1;i<=cc;i++){
					Object o = resultSet.getObject(i);
					System.out.println(String.format("column is = %s", o));
				}
			}
			connection.close();
		} catch ( Exception e) {
			e.printStackTrace();
		} finally {
			if(null!=resultSet){
				try {
					resultSet.close();
				} catch (SQLException e) {
					e.printStackTrace();
				}
			}
			if(null!=statement){
				try {
					statement.close();
				} catch (SQLException e) {
					e.printStackTrace();
				}
			}
			if(null!=connection){
				try {
					connection.close();
				} catch (SQLException e) {
					e.printStackTrace();
				}
			}
		}
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\codegen\eclipseRobot\H2JDBCService2.java---
package codegen.eclipseRobot;
import codegen.Syntax;
import codegen.eclipseRobot.model.MemoryArea;
import codegen.eclipseRobot.model.MemoryItem;
import codegen.eclipseRobot.model.MemoryItemKey;
import codegen.robot.Service;
import com.dgs.annotation.ParamAnno;
import com.dgs.annotation.ServiceMethodAnn;
import com.dgs.annotation.UIAnno;
import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import org.apache.commons.lang3.StringUtils;
import ui.validation.NotVisibleInUI;
import ui.validation.ValidationAnn;
import java.io.File;
import java.lang.reflect.Type;
import java.sql.*;
import java.util.Date;
import java.util.*;
import java.util.stream.Collectors;
public class H2JDBCService2 extends Service {
	private File file;
	private String userName="sa";
	private String pwd;
	public static final String CREATE_TABLE = "CREATE TABLE %s(ID VARCHAR(255) PRIMARY KEY, keywords VARCHAR_IGNORECASE(255), content LONGVARCHAR, comment VARCHAR(255), createTime TIMESTAMP, updateTime TIMESTAMP);";
	public static final String MEMORY_AREAS_KEY_WORDS = "MEMORY_AREAS_KEY_WORDS";
	private List<String> memoryAreas;
	List<MemoryItem> configItems;
	List<MemoryItem> commandItems;
	List<MemoryItem> miscAreaItems;
	List<MemoryItem> codeSyntaxItems;
	private Map<MemoryItemKey, MemoryItem> codeSyntaxKeywordsMapping = new HashMap<>();
	private Map<MemoryItemKey, MemoryItem> commandKeywordsMapping = new HashMap<>();
	private Map<MemoryItemKey, MemoryItem> miscKeywordsMapping = new HashMap<>();
	private Map<MemoryItemKey, MemoryItem> configKeywordsMapping = new HashMap<>();
	public static final String CONFIG_TABLE = "config";
	public static final String COMMAND_SYNTAX_TABLE = "commandsyntax";
	public static final String MISC_AREA_TABLE = "miscarea";
	public static final String CODE_SYNTAX_TABLE = "codesyntax";
	public static final String COLUMN_ID = "ID";
	public static final String COLUMN_KEYWORDS = "keywords";
	public static final String COLUMN_CONTENT = "content";
	public static final String COLUMN_COMMENT = "comment";
	public static final String JRE8_RTJAR_JAVA_JAVAX_ORG_KEYWORD = "jre8_rtjar_java_javax_org";
	public H2JDBCService2() {
	}
	public String testConnection(@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) File dbfile, String user, String password)throws Exception {
		Connection conn = getConnection(dbfile, user, password);
		if(null!=conn) {
			conn.close();
		}else {
			return "failed";
		}
		return "ok";
	}
	public Connection getConnection(@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) File dbfile, String user, String password) throws Exception {
		this.file = dbfile;
		String driverClzName = "org.h2.Driver";
		String dbFilepath = dbfile.getAbsolutePath();
		dbFilepath = dbFilepath.replaceFirst(".mv.db", "");
		String url = "jdbc:h2:file:"+dbFilepath;
		Connection connection = null;
		try {
			Class.forName(driverClzName);
			connection = DriverManager.getConnection(url, user, password);
		} catch (SQLException | ClassNotFoundException e) {
			e.printStackTrace();
			throw e;
		} finally {
		}
		return connection;
	}
	@ServiceMethodAnn(keyword = "memorize code syntax")
	public void memorizeCodeSyntax(@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) String keywords,
			@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) String content) throws Exception {
		memorizeInTable(CODE_SYNTAX_TABLE, keywords,content);
	}
	@ServiceMethodAnn(keyword = "memorize config")
	public void memorizeConfig(@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) String keywords,
			@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) String content) throws Exception {
		memorizeInTable(CONFIG_TABLE, keywords,content);
	}
	@ServiceMethodAnn(keyword = "memorize misc")
	public void memorizeMisc(@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) String keywords,
			@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) String content) throws Exception {
		memorizeInTable(MISC_AREA_TABLE, keywords,content);
	}
	@ServiceMethodAnn(keyword = "memorize command syntax")
	public void memorizeCommandSyntax(@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) String keywords,
			@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) String content) throws Exception {
		memorizeInTable(COMMAND_SYNTAX_TABLE, keywords,content);
	}
	@ServiceMethodAnn(keyword = "memorize in area")
	public void memorizeInTable(
	        @UIAnno(uiClz = "ui.ClassCombBoxpane")
	        @ParamAnno(description = "memory area") 
	        String areaName, @ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) String keywords,
			@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) String content) throws Exception {
		insert(areaName, keywords, content);
	}
	@ServiceMethodAnn(keyword = "create memory area")
	public void createTable(
	        @ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) String areaName, boolean disable)
			throws Exception {
		String sql = String.format(CREATE_TABLE, areaName);
		executeUpdate(sql, new String[]{});
		String areaJson = this.showConfigMemory(MEMORY_AREAS_KEY_WORDS);
		Gson gson = new Gson();
		Type type = new TypeToken<List<MemoryArea>>(){}.getType();
		List<MemoryArea> list1 = gson.fromJson(areaJson, type);
		MemoryArea ma = new MemoryArea(areaName, disable);
		list1.add(ma);
		areaJson = gson.toJson(list1);
		this.saveOrUpdate(CONFIG_TABLE, MEMORY_AREAS_KEY_WORDS, areaJson);
		return;
	}
	public String showMemoryById(String tableName, @ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) String id)
			throws Exception {
		MemoryItem item = this.findById(tableName, id);
		StringBuilder sb = new StringBuilder();
		if(null != item) {
			sb.append(item.getContent()).append(Syntax.NEW_LINE).append(Syntax.NEW_LINE);
		}
		return sb.toString();
	}
	@ServiceMethodAnn(keyword = "show all memory")
	public String showAllMemory(String tableName) throws Exception {
		List<MemoryItem> list = this.findAll(tableName);
		StringBuilder sb = new StringBuilder();
		for(MemoryItem item : list) {
			sb.append(item.getKey().getId()).append("-").append(item.getKey().getKeywords()).append(Syntax.NEW_LINE)
					.append(item.getContent()).append(Syntax.NEW_LINE).append(Syntax.NEW_LINE);
			sb.append("---------------------------------");
		}
		return sb.toString();
	}
	public Map<MemoryItemKey, MemoryItem> getAllItems(String tableName) throws Exception {
		Map<MemoryItemKey, MemoryItem> map = new HashMap<>();
		Connection connection = null;
		Statement statement=null;
		ResultSet resultSet=null;
		try {
			connection = getConnection(file, this.userName, this.pwd);
			connection.setAutoCommit(false);
			String sql = String.format("select * from %s", tableName);
			statement = connection.createStatement();
			resultSet = statement.executeQuery(sql);
			ResultSetMetaData resultSetMetaData = resultSet.getMetaData();
			int cc = resultSetMetaData.getColumnCount();
			while(resultSet.next()){
				MemoryItemKey memoryItemKey =  new MemoryItemKey();
				memoryItemKey.setTable(tableName);
				MemoryItem memoryItem =  new MemoryItem();
				memoryItem.setKey(memoryItemKey);
				for(int i=1;i<=cc;i++){
					String cl = null;
					try {
						cl = resultSetMetaData.getColumnLabel(i);
					} catch (Exception e) {
						cl = resultSetMetaData.getColumnName(i);
					}
					Object o = resultSet.getObject(i);
					if("id".equalsIgnoreCase(cl)) {
						memoryItemKey.setId(o.toString());
					}else if("keywords".equalsIgnoreCase(cl)) {
						memoryItemKey.setKeywords(o.toString());
					}else if("content".equalsIgnoreCase(cl)) {
						memoryItem.setContent(o.toString());
					}else if("comment".equalsIgnoreCase(cl)) {
						memoryItem.setComment("");
					}
				}
				map.put(memoryItemKey, memoryItem);
			}
		} catch (Exception e) {
			e.printStackTrace();
			throw e;
		} finally {
			if(null!=statement){
				statement.close();
			}
			if(null!=connection){
				connection.close();
			}
		}
		return map;
	}
	public void loadAllKeywordsMappings() throws Exception {
		getAllConfigItems();
		getAllMiscAreaItems();
		getAllCodeSyntaxItems();
		getAllCommandItems();
	    return ;
	}
	private Map<MemoryItemKey, MemoryItem> getAllConfigItems() throws Exception {
		this.configKeywordsMapping = getAllItems(CONFIG_TABLE);
	    return this.configKeywordsMapping;
	}
	private Map<MemoryItemKey, MemoryItem> getAllMiscAreaItems() throws Exception {
		this.miscKeywordsMapping = getAllItems(MISC_AREA_TABLE);
		return miscKeywordsMapping;
	}
	private Map<MemoryItemKey, MemoryItem> getAllCodeSyntaxItems() throws Exception {
		this.codeSyntaxKeywordsMapping = getAllItems(CODE_SYNTAX_TABLE);
		return this.codeSyntaxKeywordsMapping;
	}
	private Map<MemoryItemKey, MemoryItem> getAllCommandItems() throws Exception {
		this.commandKeywordsMapping = getAllItems(COMMAND_SYNTAX_TABLE);
		return this.commandKeywordsMapping;
	}
	public List<MemoryItemKey> getCodeSyntaxKeys()
			throws Exception {
		Set<MemoryItemKey> keys = codeSyntaxKeywordsMapping.keySet();
		List<MemoryItemKey> list = new ArrayList<>();
		list.addAll(keys);
	    return list;
	}
	public List<MemoryItemKey> getMiscAreaKeys()
			throws Exception {
		Set<MemoryItemKey> keys = miscKeywordsMapping.keySet();
		List<MemoryItemKey> list = new ArrayList<>();
		list.addAll(keys);
	    return list;
	}
	public List<MemoryItemKey> getCommandSyntaxKeys()
			throws Exception {
		Set<MemoryItemKey> keys = commandKeywordsMapping.keySet();
		List<MemoryItemKey> list = new ArrayList<>();
		list.addAll(keys);
	    return list;
	}
	public List<MemoryItemKey> getConfigKeys()
			throws Exception {
		Set<MemoryItemKey> keys = configKeywordsMapping.keySet();
		List<MemoryItemKey> list = new ArrayList<>();
		list.addAll(keys);
	    return list;
	}
	public List<String> loadAllEnabledMemoryAreas() throws Exception {
		List<MemoryArea> list = getAllMemoryAreas();
		List<String> list1=list.stream().filter(e -> !e.isDisable()).map(e->e.getTable()).collect(Collectors.toList());
		memoryAreas = list1;
		return list1;
	}
	public List<MemoryArea> getAllMemoryAreas() throws Exception {
		String areaJson = this.showConfigMemory(MEMORY_AREAS_KEY_WORDS);
		if(Objects.isNull(areaJson)) {
			System.out.print(String.format("cannot find memory area row"));
			return new ArrayList<MemoryArea>();
		}else{
			Gson gson = new Gson();
			Type type = new TypeToken<List<MemoryArea>>(){}.getType();
			List<MemoryArea> list1 = gson.fromJson(areaJson, type);
			return list1;
		}
	}
	@UIAnno(uiClz="ui.MemoryPane")
	@ServiceMethodAnn(keyword = "show memory")
	public String showMemory(String table, String keyword) throws Exception {
		MemoryItem item = findOneByKeyword(table, keyword);
		if(null!=item) {
			return item.getContent();
		}
		System.out.print(String.format("cannot find row by table %s and keyword %s", table, keyword));
		return "";
	}
	public String showCodeSyntaxMemory( String keyword) throws Exception {
		return showMemory(this.CODE_SYNTAX_TABLE, keyword);
	}
	public String showMiscAreaMemory( String keyword) throws Exception {
		return showMemory(this.MISC_AREA_TABLE, keyword);
	}
	public String showCommandMemory(String keyword) throws Exception {
		return showMemory(this.COMMAND_SYNTAX_TABLE, keyword);
	}
	public String showConfigMemory(String keyword) throws Exception {
		return showMemory(this.CONFIG_TABLE, keyword);
	}
	public List<String> getJREClzNames() throws Exception {
		String name = showMemory(this.CONFIG_TABLE, JRE8_RTJAR_JAVA_JAVAX_ORG_KEYWORD);
		List<String> list = new ArrayList<>();
		Scanner scanner = new Scanner(name);
		try {
			while (scanner.hasNextLine()) {
				String line = scanner.nextLine();
				if (line != null && !"".equals(line.trim())) {
					list.add(line);
				}
			}
		} catch (Exception e) {
		} finally {
			scanner.close();
		}
		return list;
	}
	@NotVisibleInUI
	public int insert(String tableName, String keywords, String content) throws Exception {
		UUID uuid = UUID.randomUUID();
		String id = uuid.toString();
		return insert(tableName, id, keywords, content); 
	}
	@NotVisibleInUI
    public int insert(String tableName,String id, String keywords, String content) throws Exception {
        String sql = String.format("insert into %s (keywords, content, id, createTime, updateTime) values (?, ?, ?, ?, ?)", tableName);
        long now = new Date().getTime();
        Timestamp nowTimestamp = new Timestamp(now);
        int i = executeUpdate(sql,new Object[] {  keywords, content, id, nowTimestamp, nowTimestamp});
        if(i>0){
            MemoryItemKey key = new MemoryItemKey();
            key.setId(id);
            key.setKeywords(keywords);
            key.setTable(tableName);
            MemoryItem mi = new MemoryItem();
            mi.setKey(key);
            mi.setContent(content);
            switch(tableName){ 
                case CONFIG_TABLE:
                    configKeywordsMapping.put(key, mi);
                break;
                case COMMAND_SYNTAX_TABLE:
                    this.commandKeywordsMapping.put(key, mi);
                break;
                case MISC_AREA_TABLE:
                    this.miscKeywordsMapping.put(key, mi);
                break;
                case CODE_SYNTAX_TABLE:
                    this.codeSyntaxKeywordsMapping.put(key, mi);
                break;
                default :
                break;
            }
        }
        return i; 
    }
	public void reloadMapping(String tableName) throws Exception{
		switch(tableName){ 
			case CONFIG_TABLE:
				getAllConfigItems();
			break;
			case COMMAND_SYNTAX_TABLE:
				getAllCommandItems();
			break;
			case MISC_AREA_TABLE:
				getAllMiscAreaItems();
			break;
			case CODE_SYNTAX_TABLE:
				getAllCodeSyntaxItems();
			break;
			default :
			break;
		}
	}
	public void updateMapping(MemoryItemKey oldkey, MemoryItemKey key, MemoryItem mi) throws Exception{
		switch(key.getTable() ){ 
			case CONFIG_TABLE:
				configKeywordsMapping.remove(oldkey);
				configKeywordsMapping.put(key, mi);
			break;
			case COMMAND_SYNTAX_TABLE:
				commandKeywordsMapping.remove(oldkey);
				commandKeywordsMapping.put(key, mi);
			break;
			case MISC_AREA_TABLE:
				miscKeywordsMapping.remove(oldkey);
				miscKeywordsMapping.put(key, mi);
			break;
			case CODE_SYNTAX_TABLE:
				codeSyntaxKeywordsMapping.remove(oldkey);
				codeSyntaxKeywordsMapping.put(key, mi);
			break;
			default :
			break;
		}
	}
	public void removeMapping(MemoryItemKey key) throws Exception{
		switch(key.getTable() ){ 
			case CONFIG_TABLE:
				configKeywordsMapping.remove(key);
			break;
			case COMMAND_SYNTAX_TABLE:
				commandKeywordsMapping.remove(key);
			break;
			case MISC_AREA_TABLE:
				miscKeywordsMapping.remove(key);
			break;
			case CODE_SYNTAX_TABLE:
				codeSyntaxKeywordsMapping.remove(key);
			break;
			default :
			break;
		}
	}
	public MemoryItem getOldMemoryItemFromKeywordsMapping(String table, String id) throws Exception{
		MemoryItemKey key = new MemoryItemKey();
		key.setId(id);
		key.setTable(table);
		MemoryItem item=null;
		switch(table){ 
			case CONFIG_TABLE:
				item= configKeywordsMapping.get(key);
			break;
			case COMMAND_SYNTAX_TABLE:
				item= commandKeywordsMapping.get(key);
			break;
			case MISC_AREA_TABLE:
				item= miscKeywordsMapping.get(key);
			break;
			case CODE_SYNTAX_TABLE:
				item= codeSyntaxKeywordsMapping.get(key);
			break;
			default :
			break;
		}
		return item;
	}
	public void saveOrUpdateLastProject(String content) throws Exception{
		saveOrUpdate(CONFIG_TABLE, codegen.Const.BRAIN_LAST_PROJECT_KEYWORD, content);
	}
	public void saveOrUpdate(String tableName, String keywords, String content) throws Exception{
		List<MemoryItem> itemList;
		String id;
		try {
			itemList = this.findByKeyword(tableName, keywords);
		} catch (Exception e) {
			itemList=null;
		}
		if(!Objects.isNull(itemList) && !itemList.isEmpty()){
			id =itemList.get(0).getKey().getId();
			String oldContent = itemList.get(0).getContent();
			if(!StringUtils.equalsIgnoreCase(oldContent, content)){
				int i= this.updateById(tableName, id, keywords, content);
				if(i>0){
				}else{
				}
			}
		}else{
			this.memorizeInTable(tableName, keywords, content);
		}
		return ;
	}
	@NotVisibleInUI
	public int updateById(String tableName,@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) String id, String keywords,
			String content) throws Exception {
		String sql = String.format("update %s set keywords=?,content=?,updateTime=? where id=?", tableName);
		long now = new Date().getTime();
        Timestamp nowTimestamp = new Timestamp(now);
		int i = 0;
		try {
			i = executeUpdate(sql,new Object[] { keywords, content,nowTimestamp, id});
		} catch (Exception e) {
			System.out.println(e.getMessage());
		}
		if(i>0){
			MemoryItemKey key = new MemoryItemKey();
			key.setId(id);
			key.setKeywords(keywords);
			key.setTable(tableName);
			MemoryItem mi = new MemoryItem();
			mi.setKey(key);
			mi.setContent(content);
			MemoryItem oldItem = getOldMemoryItemFromKeywordsMapping(tableName, id);
			if(null!=oldItem)
				updateMapping(oldItem.getKey(), key, mi );
		}
		return i; 
	}
	@NotVisibleInUI
	public int removeById(String tableName,@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) String id) throws Exception {
		String sql = String.format("delete from %s where id=?", tableName);
		int i=0;
		try {
			i = executeUpdate(sql,new Object[] { id});
		} catch (Exception e) {
		    System.out.println(e.getMessage());
		} 
		if(i>0){
			MemoryItem oldItem = getOldMemoryItemFromKeywordsMapping(tableName, id);
			if(null!=oldItem)
				removeMapping(oldItem.getKey());
		}
		return i; 
	}
	public MemoryItem findOneByKeyword(String tableName,String keywords) throws Exception {
		Connection connection = null;
		Statement statement=null;
		ResultSet resultSet=null;
		MemoryItem memoryItem =  new MemoryItem();
		try {
			connection = getConnection(file, this.userName, this.pwd);
			connection.setAutoCommit(false);
			String sql = String.format("select top 1 * from %s where keywords like '%%%s%%'", tableName, keywords);
			statement = connection.createStatement();
			resultSet = statement.executeQuery(sql);
			ResultSetMetaData resultSetMetaData = resultSet.getMetaData();
			int cc = resultSetMetaData.getColumnCount();
			while(resultSet.next()){
				MemoryItemKey memoryItemKey =  new MemoryItemKey();
				memoryItem.setKey(memoryItemKey);
				for(int i=1;i<=cc;i++){
					String cl = resultSetMetaData.getColumnLabel(i);
					Object o = resultSet.getObject(i);
					if(cl.equalsIgnoreCase("id")) {
						memoryItemKey.setId(o.toString());
					}else if(cl.equalsIgnoreCase("keywords")) {
						memoryItemKey.setKeywords(o.toString());
					}else if(cl.equalsIgnoreCase("content")) {
						memoryItem.setContent(o.toString());
					}else if(cl.equalsIgnoreCase("comment")) {
						memoryItem.setComment("");
					}
				}
			}
		} catch (Exception e) {
			e.printStackTrace();
			throw e;
		} finally {
			if(null!=statement){
				statement.close();
			}
			if(null!=connection){
				connection.close();
			}
		}
		if(memoryItem.getKey()==null) {
			throw new Exception("cannot find item by "+keywords);
		}
		return memoryItem;
	}
	public List<MemoryItem> findByKeyword(String tableName,String keywords) throws Exception {
		List<MemoryItem> list = new ArrayList<>();
		Connection connection = null;
		Statement statement=null;
		ResultSet resultSet=null;
		try {
			connection = getConnection(file, this.userName, this.pwd);
			connection.setAutoCommit(false);
			String sql = String.format("select * from %s where keywords like '%%%s%%'", tableName, keywords);
			statement = connection.createStatement();
			resultSet = statement.executeQuery(sql);
			ResultSetMetaData resultSetMetaData = resultSet.getMetaData();
			int cc = resultSetMetaData.getColumnCount();
			while(resultSet.next()){
				MemoryItemKey memoryItemKey =  new MemoryItemKey();
				MemoryItem memoryItem =  new MemoryItem();
				memoryItem.setKey(memoryItemKey);
				for(int i=1;i<=cc;i++){
					String cl = resultSetMetaData.getColumnLabel(i);
					Object o = resultSet.getObject(i);
					if(cl.equalsIgnoreCase("id")) {
						memoryItemKey.setId(o.toString());
					}else if(cl.equalsIgnoreCase("keywords")) {
						memoryItemKey.setKeywords(o.toString());
					}else if(cl.equalsIgnoreCase("content")) {
						memoryItem.setContent(o.toString());
					}else if(cl.equalsIgnoreCase("comment")) {
						memoryItem.setComment("");
					}
				}
				list.add(memoryItem);
			}
		} catch (Exception e) {
			e.printStackTrace();
			throw e;
		} finally {
			if(null!=statement){
				statement.close();
			}
			if(null!=connection){
				connection.close();
			}
		}
		return list;
	}
	public int executeUpdate(String sql, Object... args) throws Exception {
		int i;
		Connection connection = null;
		PreparedStatement statement=null;
		try {
			connection = getConnection(file, this.userName, this.pwd);
			connection.setAutoCommit(false);
			statement = connection.prepareStatement(sql);
			for(int j=1;j<=args.length;j++){
				statement.setString(j, args[j-1].toString());
			}
			i = statement.executeUpdate();
			connection.commit();
		} catch (Exception e) {
			e.printStackTrace();
			throw e;
		} finally {
			if(null!=statement){
				statement.close();
			}
			if(null!=connection){
				connection.close();
			}
		}
		return i;
	}
	public MemoryItem findById(String tableName,String id) throws Exception {
		Connection connection = null;
		Statement statement=null;
		ResultSet resultSet=null;
		MemoryItem memoryItem =  new MemoryItem();
		try {
			connection = getConnection(file, this.userName, this.pwd);
			connection.setAutoCommit(false);
			String sql = String.format("select * from %s where id='%s'", tableName, id);
			statement = connection.createStatement();
			resultSet = statement.executeQuery(sql);
			ResultSetMetaData resultSetMetaData = resultSet.getMetaData();
			int cc = resultSetMetaData.getColumnCount();
			while(resultSet.next()){
				MemoryItemKey memoryItemKey =  new MemoryItemKey();
				memoryItem.setKey(memoryItemKey);
				for(int i=1;i<=cc;i++){
					String cl = resultSetMetaData.getColumnLabel(i);
					Object o = resultSet.getObject(i);
					if(cl.equalsIgnoreCase("id")) {
						memoryItemKey.setId(o.toString());
					}else if(cl.equalsIgnoreCase("keywords")) {
						memoryItemKey.setKeywords(o.toString());
					}else if(cl.equalsIgnoreCase("content")) {
						memoryItem.setContent(o.toString());
					}else if(cl.equalsIgnoreCase("comment")) {
						memoryItem.setComment("");
					}
				}
			}
		} catch (Exception e) {
			e.printStackTrace();
			throw e;
		} finally {
			if(null!=statement){
				statement.close();
			}
			if(null!=connection){
				connection.close();
			}
		}
		if(memoryItem.getKey()==null) {
			throw new Exception("cannot find item by id "+id);
		}
		return memoryItem;
	}
	public List<MemoryItem> findAll(String tableName) throws Exception {
		List<MemoryItem> list = new ArrayList<>();
		Connection connection = null;
		Statement statement=null;
		ResultSet resultSet=null;
		try {
			connection = getConnection(file, this.userName, this.pwd);
			connection.setAutoCommit(false);
			String sql = String.format("select * from %s", tableName);
			statement = connection.createStatement();
			resultSet = statement.executeQuery(sql);
			ResultSetMetaData resultSetMetaData = resultSet.getMetaData();
			int cc = resultSetMetaData.getColumnCount();
			while(resultSet.next()){
				MemoryItemKey memoryItemKey =  new MemoryItemKey();
				MemoryItem memoryItem =  new MemoryItem();
				memoryItem.setKey(memoryItemKey);
				for(int i=1;i<=cc;i++){
					String cl = resultSetMetaData.getColumnLabel(i);
					Object o = resultSet.getObject(i);
					if(cl.equalsIgnoreCase("id")) {
						memoryItemKey.setId(o.toString());
					}else if(cl.equalsIgnoreCase("keywords")) {
						memoryItemKey.setKeywords(o.toString());
					}else if(cl.equalsIgnoreCase("content")) {
						memoryItem.setContent(o.toString());
					}else if(cl.equalsIgnoreCase("comment")) {
						memoryItem.setComment("");
					}
				}
				list.add(memoryItem);
			}
		} catch (Exception e) {
			e.printStackTrace();
			throw e;
		} finally {
			if(null!=statement){
				statement.close();
			}
			if(null!=connection){
				connection.close();
			}
		}
		return list;
	}
	public File getFile() {
		return file;
	}
	public void setFile(File file) {
		this.file = file;
	}
	public String getUserName() {
		return userName;
	}
	public void setUserName(String userName) {
		this.userName = userName;
	}
	public String getPwd() {
		return pwd;
	}
	public void setPwd(String pwd) {
		this.pwd = pwd;
	}
	public List<String> getMemoryAreas() {
		return memoryAreas;
	}
	public static void main(String[] args){
		Connection connection = null;
		Statement statement=null;
		ResultSet resultSet=null;
		try {
			H2JDBCService2 ds = new H2JDBCService2();
			File f = new File("/dickson/h2db/bb");
			ds.testConnection(f, "sa", "");
			ds.loadAllEnabledMemoryAreas();
			ds.loadAllKeywordsMappings();
			List<MemoryItem> list = ds.findByKeyword(ds.CONFIG_TABLE, codegen.Const.BRAIN_LOCAL_REPO_KEYWORD);
			MemoryItem mi = ds.findOneByKeyword(ds.CONFIG_TABLE, codegen.Const.BRAIN_LOCAL_REPO_KEYWORD);
			int r = ds.executeUpdate("update config set keywords=?,content=? where id=?",  mi.getKey().getKeywords(), "test", mi.getKey().getId());
			r = ds.executeUpdate("delete from config where keywords=?",  mi.getKey().getKeywords());
			mi = ds.findOneByKeyword(ds.CONFIG_TABLE, codegen.Const.BRAIN_LOCAL_REPO_KEYWORD);
			ds.removeById(ds.CONFIG_TABLE, mi.getKey().getId());
			statement = connection.createStatement();
			String sql = "select * from commandsyntax";
			resultSet = statement.executeQuery(sql);
			ResultSetMetaData resultSetMetaData = resultSet.getMetaData();
			int cc = resultSetMetaData.getColumnCount();
			while(resultSet.next()){
				for(int i=1;i<=cc;i++){
					Object o = resultSet.getObject(i);
					System.out.println(String.format("column is = %s", o));
				}
			}
			connection.close();
		} catch ( Exception e) {
			e.printStackTrace();
		} finally {
			if(null!=resultSet){
				try {
					resultSet.close();
				} catch (SQLException e) {
					e.printStackTrace();
				}
			}
			if(null!=statement){
				try {
					statement.close();
				} catch (SQLException e) {
					e.printStackTrace();
				}
			}
			if(null!=connection){
				try {
					connection.close();
				} catch (SQLException e) {
					e.printStackTrace();
				}
			}
		}
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\codegen\eclipseRobot\HtmlService.java---
package codegen.eclipseRobot;
public class HtmlService extends EclipseService {
}
----strat of file D:\projects\cg\cg-min\src\main\java\codegen\eclipseRobot\HumanLanKeyword.java---
package codegen.eclipseRobot;
public @interface HumanLanKeyword {
	String[] keywords={};;
}
----strat of file D:\projects\cg\cg-min\src\main\java\codegen\eclipseRobot\MethodDescription.java---
package codegen.eclipseRobot;
public @interface MethodDescription {
	String humanLanWords="";
}
----strat of file D:\projects\cg\cg-min\src\main\java\codegen\eclipseRobot\model\MemoryArea.java---
package codegen.eclipseRobot.model;
import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.List;
public class MemoryArea {
	private String table;
	private boolean disable;
	public MemoryArea(String table, boolean disable) {
		super();
		this.table = table;
		this.disable = disable;
	}
	public String getTable() {
		return table;
	}
	public void setTable(String table) {
		this.table = table;
	}
	public boolean isDisable() {
		return disable;
	}
	public void setDisable(boolean disable) {
		this.disable = disable;
	}
	public static void main(String[] args){
		Gson gson = new Gson();
		List<MemoryArea> list = new ArrayList<>();
		list.add(new MemoryArea("config", false));
		list.add(new MemoryArea("commandsyntax", false));
		list.add(new MemoryArea("miscarea", false));
		list.add(new MemoryArea("codesyntax", false));
		String s = gson.toJson(list);
		Type type = new TypeToken<List<MemoryArea>>(){}.getType();
		List<MemoryArea> list1 = gson.fromJson(s, type);
		System.out.println(s);
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\codegen\eclipseRobot\model\MemoryItem.java---
package codegen.eclipseRobot.model;
public class MemoryItem {
	private MemoryItemKey key;
	private String content;
	private String comment;
	public MemoryItemKey getKey() {
		return key;
	}
	public void setKey(MemoryItemKey key) {
		this.key = key;
	}
	public String getContent() {
		return content;
	}
	public void setContent(String content) {
		this.content = content;
	}
	public String getComment() {
		return comment;
	}
	public void setComment(String comment) {
		this.comment = comment;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\codegen\eclipseRobot\model\MemoryItemKey.java---
package codegen.eclipseRobot.model;
public class MemoryItemKey{
	private String table;
	private String id;
	private String keywords;
	public String getId() {
		return id;
	}
	public void setId(String id) {
		this.id = id;
	}
	public String getKeywords() {
		return keywords;
	}
	public void setKeywords(String keywords) {
		this.keywords = keywords;
	}
	public String getTable() {
		return table;
	}
	public void setTable(String table) {
		this.table = table;
	}
	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + ((id == null) ? 0 : id.hashCode());
		result = prime * result + ((table == null) ? 0 : table.hashCode());
		return result;
	}
	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		MemoryItemKey other = (MemoryItemKey) obj;
		if (id == null) {
			if (other.id != null)
				return false;
		} else if (!id.equals(other.id))
			return false;
		if (table == null) {
			if (other.table != null)
				return false;
		} else if (!table.equals(other.table))
			return false;
		return true;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\codegen\eclipseRobot\MoreReplacement.java---
package codegen.eclipseRobot;
public enum MoreReplacement {
	GROUP_ID, ARTIFACT_ID, ARTIFACT_PACK, ARTIFACT_VERSION,
	WEB_CONTEXT,WEB_PORT
}
----strat of file D:\projects\cg\cg-min\src\main\java\codegen\eclipseRobot\NewClassParam.java---
package codegen.eclipseRobot;
public class NewClassParam {
	private String className;
	private String packName;
	private String superClassName;
	private String interfaceClassName[];
	private Class superClass;
	private Class interfaceClass[];
	public String getClassName() {
		return className;
	}
	public void setClassName(String className) {
		this.className = className;
	}
	public String getPackName() {
		return packName;
	}
	public void setPackName(String packName) {
		this.packName = packName;
	}
	public String getSuperClassName() {
		return superClassName;
	}
	public void setSuperClassName(String superClassName) {
		this.superClassName = superClassName;
	}
	public String[] getInterfaceClassName() {
		return interfaceClassName;
	}
	public void setInterfaceClassName(String... interfaceClassName) {
		this.interfaceClassName = interfaceClassName;
	}
	public Class getSuperClass() {
		return superClass;
	}
	public void setSuperClass(Class superClass) {
		this.superClass = superClass;
	}
	public Class[] getInterfaceClass() {
		return interfaceClass;
	}
	public void setInterfaceClass(Class... interfaceClass) {
		this.interfaceClass = interfaceClass;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\codegen\eclipseRobot\QualifierName.java---
package codegen.eclipseRobot;
import codegen.complexobj.CodeGenContext;
import codegen.util.Common;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;
public class QualifierName {
	public class QualifierPart {
		String qualifierHead;
		String qualifierLastPart;
		public String getQualifierHead() {
			return qualifierHead;
		}
		public void setQualifierHead(String qualifierHead) {
			this.qualifierHead = qualifierHead;
		}
		public String getQualifierLastPart() {
			return qualifierLastPart;
		}
		public void setQualifierLastPart(String qualifierLastPart) {
			this.qualifierLastPart = qualifierLastPart;
		}
	}
	private QualifierPart qp;
	String packName;
	String clzSimpleName;
	public class ClzRelationShip {
		String outSideClzQualifierName;
		InnerClzRelationShip innerClzRelationShip;
	}
	public class InnerClzRelationShip {
		String ClzQualifierName;
		InnerClzRelationShip innerClzRelationShip;
	}
	String origContent;
	String classQualifierName;
	String fieldName;
	String methodName;
	String methodParam[];
	boolean isConstructor;
	String constructParam[];
	Class clz;
	Field field;
	public boolean isInnerClzName(String classQualifierName) {
		boolean isInnerClzName = false;
		return isInnerClzName;
	}
	public boolean isMethodVariable() {
		boolean isMethodVariable = false;
		return isMethodVariable;
	}
	public boolean isField() {
		boolean isField = fieldName != null ? true : false;
		return isField;
	}
	public boolean isClassCastMethod(Method method) {
		boolean b = false;
		return b;
	}
	public static boolean isClassConstructor(QualifierName qn) {
		return isClassConstructor(qn.getClz(), qn.getOrigContent());
	}
	public static boolean isClassConstructor(Class c, String origQualifierName) {
		boolean isConstructor = false;
		if (c == null) {
			return isConstructor;
		}
		if (origQualifierName.trim().startsWith(c.getName() + "." + c.getSimpleName() + "(")
				&& origQualifierName.trim().endsWith(")")) {
			isConstructor = true;
		}
		return isConstructor;
	}
	public static Constructor<?> getConstructorByQualifierName(QualifierName qn) {
		Constructor<?> cc = null;
		if (isClassConstructor(qn)) {
			String origContent = qn.getOrigContent();
			int firstBrace = origContent.indexOf("(");
			int closeBrace = origContent.indexOf(")");
			String paramStr = origContent.substring(firstBrace + 1, closeBrace);
			String pnArray[] = paramStr.split(",", -1);
			Constructor<?> cts[] = qn.getClz().getConstructors();
			for (Constructor<?> ct : cts) {
				Class<?> pt[] = ct.getParameterTypes();
				if (pnArray.length == pt.length) {
					boolean nameMatch = true;
					for (int i = 0; i < pnArray.length; i++) {
						String ptSimpleName = pt[i].getSimpleName();
						String pn = pnArray[i].trim();
						pn = pn.replaceAll("<.+>", "");
						if (!ptSimpleName.equals(pn)) {
							nameMatch = false;
						}
					}
					if (nameMatch) {
						cc = ct;
						break;
					}
				}
			}
		}
		return cc;
	}
	private static boolean isMethodMatch(Method m1, QualifierName qn) {
		Class ps[] = m1.getParameterTypes();
		boolean allMatch = true;
		for (int i = 0; i < ps.length; i++) {
			Class p = ps[i];
			String mps = qn.getMethodParam()[i];
			mps = mps.replaceAll("<.+>", "");
			if (!p.getSimpleName().equals(mps)) {
				allMatch = false;
				break;
			}
		}
		return allMatch;
	}
	public static Method getMethodByQualifierName(QualifierName qn) {
		Method m = null;
		String origContent = qn.getOrigContent();
		if (origContent.contains(".") && origContent.contains("(") && origContent.contains(")")) {
			try {
				Class c = CodeGenContext.getInstance().getReloadableDynamicClassLoaderOwner()
						.loadClass(qn.getClassQualifierName(), true);
				Method ms[] = Common.getAllMethods(c);
				List<Method> list = Arrays.asList(ms);
				List<Method> fl = list.stream().filter(e -> {
					int eParamCount = e.getParameterCount();
					int methodParamCount = qn.getMethodParam() != null ? qn.getMethodParam().length : 0;
					if ("rangeCheck".equals(e.getName())) {
						System.out.print("***");
					}
					if (e.getName().equals(qn.getMethodName()) && eParamCount == methodParamCount) {
						return true;
					} else {
						return false;
					}
				}).collect(Collectors.toList());
				if (fl.size() == 1) {
					m = fl.get(0);
				} else if (fl.size() > 1) {
					List<Method> ml = fl.stream().filter(e -> {
						return isMethodMatch(e, qn);
					}).collect(Collectors.toList());
					if (ml.size() >= 1) {
						m = ml.get(0);
					} else {
						m = fl.get(0);
					}
				}
			} catch (ClassNotFoundException e) {
				e.printStackTrace();
			}
		}
		return m;
	}
	public boolean isFieldQualifier() {
		return classQualifierName != null && fieldName != null ? true : false;
	}
	public boolean isClassQualifier() {
		return classQualifierName != null && methodName == null && fieldName != null ? true : false;
	}
	public boolean isMethodQualifier() {
		return classQualifierName != null && methodName != null ? true : false;
	}
	public String getOrigContent() {
		return origContent;
	}
	public void setOrigContent(String origContent) {
		this.origContent = origContent;
	}
	public String getClassQualifierName() {
		return classQualifierName;
	}
	public void setClassQualifierName(String classQualifierName) {
		this.classQualifierName = classQualifierName;
	}
	public String getFieldName() {
		return fieldName;
	}
	public void setFieldName(String fieldName) {
		this.fieldName = fieldName;
	}
	public Field getField() {
		return field;
	}
	public void setField(Field field) {
		this.field = field;
	}
	public String getMethodName() {
		return methodName;
	}
	public void setMethodName(String methodName) {
		this.methodName = methodName;
	}
	public String[] getMethodParam() {
		return methodParam;
	}
	public void setMethodParam(String[] methodParam) {
		this.methodParam = methodParam;
	}
	public void setConstructor(boolean isConstructor) {
		this.isConstructor = isConstructor;
	}
	public boolean isConstructor() {
		return isConstructor;
	}
	public Class getClz() {
		return clz;
	}
	public void setClz(Class clz) {
		this.clz = clz;
	}
	public QualifierPart getQp() {
		return qp;
	}
	public void setQp(QualifierPart qp) {
		this.qp = qp;
	}
	public String getPackName() {
		return packName;
	}
	public void setPackName(String packName) {
		this.packName = packName;
	}
	public String getClzSimpleName() {
		return clzSimpleName;
	}
	public void setClzSimpleName(String clzSimpleName) {
		this.clzSimpleName = clzSimpleName;
	}
	public String[] getConstructParam() {
		return constructParam;
	}
	public void setConstructParam(String[] constructParam) {
		this.constructParam = constructParam;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\codegen\eclipseRobot\UIContext.java---
package codegen.eclipseRobot;
public class UIContext {
	public static int frameX;
	public static int frameY;
}
----strat of file D:\projects\cg\cg-min\src\main\java\codegen\eclipseRobot\UIController.java---
package codegen.eclipseRobot;
import java.awt.Component;
import java.awt.PointerInfo;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.io.File;
import java.io.IOException;
import java.lang.reflect.Constructor;
import java.lang.reflect.Method;
import java.net.URL;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import javax.swing.JButton;
import javax.swing.JComponent;
import javax.swing.JLabel;
import javax.swing.JTextField;
import javax.swing.SwingUtilities;
import javax.swing.SwingWorker;
import javax.swing.event.HyperlinkEvent;
import codegen.eclipseRobot.*;
import com.dgs.DatabaseService;
import com.dgs.annotation.ServiceMethodAnn;
import com.dgs.jnaforwin32.WindowService;
import clipboardclient.ConcreteClipboardMonitor;
import codegen.Const;
import codegen.complexobj.CodeGenContext;
import codegen.eclipseRobot.model.MemoryItem;
import codegen.eclipseRobot.model.MemoryItemKey;
import codegen.util.ClipBoard;
import codegen.util.Common;
import org.apache.commons.lang3.StringUtils;
import ui.ClassCombBox;
import ui.DefaultParamConverter;
import ui.FilterCombBoxPane;
import ui.GenAnnotationPane;
import ui.GenCodePane;
import ui.MemoryPane;
import ui.MethodTypePane;
import ui.SubmitBtnPane;
import ui.TablePane;
import ui.UI;
import ui.model.UIMemoryItemKey;
public class UIController {
	private EclipseService es;
	private H2JDBCService ds;
	private WindowService ws;
	private UI ui;
	private FilterCombBox filterCombBox;
	private DataModel model;
	static String NEW_METHOD_MATCH_WORD = "newmethod";
	static String NEW_FIELD_MATCH_WORD = "newfield";
	final String needMoveCursor = String.format("(?i)((?:%s)|(?:%s))", NEW_METHOD_MATCH_WORD, NEW_FIELD_MATCH_WORD);
	Pattern p = Pattern.compile(needMoveCursor);
	private ConcreteClipboardMonitor ccm;
	public UIController() {
		super();
		init();
	}
	public void init() {
		EclipseCodeGenContext context = EclipseCodeGenContext.newInstance();
		es = new EclipseService();
		ds = new H2JDBCService();
		ws = new WindowService();
		es.setWindowService(ws);
		es.setH2JDBCService(ds);
		context.setDatabaseService(ds);
		context.setEclipseService(es);
		model = new DataModel();
		CodeGenContext.getInstance().getUiModelMap().put(DataModel.class, model);
		model.setContext(context);
		model.resetMs(EclipseService.class, H2JDBCService.class);
		ui = new UI(model);
		ui.initView();
		filterCombBox = ui.getjComboBox();
		filterCombBox.addActionListener(e -> {
			String typeText = (String) filterCombBox.getSelectedItem();
			if (filterCombBox.isValidSelectedItem(typeText)) {
				onSelectionChanged(typeText);
			}
		});
		model.setSelectedItem(ui.getSeletedItem());
		ui.getEditorPane().addHyperlinkListener((HyperlinkEvent e) -> {
			model.setEventObject(e);
			HyperlinkEvent.EventType type = e.getEventType();
			final URL url = e.getURL();
			if (type == HyperlinkEvent.EventType.ENTERED) {
				System.out.println("URL: " + url);
			} else if (type == HyperlinkEvent.EventType.ACTIVATED) {
				if (url.toString().endsWith("action=clear")) {
					Runnable runner = new Runnable() {
						public void run() {
							ui.getEditorPane().loadWithSetPage();
						}
					};
					SwingUtilities.invokeLater(runner);
				}
				if (url.toString().endsWith("action=reload")) {
					try {
						reload();
					} catch (Exception e1) {
						e1.printStackTrace();
					}
				}
			}
		});
	}
	public void clickSubmitBtn() {
		convert(model);
		BtnClickSwingWorker sw = new BtnClickSwingWorker();
		sw.execute();
	}
	public void convert(DataModel model) {
		List<MethodTypePane> paneList = this.getChildComponent(ui.getTablePane(), MethodTypePane.class);
		if (paneList.size() > 0) {
			MethodTypePane mtp = paneList.get(0);
			DefaultParamConverter dpc = new DefaultParamConverter();
			dpc.convert(model, mtp.getPps(), mtp.getParamComps());
		} else {
		}
	}
	class BtnClickSwingWorker extends SwingWorker {
		@Override
		protected Object doInBackground() throws Exception {
			Object returnObj = callServiceMethod();
			afterServiceCall(model, returnObj);
			return null;
		}
	}
	public void afterServiceCall(DataModel model, Object returnObj) {
		Method m = model.getSelectedMethod();
		if (m == null) {
			return;
		}
		String methodDesc = getMethodDesc(m);
		if (!m.getName().startsWith("switchProcess")) {
			if (returnObj != null && returnObj instanceof String) {
				String str = (String) returnObj;
				boolean b = false;
				do {
					try {
						ClipBoard.setStringUtilSuccess(str);
						b = true;
					} catch (Exception e) {
					}
				} while (!b);
				try {
					b = es.paste();
				} catch (IOException e) {
				}
				if (!b) {
					ui.addRowInHtmlEditorPane("sorry, cannot activate the IDE window, pls do it manually");
				}
			} else if (returnObj != null && returnObj instanceof File) {
				File f = (File) returnObj;
				ui.addRowInHtmlEditorPane(String.format("file %s generated", f.getName()));
			}
		}
		ui.addRowInHtmlEditorPane(String.format("%s execution done", methodDesc));
	}
	public void startClipboardServer(String clientAppPath) {
		ccm = new ConcreteClipboardMonitor();
		ccm.start();
		while (ccm.getPort() == 0) {
			try {
				Thread.sleep(50);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}
		CodeGenContext.getInstance().setClipBoardMonitorServerPort(ccm.getPort());
		System.out.println(String.format("setClipBoardMonitorServerPort with port %s", ccm.getPort()));
	}
	public void start() {
		String dbPath = System.getProperty(codegen.Const.MEMORY_FILE_PATH_NAME);
		if (dbPath != null) {
			File f = new File(dbPath);
			if(!f.exists()) {
			    f = new File(dbPath+".mv.db");
			}
			if (f.isFile()) {
				try {
					System.out.println("going to load brain " + f.getAbsolutePath());
					ds.testConnection(f, "sa", "");
					ds.loadAllEnabledMemoryAreas();
					ds.loadAllKeywordsMappings();
					List<String> areas = ds.loadAllEnabledMemoryAreas();
					CodeGenContext.getMemoryAreas().clear();
					CodeGenContext.getMemoryAreas().addAll(areas);
					CodeGenContext.getInstance().setJreClasses(ds.getJREClzNames());
					this.callUIShow();
					MemoryItem row;
					String WpfAppFile = System.getProperty(codegen.Const.CLIPBOARD_CLIENT_APP_PATH_KEYWORD);
					File appFile = null;
					if (null != WpfAppFile) {
						appFile = new File(WpfAppFile);
					} else {
						if ((row = ds.findOneByKeyword(H2JDBCService.CONFIG_TABLE,
								codegen.Const.CLIPBOARD_CLIENT_APP_PATH_KEYWORD)) != null) {
							String content = row.getContent();
							appFile = new File(content);
						}
					}
					if (null != appFile && appFile.isFile()) {
					} else {
					}
					startClipboardServer(appFile.getAbsolutePath());
					{
						String localRepInSysProp = System.getProperty(codegen.Const.BRAIN_LOCAL_REPO_PROPERTY_KEYWORD);
						String content = null;
						if (null != localRepInSysProp) {
							content = localRepInSysProp;
						} else if ((row = ds.findOneByKeyword(H2JDBCService.CONFIG_TABLE,
								codegen.Const.BRAIN_LOCAL_REPO_KEYWORD)) != null) {
							content = row.getContent();
						}
						if (null != content) {
							File repoFile = new File(content);
							if (repoFile.isDirectory()) {
								System.out.println("setLocalRepoDir as " + repoFile.getAbsolutePath());
								CodeGenContext.setLocalRepoDir(repoFile.getAbsolutePath());
								ui.addRowInHtmlEditorPane(String.format("setLocalRepoDir with %s execution done",
										repoFile.getAbsolutePath()));
							}else{
								ui.addRowInHtmlEditorPane(
										String.format("given local repository path %s is not a directory", content));
							}
						}else{
							ui.addRowInHtmlEditorPane(
									String.format("cannot find %s in config", codegen.Const.BRAIN_LOCAL_REPO_KEYWORD));
						}
					}
					if ((row = ds.findOneByKeyword(H2JDBCService.CONFIG_TABLE,
							codegen.Const.BRAIN_MVN_HOME_KEYWORD)) != null) {
						String content = row.getContent();
						File mvnHome = new File(content);
						if (mvnHome.isDirectory()) {
							System.out.println("setMvnHome as " + mvnHome.getAbsolutePath());
							ui.addRowInHtmlEditorPane(
									String.format("setMvnHome with %s execution done", mvnHome.getAbsolutePath()));
						}
					}else{
						ui.addRowInHtmlEditorPane(
								String.format("cannot find %s in config", codegen.Const.BRAIN_MVN_HOME_KEYWORD));
					}
					if ((row = ds.findOneByKeyword(H2JDBCService.CONFIG_TABLE,
							codegen.Const.BRAIN_LAST_PROJECT_KEYWORD)) != null) {
						String content = row.getContent();
						File pomFile = new File(content);
						if (pomFile.isFile()) {
							System.out.println("last project is " + pomFile.getAbsolutePath());
							es.loadProjDepependcies(pomFile);
							ui.addRowInHtmlEditorPane(
									String.format("loaded last project  %s dependencies execution done", pomFile.getAbsolutePath()));
						}
					}else{
						ui.addRowInHtmlEditorPane(String.format("cannot find %s in config table", codegen.Const.BRAIN_LAST_PROJECT_KEYWORD));
					}
					if ((row = ds.findOneByKeyword(H2JDBCService.CONFIG_TABLE,
							codegen.Const.BRAIN_CG_KEY_APP_KEYWORD)) != null) {
						String content = row.getContent();
						File file = new File(content);
						if (file.isFile()) {
							CodeGenContext.getInstance().setCGKeyAppPath(file.getAbsolutePath());
							ui.addRowInHtmlEditorPane(
									String.format("find cg key app path is  %s, execution done", file.getAbsolutePath()));
						}
					}else{
						ui.addRowInHtmlEditorPane(String.format("cannot find %s in config table", codegen.Const.BRAIN_CG_KEY_APP_KEYWORD));
					}
					if ((row = ds.findOneByKeyword(H2JDBCService.CONFIG_TABLE,
							codegen.Const.BRAIN_IDE_PROC_KEYWORD)) != null) {
						String content = row.getContent();
						if (!StringUtils.isBlank(content)) {
							CodeGenContext.setIDEProcNameKeyword(content);
							ui.addRowInHtmlEditorPane(
									String.format("IDE proc keyword is  %s, execution done", CodeGenContext.getIDEProcNameKeyword()));
						}
					}else{
						ui.addRowInHtmlEditorPane(String.format("cannot find %s in config table", codegen.Const.BRAIN_IDE_PROC_KEYWORD));
					}
				} catch (Exception e) {
					e.printStackTrace();
				}
			}
		}
	}
	public void clearFilterKeyword() {
		model.resetMs(EclipseService.class, H2JDBCService.class);
	}
	public void onSelectionChanged(String selectedItem) {
		if ("".equals(selectedItem)) {
			return;
		}
		model.setSelectedItem(selectedItem);
		this.callUIShow();
	}
	public static List<UIMemoryItemKey> convertMemoryItemKey(List<MemoryItemKey> memoryItemKeyList) {
		List<UIMemoryItemKey> uiMemoryItemKeyList = memoryItemKeyList.stream().map(e -> {
			return new UIMemoryItemKey(e);
		}).collect(Collectors.toList());
		return uiMemoryItemKeyList;
	}
	public void beforeCallUIShow() {
		Method m = model.getSelectedMethod();
		if (m != null) {
			if ("memorizeInTable".equalsIgnoreCase(m.getName())) {
                try {
                    List<String> areas = CodeGenContext.getInstance().getMemoryAreas();
                    Object[] areasArray= areas.toArray(new Object[areas.size()]);
                    model.setParamPossibleVals(areasArray);
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }else if ("showMemory".equalsIgnoreCase(m.getName())) {
                try {
                    CodeGenContext.getInstance().getParamPossibleValsMap().putIfAbsent(Const.MEMORY_AREA_KEY, CodeGenContext.getInstance().getMemoryAreas());
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }else {
			}
		}
	}
	public void callUIShow() {
		beforeCallUIShow();
		ui.show(model);
		afterCallUIShow(model);
	}
	public void afterCallUIShow(DataModel model2) {
		Method m = model.getSelectedMethod();
		if (m == null) {
			return;
		}
		TablePane tablepane = ui.getTablePane();
		List<SubmitBtnPane> submitPanes = this.getSubmitPane(tablepane);
		for (SubmitBtnPane pane : submitPanes) {
			JButton jbt = pane.getSubmitBtn();
			jbt.addKeyListener(new KeyAdapter() {
				public void keyReleased(KeyEvent e) {
					if (e.getKeyChar() == KeyEvent.VK_ENTER) {
						clickSubmitBtn();
					}
				}
			});
			jbt.addMouseListener(new MouseAdapter() {
				@Override
				public void mouseReleased(MouseEvent e) {
					clickSubmitBtn();
				}
			});
		}
		if (null != m && "genFieldDeclare".equalsIgnoreCase(m.getName())) {
			List<ClassCombBox> ccs = this.getChildComponent(tablepane, ClassCombBox.class);
			List<JTextField> jcs = this.getChildComponent(tablepane, JTextField.class);
			ClassCombBox clzCombBox = null;
			JTextField fieldNameComp = null;
			for (JTextField jc : jcs) {
				if ("fieldName".equalsIgnoreCase(jc.getName())) {
					fieldNameComp = jc;
					break;
				}
			}
			for (ClassCombBox cc : ccs) {
				if ("c".equalsIgnoreCase(cc.getName())) {
					clzCombBox = cc;
					break;
				}
			}
			if (null != clzCombBox && null != fieldNameComp) {
				final ClassCombBox fclzCombBox = clzCombBox;
				final JTextField ffieldName = fieldNameComp;
				fclzCombBox.addActionListener(l -> {
					String clzSelected = fclzCombBox.getSelectedItem().toString();
					QualifierName qn = model.extractQualifierName(clzSelected);
					if (null != qn.getClz()) {
						ffieldName.setText(Common.getInstanceName(qn.getClz()));
					}
				});
			}
		}
		List<GenAnnotationPane> genAnnPaneList = this.getChildComponent(tablepane, GenAnnotationPane.class);
		List<GenCodePane> genCodePaneList = this.getChildComponent(tablepane, GenCodePane.class);
		List<FilterCombBoxPane> filterCombboxList = this.getChildComponent(tablepane, FilterCombBoxPane.class);
		List<MemoryPane> memoryPaneList = this.getChildComponent(tablepane, MemoryPane.class);
		boolean isGenAnnPane = genAnnPaneList.size() > 0;
		boolean isGenCodePane = genCodePaneList.size() > 0;
		boolean isMemoryPane = memoryPaneList.size() > 0;
		if (isMemoryPane) {
			for (MemoryPane mp : memoryPaneList) {
			    ClassCombBox tableCcb = (ClassCombBox) mp.getTableCombBoxPane().getInputComponent();
			    tableCcb.addItemListener(l -> {
                    try {
                        String table = (String) tableCcb.getSelectedItem();
                        ClassCombBox keywordCombbox = (ClassCombBox) mp.getKeywordsCombBoxPane().getInputComponent();
                        List<UIMemoryItemKey> keywordsList;
                        if(ds.getTableKeywordsMapping().containsKey(table)) {
                            keywordsList = convertMemoryItemKey(ds.getTableKeywordsMapping().get(table));
                        }else {
                            keywordsList = new ArrayList<>();
                        }
                        keywordCombbox.resetArray(new ArrayList<>());
                        keywordCombbox.removeAllItems();
                        keywordCombbox.addCustomItem(keywordsList.toArray());
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                });
			    ClassCombBox keywordsCombbox = (ClassCombBox) mp.getKeywordsCombBoxPane().getInputComponent();
                final UIMemoryItemKey keywordsCombKey = (UIMemoryItemKey) keywordsCombbox.getSelectedItem();
                if(keywordsCombKey!=null) {
					try {
						MemoryItem item = this.ds.findById(keywordsCombKey.getTable(), keywordsCombKey.getId());
						if (null != item) {
							mp.getContentArea().setText(item.getContent());
							mp.getNewKeyWords().setText(keywordsCombKey.getKeywords());
						}
					} catch (Exception e) {
						e.printStackTrace();
					}
				}
                keywordsCombbox.addItemListener(l -> {
                    try {
                    	Object obj = keywordsCombbox.getSelectedItem();
                    	if(obj!=null && UIMemoryItemKey.class.isAssignableFrom(obj.getClass())) {
							UIMemoryItemKey key = (UIMemoryItemKey) obj;
							if (null != key) {
								MemoryItem item = this.ds.findById(key.getTable(), key.getId());
								if (null != item) {
									mp.getContentArea().setText(item.getContent());
									mp.getNewKeyWords().setText(key.getKeywords());
								}
							}
						}
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                });
                mp.getUpdateJButton().addActionListener(l -> {
                    try {
                        UIMemoryItemKey key = (UIMemoryItemKey) keywordsCombbox.getSelectedItem();
						if (null != key) {
							int i = ds.updateById(key.getTable(), key.getId(), mp.getNewKeyWords().getText(),
									mp.getContentArea().getText());
							if (i > 0) {
								ui.addRowInHtmlEditorPane(String.format("update keywords %s done", mp.getNewKeyWords().getText()));
							}else{
								ui.addRowInHtmlEditorPane(String.format("update keywords %s failed", mp.getNewKeyWords().getText()));
							}
						}
                    } catch (Exception e) {
                        e.printStackTrace();
                        ui.addRowInHtmlEditorPane(String.format("update keywords %s failed due to %s", mp.getNewKeyWords().getText(), e.getMessage()));
                    }
                });
                mp.getDeleteJButton().addActionListener(l -> {
                    UIMemoryItemKey key = (UIMemoryItemKey) keywordsCombbox.getSelectedItem();
					if (null != key) {
						try {
							int i = ds.removeById(key.getTable(), key.getId());
							if (i > 0) {
								ui.addRowInHtmlEditorPane(String.format("keywords %s deletion done", key.getKeywords()));
							} else {
								ui.addRowInHtmlEditorPane(String.format("keywords %s deletion failed", key.getKeywords()));
							}
						} catch (Exception e) {
							e.printStackTrace();
							ui.addRowInHtmlEditorPane(String.format("delete keywords %s failed due to %s", key.getKeywords(), e.getMessage()));
						}
					}
                });
                mp.getDumpJButton().addActionListener(l -> {
                    switch2IDEAndPaste(mp.getContentArea().getText());
                });
			}
		}
		if (!isGenAnnPane && !isGenCodePane) {
			List<JTextField> JTextFieldList = this.getChildComponent(tablepane, JTextField.class);
			if (JTextFieldList.size() > 0) {
				for (JTextField jc : JTextFieldList) {
					jc.addKeyListener(new KeyAdapter() {
						public void keyReleased(KeyEvent e) {
							if (e.getKeyChar() == KeyEvent.VK_ENTER) {
								clickSubmitBtn();
							}
						}
					});
				}
			}
		}
		if (genAnnPaneList.size() > 0) {
			GenAnnotationPane annPane = genAnnPaneList.get(0);
			annPane.getClassCombBox().addActionListener(l -> {
				String clzSelected = annPane.getClassCombBox().getSelectedItem().toString();
				QualifierName qn = model.extractQualifierName(clzSelected);
				if (null != qn.getClz()) {
					model.setSelectedClz(qn.getClz());
					Class<?> c = qn.getClz();
					if (!c.isAnnotation()) {
						return;
					}
					annPane.getTablePane().cleanModelData();
					Method[] ms = c.getDeclaredMethods();
					annPane.getTablePane().newRow();
					for (Method method : ms) {
						JTextField jTextField = new JTextField(5);
						jTextField.setName(method.getName());
						JLabel jLabel = new JLabel(method.getName());
						annPane.getTablePane().addComponent(jLabel, jTextField);
						annPane.getTablePane().newRow();
					}
					annPane.getTablePane().showData();
					annPane.getTablePane().updateUI();
				}
			});
			annPane.getjButton().addActionListener(l -> {
				List<JTextField> allInputs = this.getChildComponent(tablepane, JTextField.class);
				Map<String, String> map = allInputs.stream()
						.collect(Collectors.toMap(e -> e.getName(), e -> e.getText(), (e1, e2) -> {
							return e1;
						}));
				Class<?> c = model.getSelectedClz();
				Method[] ms = c.getDeclaredMethods();
				StringBuilder sb = new StringBuilder();
				sb.append("@").append(c.getSimpleName());
				StringBuilder valsb = new StringBuilder();
				for (Method method : ms) {
					boolean b = map.containsKey(method.getName());
					if (b) {
						Class rt = method.getReturnType();
						String str = getAnnotationMethodReturnTypeVal(rt, map.get(method.getName()));
						if(!Objects.isNull(str) && !str.isEmpty() && !"\"\"".equals(str)){
							valsb.append(method.getName()).append("=").append(str).append(", ");
						}
					}
				}
				if (valsb.length() > 0) {
					sb.append("(");
					valsb.delete(valsb.length() - 2, valsb.length());
					sb.append(valsb.toString());
					sb.append(")");
				}
				switch2IDEAndPaste(sb.toString());
			});
		} else if (genCodePaneList.size() > 0) {
			Map<java.lang.Class, String> types = new HashMap<>();
			for (GenCodePane gcp : genCodePaneList) {
				gcp.getClassCombBox().addActionListener(l -> {
					String clzSelected = gcp.getClassCombBox().getSelectedItem().toString();
					QualifierName qn = model.extractQualifierName(clzSelected);
					if (null != qn.getClz()) {
						model.setSelectedClz(qn.getClz());
						try {
							String[] mstrs = Common.getAllMethodsAndConstructorStr(qn.getClz());
							gcp.getMethodCombBox().resetArray(new ArrayList<>());
							gcp.getMethodCombBox().removeAllItems();
							gcp.getMethodCombBox().addCustomItem(mstrs);
						} catch (Exception e) {
							e.printStackTrace();
						}
					}
				});
				gcp.getGen().addActionListener(l -> {
					String methodSelected = gcp.getMethodCombBox().getSelectedItem().toString().trim();
					if (!"".equals(methodSelected)) {
						Class<?> clz = model.getSelectedClz();
						for (Constructor ct : clz.getConstructors()) {
							if (methodSelected.equalsIgnoreCase(ct.toGenericString())) {
								try {
									String codeLine = es.genConstructorStr(clz, ct, types);
									gcp.getCodeLine().requestFocus();
									boolean b = false;
									do {
										try {
											ClipBoard.setStringUtilSuccess(codeLine);
											b = true;
										} catch (Exception e) {
										}
									} while (!b);
									es.getkRobot().paste();
								} catch (Exception e) {
									e.printStackTrace();
								}
							}
						}
						;
						Optional<Method> smP = Common.getAllMethodList(clz).stream()
								.filter(e -> e.toGenericString().equalsIgnoreCase(methodSelected)).findFirst();
						if (smP.isPresent()) {
							Method sm = smP.get();
							boolean omitReturn = gcp.getOmitReturn().isSelected();
							try {
								String codeLine = es.genCallInstanceMethodStr1(clz, null, sm, omitReturn, types);
								gcp.getCodeLine().requestFocus();
								boolean b = false;
								do {
									try {
										ClipBoard.setStringUtilSuccess(codeLine);
										b = true;
									} catch (Exception e) {
									}
								} while (!b);
								es.getkRobot().paste();
							} catch (Exception e) {
								e.printStackTrace();
							}
						}
					}
				});
				gcp.getDump().addActionListener(l -> {
					if ("".equals(gcp.getCodeLine().getText())) {
						return;
					}
					if (switch2IDEAndPaste(gcp.getCodeLine().getText())) {
						gcp.getCodeLine().setText("");
						types.clear();
					}
				});
			}
		} else {
		}
	}
	private boolean switch2IDEAndPaste(String content) {
		boolean b = false;
		try {
			es.switchProcess();
		} catch (Exception e) {
			e.printStackTrace();
		}
		do {
			try {
				ClipBoard.setStringUtilSuccess(content);
				b = true;
			} catch (Exception e) {
			}
		} while (!b);
		try {
			b =es.paste();
		} catch (IOException e) {
			e.printStackTrace();
		}
		return b;
	}
	private String getAnnotationMethodReturnTypeVal(Class rt, String val) {
		if (rt.equals(String.class)) {
			return "\"" + val + "\"";
		} else {
			return val;
		}
	}
	public void switchProcess() throws Exception {
		es.switchProcess();
	}
	public void reload() throws Exception {
		es.reloadAll();
		ui.addRowInHtmlEditorPane("reload execution done");
	}
	public Object callServiceMethod() throws Exception {
		Method m = this.model.getSelectedMethod();
		Class rt = m.getReturnType();
		boolean isReturnStr = false;
		if (rt.isAssignableFrom(String.class)) {
			isReturnStr = true;
		}
		Class c = m.getDeclaringClass();
		Exception expThrown = null;
		Object object = null;
		if (c.isAssignableFrom(EclipseService.class)) {
			object = es;
		} else if (c.isAssignableFrom(H2JDBCService.class)) {
			object = ds;
		} else {
			try {
				object = c.newInstance();
			} catch (InstantiationException e) {
				e.printStackTrace();
				expThrown = e;
			} catch (IllegalAccessException e) {
				e.printStackTrace();
				expThrown = e;
			}
		}
		Object serviceMethodReturnObj = null;
		if (object != null) {
			String name = m.getName();
			String methodDesc = getMethodDesc(m);
			try {
				if (name.startsWith("gen")) {
					serviceMethodReturnObj = m.invoke(object, this.model.getParams());
					if (!Common.isVoid(m)) {
						es.switchProcess();
						Matcher matcher = p.matcher(name);
						if (matcher.find()) {
							String matchStr = matcher.group();
							if (NEW_METHOD_MATCH_WORD.equalsIgnoreCase(matchStr)) {
							} else if (NEW_FIELD_MATCH_WORD.equalsIgnoreCase(matchStr)) {
							}
						}
					}
				} else {
					System.out.println("switch eclipse begin at " + System.currentTimeMillis());
					es.switchProcess();
					System.out.println("switch eclipse done at " + System.currentTimeMillis());
					serviceMethodReturnObj = m.invoke(object, this.model.getParams());
					System.out.println("invoke method done at " + System.currentTimeMillis());
				}
				if (m.getName().equalsIgnoreCase("attacheServiceClz")) {
					this.model.resetMs(EclipseService.class, DatabaseService.class);
					ui.refeedFilterCombBox();
				}
			} catch (Exception e) {
				e.printStackTrace();
				expThrown = e;
				String msg = null;
				if (e.getCause() != null && e.getCause().getMessage() != null
						&& !"null".equals(e.getCause().getMessage())) {
					msg = e.getCause().getMessage();
					ui.addRowInHtmlEditorPane(String.format("error when %s due to %s", methodDesc, msg));
				} else {
					ui.addRowInHtmlEditorPane(String.format("error when %s", methodDesc));
				}
			}
		} else {
			System.out.println(String.format("cannot get obj for Class %s", c.getCanonicalName()));
		}
		if (null != expThrown) {
			throw expThrown;
		}
		return serviceMethodReturnObj;
	}
	private String getMethodDesc(Method m) {
		String methodDesc = null;
		ServiceMethodAnn annotation = m.getAnnotation(ServiceMethodAnn.class);
		if (annotation == null || !annotation.visible()) {
			methodDesc = m.getName();
		} else {
			methodDesc = annotation.keyword()[0];
		}
		return methodDesc;
	}
	public void getAllChildComponents(JComponent container, List<JComponent> list) {
		Component componentArray[] = container.getComponents();
		List<JComponent> childList = Stream.of(componentArray).filter(e -> {
			if (e instanceof JComponent) {
				return true;
			}
			return false;
		}).map(e -> (JComponent) e).collect(Collectors.toList());
		list.addAll(childList);
		for (JComponent jComponent : childList) {
			getAllChildComponents(jComponent, list);
		}
	}
	public <T extends JComponent> List<T> getChildComponent(JComponent container, Class<T> componentType) {
		List<JComponent> list = new ArrayList<>();
		getAllChildComponents(container, list);
		List<T> list2 = list.stream().filter(e -> {
			Class c = e.getClass();
			if (componentType.isAssignableFrom(c)) {
				return true;
			}
			return false;
		}).map(e -> (T) e).collect(Collectors.toList());
		return list2;
	}
	public List<SubmitBtnPane> getSubmitPane(JComponent container) {
		List<SubmitBtnPane> panes = new ArrayList<>();
		List<JComponent> allComponents = this.getChildComponent(container, JComponent.class);
		for (JComponent comp : allComponents) {
			Class c = comp.getClass();
			if (SubmitBtnPane.class.isAssignableFrom(c)) {
				panes.add((SubmitBtnPane) comp);
			}
		}
		return panes;
	}
	public DataModel getModel() {
		return model;
	}
	public void setModel(DataModel model) {
		this.model = model;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\codegen\JavaKeyword.java---
/**
 * 
 */
package codegen;
/**
 * @author Administrator
 *
 */
public enum JavaKeyword {
	FOR("for"),WHILE("while"),GOTO("goto"),DO("do"),PUBLIC("public"),PRIVATE("private"),PROTECTED("protected"),STATIC("static"),FINAL("final"),SYNCHRONIZED("synchronized"),CLASS("class"),INT("int"),LONG("long"),BOOLEAN("boolean"),DOUBLE("double"),FLOAT("float"),NULL("null"),INSTANCEOF("instanceof"),IF("if"),ELSE("else"),ENUM("enum"),INTERFACE("interface");
	String value;
	private JavaKeyword(String value){
		this.value = value;
	}
	public String getValue() {
		return value;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\codegen\MethodCallParamVariableCode.java---
package codegen;
public class MethodCallParamVariableCode {
	String paramVariableDeclareWithDefaultVal;
	String[] paramvariables;
	public String getParamVariableDeclareWithDefaultVal() {
		return paramVariableDeclareWithDefaultVal;
	}
	public void setParamVariableDeclareWithDefaultVal(String paramVariableDeclareWithDefaultVal) {
		this.paramVariableDeclareWithDefaultVal = paramVariableDeclareWithDefaultVal;
	}
	public String[] getParamvariables() {
		return paramvariables;
	}
	public void setParamvariables(String[] paramvariables) {
		this.paramvariables = paramvariables;
	}
	public MethodCallParamVariableCode(String paramVariableDeclareWithDefaultVal, String[] paramvariables) {
		super();
		this.paramVariableDeclareWithDefaultVal = paramVariableDeclareWithDefaultVal;
		this.paramvariables = paramvariables;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\codegen\MethodMatcher.java---
package codegen;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.List;
public class MethodMatcher {
	private Class c;
	private String methodName;
	private Class classParams[];
	private List<MethodMatcher> miList = new ArrayList<>();
	public MethodMatcher(Class c) {
		super();
		this.c = c;
	}
	public MethodMatcher add(String methodName, Class... cp) {
		MethodMatcher mi = new MethodMatcher(c);
		mi.setMethodName(methodName);
		mi.setClassParams(cp);
		miList.add(mi);
		return this;
	}
	public String getMethodName() {
		return methodName;
	}
	public void setMethodName(String methodName) {
		this.methodName = methodName;
	}
	public Class getC() {
		return c;
	}
	public Class[] getClassParams() {
		return classParams;
	}
	public void setClassParams(Class[] classParams) {
		this.classParams = classParams;
	}
	public List<MethodMatcher> getMiList() {
		return miList;
	}
	public void setMiList(List<MethodMatcher> miList) {
		this.miList = miList;
	}
	public boolean match(Method m) {
		Class mC = m.getDeclaringClass();
		boolean b = false;
		if (!mC.equals(this.c)) {
			return b;
		}
		Class mp[] = m.getParameterTypes();
		if (m.getName().equals(this.methodName)) {
			if (m.getParameterCount() == 0 && (this.classParams == null || this.classParams.length == 0)) {
				return true;
			}
			if (m.getParameterCount() > 0) {
				if (this.classParams != null && this.classParams.length == mp.length) {
					for (int i = 0; i < mp.length; i++) {
						if (!mp[i].equals(this.classParams[i])) {
							i = mp.length;
						} else if (i == mp.length - 1) {
							b = true;
						}
					}
				}
			}
		}
		return b;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\codegen\Replacement.java---
package codegen;
public enum Replacement {
	PACKAGE_NAME, CLASS_NAME, INSTANCE_NAME, SEPERATOR, GENERIC_TYPE_NAME, GENERIC_TYPE_KEY, GENERIC_TYPE_VAL,
	ABSTRACT_CLASS_NAME, ABSTRACT_INSTANCE_NAME, TMP_CLASS_NAME, TMP_INSTANCE_NAME, TMP_INSTANCE_VALUE, ITEM_NAME,
	TARGET_CLASS_NAME, TARGET_INSTANCE_NAME, INIT_CLASS_WITH_DEFAULT_VALUE, DEFAULT_VALUE,
	ASSIGN_SYMBOL, NEW_LINE, END_OF_LINE, CLASS_END_LINE, FIELD_CLASS_NAME, FIELD_INSTANCE_NAME, FIELD_VALUE, QUALIFIER,
	METHOD_NAME, METHOD_RETURN_TYPE, METHOD_PARAMS, METHOD_PARAMS_VARIABLE, MATCH_PARAMS_VARIABLE,
	PRIVILEDGE_MODIFIER, STATIC_MODIFIER, ABSTRACT_MODIFIER, FINAL_MODIFIER, VOLATILE_MODIFIER, SYNC_MODIFIER, METHOD_PARAMS_DECLARE,
	METHOD_BODY, METHOD_RETURN_VALUE,
	LAMBDA_PARAMS_VARIABLE,
	THROWS_EXCEPTION, TRY_BODY, EXCEPTIONS_DECLARE, EXCEPTION_NAME, EXCEPTION_INSTANCE_NAME, CATCH_BODY, FINALLY_BODY,
	ANY_MATCH, RETURN_TYPE, RETURN_TYPE_INSTANCE,
	ASSERT_NOT_NULL, EXPECT_VALUE, ACTUAL_VALUE,
	EXCEPTION_CLASS, PREFIX_STR, IF_EXPRESSION, ELSE_BLOCK, IF_BODY, ELSE_BODY,
	BLOCK_BODY,
	CORE_POOL_SIZE, MAX_POOL_SIZE, NEW_THREAD_FACTORY,
	PATH, METHOD_STR, HEADERS, CONSUMERS, PRODUCES, RESPONSE_BODY,
	TAG_NAME,ID,LINK,TARGET, REQUEST_METHOD, 
	GROUP_ID, ARTIFACTOR_ID, VERSION, SCOPE,
}
----strat of file D:\projects\cg\cg-min\src\main\java\codegen\robot\KeyboardRobot.java---
package codegen.robot;
import java.awt.*;
import java.awt.event.KeyEvent;
import java.io.IOException;
public class KeyboardRobot {
	public static short asciiKeyEventCodeMapping[][][] = new short[][][] { { { 0, 0, 0 }, { 1, 0, 0 }, { 2, 0, 0 },
			{ 3, 0, 0 }, { 4, 0, 0 }, { 5, 0, 0 }, { 6, 0, 0 }, { 7, 0, 0 }, { 8, KeyEvent.VK_BACK_SPACE, 0 },
			{ 9, 0, 0 }, { 10, KeyEvent.VK_ENTER, 0 }, { 11, 0, 0 }, { 12, 0, 0 }, { 13, KeyEvent.VK_ENTER, 0 },
			{ 14, 0, 0 }, { 15, 0, 0 }, { 16, 0, 0 }, { 17, 0, 0 }, { 18, 0, 0 }, { 19, 0, 0 }, { 20, 0, 0 },
			{ 21, 0, 0 }, { 22, 0, 0 }, { 23, 0, 0 }, { 24, 0, 0 }, { 25, 0, 0 }, { 26, 0, 0 }, { 27, 0, 0 },
			{ 28, 0, 0 }, { 29, 0, 0 }, { 30, 0, 0 }, { 31, 0, 0 }, { 32, KeyEvent.VK_SPACE, 0 },
			{ 33, KeyEvent.VK_1, 1 }, { 34, KeyEvent.VK_QUOTE, 1 }, { 35, KeyEvent.VK_3, 1 }, { 36, KeyEvent.VK_4, 1 },
			{ 37, KeyEvent.VK_5, 1 }, { 38, KeyEvent.VK_7, 1 }, { 39, KeyEvent.VK_QUOTE, 0 }, { 40, KeyEvent.VK_9, 1 },
			{ 41, KeyEvent.VK_0, 1 }, { 42, KeyEvent.VK_8, 1 }, { 43, KeyEvent.VK_EQUALS, 1 },
			{ 44, KeyEvent.VK_COMMA, 0 }, { 45, KeyEvent.VK_MINUS, 0 }, { 46, KeyEvent.VK_PERIOD, 0 },
			{ 47, KeyEvent.VK_SLASH, 0 }, { 48, KeyEvent.VK_0, 0 }, { 49, KeyEvent.VK_1, 0 }, { 50, KeyEvent.VK_2, 0 },
			{ 51, KeyEvent.VK_3, 0 }, { 52, KeyEvent.VK_4, 0 }, { 53, KeyEvent.VK_5, 0 }, { 54, KeyEvent.VK_6, 0 },
			{ 55, KeyEvent.VK_7, 0 }, { 56, KeyEvent.VK_8, 0 }, { 57, KeyEvent.VK_9, 0 },
			{ 58, KeyEvent.VK_SEMICOLON, 1 }, { 59, KeyEvent.VK_SEMICOLON, 0 }, { 60, KeyEvent.VK_COMMA, 1 },
			{ 61, KeyEvent.VK_EQUALS, 0 }, { 62, KeyEvent.VK_PERIOD, 1 }, { 63, KeyEvent.VK_SLASH, 1 },
			{ 64, KeyEvent.VK_2, 1 }, { 65, KeyEvent.VK_A, 1 }, { 66, KeyEvent.VK_B, 1 }, { 67, KeyEvent.VK_C, 1 },
			{ 68, KeyEvent.VK_D, 1 }, { 69, KeyEvent.VK_E, 1 }, { 70, KeyEvent.VK_F, 1 }, { 71, KeyEvent.VK_G, 1 },
			{ 72, KeyEvent.VK_H, 1 }, { 73, KeyEvent.VK_I, 1 }, { 74, KeyEvent.VK_J, 1 }, { 75, KeyEvent.VK_K, 1 },
			{ 76, KeyEvent.VK_L, 1 }, { 77, KeyEvent.VK_M, 1 }, { 78, KeyEvent.VK_N, 1 }, { 79, KeyEvent.VK_O, 1 },
			{ 80, KeyEvent.VK_P, 1 }, { 81, KeyEvent.VK_Q, 1 }, { 82, KeyEvent.VK_R, 1 }, { 83, KeyEvent.VK_S, 1 },
			{ 84, KeyEvent.VK_T, 1 }, { 85, KeyEvent.VK_U, 1 }, { 86, KeyEvent.VK_V, 1 }, { 87, KeyEvent.VK_W, 1 },
			{ 88, KeyEvent.VK_X, 1 }, { 89, KeyEvent.VK_Y, 1 }, { 90, KeyEvent.VK_Z, 1 },
			{ 91, KeyEvent.VK_OPEN_BRACKET, 0 }, { 92, KeyEvent.VK_BACK_SLASH, 0 },
			{ 93, KeyEvent.VK_CLOSE_BRACKET, 0 }, { 94, KeyEvent.VK_6, 1 }, { 95, KeyEvent.VK_MINUS, 1 },
			{ 96, KeyEvent.VK_BACK_QUOTE, 0 }, { 97, KeyEvent.VK_A, 0 }, { 98, KeyEvent.VK_B, 0 },
			{ 99, KeyEvent.VK_C, 0 }, { 100, KeyEvent.VK_D, 0 }, { 101, KeyEvent.VK_E, 0 }, { 102, KeyEvent.VK_F, 0 },
			{ 103, KeyEvent.VK_G, 0 }, { 104, KeyEvent.VK_H, 0 }, { 105, KeyEvent.VK_I, 0 }, { 106, KeyEvent.VK_J, 0 },
			{ 107, KeyEvent.VK_K, 0 }, { 108, KeyEvent.VK_L, 0 }, { 109, KeyEvent.VK_M, 0 }, { 110, KeyEvent.VK_N, 0 },
			{ 111, KeyEvent.VK_O, 0 }, { 112, KeyEvent.VK_P, 0 }, { 113, KeyEvent.VK_Q, 0 }, { 114, KeyEvent.VK_R, 0 },
			{ 115, KeyEvent.VK_S, 0 }, { 116, KeyEvent.VK_T, 0 }, { 117, KeyEvent.VK_U, 0 }, { 118, KeyEvent.VK_V, 0 },
			{ 119, KeyEvent.VK_W, 0 }, { 120, KeyEvent.VK_X, 0 }, { 121, KeyEvent.VK_Y, 0 }, { 122, KeyEvent.VK_Z, 0 },
			{ 123, KeyEvent.VK_OPEN_BRACKET, 1 }, { 124, KeyEvent.VK_BACK_SLASH, 1 },
			{ 125, KeyEvent.VK_CLOSE_BRACKET, 1 }, { 126, KeyEvent.VK_BACK_QUOTE, 1 },
			{ 127, KeyEvent.VK_DELETE, 0 }, } };
	Robot robot;
	public KeyboardRobot() {
		try {
			robot = new Robot();
		} catch (AWTException e) {
			e.printStackTrace();
		}
	}
	public KeyboardRobot(Robot robot) {
		this.robot = robot;
	}
	public Robot getRobot() {
		return robot;
	}
	public void openApp(String appName) {
		try {
			Runtime.getRuntime().exec(appName);
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
	public void typeLetter(char c) {
		if (Character.isLetter(c)) {
		}
	}
	public void typeStr(String str) {
		char ch[] = str.toCharArray();
		for (char c : ch) {
			typeLetterOrDigit(c);
		}
	}
	/**
	 * enter event may click on UI not in eclipse window
	 */
	public void enter() {
		robot.keyPress(KeyEvent.VK_ENTER);
		robot.keyRelease(KeyEvent.VK_ENTER);
	}
	public void copy() {
		robot.keyPress(KeyEvent.VK_CONTROL);
		robot.keyPress(KeyEvent.VK_C);
		robot.delay(500);
		robot.keyRelease(KeyEvent.VK_CONTROL);
		robot.keyRelease(KeyEvent.VK_C);
	}
	public void paste() {
		robot.keyPress(KeyEvent.VK_CONTROL);
		robot.keyPress(KeyEvent.VK_V);
		robot.delay(500);
		robot.keyRelease(KeyEvent.VK_CONTROL);
		robot.keyRelease(KeyEvent.VK_V);
	}
	public void del() {
		typeLetterOrDigit((char) 127);
	}
	public void typeLetterOrDigit(char c) {
		short keyEventcode = asciiKeyEventCodeMapping[0][c][1];
		short shiftFlag = asciiKeyEventCodeMapping[0][c][2];
		boolean shift = toBoolean(shiftFlag);
		if (shift) {
			robot.keyPress(KeyEvent.VK_SHIFT);
		}
		robot.keyPress(keyEventcode);
		robot.keyRelease(keyEventcode);
		if (shift) {
			robot.keyRelease(KeyEvent.VK_SHIFT);
		}
		if (c == 34 || c == 39 || c == 40) {
			del();
		}
	}
	public void clickKey(int key) {
		robot.keyPress(key);
		robot.keyRelease(key);
	}
	public void pageUp() {
		clickKey(KeyEvent.VK_PAGE_UP);
	}
	public void pageDown() {
		clickKey(KeyEvent.VK_PAGE_DOWN);
	}
	public void home() {
		clickKey(KeyEvent.VK_HOME);
	}
	public void end() {
		clickKey(KeyEvent.VK_END);
	}
	public void arrowUp() {
		this.clickKey(KeyEvent.VK_UP);
	}
	public void arrowUp(int times) {
		for (int i = 0; i < times; i++)
			this.clickKey(KeyEvent.VK_UP);
	}
	public void arrowleft() {
		clickKey(KeyEvent.VK_LEFT);
	}
	public void arrowDown() {
		clickKey(KeyEvent.VK_DOWN);
	}
	public void arrowDown(int times) {
		for (int i = 0; i < times; i++)
			clickKey(KeyEvent.VK_DOWN);
	}
	public void tab() {
		clickKey(KeyEvent.VK_TAB);
	}
	public void space() {
		clickKey(KeyEvent.VK_SPACE);
	}
	public void tab(int times) {
		for (int i = 0; i < times; i++)
			clickKey(KeyEvent.VK_TAB);
	}
	public void backSace() {
		clickKey(KeyEvent.VK_BACK_SPACE);
	}
	public void backSace(int times) {
		for (int i = 0; i < times; i++)
			clickKey(KeyEvent.VK_BACK_SPACE);
	}
	public void altTab() {
		this.clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_TAB);
	}
	public void arrowRight() {
		clickKey(KeyEvent.VK_RIGHT);
	}
	public static boolean toBoolean(int s) {
		boolean b = false;
		b = s <= 0 ? false : true;
		return b;
	}
	public void copyLine() {
		Toolkit.getDefaultToolkit().setLockingKeyState(144, false);
		this.home();
		robot.keyPress(KeyEvent.VK_SHIFT);
		robot.delay(1000);
		this.end();
		robot.delay(1000);
		robot.keyRelease(KeyEvent.VK_SHIFT);
		this.copy();
	}
	public void clickCompositeKey(int... keycodes) {
		for (int k : keycodes) {
			robot.keyPress(k);
		}
		robot.delay(500);
		for (int i = keycodes.length - 1; i >= 0; i--) {
			robot.keyRelease(keycodes[i]);
		}
	}
	public void selectAll() {
		this.clickCompositeKey(KeyEvent.VK_CONTROL, KeyEvent.VK_A);
	}
	public static void main(String[] args) throws AWTException {
		Robot robot = new Robot();
		/*
		 * Dimension d= Toolkit.getDefaultToolkit().getScreenSize(); double width =
		 * d.getWidth(); double height = d.getHeight();
		 * System.out.println(String.format("width = %s, height = %s", width, height));
		 * for(int y = 0; y<height;y++){ for(int x = 0; x<width;x++){ robot.mouseMove(x,
		 * y); System.out.println("x =" +
		 * MouseInfo.getPointerInfo().getLocation().getX() + " Y = " +
		 * MouseInfo.getPointerInfo().getLocation().getY()); } }
		 */
		try {
			Thread.sleep(1500L);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		KeyboardRobot kr = new KeyboardRobot();
		kr.typeStr("pool.setOddsType(\"\");\r\npool.setAllupLevelKey(1);");
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\codegen\robot\MouseRobot.java---
package codegen.robot;
import java.awt.*;
import java.awt.event.InputEvent;
import java.awt.image.BufferedImage;
public class MouseRobot {
	Robot robot;
	public MouseRobot() {
		try {
			robot = new Robot();
		} catch (AWTException e) {
			e.printStackTrace();
		}
	}
	public MouseRobot(Robot robot) {
		this.robot = robot;
	}
	public Robot getRobot() {
		return robot;
	}
	public void delay(int ms) {
		robot.delay(ms);
	}
	public void mouseMove(int x, int y) {
		robot.mouseMove(x, y);
	}
	public void mouseMoveDown(int y) {
		int x = (int) MouseInfo.getPointerInfo().getLocation().getX();
		this.mouseMove(x, y);
	}
	public void moveRight(int offsetX) {
		int x = (int) MouseInfo.getPointerInfo().getLocation().getX();
		int y = (int) MouseInfo.getPointerInfo().getLocation().getY();
		x = x + offsetX;
		this.mouseMove(x, y);
	}
	public void mouseClickThreeTimes(int x, int y) {
		mouseClick(x, y);
		mouseClick(x, y);
		mouseClick(x, y);
	}
	public void mouseDoubleClick(int x, int y) {
		mouseClick(x, y);
		mouseClick(x, y);
	}
	public void mouseDoubleClick() {
		mouseClick();
		mouseClick();
	}
	public void mousePress() {
		robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);
	}
	public void mouseRelease() {
		robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);
	}
	public void dragTo(int offsetX) {
		this.mousePress();
		int x = (int) MouseInfo.getPointerInfo().getLocation().getX();
		int y = (int) MouseInfo.getPointerInfo().getLocation().getY();
		x = x + offsetX;
		this.mouseMove(x, y);
		this.mouseRelease();
	}
	@Deprecated
	/**
	 * mouse click event may click on UI not in eclipse window
	 */
	public void mouseClick() {
		robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);
		robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);
	}
	public void mouseClick(int x, int y) {
		robot.mouseMove(x, y);
		robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);
		robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);
	}
	public void mouseRightClick(int x, int y) {
		robot.mouseMove(x, y);
		robot.mousePress(InputEvent.BUTTON3_DOWN_MASK);
		robot.mouseRelease(InputEvent.BUTTON3_DOWN_MASK);
	}
	public void clickBtnByRsName(String rsName) throws Exception {
		try {
			BufferedImage image = Resource.getBufferedImageByRsName(rsName);
			clickBtn(image);
		} catch (Exception e) {
			throw new Exception(String.format("failed click with the specified rs name %s", rsName), e);
		}
	}
	public void clickBtn(BufferedImage btnImg) throws Exception {
		Dimension d = Toolkit.getDefaultToolkit().getScreenSize();
		double width = d.getWidth();
		double height = d.getHeight();
		Rectangle rect = new Rectangle((int) width, (int) height);
		BufferedImage img = robot.createScreenCapture(rect);
		PixelMatchResult mr = seek(btnImg, img);
		if (mr != null) {
			this.mouseClick(mr.getCenterPixel().getX(), mr.getCenterPixel().getY());
		} else {
			throw new Exception("cannot find the specified image on screen");
		}
	}
	public int[][] getPixels(BufferedImage img) {
		int w = img.getWidth();
		int h = img.getHeight();
		int[][] ps = new int[w][h];
		for (int i = 0; i < w; i++) {
			for (int j = 0; j < h; j++) {
				int pixel = img.getRGB(i, j);
				ps[i][j] = pixel;
			}
		}
		return ps;
	}
	public PixelMatchResult trySeek(int[][] rsPixels, int offsetX, int offsetY, BufferedImage screenCapture) {
		PixelMatchResult mr = null;
		int w = screenCapture.getWidth();
		int h = screenCapture.getHeight();
		int rw = rsPixels.length;
		int rh = rsPixels[0].length;
		int totalPixelMatched = 0;
		for (int j = 0; j < rh; j++) {
			for (int i = 0; i < rw; i++) {
				int rsPixel = rsPixels[i][j];
				int x = i + offsetX;
				int y = j + offsetY;
				if (x >= w || y >= h) {
					return null;
				}
				int pixel = screenCapture.getRGB(x, y);
				if (pixel == rsPixel) {
					totalPixelMatched++;
				} else {
					return null;
				}
			}
		}
		if (totalPixelMatched == rw * rh) {
			mr = new PixelMatchResult();
			int centerPixelX = rw / 2 + offsetX;
			int centerPixelY = rh / 2 + offsetY;
			Pixel p = new Pixel(centerPixelX, centerPixelY);
			mr.setCenterPixel(p);
			Pixel startPixel = new Pixel(offsetX, offsetY);
			mr.setStartPixel(startPixel);
			mr.setMatch(true);
		}
		return mr;
	}
	public PixelMatchResult seek(BufferedImage rsImg, BufferedImage screenCapture) {
		PixelMatchResult mr = null;
		int offsetX = 0;
		int offsetY = 0;
		int w = screenCapture.getWidth();
		int h = screenCapture.getHeight();
		int rsPs[][] = getPixels(rsImg);
		for (int j = 0; j < h; j++) {
			for (int i = 0; i < w; i++) {
				int pixel = screenCapture.getRGB(i, j);
				/*
				 * if(totalPixelMatched >0){ int x = i - offsetX; int y = j - offsetY; if(pixel
				 * == rsPs[x][y]){ totalPixelMatched++; if(totalPixelMatched == totalRsPixels){
				 * //matched mr = new PixelMatchResult(); int centerPixelX = rsImg.getWidth()/2
				 * + offsetX; int centerPixelY = rsImg.getHeight()/2 + offsetY; Pixel p = new
				 * Pixel(centerPixelX, centerPixelY); mr.setCenterPixel(p); mr.setMatch(true);
				 * return mr; } }else{ totalPixelMatched = 0; offsetX = 0; offsetY = 0; } }
				 */
				if (pixel == rsPs[0][0]) {
					offsetX = i;
					offsetY = j;
					mr = trySeek(rsPs, offsetX, offsetY, screenCapture);
					if (mr != null) {
						return mr;
					}
				}
			}
		}
		return mr;
	}
	public void trimImg(BufferedImage img) {
	}
	public void breakAlphaAndRGB(int pixel) {
		long alpha = ((long) pixel & (255L << 24)) >> 24;
		int red = (pixel & (255 << 16)) >> 16;
		int green = (pixel & (255 << 8)) >> 8;
		int blue = pixel & (255);
		System.out.println(String.format("alpha is %s, red is %s, green is %s, blue is %s ", alpha, red, green, blue));
	}
	public static void main(String[] args) {
		MouseRobot mr = new MouseRobot();
		try {
			Thread.sleep(3000);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		for (int i = 0; i <= 999999; i++) {
			mr.mouseClick();
			try {
				Thread.sleep(100);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}
		/*
		 * try { // BufferedImage projImg = Resource.getResource(new //
		 * File("d:\\eclipse packexploer font.png")); BufferedImage javaImg =
		 * Resource.getResource(new File("d:\\servers.png")); int javaImgPx[][] =
		 * mr.getPixels(javaImg); // int projImgPx[][] = mr.getPixels(projImg); //
		 * int firstJavaPx = javaImgPx[0][0]; int[][] ps = mr.getPixels(javaImg); //
		 * int firstProjPx = projImgPx[0][0]; int rw = ps.length; int rh =
		 * ps[0].length; for (int i = 0; i < rw; i++) { for (int j = 0; j < rh; j++) {
		 * System.out.print(String.format("i=%s,j=%s,dec=%s ", i, j, ps[i][j]));
		 * mr.breakAlphaAndRGB(ps[i][j]); } } // mr.breakAlphaAndRGB(firstProjPx); //
		 * mr.seek(javaImg, projImg); } catch (IOException e) { // TODO Auto-generated
		 * catch block e.printStackTrace(); }
		 */
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\codegen\robot\Pixel.java---
package codegen.robot;
public class Pixel {
	private int x;
	private int y;
	private int value;
	public Pixel(int x, int y) {
		super();
		this.x = x;
		this.y = y;
	}
	public int getX() {
		return x;
	}
	public void setX(int x) {
		this.x = x;
	}
	public int getY() {
		return y;
	}
	public void setY(int y) {
		this.y = y;
	}
	public int getValue() {
		return value;
	}
	public void setValue(int value) {
		this.value = value;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\codegen\robot\PixelMatchResult.java---
package codegen.robot;
public class PixelMatchResult {
	Pixel centerPixel;
	Pixel startPixel;
	boolean match;
	double percentage;
	public Pixel getCenterPixel() {
		return centerPixel;
	}
	public void setCenterPixel(Pixel centerPixel) {
		this.centerPixel = centerPixel;
	}
	public Pixel getStartPixel() {
		return startPixel;
	}
	public void setStartPixel(Pixel startPixel) {
		this.startPixel = startPixel;
	}
	public boolean isMatch() {
		return match;
	}
	public void setMatch(boolean match) {
		this.match = match;
	}
	public double getPercentage() {
		return percentage;
	}
	public void setPercentage(double percentage) {
		this.percentage = percentage;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\codegen\robot\Resource.java---
package codegen.robot;
import javax.imageio.ImageIO;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.IOException;
import java.net.URL;
public class Resource {
	public static BufferedImage getResource(File file) throws IOException {
		BufferedImage image = ImageIO.read(file);
		return image;
	}
	public static BufferedImage getResource(URL url) throws IOException {
		BufferedImage image = ImageIO.read(url);
		return image;
	}
	public static BufferedImage getBufferedImageByRsName(String rsName) throws IOException{
		BufferedImage image = null;
	    try{
		URL url = Resource.class.getClassLoader().getResource(rsName);
	    image = getResource(url);
	    } catch(IOException e){
	    	e.printStackTrace();
	    	throw e;
	    }
		return image;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\codegen\robot\Service.java---
package codegen.robot;
import codegen.complexobj.CodeGenContext;
import codegen.unittest.*;
import codegen.util.Common;
import com.dgs.annotation.FileChooserAnnotation;
import com.dgs.annotation.ParamAnno;
import com.dgs.annotation.ServiceMethodAnn;
import java.awt.*;
import java.awt.datatransfer.Clipboard;
import java.awt.image.BufferedImage;
import java.io.*;
import java.net.URL;
import java.nio.charset.Charset;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;
import java.util.stream.Stream;
public class Service {
	UnitTestCodeGeneratorDependOnClass u;
	MockClzFactoryGenerator i;
	private MouseRobot mRobot;
	private KeyboardRobot kRobot;
	public Service() {
		try {
			Robot r = new Robot();
			mRobot = new MouseRobot(r);
			kRobot = new KeyboardRobot(r);
		} catch (AWTException e) {
			e.printStackTrace();
		}
	}
	@ServiceMethodAnn(keyword = "set system property")
	public void addSystemProperty(String propertyName, String propertyValue) {
		System.setProperty(propertyName, propertyValue);
		if (codegen.Const.OUTPUT_SYS_PROPERTY_NAME.equals(propertyName)) {
			File f = new File(propertyValue);
			if (propertyValue != null && f.isFile()) {
				FileOutputStream fileOutputStream;
				try {
					fileOutputStream = new FileOutputStream(f);
					BufferedOutputStream bufferedOutputStream = new BufferedOutputStream(fileOutputStream);
					PrintStream printStream = new PrintStream(bufferedOutputStream, true);
					System.setOut(printStream);
					System.setErr(printStream);
				} catch (FileNotFoundException e) {
					e.printStackTrace();
				}
			}
		}
	}
	@ServiceMethodAnn(keyword = "install maven jar in local repository")
	public String genMvnInstallForJar(@ParamAnno(description = "Jar File") File jarFile, String groupId, String artifactId, String version, String pack) {
		String cmd = String.format("mvn install:install-file -Dfile=%s -DgroupId=%s -DartifactId=%s -Dversion=%s -Dpackaging=%s >deploy.log", 
				jarFile.getAbsolutePath(), groupId, artifactId, version,  pack);
		return cmd;
	}
	@ServiceMethodAnn(keyword = "gen all test classes at same package")
	public void genAllTestClssesByPackage(@ParamAnno(description = "One of Class") Class oneOfClass, 
			@FileChooserAnnotation(chooseDirOnly = true)  @ParamAnno(description = "Target Directory") File targetDirectory) throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		u = new UnitTestCodeGeneratorDependOnClass();
		GenTestParam gtp = new GenTestParam();
		gtp.setTargetDir(targetDirectory.getAbsolutePath());
		u.genAllTestUnderPack(oneOfClass, gtp, context);
		u = null;
	}
	@ServiceMethodAnn(keyword = "gen one class unittest save at target dir")
	public void genOneTestClass(@ParamAnno(description = "Class To Test") Class clzToTest, 
			@FileChooserAnnotation(chooseDirOnly = true) @ParamAnno(description = "Target Directory") File targetDirectory) throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		u = new UnitTestCodeGeneratorDependOnClass();
		GenTestParam gtp = new GenTestParam();
		gtp.setTargetDir(targetDirectory.getAbsolutePath());
		u.genAllTestCasesAndSave(clzToTest, gtp, context);
		u = null;
	}
	@ServiceMethodAnn(keyword = "gen one class unittest source code")
	public String genTestClassSource(@ParamAnno(description = "Class to Test") Class clzToTest) throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		u = new UnitTestCodeGeneratorDependOnClass();
		GenTestParam gtp = new GenTestParam();
		OneTestClassCreateResult otccr = u.genAllTest(clzToTest, gtp, context);
		u = null;
		return otccr.getCode();
	}
	@ServiceMethodAnn(keyword = "gen one class mock class source code")
	public String genMockClassSource(@ParamAnno(description = "Class") Class c) throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		i = new MockClzFactoryGenerator();
		MockClzFactoryCreateResult mcr = i.genMockClassSource(c, context);
		i = null;
		return mcr.getCode();
	}
	@ServiceMethodAnn(keyword = "gen mock class ")
	public void genMock(Class clzToTest, String targetDirectory) throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		i = new MockClzFactoryGenerator();
		i.genMock(clzToTest, targetDirectory, context);
		i = null;
	}
	@ServiceMethodAnn(keyword = "gen interface mock class source code at same package")
	public void genAllInterfaceMockUnderPack(Class oneOfClass, String targetDirectory) throws Exception {
		i = new MockClzFactoryGenerator();
		i.genAllInterfaceMockUnderPack(oneOfClass, targetDirectory);
		i = null;
	}
	/*
	 * public void genAllInterfaceMockUnderPack(Package sourcePack, String
	 * targetDirectory) throws Exception { CodeGenContext context =
	 * CodeGenContext.getInstance(); i = new InterfaceMockGenerator();
	 * i.genAllInterfaceMockUnderPack(sourcePack, targetDirectory, context); i =
	 * null; }
	 */
	public void typeStr(String str) {
		kRobot.typeStr(str);
	}
	public void cleanTextField() {
		mRobot.delay(1000);
		mRobot.mouseDoubleClick();
		mRobot.delay(1000);
		kRobot.del();
	}
	public void copy1Line(URL keyboardCursorURL) throws Exception {
		BufferedImage rsImg;
		try {
			rsImg = Resource.getResource(keyboardCursorURL);
			copy1Line(rsImg);
		} catch (IOException e) {
			e.printStackTrace();
			return;
		}
	}
	public void copy1Line(String keyboardCursorRSName) throws Exception {
		BufferedImage rsImg;
		try {
			rsImg = Resource.getBufferedImageByRsName(keyboardCursorRSName);
			copy1Line(rsImg);
		} catch (IOException e) {
			e.printStackTrace();
			return;
		}
	}
	public void copy1Line(BufferedImage rsImg) throws Exception {
		select1LineAndNewLineChar(rsImg);
		this.kRobot.copy();
		Toolkit tk = Toolkit.getDefaultToolkit();
		Clipboard c = tk.getSystemClipboard();
	}
	public void copy1Line() throws Exception {
		selectLine();
		this.kRobot.copy();
	}
	public void selectLine() {
		getkRobot().copyLine();
	}
	public void select1LineAndNewLineChar(BufferedImage rsImg) throws Exception {
		this.getkRobot().home();
		this.getkRobot().home();
		Dimension d = Toolkit.getDefaultToolkit().getScreenSize();
		double width = d.getWidth();
		double height = d.getHeight();
		Rectangle rect = new Rectangle((int) width, (int) height);
		BufferedImage img = this.getkRobot().getRobot().createScreenCapture(rect);
		PixelMatchResult mr = this.getmRobot().seek(rsImg, img);
		if (mr != null) {
			int rsHeight = rsImg.getHeight();
			int x = mr.getStartPixel().getX();
			int y = mr.getStartPixel().getY() + rsHeight / 2;
			this.getmRobot().mouseMove(x, y);
			this.getmRobot().mousePress();
			y = y + rsImg.getHeight();
			this.getmRobot().mouseMove(x, y);
			this.getmRobot().mouseRelease();
		} else {
			throw new Exception();
		}
	}
	public void select1LineAndNewLineChar(String keyboardCursorRSName) throws Exception {
		BufferedImage rsImg;
		try {
			rsImg = Resource.getBufferedImageByRsName(keyboardCursorRSName);
			select1LineAndNewLineChar(rsImg);
		} catch (IOException e) {
			e.printStackTrace();
			return;
		}
	}
	public void select1LineAndNewLineChar(URL keyboardCursorURL) throws Exception {
		BufferedImage rsImg;
		try {
			rsImg = Resource.getResource(keyboardCursorURL);
			select1LineAndNewLineChar(rsImg);
		} catch (IOException e) {
			e.printStackTrace();
			return;
		}
	}
	public MouseRobot getmRobot() {
		return mRobot;
	}
	public void setmRobot(MouseRobot mRobot) {
		this.mRobot = mRobot;
	}
	public KeyboardRobot getkRobot() {
		return kRobot;
	}
	public void setkRobot(KeyboardRobot kRobot) {
		this.kRobot = kRobot;
	}
	static class Helper{
		private int data=5;
		public void bump(int inc){
			inc++;
			data=data+inc;
		}
	}
	public static void main(String[] args) {
		Double d = 1.0;
		if(d instanceof Number)
			d=d++;
		double e1 = 1.0;
		if((Double)e1 instanceof Double | d++==e1++)
			d+=d;
		Stream.of("little","red","riding","hood").parallel()
		.map(s->{System.out.println("map:"+s+" "+Thread.currentThread().getName());return s+"_";})
		.filter(s->{System.out.println("filter: "+s+" "+Thread.currentThread().getName());return s.length()>3;})
		.reduce((s1,s2)-> {System.out.println("reducer: "+s1+" "+Thread.currentThread().getName());return s1.length()>s2.length()?s1:s2;});
		Path inputFile = Paths.get("");
		Path outputFile = Paths.get("");
		try {
			BufferedReader reader = Files.newBufferedReader(inputFile, Charset.defaultCharset());
			BufferedWriter writer = Files.newBufferedWriter(outputFile, Charset.defaultCharset());
			String line = "";
			while((line=reader.readLine())!=null)
				writer.append(line);
		} catch (IOException e) {
			e.printStackTrace();
		}
		Float f = new Float(23.33);
		StringBuilder sb = new StringBuilder();
		for(String arg: args){
			if(sb.indexOf(arg)<1){
				sb.append(arg+" ");
			}
		}
		List<String> list11=new ArrayList<>();
		list11.add("Jupiter");
		list11.add("Neptune");
		list11.add("Mars");
		list11.add("Barth");
		Map<Integer, List<String>> len = list11.stream().collect(Collectors.groupingBy(p->p.length()));
		len.forEach((l,s)->System.out.print(l+"="+s+" "));
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\codegen\robot\TopLeftValidPixel.java---
package codegen.robot;
public class TopLeftValidPixel {
	public TopLeftValidPixel() {
	}
	private int validPixelOffsetX;
	private int validPixelOffsetY;
	private int pixelVal;
	public int getValidPixelOffsetX() {
		return validPixelOffsetX;
	}
	public void setValidPixelOffsetX(int validPixelOffsetX) {
		this.validPixelOffsetX = validPixelOffsetX;
	}
	public int getValidPixelOffsetY() {
		return validPixelOffsetY;
	}
	public void setValidPixelOffsetY(int validPixelOffsetY) {
		this.validPixelOffsetY = validPixelOffsetY;
	}
	public int getPixelVal() {
		return pixelVal;
	}
	public void setPixelVal(int pixelVal) {
		this.pixelVal = pixelVal;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\codegen\Syntax.java---
package codegen;
public class Syntax {
	public static String REFERENCE_SYMBOL = "$";
	public static String ASSIGN_SYMBOL = "=";
	public static String NEW_LINE = "\r\n";
	public static String END_OF_LINE = ";\r\n";
	public static String PACKAGE_DECLARE = "package $PACKAGE_NAME$$END_OF_LINE$";
	public static String FIELD_DECLARE = "$PRIVILEDGE_MODIFIER$$STATIC_MODIFIER$$ABSTRACT_MODIFIER$$FINAL_MODIFIER$$VOLATILE_MODIFIER$$SYNC_MODIFIER$ $FIELD_CLASS_NAME$ $FIELD_INSTANCE_NAME$$END_OF_LINE$";
	public static String FIELD_DECLARE_WITH_ASSIGN = "$PRIVILEDGE_MODIFIER$$STATIC_MODIFIER$$ABSTRACT_MODIFIER$$FINAL_MODIFIER$$SYNC_MODIFIER$ $FIELD_CLASS_NAME$ $FIELD_INSTANCE_NAME$=$TMP_INSTANCE_VALUE$$END_OF_LINE$";
	public static String IMPORT_LINE = "import $QUALIFIER$$END_OF_LINE$";
	public static String CLASS_BEGIN_LINE = "$PRIVILEDGE_MODIFIER$$STATIC_MODIFIER$$ABSTRACT_MODIFIER$$FINAL_MODIFIER$$SYNC_MODIFIER$ class $TMP_CLASS_NAME$ {$NEW_LINE$";
	public static String CLASS_END_LINE = "}";
	public static String DECLARE_LINE = "$TMP_CLASS_NAME$ $TMP_INSTANCE_NAME$;$NEW_LINE$";
	public static String ASSIGN_LINE = "$TMP_CLASS_NAME$ $TMP_INSTANCE_NAME$ = $TMP_INSTANCE_VALUE$;$NEW_LINE$";
	public static String ARRAY_DECLARE_LINE = "$TMP_CLASS_NAME$ $TMP_INSTANCE_NAME$[];$NEW_LINE$";
	public static String ARRAY_ASSIGN_LINE = "$TMP_CLASS_NAME$ $TMP_INSTANCE_NAME[]$ = $TMP_INSTANCE_VALUE$;$NEW_LINE$";
	public static String CAST_LINE = "$TARGET_CLASS_NAME$$SEPERATOR$$TARGET_INSTANCE_NAME$ = $TMP_CLASS_NAME$.class.cast(TMP_INSTANCE_VALUE);$NEW_LINE$";
	public static String CAST_EXPLICIT_LINE = "$TARGET_CLASS_NAME$$SEPERATOR$$TARGET_INSTANCE_NAME$ = ($TMP_CLASS_NAME$)$TMP_INSTANCE_VALUE$;$NEW_LINE$";
	public static String ABSTRACT_NEW_INSTANCE_LINE_WITH_DECLARE_OR_NOT = "$ABSTRACT_CLASS_NAME$$SEPERATOR$$ABSTRACT_INSTANCE_NAME$ = new $TMP_CLASS_NAME$($METHOD_PARAMS_VARIABLE$);$NEW_LINE$";
	public static String NEW_INSTANCE_LINE = "$TMP_INSTANCE_NAME$ = new $TMP_CLASS_NAME$();$NEW_LINE$";
	public static String INIT_CLASS_WITH_CONCRETE_LINE = "$ABSTRACT_CLASS_NAME$ $ABSTRACT_INSTANCE_NAME$ = $TMP_CLASS_NAME$.$METHOD_NAME$($METHOD_PARAMS_VARIABLE$);$NEW_LINE$";
	public static String NEW_ABSTRACT_CLASS_INSTANCE_LINE_BEGIN_LINE = "$TMP_INSTANCE_NAME$ = new $TMP_CLASS_NAME$(){$CLASS_END_LINE$";
	public static String NEW_ABSTRACT_CLASS_METHOD_WITH_RETURN = "@Override$CLASS_END_LINE$"
			+ "public $METHOD_RETURN_TYPE$ $METHOD_NAME$($METHOD_PARAMS_DECLARE$) {" + "return null;" + "}";
	public static String CONTROLLER_METHOD = "@RequestMapping(value=\"$PATH$\"$METHOD_STR$$HEADERS$$CONSUMERS$$PRODUCES$)"
			+ "$NEW_LINE$$PRIVILEDGE_MODIFIER$$STATIC_MODIFIER$$ABSTRACT_MODIFIER$$FINAL_MODIFIER$$SYNC_MODIFIER$ $METHOD_RETURN_TYPE$ $METHOD_NAME$($METHOD_PARAMS_DECLARE$) $THROWS_EXCEPTION${$NEW_LINE$"
			+ "    $METHOD_BODY$$NEW_LINE$" + "    return $METHOD_RETURN_VALUE$$END_OF_LINE$" + "}";
	public static String NORMAL_METHOD = "$PRIVILEDGE_MODIFIER$$STATIC_MODIFIER$$ABSTRACT_MODIFIER$$FINAL_MODIFIER$$SYNC_MODIFIER$ $METHOD_RETURN_TYPE$ $METHOD_NAME$($METHOD_PARAMS_DECLARE$) $THROWS_EXCEPTION${$NEW_LINE$"
			+ "    $METHOD_BODY$$NEW_LINE$" + "    return $METHOD_RETURN_VALUE$$END_OF_LINE$" + "}";
	public static String METHOD_END_LINE = "}";
	/***/
	public static String INIT_CLASS_WITH_DEFAULT_VALUE = "$TMP_CLASS_NAME$$SEPERATOR$$TMP_INSTANCE_NAME$ = $DEFAULT_VALUE$;$NEW_LINE$";
	public static String INIT_LIST = "List<$GENERIC_TYPE_NAME$> $TMP_INSTANCE_NAME$ = new $TMP_CLASS_NAME$<>();";
	public static String INIT_Map = "Map<$GENERIC_TYPE_KEY$, $GENERIC_TYPE_VAL$> $TMP_INSTANCE_NAME$ = new $TMP_CLASS_NAME$<>();";
	public static String NEW_ABSTRACT_CLASS_METHOD_RETURN_VOID = "@Override$CLASS_END_LINE$"
			+ "public void $METHOD_NAME$($METHOD_PARAMS_DECLARE$) {" + "return ;" + "}";
	public static String NEW_EXCEPTION_THROW = "throw new $TMP_CLASS_NAME$($METHOD_PARAMS_VARIABLE$);";
	public static String RETURN = "return $TMP_INSTANCE_VALUE$;";
	public static String LOGGER_TRACE = "log.trace(String.format(\" %s\", s));";
	public static String LOGGER_DEBUG = "log.debug(String.format(\" %s\", s));";
	public static String LOGGER_INFO = "log.info(String.format(\" %s\", s));";
	public static String LOGGER_ERROR = "log.error(String.format(\" %s\", s));";
	public static String LOGGER_FATAL = "log.fatal(String.format(\" %s\", s));";
	public static String NORMAL_SETUP_BEGIN_LINE = "@Before$NEW_LINE$"
			+ "public void setUp() throws Exception {$NEW_LINE$";
	public static String NORMAL_TEST_CASE_BEGIN_LINE = "@Test$NEW_LINE$" + "public void test$METHOD_NAME$() {";
	public static String EXCEPTION_TEST_CASE_BEGIN_LINE = "@Test(expected=$EXCEPTION_CLASS$.class)$CLASS_END_LINE$"
			+ "public void test$METHOD_NAME$() {";
	public static String METHOD_WITH_RETURN_CALLING = "$RETURN_TYPE$ $RETURN_TYPE_INSTANCE$ = $TMP_INSTANCE_NAME$.$METHOD_NAME$($METHOD_PARAMS_VARIABLE$);$NEW_LINE$";
	public static String VOID_METHOD_CALLING = "$TMP_INSTANCE_NAME$.$METHOD_NAME$($METHOD_PARAMS_VARIABLE$);$NEW_LINE$";
	public static String METHOD_PARAMS_VARIABLE_LINE = "$METHOD_PARAM1$, $METHOD_PARAM2$";
	public static String IF_ELSE_BLOCK = "$PREFIX_STR$if($IF_EXPRESSION$){$NEW_LINE$$NEW_LINE$" + "}";
	public static String ELSE_BLOCK = "else{$NEW_LINE$$NEW_LINE$" + "}";
	public static String FOR_EACH_BLOCK = "for($TMP_CLASS_NAME$ $ITEM_NAME$ : $TMP_INSTANCE_NAME$){$NEW_LINE$}";
	public static String FOR_LOOP_INCREMENT_BLOCK = "for($TMP_CLASS_NAME$ $TMP_INSTANCE_NAME$=0;$TMP_INSTANCE_NAME$<.length();$TMP_INSTANCE_NAME$++){$NEW_LINE$}";
	public static String FOR_LOOP_DECREMENT_BLOCK = "for($TMP_CLASS_NAME$ $TMP_INSTANCE_NAME$=.length()-1;$TMP_INSTANCE_NAME$>=0;$TMP_INSTANCE_NAME$--){$NEW_LINE$}";
	public static String SWITCH_BLOCK = "switch($TMP_INSTANCE_NAME$){$NEW_LINE$$BLOCK_BODY$}";
	public static String SWITCH_CASE_BLOCK = "case $TMP_INSTANCE_NAME$:$NEW_LINE$$NEW_LINE$$NEW_LINE$break$END_OF_LINE$";
	public static String SWITCH_DEFAULT_BLOCK = "default :$NEW_LINE$$NEW_LINE$break$END_OF_LINE$";
	public static String WHILE_BLOCK = "while($TMP_INSTANCE_NAME$){$NEW_LINE$$BLOCK_BODY$}";
	public static String DO_WHILE_BLOCK = "do{$NEW_LINE$$BLOCK_BODY$}while($TMP_INSTANCE_NAME$)$END_OF_LINE$";
	public static String SYNCHRONIZED_BLOCK = "synchronized($TMP_INSTANCE_NAME$){$NEW_LINE$$BLOCK_BODY$}";
	public static String TRY_CATCH_BLOCK = "try{$NEW_LINE$" + "$TRY_BODY$$NEW_LINE$"
			+ "}catch($EXCEPTIONS_DECLARE$){$NEW_LINE$" + "$CATCH_BODY$$NEW_LINE$" + "}finally{" + "$FINALLY_BODY$"
			+ "}";
	public static String COLLECTION_STREAM = "$TMP_CLASS_NAME$ $TMP_INSTANCE_NAME$$ASSIGN_SYMBOL$$TMP_INSTANCE_VALUE$.stream()";
	public static String STREAM_DISTINCT = ".distinct()";
	public static String STREAM_SORT = ".sorted((Object o1, Object o2)-> {$NEW_LINE$ if(o1 > o2) {$NEW_LINE$return -1;$NEW_LINE$}else if(o1 == o2) {$NEW_LINE$return 0;$NEW_LINE$}else {$NEW_LINE$return 1;} $NEW_LINE$})";
	public static String STREAM_FOREACH = ".forEach(e-> {})";
	public static String STREAM_FILTER = ".filter(e -> {if (\"\".equals(e)) { return true; } return false; })";
	public static String STREAM_MAP = ".map(e-> {return e;})";
	public static String STREAM_COLLECT_AS_LIST = ".collect(Collectors.toList())";
	public static String STREAM_COLLECT_AS_SET = ".collect(Collectors.toSet())";
	public static String STREAM_COLLECT_AS_MAP = ".collect(Collectors.toMap(e-> e.getId().toString().toLowerCase(), e->e.getValue(), (e1,e2)->{return e1;}))";
	public static String STREAM_COLLECT_AS_TREE_MAP = ".collect(Collectors.toMap(e-> e.getId().toString().toLowerCase(), e->e.getValue(), (e1,e2)->{return e1;}, ()->new TreeMap(String.CASE_INSENSITIVE_ORDER))";
	public static String STREAM_COLLECT_AS_CONCURRENTMAP = ".collect(Collectors.toConcurrentMap($GENERIC_TYPE_KEY$, $GENERIC_TYPE_VAL$))";
	public static String MAP_ENTRY_SET = "$TMP_INSTANCE_NAME$.entrySet()";
	public static String MAP_VALUES = "$TMP_INSTANCE_NAME$.values()";
	public static String MAP_KEY_SET = "$TMP_INSTANCE_NAME$.keySet()";
	public static String MAIN_BLOCK = "public static void main(String[] args){\r\n}";
	public static String EXCEPTIONS_DECLARE_LINE = "$EXCEPTION_NAME$ $EXCEPTION_INSTANCE_NAME$";
	public static String COLLECTION_LAMBDA_FOR_EACH = "$TMP_INSTANCE_NAME$.$METHOD_NAME$().forEach(($LAMBDA_PARAMS_VARIABLE$) -> {$NEW_LINE$"
			+ "$METHOD_BODY$" + "$NEW_LINE$});$NEW_LINE$";
	public static String SYS_IN = "BufferedReader br = new BufferedReader(new InputStreamReader(System.in));$NEW_LINE$"
			+ "while (true) {$NEW_LINE$" + "    String input = br.readLine();$NEW_LINE$"
			+ "    if (input != null && !input.isEmpty()){$NEW_LINE$" + "        switch (input){$NEW_LINE$"
			+ "            case \"\":$NEW_LINE$" + "                break;$NEW_LINE$"
			+ "            case \"exit\":$NEW_LINE$" + "                System.exit(0);$NEW_LINE$"
			+ "            default :$NEW_LINE$" + "                $NEW_LINE$" + "         }$NEW_LINE$"
			+ "    }$NEW_LINE$" + "}$NEW_LINE$";
	public static String SYS_OUT = "System.out.$METHOD_NAME$($METHOD_PARAMS_VARIABLE$);";
	public static String STRING_FORMAT = "String.format($METHOD_PARAMS_VARIABLE$);";
	public static String PATTERN_COMPILE = "Pattern $TMP_INSTANCE_VALUE$ = Pattern.compile($TMP_INSTANCE_NAME$, Pattern.MULTILINE | Pattern.CASE_INSENSITIVE);";
	public static String PATTERN_CREATE_MATCHER = "Matcher $TMP_INSTANCE_VALUE$ = $TMP_INSTANCE_NAME$.matcher($METHOD_PARAMS_VARIABLE$);";
	public static String MATCHER_FIND = "boolean $TMP_INSTANCE_VALUE$ = $TMP_INSTANCE_NAME$.find();";
	public static String MATCHER_MATCHES = "boolean $TMP_INSTANCE_VALUE$ = $TMP_INSTANCE_NAME$.matches();";
	public static String UNIT_TEST_SET_TARGET_OBJ_FIELD_CALLING = "setTargetObjField(\"$FIELD_INSTANCE_NAME$\", $TMP_INSTANCE_NAME$, $FIELD_VALUE$)$END_OF_LINE$";
	public static String UNIT_TEST_SET_TARGET_OBJ_FIELD_METHOD = "private void setTargetObjField(String fieldName, Object target, Object fieldObj){$NEW_LINE$"
			+ "try {$NEW_LINE$" + "Field f = getField(fieldName, target.getClass());$NEW_LINE$"
			+ "if(f == null){$NEW_LINE$" + "return;$NEW_LINE$" + "}$NEW_LINE$" + "f.setAccessible(true);$NEW_LINE$"
			+ "f.set(target, fieldObj);$NEW_LINE$"
			+ "} catch (SecurityException | IllegalArgumentException | IllegalAccessException e) {$NEW_LINE$"
			+ "e.printStackTrace();$NEW_LINE$" + "}$NEW_LINE$" + "}";
	public static String UNIT_TEST_GET_FIELD_METHOD = "private Field getField(String fieldName, Class target){$NEW_LINE$"
			+ "Field f = null;$NEW_LINE$" + "try{$NEW_LINE$" + "f = target.getDeclaredField(fieldName);$NEW_LINE$"
			+ "}catch(NoSuchFieldException e){$NEW_LINE$" + "Class superC = target.getSuperclass();$NEW_LINE$"
			+ "if(superC != null){$NEW_LINE$" + "return getField(fieldName, superC);$NEW_LINE$" + "}$NEW_LINE$"
			+ "}$NEW_LINE$" + "return f;$NEW_LINE$" + "}$NEW_LINE$";
	public static String ASSERT_FAIL = "Assert.fail()$END_OF_LINE$";
	public static String ASSERT_NOT_NULL = "Assert.assertNotNull($TMP_INSTANCE_NAME$)$END_OF_LINE$";
	public static String ASSERT_EQUAL = "Assert.assertEquals($EXPECT_VALUE$, $ACTUAL_VALUE$)$END_OF_LINE$";
	public static String MOCKITO_VERIFY = "Mockito.verify($INSTANCE_NAME$, Mockito.times(1)).$METHOD_NAME$($MATCH_PARAMS_VARIABLE$)$END_OF_LINE$";
	public static String POWER_MOCK_STATIC_VERIFY = "";
	public static String ANY_MATCH = "Mockito.any()";
	public static String ANY_OF_CLASS_MATCH = "Mockito.any($TMP_CLASS_NAME$.class)";
	public static String INTERFACE_MOCK_CLASS_NAME = "$TMP_CLASS_NAME$MOCK";
	public static String MOCK_CLASS_LINE = "$TMP_CLASS_NAME$ $TMP_INSTANCE_NAME$ = Mockito.mock($TMP_CLASS_NAME$.class)$END_OF_LINE$";
	public static String MOCK_THROW = "Mockito.doThrow(Exception.class).when($TMP_INSTANCE_NAME$).$METHOD_NAME$($METHOD_PARAMS_VARIABLE$)$END_OF_LINE$";
	public static String MOCK_RETURN_VOID = "Mockito.doNothing().when($TMP_INSTANCE_NAME$).$METHOD_NAME$($METHOD_PARAMS_VARIABLE$)$END_OF_LINE$";
	public static String MOCK_RETURN = "Mockito.doReturn($METHOD_RETURN_VALUE$).when($TMP_INSTANCE_NAME$).$METHOD_NAME$($METHOD_PARAMS_VARIABLE$)$END_OF_LINE$";
	public static String WRITE_FILE = "public static void write(File f, String fileStr) throws IOException {"
			+ "$NEW_LINE$" + "FileOutputStream fos = new FileOutputStream(f);" + "$NEW_LINE$"
			+ "fos.write(fileStr.getBytes());" + "$NEW_LINE$" + "fos.flush();" + "$NEW_LINE$" + "fos.close();"
			+ "$NEW_LINE$" + "}";
	public static String READ_FILE = "public static String readAsStr(File f) throws IOException {" + "$NEW_LINE$"
			+ "FileInputStream is = new FileInputStream(f);" + "$NEW_LINE$" + "StringBuilder sb = new StringBuilder();"
			+ "$NEW_LINE$" + "BufferedReader in = null;" + "$NEW_LINE$" + "try {" + "$NEW_LINE$"
			+ "	in = new BufferedReader(new InputStreamReader(is));" + "$NEW_LINE$" + "	String line = null;"
			+ "$NEW_LINE$" + "	while ((line = in.readLine()) != null) {" + "$NEW_LINE$"
			+ "		sb.append(line).append(\"\r\n\");" + "$NEW_LINE$" + "	}" + "$NEW_LINE$"
			+ "} catch (IOException e) {" + "$NEW_LINE$" + "	e.printStackTrace();" + "$NEW_LINE$" + "	throw e;"
			+ "$NEW_LINE$" + "} finally {" + "$NEW_LINE$" + "	if (in != null)" + "$NEW_LINE$" + "		try {"
			+ "$NEW_LINE$" + "			in.close();" + "$NEW_LINE$" + "		} catch (IOException e) {" + "$NEW_LINE$"
			+ "			e.printStackTrace();" + "$NEW_LINE$" + "		}" + "$NEW_LINE$" + "}" + "$NEW_LINE$"
			+ "return sb.toString();" + "$NEW_LINE$" + "}";
	public static String THREAD_POOL_EXECUTOR = "$PRIVILEDGE_MODIFIER$$STATIC_MODIFIER$$ABSTRACT_MODIFIER$$FINAL_MODIFIER$ BlockingQueue<Runnable> arrayBlockingQueue = new ArrayBlockingQueue<>($MAX_POOL_SIZE$);"
			+ "$NEW_LINE$"
			+ "$PRIVILEDGE_MODIFIER$$STATIC_MODIFIER$$ABSTRACT_MODIFIER$$FINAL_MODIFIER$ ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor($CORE_POOL_SIZE$, $MAX_POOL_SIZE$, 1L, java.util.concurrent.TimeUnit.SECONDS, arrayBlockingQueue $NEW_THREAD_FACTORY$);"
			+ "$NEW_LINE$"
			+ "$PRIVILEDGE_MODIFIER$$STATIC_MODIFIER$$ABSTRACT_MODIFIER$$FINAL_MODIFIER$ void shutdownThreadPool() {"
			+ "$NEW_LINE$" + "    threadPoolExecutor.shutdown();" + "$NEW_LINE$" + "}";
	public static String NEW_THREAD_FACTORY = "new ThreadFactory(){" + "$NEW_LINE$" + "@Override" + "$NEW_LINE$"
			+ "public Thread newThread(Runnable r) {" + "$NEW_LINE$" + "    return new Thread(r);" + "$NEW_LINE$"
			+ "}}";
	public static String SUBMIT_CALLABLE_TASK = "$PRIVILEDGE_MODIFIER$$STATIC_MODIFIER$$ABSTRACT_MODIFIER$$FINAL_MODIFIER$ $RETURN_TYPE$ submitTask(Callable<$RETURN_TYPE$> task) throws Exception {"
			+ "$NEW_LINE$" + "    Future<$RETURN_TYPE$> f = threadPoolExecutor.submit(task);" + "$NEW_LINE$"
			+ "    return f.get();" + "$NEW_LINE$" + "}";
	public static String SUBMIT_RUNNABLE_TASK = "$PRIVILEDGE_MODIFIER$$STATIC_MODIFIER$$ABSTRACT_MODIFIER$$FINAL_MODIFIER$ void submitTask(Runnable task) {"
			+ "$NEW_LINE$" + "    threadPoolExecutor.submit(task);" + "$NEW_LINE$" + "}";
	public static String MAVEN_DEPENDENCY = "<dependency>$NEW_LINE$<groupId>$GROUP_ID$</groupId>$NEW_LINE$<artifactId>$ARTIFACTOR_ID$</artifactId>$NEW_LINE$"
			+ "<version>$VERSION$</version>$NEW_LINE$<scope>$SCOPE$</scope>$NEW_LINE$</dependency>";
	public static String HTML_TAG_A = "<a$ID$ href=$LINK$></a>";
	public static String HTML_TAG_TEXT = "<input type=\"text\"$ID$ name=\"$TAG_NAME$\" value=\"\"></input>";
	public static String HTML_TAG_HIDDEN = "<input type=\"hidden\"$ID$ name=\"$TAG_NAME$\"  value=\"\"></input>";
	public static String HTML_TAG_BTN = "<input type=\"button\"$ID$ name=\"$TAG_NAME$\"  value=\"\"></input>";
	public static String HTML_TAG_FILE = "<input type=\"file\"$ID$ name=\"$TAG_NAME$\"  value=\"\"></input>";
	public static String HTML_TAG_SELECT = "<input type=\"select\"$ID$ name=\"$TAG_NAME$\">$NEW_LINE$<option value=\"\"></option>$NEW_LINE$</input>";
	public static String HTML_TAG_FORM = "<form$ID$ method=$REQUEST_METHOD$$ID$ action=$LINK$$TARGET$$NEW_LINE$</form>";
	public static String PODAM_INIT_POJO = "$TMP_CLASS_NAME$ $TMP_INSTANCE_NAME$ = new PodamFactoryImpl().manufacturePojo($TMP_CLASS_NAME$.class)$END_OF_LINE$";
}
----strat of file D:\projects\cg\cg-min\src\main\java\codegen\unittest\ClzNeedMockDetermination.java---
package codegen.unittest;
import codegen.util.Common;
import java.lang.annotation.Annotation;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.Map;
public class ClzNeedMockDetermination {
	public boolean needMock(Class<?> c) throws ClassNotFoundException {
		boolean b = true;
		boolean isInterface = c.isInterface();
		boolean isAbstract = Common.isAbstract(c);
		if (isInterface || isAbstract) {
			return true;
		}
		boolean isAnySpecifiedAnn = isAnySpecifiedAnnPackMatch(c,
				new String[] { "javax.persistence", "javax.xml.bind", "com.fasterxml.jackson.databind" });
		if (isAnySpecifiedAnn) {
			return false;
		}
		boolean isSimpleType = isSimpleTypeOrCollectionOfSimple(c);
		boolean isSimpleTypeMap = isSimpleTypeOrCollectionOfSimple(c);
		boolean isAllFieldsSimpleType = isAllFieldsSimpleType(c);
		if (isSimpleType) {
			return false;
		}
		if (isSimpleTypeMap) {
			return false;
		}
		if (isAllFieldsSimpleType) {
			return false;
		}
		boolean isAllStaticMethods = isAllMethodStatic(c);
		if (isAllStaticMethods) {
			return false;
		}
		return b;
	}
	public boolean isAllMethodStatic(Class<?> c) {
		Method[] ms = Common.getAllMethods(c);
		for (Method m : ms) {
			if ((m.getModifiers() & Modifier.STATIC) != 1) {
				return false;
			}
		}
		return true;
	}
	/**
	 * enum and all primitive types not need mock Object and Exception child classes
	 * and has default constructor or simply type param constructor are data Object
	 * Collection, arrays of all above classes not need mock
	 */
	public boolean isSimpleTypeOrMapOfSimple(Class<?> c) {
		boolean b = false;
		if (c.isAssignableFrom(Map.class)) {
			return true;
		} else {
		}
		b = Common.isPrimitiveType(c);
		if (b) {
			return true;
		} else {
			if (c.isAssignableFrom(Map.class)) {
				return true;
			} else {
			}
		}
		return b;
	}
	/**
	 * enum and all primitive types not need mock Object and Exception child classes
	 * and has default constructor or simply type param constructor are data Object
	 * Collection, arrays of all above classes not need mock
	 */
	public boolean isSimpleType(Class<?> c) {
		boolean b = false;
		b = Common.isPrimitiveType(c);
		if (b) {
			return true;
		} else {
			if (c.isAssignableFrom(Exception.class)) {
				return true;
			} else {
			}
		}
		return b;
	}
	/**
	 * enum and all primitive types not need mock Object and Exception child classes
	 * and has default constructor or simply type param constructor are data Object
	 * Collection, arrays of all above classes not need mock
	 */
	public boolean isSimpleTypeOrCollectionOfSimple(Class<?> c) {
		boolean b = false;
		b = Common.isPrimitiveType(c);
		if (b) {
			return true;
		} else {
			if (c.isAssignableFrom(Exception.class)) {
				return true;
			} else if (c.isAssignableFrom(Collection.class) || c.isAssignableFrom(Map.class)) {
				return true;
			}
		}
		return b;
	}
	private boolean isAllFieldsSimpleType(Class<?> c) {
		List<Field> fList = Common.getAllFields(c);
		boolean isAllFieldsSimpleType = fList.stream().anyMatch(f -> {
			return isSimpleType(f.getDeclaringClass());
		});
		return isAllFieldsSimpleType;
	}
	/**
	 * Entity, JaxbElement, xmlType, Json related objects are data Object
	 */
	private boolean isAnySpecifiedAnnPackMatch(Class<?> clz, String[] annPackName) throws ClassNotFoundException {
		List<Annotation> list = new ArrayList<>();
		Common.getAllClzAnnotation(clz, list);
		boolean anySpecifiedAnnPackMatch = list.stream().anyMatch(ann -> {
			boolean am = false;
			for (String packName : annPackName) {
				if (ann.annotationType().getName().startsWith(packName)) {
					am = true;
					break;
				}
			}
			return am;
		});
		return anySpecifiedAnnPackMatch;
	}
	/**
	 * Entity, JaxbElement, xmlType, Json related objects are data Object
	 *//*
		 * private boolean isSpecifiedAnn(Class<?> clz, String annClzName) throws
		 * ClassNotFoundException { Class annClz =
		 * CodeGenContext.getInstance().getReloadableDynamicClassLoaderOwner().loadClass(annClzName, true); return isSpecifiedAnnoInclz(clz,
		 * annClz); }
		 * 
		 * private <A extends Annotation> boolean isSpecifiedAnnoInclz(Class<?> c,
		 * Class<A> ac) { Annotation anns[] = c.getAnnotationsByType(ac); return
		 * anns.length > 1; }
		 */
}
----strat of file D:\projects\cg\cg-min\src\main\java\codegen\unittest\FieldInitParams.java---
package codegen.unittest;
import java.lang.reflect.Field;
public class FieldInitParams {
	private Field field;
	private Class<?> fieldType;
	private int mod;
	private String fieldName;
	private String defaultVal;
	private boolean tooManyMethods;
	private boolean needMock;
	private boolean needMockFactroyClz;
	private boolean isComplexType;
	public boolean isNeedMockFactroyClz() {
		return needMockFactroyClz;
	}
	public void setNeedMockFactroyClz(boolean needMockFactroyClz) {
		this.needMockFactroyClz = needMockFactroyClz;
	}
	public Field getField() {
		return field;
	}
	public void setField(Field field) {
		this.field = field;
	}
	public Class<?> getFieldType() {
		return fieldType;
	}
	public void setFieldType(Class<?> fieldType) {
		this.fieldType = fieldType;
	}
	public int getMod() {
		return mod;
	}
	public void setMod(int mod) {
		this.mod = mod;
	}
	public String getFieldName() {
		return fieldName;
	}
	public void setFieldName(String fieldName) {
		this.fieldName = fieldName;
	}
	public String getDefaultVal() {
		return defaultVal;
	}
	public void setDefaultVal(String defaultVal) {
		this.defaultVal = defaultVal;
	}
	public boolean isNeedMock() {
		return needMock;
	}
	public void setNeedMock(boolean needMock) {
		this.needMock = needMock;
	}
	public boolean isTooManyMethods() {
		return tooManyMethods;
	}
	public void setTooManyMethods(boolean tooManyMethods) {
		this.tooManyMethods = tooManyMethods;
	}
	public boolean isComplexType() {
		return isComplexType;
	}
	public void setComplexType(boolean isComplexType) {
		this.isComplexType = isComplexType;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\codegen\unittest\GenTestParam.java---
package codegen.unittest;
import java.util.ArrayList;
import java.util.List;
public class GenTestParam {
	List<OneTestClassCreateParam> oneTestClassParamList=new ArrayList<>();
	List<MockClzFactoryCreateParam> mockClzFactoryCreateParamList=new ArrayList<>();
	List<MockClzFactoryCreateResult> mockClzFactoryCreateResult = new ArrayList<>();
	String targetDir;
	public String getTargetDir() {
		return targetDir;
	}
	public void setTargetDir(String targetDir) {
		this.targetDir = targetDir;
	}
	public OneTestClassCreateParam getOneTestClassParamByClzEvenNotPresent(Class<?> clzToTest){
		for(OneTestClassCreateParam otc : getOneTestClassParamList()){
			if(otc.getClzBeTest().equals(clzToTest)){
				return otc;
			}
		}
		OneTestClassCreateParam otcp = new OneTestClassCreateParam();
		otcp.setClzBeTest(clzToTest);
		oneTestClassParamList.add(otcp);
		return otcp;
	}
	public OneTestClassCreateParam getOneTestClassParamByClz(Class<?> clzToTest){
		for(OneTestClassCreateParam otc : getOneTestClassParamList()){
			if(otc.getClzBeTest().equals(clzToTest)){
				return otc;
			}
		}
		return null;
	}
	public MockClzFactoryCreateResult getMockClzFactoryCreateResult(Class<?> clzBeMock){
		for(MockClzFactoryCreateResult mccr : getMockClzFactoryCreateResult()){
			if(mccr.getClzBeMock().equals(clzBeMock)){
				return mccr;
			}
		}
		return null;
	}
	public List<OneTestClassCreateParam> getOneTestClassParamList() {
		return oneTestClassParamList;
	}
	public void setOneTestClassParamList(List<OneTestClassCreateParam> oneTestClassParamList) {
		this.oneTestClassParamList = oneTestClassParamList;
	}
	public List<MockClzFactoryCreateParam> getMockClzFactoryCreateParamList() {
		return mockClzFactoryCreateParamList;
	}
	public void setMockClzFactoryCreateParamList(List<MockClzFactoryCreateParam> mockClzFactoryCreateParamList) {
		this.mockClzFactoryCreateParamList = mockClzFactoryCreateParamList;
	}
	public List<MockClzFactoryCreateResult> getMockClzFactoryCreateResult() {
		return mockClzFactoryCreateResult;
	}
	public void setMockClzFactoryCreateResult(List<MockClzFactoryCreateResult> mockClzFactoryCreateResult) {
		this.mockClzFactoryCreateResult = mockClzFactoryCreateResult;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\codegen\unittest\MethodCallingVariable.java---
package codegen.unittest;
public class MethodCallingVariable {
	Class c;
	String methodBody;
	String methodBlock;
	String methodName;
	public MethodCallingVariable() {
	}
	public Class getC() {
		return c;
	}
	public void setC(Class c) {
		this.c = c;
	}
	public String getMethodBody() {
		return methodBody;
	}
	public void setMethodBody(String methodBody) {
		this.methodBody = methodBody;
	}
	public String getMethodBlock() {
		return methodBlock;
	}
	public void setMethodBlock(String methodBlock) {
		this.methodBlock = methodBlock;
	}
	public String getMethodName() {
		return methodName;
	}
	public void setMethodName(String methodName) {
		this.methodName = methodName;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\codegen\unittest\MethodCaseCreateParam.java---
package codegen.unittest;
import java.lang.reflect.Method;
public class MethodCaseCreateParam {
	private Method methodForTest;
	private String methodName;
	private int mod;
	private Class returnType;
	private Class expected;
	private Class throwExp;
	public Method getMethodForTest() {
		return methodForTest;
	}
	public void setMethodForTest(Method methodForTest) {
		this.methodForTest = methodForTest;
	}
	public String getMethodName() {
		return methodName;
	}
	public void setMethodName(String methodName) {
		this.methodName = methodName;
	}
	public int getMod() {
		return mod;
	}
	public void setMod(int mod) {
		this.mod = mod;
	}
	public Class getReturnType() {
		return returnType;
	}
	public void setReturnType(Class returnType) {
		this.returnType = returnType;
	}
	public Class getExpected() {
		return expected;
	}
	public void setExpected(Class expected) {
		this.expected = expected;
	}
	public Class getThrowExp() {
		return throwExp;
	}
	public void setThrowExp(Class throwExp) {
		this.throwExp = throwExp;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\codegen\unittest\MockClzCreateParams.java---
package codegen.unittest;
public class MockClzCreateParams {
	private Class<?> clzBeMock;
	public Class<?> getClzBeMock() {
		return clzBeMock;
	}
	public void setClzBeMock(Class<?> clzBeMock) {
		this.clzBeMock = clzBeMock;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\codegen\unittest\MockClzFactoryCreateParam.java---
package codegen.unittest;
public class MockClzFactoryCreateParam {
	String targetDir;
	private Class<?> clzBeMock;
	private String factoryMethodName;
	public String getFactoryMethodName() {
		return factoryMethodName;
	}
	public void setFactoryMethodName(String factoryMethodName) {
		this.factoryMethodName = factoryMethodName;
	}
	public String getTargetDir() {
		return targetDir;
	}
	public void setTargetDir(String targetDir) {
		this.targetDir = targetDir;
	}
	public Class<?> getClzBeMock() {
		return clzBeMock;
	}
	public void setClzBeMock(Class<?> clzBeMock) {
		this.clzBeMock = clzBeMock;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\codegen\unittest\MockClzFactoryCreateResult.java---
package codegen.unittest;
import java.io.File;
public class MockClzFactoryCreateResult {
	private String moclClzName;
	private String moclClzSimpleName;
	private Class<?> clzBeMock;
	private String factoryMethodName;
	private String code;
	private File file;
	public String getMoclClzName() {
		return moclClzName;
	}
	public void setMoclClzName(String moclClzName) {
		this.moclClzName = moclClzName;
	}
	public String getMoclClzSimpleName() {
		return moclClzSimpleName;
	}
	public void setMoclClzSimpleName(String moclClzSimpleName) {
		this.moclClzSimpleName = moclClzSimpleName;
	}
	public Class<?> getClzBeMock() {
		return clzBeMock;
	}
	public void setClzBeMock(Class<?> clzBeMock) {
		this.clzBeMock = clzBeMock;
	}
	public String getFactoryMethodName() {
		return factoryMethodName;
	}
	public void setFactoryMethodName(String factoryMethodName) {
		this.factoryMethodName = factoryMethodName;
	}
	public String getCode() {
		return code;
	}
	public void setCode(String code) {
		this.code = code;
	}
	public File getFile() {
		return file;
	}
	public void setFile(File file) {
		this.file = file;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\codegen\unittest\MockClzFactoryGenerator.java---
package codegen.unittest;
import codegen.Replacement;
import codegen.Syntax;
import codegen.complexobj.CodeGenContext;
import codegen.util.Common;
import java.io.File;
import java.io.FileOutputStream;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.nio.ByteBuffer;
import java.nio.CharBuffer;
import java.nio.channels.FileChannel;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
public class MockClzFactoryGenerator {
	private String genClassBegin(Class c, CodeGenContext context) throws Exception {
		Common.setModifier(Modifier.PUBLIC, context);
		return Common.genMockClassBegin(c, context);
	}
	public MockClzFactoryCreateResult genMock(Class clzToBeMock, String targetDirectory, CodeGenContext context)
			throws Exception {
		MockClzFactoryCreateResult mcr = genMockClassSource(clzToBeMock, context);
		if (mcr == null) {
			return mcr;
		}
		File file = new File(targetDirectory);
		if (!file.exists()) {
			file.mkdirs();
		}
		File mockFactoryFile = new File(targetDirectory + File.separator + clzToBeMock.getSimpleName() + "Mock.java");
		mcr.setFile(mockFactoryFile);
		FileOutputStream fos = new FileOutputStream(mockFactoryFile);
		FileChannel fc = fos.getChannel();
		ByteBuffer bb = Common.utf8CharsetEncoder.encode(CharBuffer.wrap(mcr.getCode()));
		fc.write(bb);
		fc.close();
		fos.close();
		return mcr;
	}
	public MockClzFactoryCreateResult genMockClassSource(Class c, CodeGenContext context) throws Exception {
		MockClzFactoryCreateResult mockClzCreateResult = new MockClzFactoryCreateResult();
		mockClzCreateResult.setMoclClzName(c.getName());
		mockClzCreateResult.setMoclClzSimpleName(c.getSimpleName());
		mockClzCreateResult.setClzBeMock(c);
		String methodName = Common.getDefaultCreateMethodName(c);
		mockClzCreateResult.setFactoryMethodName(methodName);
		StringBuilder sb = new StringBuilder();
		String classBegin = genClassBegin(c, context);
		context.getPackageSB().append(Common.genPackage(c, context.getVariableMap()));
		context.getImportSB()
				.append(Common.genimportStr(c, context.getAlreadyImportClasses(), context.getVariableMap()));
		String methodBody = genAllMethodMockLines(c, context);
		Common.setModifier(Modifier.PUBLIC | Modifier.STATIC, context);
		context.getVariableMap().put(Replacement.METHOD_RETURN_TYPE.name(), c.getSimpleName());
		context.getVariableMap().put(Replacement.METHOD_NAME.name(), methodName);
		context.getVariableMap().put(Replacement.METHOD_PARAMS_DECLARE.name(), "");
		String returnTypeInstanceName = Common.getInstanceName(c);
		context.getVariableMap().put(Replacement.METHOD_BODY.name(), methodBody);
		context.getVariableMap().put(Replacement.METHOD_RETURN_VALUE.name(), returnTypeInstanceName);
		context.getVariableMap().put(Replacement.THROWS_EXCEPTION.name(), "");
		String mockMethodCreateStr = Common.replaceAllKeyWord(Syntax.NORMAL_METHOD, context.getVariableMap());
		sb.append(context.getPackageSB()).append(Syntax.NEW_LINE).append(context.getImportSB()).append(classBegin);
		sb.append(Syntax.NEW_LINE).append(mockMethodCreateStr);
		sb.append(Syntax.NEW_LINE).append(context.getCreatedComplexTypeMethod());
		sb.append(Syntax.NEW_LINE).append(Syntax.CLASS_END_LINE);
		context.clearExceptGlobalParam();
		mockClzCreateResult.setCode(sb.toString());
		return mockClzCreateResult;
	}
	public boolean isConcern(CodeGenContext context, Method m) {
		boolean b = false;
		codegen.MethodMatcher mi = context.getMethodMatchers().get(m.getDeclaringClass());
		boolean notEmptyMM = mi != null && mi.getMiList() != null && mi.getMiList().size() > 0;
		if (notEmptyMM) {
			for (codegen.MethodMatcher mm : mi.getMiList()) {
				if (mm.match(m)) {
					return true;
				}
			}
		} else {
			b = true;
		}
		return b;
	}
	public String genAllMethodMockLines(Class c, CodeGenContext context) throws Exception {
		context.renewSameTypeCreatedTimesMap();
		StringBuilder sb = new StringBuilder();
		StringBuilder mockMethodsLine = new StringBuilder();
		Method ms[] = Common.getAllPublicMethods(c);
		context.getVariableMap().put(Replacement.TMP_CLASS_NAME.name(), c.getSimpleName());
		String instanceName = Common.getInstanceName(c);
		context.getVariableMap().put(Replacement.TMP_INSTANCE_NAME.name(), instanceName);
		String mockClassLine = Common.replaceAllKeyWord(Syntax.MOCK_CLASS_LINE, context.getVariableMap());
		sb.append(mockClassLine);
		Common.importPack("org.mockito.*", context.getVariableMap(), context.getImportSB());
		boolean hasExceptionThrow = false;
		for (Method m : ms) {
			if (!Common.isStatic(m) && isConcern(context, m)// &&
			) {
				if (m.getExceptionTypes() != null && m.getExceptionTypes().length > 0) {
					hasExceptionThrow = true;
				}
				Class<?>[] ccs = Common.getConcreteClass(m.getParameterTypes(), context);
				if (!Common.isVoid(m)) {
					context.getVariableMap().put(Replacement.TMP_INSTANCE_NAME.name(), instanceName);
					context.getVariableMap().put(Replacement.METHOD_NAME.name(), m.getName());
					context.getImportSB().append(
							Common.genimportStr(context.getAlreadyImportClasses(), context.getVariableMap(), ccs));
					String paramVariables = Common.genUnitTestMatchersMethodParamsVariable(context.getVariableMap(),
							Common.getConcreteClass(m.getParameterTypes(), context));
					context.getVariableMap().put(Replacement.METHOD_PARAMS_VARIABLE.name(), paramVariables);
					String mockThrow = Common.replaceAllKeyWord(Syntax.MOCK_THROW, context.getVariableMap());
					Class rt = m.getReturnType();
					String returnValue = null;
					if (Common.isComplexType(rt)) {
						String typeName = m.getGenericReturnType().getTypeName();
						Class collectionGenericType = null;
						if (Common.isACollection(rt)) {
							String genericType = null;
							int start = typeName.indexOf("<");
							int end = typeName.indexOf(">");
							genericType = typeName.substring(start + 1, end);
							try {
								collectionGenericType = CodeGenContext.getInstance().getReloadableDynamicClassLoaderOwner().loadClass(genericType, true);
								Common.importC(collectionGenericType, context);
							} catch (Exception e1) {
							}
						}
						Common.importC(rt, context);
						Common.setModifier(Modifier.PUBLIC | Modifier.STATIC, context);
						MethodCallingVariable mc = Common.genIfNotExistAndGetClassCreateMethod(rt,
								new Class[] { collectionGenericType }, false, context);
						if (mc != null) {
							returnValue = Common.getInstanceName(rt, context.getSameTypeCreatedTimesMap());
							context.getVariableMap().put(Replacement.RETURN_TYPE.name(), rt.getSimpleName());
							context.getVariableMap().put(Replacement.RETURN_TYPE_INSTANCE.name(), returnValue);
							context.getVariableMap().put(Replacement.TMP_INSTANCE_NAME.name(),
									c.getSimpleName() + "Mock");
							context.getVariableMap().put(Replacement.METHOD_NAME.name(), mc.getMethodName());
							context.getVariableMap().put(Replacement.METHOD_PARAMS_VARIABLE.name(), "");
							String methodCallingStr = Common.replaceAllKeyWord(Syntax.METHOD_WITH_RETURN_CALLING,
									context.getVariableMap());
							mockMethodsLine.append(methodCallingStr);
						}
					} else {
						returnValue = Common.getDefaultVal(rt);
						returnValue = returnValue == null ? "" : returnValue;
					}
					context.getVariableMap().put(Replacement.TMP_INSTANCE_NAME.name(), instanceName);
					context.getVariableMap().put(Replacement.METHOD_RETURN_VALUE.name(), returnValue);
					context.getVariableMap().put(Replacement.METHOD_NAME.name(), m.getName());
					context.getVariableMap().put(Replacement.METHOD_PARAMS_VARIABLE.name(), paramVariables);
					String mockWithReturn = Common.replaceAllKeyWord(Syntax.MOCK_RETURN, context.getVariableMap());
					mockMethodsLine.append(mockThrow).append(mockWithReturn);
				} else {
					context.getVariableMap().put(Replacement.TMP_INSTANCE_NAME.name(), instanceName);
					context.getVariableMap().put(Replacement.METHOD_NAME.name(), m.getName());
					Common.importC(ccs, context);
					String paramVariables = Common.genUnitTestMatchersMethodParamsVariable(context.getVariableMap(),
							ccs);
					context.getVariableMap().put(Replacement.METHOD_PARAMS_VARIABLE.name(), paramVariables);
					String mockThrow = Common.replaceAllKeyWord(Syntax.MOCK_THROW, context.getVariableMap());
					String mockReturnVoid = Common.replaceAllKeyWord(Syntax.MOCK_RETURN_VOID, context.getVariableMap());
					mockMethodsLine.append(mockThrow).append(mockReturnVoid);
				}
			} else {
			}
		}
		if (!hasExceptionThrow) {
			sb.append(mockMethodsLine).append(Syntax.NEW_LINE);
		} else {
			context.getVariableMap().put(Replacement.TRY_BODY.name(), mockMethodsLine.toString());
			context.getVariableMap().put(Replacement.EXCEPTION_NAME.name(), Exception.class.getSimpleName());
			context.getVariableMap().put(Replacement.EXCEPTION_INSTANCE_NAME.name(), "e");
			String exceptionsDeclare = Common.replaceAllKeyWord(Syntax.EXCEPTIONS_DECLARE_LINE,
					context.getVariableMap());
			context.getVariableMap().put(Replacement.EXCEPTIONS_DECLARE.name(), exceptionsDeclare);
			context.getVariableMap().put(Replacement.CATCH_BODY.name(), "e.printStackTrace();");
			context.getVariableMap().put(Replacement.FINALLY_BODY.name(), "");
			String tryCatch = Common.replaceAllKeyWord(Syntax.TRY_CATCH_BLOCK, context.getVariableMap());
			sb.append(tryCatch).append(Syntax.NEW_LINE);
		}
		return sb.toString();
	}
	/*
	 * @Deprecated public void genMock(Class clzToTest, String targetDirectory)
	 * throws Exception { String strForFile = genMockClassSource(clzToTest); if
	 * (strForFile == null) { return; } File file = new File(targetDirectory +
	 * File.separator + clzToTest.getSimpleName() + "Mock.java"); FileOutputStream
	 * fos = new FileOutputStream(file); FileChannel fc = fos.getChannel();
	 * ByteBuffer bb =
	 * Common.utf8CharsetEncoder.encode(CharBuffer.wrap(strForFile)); fc.write(bb);
	 * fc.close(); fos.close(); }
	 */
	public void genAllInterfaceMockUnderPack(Class oneOfClass, String targetDirectory) throws Exception {
		Package sourcePack = oneOfClass.getPackage();
		if (sourcePack == null) {
			System.out.println("sourcePack is null");
			return;
		}
		File file = new File(targetDirectory);
		if (file.listFiles() != null && file.listFiles().length > 0) {
			System.out.println(
					String.format("targetDirectory %s is not empty, will skip the generating", targetDirectory));
			return;
		}
		if (!file.exists()) {
			file.mkdirs();
		}
		List<Class> list = new ArrayList<>();
		Common.getAllTopLevelClasses(oneOfClass, true, list);
		CodeGenContext context = CodeGenContext.getInstance();
		list.forEach(c -> {
			try {
				if (c.isInterface()) {
					genMock(c, targetDirectory, context);
				}
			} catch (Exception e) {
				e.printStackTrace();
			}
		});
	}
	public static void main(String[] args) {
		MockClzFactoryGenerator gen = new MockClzFactoryGenerator();
		try {
			Class rt = Object.class;
			Map<Class, Short> map = new HashMap<>();
			System.out.println(Modifier.PRIVATE | Modifier.STATIC);
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\codegen\unittest\OneTestClassCreateParam.java---
package codegen.unittest;
import java.util.ArrayList;
import java.util.List;
public class OneTestClassCreateParam {
	Class<?> clzBeTest;
	List<FieldInitParams> fieldInitParamList=new ArrayList<>();
	List<MockClzCreateParams> mockClzCreateParamList=new ArrayList<>();
	List<MethodCaseCreateParam> MethodCaseCreateParamList =new ArrayList<>();
	private OneTestClassCreateResult oneTestClassCreateResult;
	public Class<?> getClzBeTest() {
		return clzBeTest;
	}
	public void setClzBeTest(Class<?> clzBeTest) {
		this.clzBeTest = clzBeTest;
	}
	public List<FieldInitParams> getFieldInitParamList() {
		return fieldInitParamList;
	}
	public void setFieldInitParamList(List<FieldInitParams> fieldInitParamList) {
		this.fieldInitParamList = fieldInitParamList;
	}
	public List<MockClzCreateParams> getMockClzCreateParamList() {
		return mockClzCreateParamList;
	}
	public void setMockClzCreateParamList(List<MockClzCreateParams> mockClzCreateParamList) {
		this.mockClzCreateParamList = mockClzCreateParamList;
	}
	public List<MethodCaseCreateParam> getMethodCaseCreateParamList() {
		return MethodCaseCreateParamList;
	}
	public void setMethodCaseCreateParamList(List<MethodCaseCreateParam> methodCaseCreateParamList) {
		MethodCaseCreateParamList = methodCaseCreateParamList;
	}
	public OneTestClassCreateResult getOneTestClassCreateResult() {
		return oneTestClassCreateResult;
	}
	public void setOneTestClassCreateResult(OneTestClassCreateResult oneTestClassCreateResult) {
		this.oneTestClassCreateResult = oneTestClassCreateResult;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\codegen\unittest\OneTestClassCreateResult.java---
package codegen.unittest;
import java.io.File;
public class OneTestClassCreateResult {
	private File file;
	private Class<?> clzForTest;
	private String code;
	public File getFile() {
		return file;
	}
	public void setFile(File file) {
		this.file = file;
	}
	public Class<?> getClzForTest() {
		return clzForTest;
	}
	public void setClzForTest(Class<?> clzForTest) {
		this.clzForTest = clzForTest;
	}
	public String getCode() {
		return code;
	}
	public void setCode(String code) {
		this.code = code;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\codegen\unittest\UnitTestCodeGeneratorDependOnClass.java---
package codegen.unittest;
import codegen.Const;
import codegen.Replacement;
import codegen.Syntax;
import codegen.complexobj.CodeGenContext;
import codegen.util.Common;
import java.io.File;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.lang.reflect.Parameter;
import java.util.ArrayList;
import java.util.List;
import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import java.util.stream.Stream;
public class UnitTestCodeGeneratorDependOnClass {
	MockClzFactoryGenerator im = new MockClzFactoryGenerator();
	int maxMethod = 10;
	ClzNeedMockDetermination cmd = new ClzNeedMockDetermination();
	public void init(Class<?> clzToTest, CodeGenContext context) {
		context.getVariableMap().put(Replacement.CLASS_NAME.name(), Common.getClassName(clzToTest, context));
		context.getVariableMap().put(Replacement.INSTANCE_NAME.name(), Common.getInstanceName(clzToTest));
	}
	public void genPackage(Class<?> clzToTest, CodeGenContext context) throws Exception {
		context.getVariableMap().put(Replacement.PACKAGE_NAME.name(), clzToTest.getPackage().getName());
		String packageStr = Common.replaceAllKeyWord(Syntax.PACKAGE_DECLARE, context.getVariableMap());
		context.getPackageSB().append(packageStr);
	}
	private void importSimple(String qualifier, CodeGenContext context) throws Exception {
		Class<?> c = null;
		try {
			c = CodeGenContext.getInstance().getReloadableDynamicClassLoaderOwner().loadClass(qualifier, true);
		} catch (Exception e) {
		}
		if (c != null)
			Common.importC(c, context);
	}
	public void genImport(Class<?> clzToTest, CodeGenContext context) throws Exception {
		Common.importC(clzToTest, context);
		Common.importPack("org.junit.*", context.getVariableMap(), context.getImportSB());
		Common.importPack("org.mockito.*", context.getVariableMap(), context.getImportSB());
	}
	public void determineGenTestParam(Class<?> clzToTest, GenTestParam gtp, CodeGenContext context) throws Exception {
		if (gtp == null) {
			gtp = new GenTestParam();
		}
		this.determineFields(clzToTest, gtp, context);
		this.determineMockClzFactoryCreateParams(clzToTest, gtp, context);
		this.determineMockClzCreateParams(clzToTest, gtp, context);
		this.determineMethodCaseCreateParams(clzToTest, gtp, context);
	}
	public void determineMockClzCreateParams(Class<?> clzToTest, GenTestParam gtp, CodeGenContext context)
			throws Exception {
		List<MockClzCreateParams> list = new ArrayList<>();
		List<FieldInitParams> fipList = gtp.getOneTestClassParamByClzEvenNotPresent(clzToTest).getFieldInitParamList();
		for (FieldInitParams fip : fipList) {
			Field f = fip.getField();
			Class<?> fType = f.getType();
			if (Common.isFinal(f) || f.getName().contains("$") || this.canIgnore(fType))
				continue;
			if (fip.isComplexType()) {
				Common.importC(fType, context);
				boolean isTooManyMethods = fip.isTooManyMethods();
				boolean needMockFactroy = fip.isNeedMockFactroyClz() || isTooManyMethods;
				boolean needMock = needMockFactroy ? cmd.needMock(fip.getFieldType()) : true;
				fip.setNeedMock(needMock);
				if (needMock) {
					MockClzCreateParams mcp = new MockClzCreateParams();
					mcp.setClzBeMock(clzToTest);
					list.add(mcp);
				}
			}
		}
	}
	public void determineMockClzFactoryCreateParams(Class<?> clzToTest, GenTestParam gtp, CodeGenContext context)
			throws Exception {
		List<MockClzFactoryCreateParam> list = gtp.getMockClzFactoryCreateParamList();
		List<FieldInitParams> fipList = gtp.getOneTestClassParamByClzEvenNotPresent(clzToTest).getFieldInitParamList();
		for (FieldInitParams fip : fipList) {
			Field f = fip.getField();
			Class<?> fType = f.getType();
			if (Common.isFinal(f) || f.getName().contains("$") || this.canIgnore(fType))
				continue;
			if (fip.isComplexType()) {
				fip.setNeedMock(cmd.needMock(fip.getFieldType()));
				boolean isTooManyMethods = fip.isTooManyMethods();
				boolean needMockFactroyClz = isTooManyMethods || fip.getFieldType().isInterface();
				fip.setNeedMockFactroyClz(needMockFactroyClz);
				if (needMockFactroyClz) {
					MockClzFactoryCreateParam mccp = new MockClzFactoryCreateParam();
					if (!list.stream().anyMatch(e -> {
						return e.getClzBeMock().equals(fType);
					})) {
						mccp.setClzBeMock(fType);
						mccp.setFactoryMethodName("create" + fType.getSimpleName());
						mccp.setTargetDir(gtp.getTargetDir() + File.separator + "mock");
						list.add(mccp);
					}
				}
			} else {
				fip.setNeedMock(false);
				fip.setNeedMockFactroyClz(false);
			}
		}
	}
	public void determineFields(Class<?> clzToTest, GenTestParam gtp, CodeGenContext context) throws Exception {
		List<FieldInitParams> list = new ArrayList<>();
		List<String> concernedPackageNames = Common.getDefaultConcernedPacks(clzToTest);
		Common.getAllFields(clzToTest, concernedPackageNames, context.getAllFieldList());
		Field fa[] = context.getAllFieldList().toArray(new Field[0]);
		for (Field f : fa) {
			Class<?> fType = f.getType();
			if (Common.isFinal(f) || f.getName().contains("$") || canIgnore(fType))
				continue;
			FieldInitParams fieldInitParams = new FieldInitParams();
			boolean isTooManyMethods = Common.getAllDeclaredPublicMethodsForTest(fType).length > maxMethod ? true
					: false;
			fieldInitParams.setTooManyMethods(isTooManyMethods);
			fieldInitParams.setField(f);
			fieldInitParams.setMod(Modifier.PRIVATE);
			fieldInitParams.setFieldType(fType);
			fieldInitParams.setFieldName(Common.getInstanceName(fType));
			fieldInitParams.setComplexType(Common.isComplexType(fType));
			list.add(fieldInitParams);
		}
		gtp.getOneTestClassParamByClzEvenNotPresent(clzToTest).getFieldInitParamList().addAll(list);
	}
	public void determineMethodCaseCreateParams(Class<?> clzToTest, GenTestParam gtp, CodeGenContext context)
			throws Exception {
		Method ms[] = Common.getAllDeclaredPublicMethodsForTest(clzToTest);
		for (Method m : ms) {
			determineOneMethod(clzToTest, gtp, m, context);
		}
	}
	public void determineOneMethod(Class<?> clzToTest, GenTestParam gtp, Method m, CodeGenContext context) {
		MethodCaseCreateParam methodCaseCreateParam = new MethodCaseCreateParam();
		methodCaseCreateParam.setMod(Modifier.PUBLIC);
		methodCaseCreateParam.setMethodForTest(m);
		methodCaseCreateParam.setReturnType(m.getReturnType());
		String testMethodName = Common.makeFirstCharInUpperCase(m.getName());
		methodCaseCreateParam.setMethodName(Common.getMethodName(testMethodName, context));
		gtp.getOneTestClassParamByClzEvenNotPresent(clzToTest).getMethodCaseCreateParamList()
				.add(methodCaseCreateParam);
		Class<?> expClasses[] = m.getExceptionTypes();
		String expCaseNameFormat = "test%sWhen%s";
		for (Class<?> exp : expClasses) {
			MethodCaseCreateParam methodCaseCreateParam1 = new MethodCaseCreateParam();
			methodCaseCreateParam1.setMod(Modifier.PUBLIC);
			methodCaseCreateParam1.setReturnType(m.getReturnType());
			methodCaseCreateParam1.setMethodName(
					Common.getMethodName(String.format(expCaseNameFormat, m.getName(), exp.getSimpleName()), context));
			methodCaseCreateParam1.setExpected(exp);
			methodCaseCreateParam1.setMethodForTest(m);
			methodCaseCreateParam1.setThrowExp(exp);
			gtp.getOneTestClassParamByClzEvenNotPresent(clzToTest).getMethodCaseCreateParamList()
					.add(methodCaseCreateParam1);
		}
	}
	public void genFields(Class<?> clzToTest, GenTestParam gtp, CodeGenContext context) throws Exception {
		List<FieldInitParams> fipList = gtp.getOneTestClassParamByClzEvenNotPresent(clzToTest).getFieldInitParamList();
		for (FieldInitParams fip : fipList) {
			Field f = fip.getField();
			Class<?> fType = fip.getFieldType();
			if (Common.isFinal(f) || f.getName().contains("$") || canIgnore(fType))
				continue;
			String fieldTypeName = fType.getName();
			importSimple(fieldTypeName, context);
			String fieldTypeSimpleName = fType.getSimpleName();
			context.getVariableMap().put(Replacement.FIELD_CLASS_NAME.name(), fieldTypeSimpleName);
			context.getVariableMap().put(Replacement.FIELD_INSTANCE_NAME.name(), f.getName());
			Common.setModifier(Modifier.PRIVATE, context);
			String fieldStr = Common.replaceAllKeyWord(Syntax.FIELD_DECLARE, context.getVariableMap());
			context.getFieldsSB().append(fieldStr);
		}
		String fieldTypeSimpleName = clzToTest.getSimpleName();
		context.getVariableMap().put(Replacement.FIELD_CLASS_NAME.name(), fieldTypeSimpleName);
		context.getVariableMap().put(Replacement.FIELD_INSTANCE_NAME.name(), Common.getInstanceName(clzToTest));
		Common.setModifier(Modifier.PRIVATE, context);
		String fieldStr = Common.replaceAllKeyWord(Syntax.FIELD_DECLARE, context.getVariableMap());
		context.getFieldsSB().append(fieldStr);
		if (fipList.size() > 0) {
			Common.importC(Field.class, context);
			String setTargetObjFieldMethodStr = Common.replaceAllKeyWord(Syntax.UNIT_TEST_SET_TARGET_OBJ_FIELD_METHOD,
					context.getVariableMap());
			String getFieldMethodStr = Common.replaceAllKeyWord(Syntax.UNIT_TEST_GET_FIELD_METHOD,
					context.getVariableMap());
			context.getAddtionalMethods().append(Syntax.NEW_LINE).append(setTargetObjFieldMethodStr);
			context.getAddtionalMethods().append(getFieldMethodStr);
		}
	}
	private boolean canIgnore(Class<?> fieldType) {
		boolean b = false;
		if (fieldType.isAssignableFrom(Logger.class)) {
			b = true;
		}
		if (fieldType.isAssignableFrom(org.slf4j.Logger.class)) {
			b = true;
		}
		if ("logger".equalsIgnoreCase(fieldType.getSimpleName())) {
			b = true;
		}
		return b;
	}
	public void genSetup(Class<?> clzToTest, GenTestParam gtp, CodeGenContext context) throws Exception {
		List<FieldInitParams> fipList = gtp.getOneTestClassParamByClzEvenNotPresent(clzToTest).getFieldInitParamList();
		String setupStr = Common.replaceAllKeyWord(Syntax.NORMAL_SETUP_BEGIN_LINE, context.getVariableMap());
		context.getSetupSB().append(setupStr);
		context.getSetupSB().append(Common.initAClass(clzToTest, context));
		String clzToTestInstanceName = Common.getInstanceName(clzToTest);
		for (FieldInitParams fip : fipList) {
			Field f = fip.getField();
			Class<?> fType = f.getType();
			if (Common.isFinal(f) || f.getName().contains("$") || this.canIgnore(fType))
				continue;
			if (fip.isNeedMockFactroyClz()) {
				MockClzFactoryCreateResult mccr = gtp.getMockClzFactoryCreateResult(fType);
				if (mccr != null) {
					context.getVariableMap().put(Replacement.RETURN_TYPE.name(), "");
					context.getVariableMap().put(Replacement.RETURN_TYPE_INSTANCE.name(), f.getName());
					context.getVariableMap().put(Replacement.TMP_INSTANCE_NAME.name(), Common.getDefaultVal(fType));
					context.getVariableMap().put(Replacement.METHOD_NAME.name(), mccr.getFactoryMethodName());
					context.getVariableMap().put(Replacement.METHOD_PARAMS_VARIABLE.name(), "");
					String mockClzFactoryCallLine = Common.replaceAllKeyWord(Syntax.METHOD_WITH_RETURN_CALLING,
							context.getVariableMap());
					context.getSetupSB().append(mockClzFactoryCallLine);
				} else {
					throw new Exception(String.format("cannot get MockClzFactoryCreateResult for mockClz %s", fType));
				}
			} else if (fip.isNeedMock()) {
				tryRegistryMockConcreteClass(fType, context);
				Common.importC(fType, context);
				context.getVariableMap().put(Replacement.TMP_CLASS_NAME.name(), fType.getSimpleName());
				String mockLine = Common.replaceAllKeyWord(Syntax.MOCK_CLASS_LINE, context.getVariableMap());
				context.getSetupSB().append(mockLine);
			}
			boolean isPrimitiveType = Common.isPrimitiveType(fType);
			if (isPrimitiveType) {
				context.getVariableMap().put(Replacement.TMP_CLASS_NAME.name(), "");
				context.getVariableMap().put(Replacement.DEFAULT_VALUE.name(), Common.getDefaultVal(fType));
				context.getVariableMap().put(Replacement.SEPERATOR.name(), "");
				String fieldAssign = Common.replaceAllKeyWord(Syntax.INIT_CLASS_WITH_DEFAULT_VALUE,
						context.getVariableMap());
				context.getSetupSB().append(fieldAssign);
			}
			context.getVariableMap().put(Replacement.TMP_INSTANCE_NAME.name(), clzToTestInstanceName);
			context.getVariableMap().put(Replacement.FIELD_INSTANCE_NAME.name(), f.getName());
			context.getVariableMap().put(Replacement.FIELD_VALUE.name(), f.getName());
			String setFieldMethodStr = Common.replaceAllKeyWord(Syntax.UNIT_TEST_SET_TARGET_OBJ_FIELD_CALLING,
					context.getVariableMap());
			context.getSetupSB().append(setFieldMethodStr);
		}
		context.getSetupSB().append(Syntax.METHOD_END_LINE);
	}
	public void tryRegistryMockConcreteClass(Class<?> c, CodeGenContext context) {
		String mockClassName = Common.getDefaultMockClassName(c, context);
		try {
			Class<?> mockC = CodeGenContext.getInstance().getReloadableDynamicClassLoaderOwner().loadClass(mockClassName, true);
			String defaultCreateMethodName = Common.getDefaultCreateMethodName(c);
			Method ms[] = Common.getAllDeclaredPublicMethodsForTest(mockC);
			for (Method m : ms) {
				if (m.getName().equals(defaultCreateMethodName) && m.getParameterCount() == 0) {
					context.registerAbstractConcreteClassMappingSimple(c, mockC, defaultCreateMethodName);
					break;
				}
			}
		} catch (ClassNotFoundException e) {
		}
	}
	public StringBuilder genOneParamObject(Class<?> paramClz) {
		return null;
	}
	@SuppressWarnings("unused")
	private static String getEnumCreateStr(Class<?> c) {
		StringBuilder sb = new StringBuilder();
		String classNameForPrint = c.getName().replaceAll("\\$", "\\.");
		Object obj[] = c.getEnumConstants();
		sb.append(classNameForPrint).append(".").append(obj[0].toString());
		return sb.toString();
	}
	public String getComplexTypeCreateMethodName(Class<?> target, CodeGenContext context) {
		String methodName = "create" + target.getSimpleName();
		int sameMethodNameCound = 0;
		for (String name : context.getCreatedMethodName()) {
			Pattern p = Pattern.compile(methodName + "(\\d*)");
			Matcher m = p.matcher(name);
			if (m.find()) {
				String methodNameIndex = m.group(1);
				if (methodNameIndex != null && !"".equals(methodNameIndex.trim())) {
					try {
						sameMethodNameCound = Integer.valueOf(methodNameIndex);
					} catch (Exception e) {
						throw e;
					}
				}
				sameMethodNameCound++;
			}
		}
		if (sameMethodNameCound > 0)
			methodName = methodName + sameMethodNameCound;
		return methodName;
	}
	public void genAllTestCase(GenTestParam gtp, Class<?> clzToTest, CodeGenContext context) throws Exception {
		List<MethodCaseCreateParam> mcpList = gtp.getOneTestClassParamByClzEvenNotPresent(clzToTest)
				.getMethodCaseCreateParamList();
		for (MethodCaseCreateParam mcp : mcpList) {
			context.getAllTestCaseSB().append(genOneTestCase(clzToTest, mcp, context));
		}
	}
	public String genOneTestCase(Class<?> clzToTest, MethodCaseCreateParam mcc, CodeGenContext context)
			throws Exception {
		boolean isStatic = Common.isStatic(mcc.getMethodForTest());
		String clzInstanceName = Common.getInstanceName(clzToTest);
		context.getVariableMap().put(Replacement.METHOD_NAME.name(), mcc.getMethodName());
		StringBuilder sb = new StringBuilder();
		StringBuilder caseBodyExceptTryCatch = new StringBuilder();
		sb.append(Syntax.NEW_LINE);
		String caseBeginStr = Common.replaceAllKeyWord(Syntax.NORMAL_TEST_CASE_BEGIN_LINE, context.getVariableMap());
		sb.append(caseBeginStr).append(Syntax.NEW_LINE);
		Class<?> returnType = mcc.getReturnType();
		/** begin of method calling replacement **/
		Parameter[] ps = mcc.getMethodForTest().getParameters();
		Class<?> paramClasses[] = mcc.getMethodForTest().getParameterTypes();
		StringBuilder methodParamVariables = new StringBuilder();
		for (Parameter p : ps) {
			Class<?> c = p.getType();
			if (c != null) {
				String name = p.getName();
				Common.importC(c, context);
				String value = "null";
				if (!Common.isComplexType(c)) {
					value = Common.getDefaultVal(c);
				} else {
					Class<?> collectionGenericType = null;
					if (Common.isACollection(c)) {
						String genericType = null;
						String typeName = null;
						typeName = p.getParameterizedType().getTypeName();
						int start = typeName.indexOf("<");
						int end = typeName.indexOf(">");
						genericType = typeName.substring(start + 1, end);
						try {
							collectionGenericType = CodeGenContext.getInstance().getReloadableDynamicClassLoaderOwner().loadClass(genericType, true);
							Common.importC(collectionGenericType, context);
						} catch (Exception e1) {
						}
					}
					MethodCallingVariable mc = Common.genIfNotExistAndGetClassCreateMethod(c,
							new Class[] { collectionGenericType }, false, context);
					if (mc != null)
						value = mc.getMethodName() + "()";
				}
				context.getVariableMap().put(Replacement.TMP_CLASS_NAME.name(), Common.getClassName(c, context));
				context.getVariableMap().put(Replacement.TMP_INSTANCE_NAME.name(), name);
				context.getVariableMap().put(Replacement.TMP_INSTANCE_VALUE.name(), value);
				String paramAssignment = Common.replaceAllKeyWord(Syntax.ASSIGN_LINE, context.getVariableMap());
				caseBodyExceptTryCatch.append(Syntax.NEW_LINE).append(paramAssignment);
				methodParamVariables.append(name).append(", ");
			} else {
				System.out.println(String.format("p type %s is null", p));
			}
		}
		if (methodParamVariables.length() > 0) {
			methodParamVariables.delete(methodParamVariables.length() - 2, methodParamVariables.length());
		}
		String returnTypeInstanceName = Common.getInstanceName(returnType);
		boolean isVoidMethod = Common.isVoid(mcc.getMethodForTest());
		if (!isVoidMethod) {
			context.getVariableMap().put(Replacement.RETURN_TYPE.name(), Common.getClassName(returnType, context));
			context.getVariableMap().put(Replacement.RETURN_TYPE_INSTANCE.name(), returnTypeInstanceName);
		}
		String tempInstanceName = !isStatic ? clzInstanceName : clzToTest.getSimpleName();
		context.getVariableMap().put(Replacement.TMP_INSTANCE_NAME.name(), tempInstanceName);
		context.getVariableMap().put(Replacement.METHOD_NAME.name(), mcc.getMethodForTest().getName());
		context.getVariableMap().put(Replacement.METHOD_PARAMS_VARIABLE.name(), methodParamVariables.toString());
		String methodCallingStr = Common.replaceAllKeyWord(
				isVoidMethod ? Syntax.VOID_METHOD_CALLING : Syntax.METHOD_WITH_RETURN_CALLING,
				context.getVariableMap());
		caseBodyExceptTryCatch.append(Syntax.NEW_LINE).append(methodCallingStr);
		/** end of method calling replacement **/
		if (!isVoidMethod) {
			if (!returnType.isPrimitive()) {
				context.getVariableMap().put(Replacement.TMP_INSTANCE_NAME.name(), returnTypeInstanceName);
				String assertNotNull = Common.replaceAllKeyWord(Syntax.ASSERT_NOT_NULL, context.getVariableMap());
				caseBodyExceptTryCatch.append(Syntax.NEW_LINE).append(assertNotNull);
			}
			String expectedReturnTypeInstanceName = Common.getInstanceName(returnType, "expected");
			String value = null;
			if (!Common.isComplexType(returnType)) {
				value = Common.getDefaultVal(returnType);
			} else {
				/*
				 * MethodCallingVariable mc =
				 * Common.genIfNotExistAndGetClassCreateMethod(returnType, true, context); value
				 * = mc.getMethodName() + "()";
				 */
			}
			context.getVariableMap().put(Replacement.TMP_CLASS_NAME.name(), Common.getClassName(returnType, context));
			context.getVariableMap().put(Replacement.TMP_INSTANCE_NAME.name(), expectedReturnTypeInstanceName);
			context.getVariableMap().put(Replacement.TMP_INSTANCE_VALUE.name(), value);
			String expectedReturnTypeAssign = Common.replaceAllKeyWord(Syntax.ASSIGN_LINE, context.getVariableMap());
			context.getVariableMap().put(Replacement.EXPECT_VALUE.name(), expectedReturnTypeInstanceName);
			context.getVariableMap().put(Replacement.ACTUAL_VALUE.name(), returnTypeInstanceName);
			String assertEqual = Common.replaceAllKeyWord(Syntax.ASSERT_EQUAL, context.getVariableMap());
			Common.importC(returnType, context);
		}
		context.getVariableMap().put(Replacement.INSTANCE_NAME.name(), clzInstanceName);
		context.getVariableMap().put(Replacement.METHOD_NAME.name(), mcc.getMethodName());
		StringBuilder methodMatchVariables = new StringBuilder();
		for (int i = 0; i < ps.length; i++) {
			String anyMatch = Common.replaceAllKeyWord(Syntax.ANY_MATCH, context.getVariableMap());
			methodMatchVariables.append(anyMatch).append(", ");
		}
		if (methodMatchVariables.length() > 0) {
			methodMatchVariables.delete(methodMatchVariables.length() - 2, methodMatchVariables.length());
		}
		context.getVariableMap().put(Replacement.MATCH_PARAMS_VARIABLE.name(), methodMatchVariables.toString());
		String mockitoVerify = Common.replaceAllKeyWord(Syntax.MOCKITO_VERIFY, context.getVariableMap());
		Class<?> expClasses[] = mcc.getMethodForTest().getExceptionTypes();
		if (expClasses == null || expClasses.length == 0) {
			sb.append(caseBodyExceptTryCatch);
		} else {
			String names = Stream.of(expClasses).map(e -> {
				return e.getSimpleName();
			}).collect(Collectors.joining(" | "));
			for (Class<?> e : expClasses) {
				Common.importC(e, context);
			}
			context.getVariableMap().put(Replacement.EXCEPTION_NAME.name(), names);
			context.getVariableMap().put(Replacement.EXCEPTION_INSTANCE_NAME.name(), "e");
			String exceptionsDeclare = Common.replaceAllKeyWord(Syntax.EXCEPTIONS_DECLARE_LINE,
					context.getVariableMap());
			context.getVariableMap().put(Replacement.TRY_BODY.name(), caseBodyExceptTryCatch.toString());
			String catchBody = Common.replaceAllKeyWord(Syntax.ASSERT_FAIL, context.getVariableMap());
			context.getVariableMap().put(Replacement.CATCH_BODY.name(), catchBody);
			context.getVariableMap().put(Replacement.FINALLY_BODY.name(), "");
			context.getVariableMap().put(Replacement.EXCEPTIONS_DECLARE.name(), exceptionsDeclare);
			String tryCatchBlock = Common.replaceAllKeyWord(Syntax.TRY_CATCH_BLOCK, context.getVariableMap());
			sb.append(tryCatchBlock);
		}
		sb.append(Syntax.NEW_LINE).append(Syntax.CLASS_END_LINE).append(Syntax.NEW_LINE);
		return sb.toString();
	}
	private String genClassBegin(Class<?> clzToTest, CodeGenContext context) throws Exception {
		String className = Common.getClassName(clzToTest, context) + "Test";
		Common.setModifier(Modifier.PUBLIC, context);
		context.getVariableMap().put(Replacement.TMP_CLASS_NAME.name(), className);
		String beginstr = Common.replaceAllKeyWord(Syntax.CLASS_BEGIN_LINE, context.getVariableMap());
		return beginstr;
	}
	public OneTestClassCreateResult genAllTest(Class<?> clzToTest, GenTestParam gtp, CodeGenContext context)
			throws Exception {
		if (clzToTest.isInterface() || clzToTest.getEnclosingClass() != null) {
			return null;
		}
		if (clzToTest.isEnum()) {
			return null;
		}
		OneTestClassCreateResult oneTestClassCreateResult = new OneTestClassCreateResult();
		oneTestClassCreateResult.setClzForTest(clzToTest);
		this.init(clzToTest, context);
		context.getVariableMap().put(Const.CLASS_SIMPLE_NAME_KEY, clzToTest.getSimpleName());
		context.getVariableMap().put(Const.CLASS_NAME_KEY, clzToTest.getName());
		StringBuilder sb = new StringBuilder();
		this.determineFields(clzToTest, gtp, context);
		this.determineMockClzFactoryCreateParams(clzToTest, gtp, context);
		this.determineMockClzCreateParams(clzToTest, gtp, context);
		List<MockClzFactoryCreateParam> mcfcpList = gtp.getMockClzFactoryCreateParamList();
		for (MockClzFactoryCreateParam mcfcp : mcfcpList) {
			MockClzFactoryCreateResult mcfcr = im.genMock(mcfcp.getClzBeMock(), mcfcp.getTargetDir(), context);
			if (mcfcr.getFile() == null) {
				throw new Exception(String.format("mock class %s file not created", mcfcp.getClzBeMock()));
			} else {
				gtp.getMockClzFactoryCreateResult().add(mcfcr);
			}
		}
		this.determineMethodCaseCreateParams(clzToTest, gtp, context);
		genPackage(clzToTest, context);
		genImport(clzToTest, context);
		List<MethodCaseCreateParam> list = gtp.getOneTestClassParamByClzEvenNotPresent(clzToTest)
				.getMethodCaseCreateParamList();
		gtp.getOneTestClassParamByClzEvenNotPresent(clzToTest).getFieldInitParamList();
		genFields(clzToTest, gtp, context);
		genSetup(clzToTest, gtp, context);
		for (MethodCaseCreateParam mcp : list) {
			String oneTestCase = genOneTestCase(clzToTest, mcp, context);
			context.getAllTestCaseSB().append(oneTestCase);
		}
		sb.append(context.getPackageSB());
		sb.append(context.getImportSB());
		sb.append(genClassBegin(clzToTest, context));
		sb.append(context.getFieldsSB());
		sb.append(context.getSetupSB());
		sb.append(context.getAddtionalMethods());
		sb.append(context.getAllTestCaseSB());
		sb.append(context.getCreatedComplexTypeMethod());
		sb.append(Syntax.CLASS_END_LINE);
		context.clearExceptGlobalParam();
		oneTestClassCreateResult.setCode(sb.toString());
		gtp.getOneTestClassParamByClz(clzToTest).setOneTestClassCreateResult(oneTestClassCreateResult);
		File dir = Common.getFileByPackage(gtp.getTargetDir(), clzToTest.getPackage().getName());
		if (!dir.isDirectory()) {
			dir.mkdirs();
		}
		File file = new File(dir.getAbsolutePath() + File.separator + clzToTest.getSimpleName() + "Test.java");
		Common.write(file, sb.toString());
		oneTestClassCreateResult.setFile(file);
		return oneTestClassCreateResult;
	}
	public void genAllTestCasesAndSave(Class<?> clzToTest, GenTestParam gtp, CodeGenContext context) throws Exception {
		File file = new File(gtp.getTargetDir());
		boolean isMockClzFactoryCreated = !gtp.getMockClzFactoryCreateResult().isEmpty();
		boolean isTestClzFileCreated = gtp.getOneTestClassParamByClz(clzToTest) != null
				&& gtp.getOneTestClassParamByClz(clzToTest).getOneTestClassCreateResult() != null ? true : false;
		if (!isMockClzFactoryCreated && !isTestClzFileCreated && !gtp.getMockClzFactoryCreateResult().isEmpty()
				&& file.listFiles() != null && file.listFiles().length > 0) {
			System.out.println(
					String.format("targetDirectory %s is not empty, will skip the generating", gtp.getTargetDir()));
			return;
		}
		if (!file.exists()) {
			file.mkdirs();
		}
		OneTestClassCreateResult oneTestClassCreateResult = genAllTest(clzToTest, gtp, context);
		if (oneTestClassCreateResult == null) {
			return;
		}
	}
	@SuppressWarnings("rawtypes")
	public void genAllTestUnderPack(Class<?> oneOfClass, GenTestParam gtp, CodeGenContext context) throws Exception {
		Package sourcePack = oneOfClass.getPackage();
		if (sourcePack == null) {
			System.out.println("sourcePack is null");
			return;
		}
		File file = new File(gtp.getTargetDir());
		if (file.listFiles() != null && file.listFiles().length > 0) {
			System.out.println(
					String.format("targetDirectory %s is not empty, will skip the generating", gtp.getTargetDir()));
			return;
		}
		if (!file.exists()) {
			file.mkdirs();
		}
		List<Class> list = new ArrayList<>();
		Common.getAllTopLevelClasses(oneOfClass, true, list);
		list.forEach(c -> {
			try {
				genAllTestCasesAndSave(c, gtp, context);
			} catch (Exception e) {
				e.printStackTrace();
			}
		});
	}
	public static void main(String[] args) {
		UnitTestCodeGeneratorDependOnClass app = new UnitTestCodeGeneratorDependOnClass();
		try {
			Class<?> c = ClassLoader.getSystemClassLoader().loadClass("classfortest.Test1");
			GenTestParam gtp = new GenTestParam();
			gtp.setTargetDir("d:\\test1\\test2");
			app.genAllTestUnderPack(c, gtp, CodeGenContext.newInstance());
		} catch (Exception e) {
			e.printStackTrace();
		}
		/*
		 * Class c = ClassToTest.class; try { app.genAllTest(c, "c:\\"); } catch
		 * (Exception e) { // TODO Auto-generated catch block e.printStackTrace(); }
		 */
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\codegen\util\ClipBoard.java---
package codegen.util;
import java.awt.*;
import java.awt.datatransfer.Clipboard;
import java.awt.datatransfer.DataFlavor;
import java.awt.datatransfer.FlavorListener;
import java.awt.datatransfer.StringSelection;
public class ClipBoard {
	public static Toolkit toolkit = Toolkit.getDefaultToolkit();
	public static Clipboard clipboard = toolkit.getSystemClipboard();
	public static void addFlavorListener(FlavorListener l) {
		clipboard.addFlavorListener(l);
	}
	public static void setStringUtilSuccess(String srcData) {
		boolean b = false;
		do {
			try {
				StringSelection contents = new StringSelection(srcData);
				clipboard.setContents(contents, null);
				b = true;
			} catch (Exception e) {
			}
		} while (!b);
	}
	public static String getString() {
		String str = null;
		try {
			str = (String) clipboard.getData(DataFlavor.stringFlavor);
		} catch (Exception e) {
			System.out.println("cannot get clipboard string");
		}
		return str;
	}
	public static Image getImage() {
		Image img = null;
		try {
			img = (Image) clipboard.getData(DataFlavor.imageFlavor);
		} catch (Exception e) {
			System.out.println("cannot get clipboard image");
		}
		return img;
	}
	public static Toolkit getToolkit() {
		return toolkit;
	}
	public static void setToolkit(Toolkit toolkit) {
		ClipBoard.toolkit = toolkit;
	}
	public static Clipboard getClipboard() {
		return clipboard;
	}
	public static void setClipboard(Clipboard clipboard) {
		ClipBoard.clipboard = clipboard;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\codegen\util\Common.java---
package codegen.util;
import codegen.AbstractConcreteClassMapping;
import codegen.Replacement;
import codegen.Syntax;
import codegen.complexobj.CodeGenContext;
import codegen.complexobj.PojoSetterGenerator;
import codegen.unittest.MethodCallingVariable;
import java.io.*;
import java.lang.annotation.Annotation;
import java.lang.reflect.*;
import java.net.MalformedURLException;
import java.net.URISyntaxException;
import java.net.URL;
import java.nio.charset.Charset;
import java.nio.charset.CharsetDecoder;
import java.nio.charset.CharsetEncoder;
import java.nio.file.FileSystem;
import java.nio.file.*;
import java.security.CodeSource;
import java.security.ProtectionDomain;
import java.sql.Date;
import java.util.*;
import java.util.Map.Entry;
import java.util.concurrent.ThreadLocalRandom;
import java.util.jar.JarEntry;
import java.util.jar.JarFile;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;
public class Common {
	public static Charset utf8Charset = Charset.forName("UTF-8");
	public static CharsetEncoder utf8CharsetEncoder = utf8Charset.newEncoder();
	public static CharsetDecoder utf8CharsetDecoder = utf8Charset.newDecoder();
	public static String getRunningJar() {
		ProtectionDomain protectionDomain = Common.class.getProtectionDomain();
		CodeSource codeSource = protectionDomain.getCodeSource();
		URL uRL = codeSource.getLocation();
		String path = uRL.getPath();
		File jarFile = new File(path);
		String jarFilePath = jarFile.getAbsolutePath();
		return jarFilePath;
	}
	public static String getWorkingDir() {
		ProtectionDomain protectionDomain = Common.class.getProtectionDomain();
		CodeSource codeSource = protectionDomain.getCodeSource();
		URL uRL = codeSource.getLocation();
		String path = uRL.getPath();
		File jarFile = new File(path);
		String jarFilePath = jarFile.getAbsolutePath();
		String s = jarFilePath.replace(jarFile.getName(), "");
		return s;
	}
	public static Class[] getClassByName(String... clzNames) {
		List<Class<?>> list = new ArrayList<>();
		for(String name : clzNames) {
			Class<?> c = null;
			try {
				if(null==c) {
					c = Class.forName(name, false, Common.class.getClassLoader());
				}
			} catch (Exception e) {
			}
			if(null!=c) {
				list.add(c);
			}
		}
		return list.toArray(new Class[list.size()] );
	}
	public static Class getClzByName(String clzName) {
		Class o = null;
		try {
			o = CodeGenContext.getInstance().getReloadableDynamicClassLoaderOwner().loadClass(clzName, true);
		} catch (Exception e) {
			boolean isArrayType = false;
			String name = null;
			if (clzName.trim().endsWith("[]")) {
				isArrayType = true;
				String componentType = clzName.replaceAll("\\[\\]", "");
				name = componentType;
			} else {
				name = clzName;
			}
			try {
				Class componentClz = CodeGenContext.getInstance().getReloadableDynamicClassLoaderOwner().loadClass(name,
						true);
			} catch (ClassNotFoundException e1) {
				if (void.class.getSimpleName().equals(name)) {
					o = void.class;
				} else if (name.equals("java.lang.Object")) {
					o = Object.class;
				} else if (name.equals("java.lang.String")) {
					o = String.class;
				} else if (name.equals("java.lang.Boolean")) {
					o = Boolean.class;
				} else if (name.equals("java.lang.Long")) {
					o = Long.class;
				} else if (name.equals("java.lang.Double")) {
					o = Double.class;
				} else if (name.equals("java.lang.Integer")) {
					o = Integer.class;
				} else if (name.equals("java.lang.Short")) {
					o = Short.class;
				} else if (name.equals("java.lang.Float")) {
					o = Float.class;
				} else if (name.equals("java.lang.Byte")) {
					o = Byte.class;
				} else if (name.equals("java.lang.Character")) {
					o = Character.class;
				} else if (name.equals("java.sql.Date")) {
					o = Date.class;
				} else if (name.equals("boolean")) {
					o = boolean.class;
				} else if (name.equals("long")) {
					o = long.class;
				} else if (name.equals("double")) {
					o = double.class;
				} else if (name.equals("int")) {
					o = int.class;
				} else if (name.equals("short")) {
					o = short.class;
				} else if (name.equals("float")) {
					o = float.class;
				} else if (name.equals("byte")) {
					o = byte.class;
				} else if (name.equals("char")) {
					o = char.class;
				} else if (name.equals("java.sql.Timestamp")) {
					o = java.sql.Timestamp.class;
				} else if (name.equals("java.util.Date")) {
					o = Date.class;
				} else if (name.startsWith("java.util.Map")) {
					o = HashMap.class;
				} else if (name.startsWith("java.util.Set")) {
					o = HashSet.class;
				} else if (name.equals("java.math.BigInteger")) {
					o = java.math.BigInteger.class;
				} else if (name.equals("java.math.BigDecimal")) {
					o = java.math.BigDecimal.class;
				}
			}
			if (isArrayType) {
				Object arrayObj = Array.newInstance(o, 1);
				o = arrayObj.getClass();
			}
		}
		return o;
	}
	public static <T extends Annotation> T getParameterAnnotationByType(Class<T> c, Parameter param) {
		Annotation panns1[] = param.getAnnotations();
		Annotation ann = null;
		for (Annotation an : panns1) {
			if (c.isAssignableFrom(an.annotationType())) {
				ann = an;
				break;
			}
		}
		return (T) ann;
	}
	public static List<String> getDefaultConcernedPacks(Class c) {
		List<String> concernedPacks = new ArrayList<String>();
		String packageName = c.getPackage() != null ? c.getPackage().getName() : "";
		String packDeep[] = packageName.split("\\.");
		StringBuilder sb = new StringBuilder();
		if (packDeep.length > 2) {
			for (int i = 0; i <= 2; i++) {
				sb.append(packDeep[i]).append(".");
			}
			sb.delete(sb.length() - 1, sb.length());
		} else {
			sb.append(packageName);
		}
		concernedPacks.add(sb.toString());
		return concernedPacks;
	}
	public static boolean isConcernPack(String packName, List<String> concernedPackageNames) {
		boolean isconcern = false;
		isconcern = concernedPackageNames.stream().anyMatch(cp -> {
			if (packName.startsWith(cp.trim())) {
				return true;
			} else {
				return false;
			}
		});
		return isconcern;
	}
	public static List<Field> getAllFields(Class c) {
		List<Field> allFieldList = new ArrayList<>();
		while (c != Object.class) {
			allFieldList.addAll(Arrays.asList(c.getDeclaredFields()));
			c = c.getSuperclass();
		}
		return allFieldList;
	}
	public static void getAllFields(Class c, List<String> concernedPackageNames, List<Field> allFieldList) {
		for (Field f : c.getDeclaredFields()) {
			allFieldList.add(f);
		}
		Class superClass = c.getSuperclass();
		if (superClass != null) {
			String packName = superClass.getPackage().getName();
			isConcernPack(packName, concernedPackageNames);
			getAllFields(superClass, concernedPackageNames, allFieldList);
		}
	}
	public static void getAllFieldNames(Class c, List<String> concernedPackageNames, List<String> allFieldList) {
		for (Field f : c.getDeclaredFields()) {
			allFieldList.add(f.getName());
		}
		Class superClass = c.getSuperclass();
		if (superClass != null) {
			String packName = superClass.getPackage().getName();
			isConcernPack(packName, concernedPackageNames);
			getAllFieldNames(superClass, concernedPackageNames, allFieldList);
		}
	}
	public static Boolean isMethodReturnBoolean(Method m) {
		boolean b = false;
		Class c = m.getReturnType();
		if (Boolean.class.equals(c) || boolean.class.equals(c)) {
			b = true;
		}
		return b;
	}
	public static boolean isMethodReturnCollectionType(Method m) {
		boolean b = false;
		Class c = m.getReturnType();
		if (isACollection(c)) {
			b = true;
		}
		return b;
	}
	public static boolean isACollection(Class s) {
		boolean b = false;
		if (Collection.class.isAssignableFrom(s)) {
			b = true;
		}
		return b;
	}
	@Deprecated
	public static Class getOneClassUnderDirectory(String packName, String directory) {
		Class c = null;
		File childDirectory = new File(directory);
		if (childDirectory.isDirectory()) {
			File files[] = childDirectory.listFiles();
			if (files != null) {
				for (File file : files) {
					if (file.getName().endsWith(".class")) {
						StringBuilder sb = new StringBuilder(file.getName());
						String className = sb.delete(sb.length() - 6, sb.length()).toString();
						try {
							c = CodeGenContext.getInstance().getReloadableDynamicClassLoaderOwner()
									.loadClass(packName + "." + className, true);
							return c;
						} catch (Exception e) {
						}
					}
				}
			}
		}
		return c;
	}
	public static void getClassesUnderPackage(Class oneOfClass, List<Class> classList) {
		String packName = oneOfClass.getPackage().getName();
		if ("".equals(packName)) {
			getAllTopLevelClassesInClassesDirectory(oneOfClass, classList);
		} else {
			List<String> loadedClzNames = CodeGenContext.getInstance().getLoadedClassesName();
			List<String> claNames = loadedClzNames.stream().filter(e -> e.startsWith(packName))
					.collect(Collectors.toList());
			for (String clzName : claNames) {
				try {
					Class<?> clz = CodeGenContext.getInstance().getReloadableDynamicClassLoaderOwner()
							.loadClass(clzName, true);
					classList.add(clz);
				} catch (ClassNotFoundException e1) {
					System.out.println(String.format("cannot find class by name %s", clzName));
				}
			}
		}
	}
	public static void getAllTopLevelClassesInClassesDirectory(Class oneOfClass, List<Class> classList) {
		Package sourcePack = oneOfClass.getPackage();
		List<String> classNameList = new ArrayList<String>();
		String sourceDirectory = sourcePack.getName().replaceAll("\\.", "/");
		URL url = oneOfClass.getClassLoader().getResource(sourceDirectory);
		try {
			if (null != url) {
				java.net.URI uri = url.toURI();
				Path path;
				if (uri.getScheme().equals("jar")) {
					Map<String, Object> map = new HashMap<>();
					FileSystem fs = null;
					try {
						try {
							fs = FileSystems.getFileSystem(uri);
						} catch (Exception e) {
						}
						if (fs == null)
							fs = FileSystems.newFileSystem(uri, map);
					} catch (Exception e) {
					}
					if (fs == null) {
						System.out.print("cannot get FileSystem");
						return;
					}
					path = fs.getPath(sourceDirectory);
				} else {
					path = Paths.get(uri);
				}
				java.util.stream.Stream<Path> stream = Files.walk(path, Integer.MAX_VALUE);
				stream.forEach(e -> {
					if (e.toString().endsWith(".class")) {
						try {
							File f = e.toFile();
							classNameList.add(sourcePack.getName() + "." + f.getName());
						} catch (UnsupportedOperationException e1) {
							String name = e.toString();
							if (name.startsWith("/")) {
								name = name.substring(1);
							}
							name = name.replaceAll("/", ".");
							classNameList.add(name);
						}
					}
				});
			}
		} catch (URISyntaxException e) {
			e.printStackTrace();
		} catch (IOException e) {
			e.printStackTrace();
		}
		/*
		 * File fileDirectory = new File(url.getPath()); File files[] =
		 * fileDirectory.listFiles(); if(files != null){ for(File file : files){
		 * if(file.isDirectory()){ String packName = sourcePack.getName() + "." +
		 * file.getName(); String childDirectoryStr =
		 * sourcePack.getName().replaceAll("\\.", "/") + "/"+ file.getName(); URL
		 * childUrl = ClassLoader.getSystemClassLoader().getResource(childDirectoryStr);
		 * if(childUrl != null){ Class c = getOneClassUnderDirectory(packName,
		 * childUrl.getPath()); if(c != null){ getAllTopLevelClasses(c.getPackage(),
		 * classList); } } }else{ if(file.getName().endsWith(".class")){
		 * classNameList.add(sourcePack.getName() + "." + file.getName()); } } } }
		 */
		classNameList.forEach(name -> {
			StringBuilder sb = new StringBuilder(name);
			String className = sb.delete(sb.length() - 6, sb.length()).toString();
			try {
				Class c = CodeGenContext.getInstance().getReloadableDynamicClassLoaderOwner().loadClass(className,
						true);
				classList.add(c);
			} catch (Exception e) {
				e.printStackTrace();
			}
		});
		/*
		 * classNameList.forEach(name -> { StringBuilder sb = new StringBuilder(name);
		 * String className = sb.delete(sb.length() -6 , sb.length()).toString(); try {
		 * Class c =
		 * CodeGenContext.getInstance().getReloadableDynamicClassLoaderOwner().loadClass
		 * (className); classList.add(c); } catch (Exception e) { e.printStackTrace(); }
		 * });
		 */
		return;
	}
	/*
	 * @Deprecated public static void getAllTopLevelClasses(Package sourcePack,
	 * List<Class> classList){ List<String> classNameList = new ArrayList<String>();
	 * String sourceDirectory = sourcePack.getName().replaceAll("\\.", "/"); URL url
	 * = Common.class.getClassLoader().getResource(sourceDirectory); File
	 * fileDirectory = new File(url.getPath()); File files[] =
	 * fileDirectory.listFiles(); if(files != null){ for(File file : files){
	 * if(file.isDirectory()){ String packName = sourcePack.getName() + "." +
	 * file.getName(); String childDirectoryStr =
	 * sourcePack.getName().replaceAll("\\.", "/") + "/"+ file.getName(); URL
	 * childUrl = ClassLoader.getSystemClassLoader().getResource(childDirectoryStr);
	 * if(childUrl != null){ Class c = getOneClassUnderDirectory(packName,
	 * childUrl.getPath()); if(c != null){ getAllTopLevelClasses(c.getPackage(),
	 * classList); } } }else{ if(file.getName().endsWith(".class")){
	 * classNameList.add(sourcePack.getName() + "." + file.getName()); } } } }
	 * classNameList.forEach(name -> { StringBuilder sb = new StringBuilder(name);
	 * String className = sb.delete(sb.length() -6 , sb.length()).toString(); try {
	 * Class c =
	 * CodeGenContext.getInstance().getReloadableDynamicClassLoaderOwner().loadClass
	 * (className); classList.add(c); } catch (Exception e) { e.printStackTrace(); }
	 * }); return ; }
	 */
	public static void getAllTopLevelClasses(Class oneOfClass, boolean startDirectory, List<Class> classList) {
		getClassesUnderPackage(oneOfClass, classList);
	}
	public static String makeFirstCharInLowercase(String name) {
		char firstCh = name.charAt(0);
		String lowerCaseCh = new String(new char[] { firstCh });
		lowerCaseCh = lowerCaseCh.toLowerCase();
		return name.replaceFirst("\\w{1}", lowerCaseCh);
	}
	public static String makeFirstCharInUpperCase(String name) {
		char firstCh = name.charAt(0);
		String upperCaseCh = new String(new char[] { firstCh });
		upperCaseCh = upperCaseCh.toUpperCase();
		return name.replaceFirst("\\w{1}", upperCaseCh);
	}
	public static String getInstanceName(Class c, String prefix, String suffix) {
		if(null==c) {
			return "";
		}
		if (prefix != null && !"".equals(prefix.trim())) {
			String name = prefix + c.getSimpleName();
			if (suffix != null)
				name = name + suffix;
			return name;
		} else {
			char firstCh = c.getSimpleName().charAt(0);
			String lowerCaseCh = new String(new char[] { firstCh });
			lowerCaseCh = lowerCaseCh.toLowerCase();
			if (!isComplexType(c)) {
				return lowerCaseCh;
			}
			if (c == Class.class) {
				return "clz";
			}
			return c.getSimpleName().replaceFirst("\\w{1}", lowerCaseCh);
		}
	}
	public static String getInstanceName(Class c, String prefix) {
		return getInstanceName(c, prefix, null);
	}
	public static String getInstanceName(Class c) {
		return getInstanceName(c, null, null);
	}
	public static String getDefaultVal(Parameter p) {
		String defaultVal = null;
		if (p != null) {
			String typeName = null;
			typeName = p.getParameterizedType().getTypeName();
			Class c = null;
			try {
				c = CodeGenContext.getInstance().getReloadableDynamicClassLoaderOwner().loadClass(typeName, true);
			} catch (ClassNotFoundException e) {
			}
			if (typeName.equals("java.lang.Object")) {
				defaultVal = "new Object()";
			}
			if (typeName.equals("java.lang.String")) {
				defaultVal = "\"\"";
			}
			if (typeName.equals("java.lang.Boolean") || typeName.equals("boolean")) {
				defaultVal = "false";
			}
			if (typeName.equals("java.lang.Long") || typeName.equals("long")) {
				defaultVal = "1L";
			}
			if (typeName.equals("java.lang.Double") || typeName.equals("double")) {
				defaultVal = "1d";
			}
			if (typeName.equals("java.lang.Integer") || typeName.equals("int")) {
				defaultVal = "1";
			}
			if (typeName.equals("java.lang.Short") || typeName.equals("short")) {
				defaultVal = "(short)1";
			}
			if (typeName.equals("java.lang.Float") || typeName.equals("float")) {
				defaultVal = "1f";
			}
			if (typeName.equals("java.lang.Byte") || typeName.equals("byte")) {
				defaultVal = "(byte)0";
			}
			if (typeName.equals("java.lang.Character") || typeName.equals("char")) {
				defaultVal = "'a'";
			}
			if (typeName.equals("java.util.Date")) {
				defaultVal = "new java.util.Date()";
			}
			if (typeName.equals("java.sql.Date") || typeName.equals("java.sql.Timestamp")) {
				defaultVal = "new " + c.getName() + "(new java.util.Date().getTime())";
			}
			if (typeName.startsWith("java.util.Map")) {
				defaultVal = "new java.util.HashMap()";
			}
			if (typeName.startsWith("java.util.Set")) {
				defaultVal = "new java.util.HashSet()";
			}
			if (typeName.equals("java.math.BigInteger")) {
				defaultVal = "java.math.BigInteger.valueOf(1)";
			}
			if (typeName.equals("java.math.BigDecimal")) {
				defaultVal = "java.math.BigDecimal.valueOf(0)";
			}
			if (typeName.equals("javax.xml.datatype.XMLGregorianCalendar")) {
				defaultVal = "javax.xml.datatype.DatatypeFactory.newInstance().newXMLGregorianCalendar(new java.util.GregorianCalendar())";
			}
			if (c != null && c.isEnum()) {
				defaultVal = Common.getEnumCreateStr(c);
			}
			if (defaultVal == null && c != null) {
				defaultVal = getInstanceName(c);
			}
		}
		return defaultVal;
	}
	public static int getArrayDemension(Class<?> ptype) throws Exception {
		boolean b = ptype.isArray();
		int m = -1;
		if (b) {
			m = 1;
			Class<?> componentType = ptype.getComponentType();
			while (componentType.isArray()) {
				componentType = componentType.getComponentType();
				m++;
			}
		} else {
			throw new Exception("Object is not an array instance");
		}
		return m;
	}
	public static String getArrayComponentTypeByrepstr(String str) {
		String type = null;
		if (str.trim().length() == 1) {
			char ch = str.charAt(0);
			switch (ch) {
			case 'D':
				type = "double";
				break;
			case 'F':
				type = "float";
				break;
			case 'S':
				type = "short";
				break;
			case 'B':
				type = "byte";
				break;
			case 'Z':
				type = "boolean";
				break;
			case 'I':
				type = "int";
				break;
			case 'C':
				type = "char";
				break;
			default:
				break;
			}
		} else {
			str = str.replaceFirst("L", "");
			str = str.replaceFirst(";", "");
			type = str;
		}
		return type;
	}
	public static String getArrayClzTypeJavaCode(Class c) {
		String realType = null;
		if (c.isArray()) {
			String s = c.toString();
			String sArray[] = s.split(" ");
			if (sArray.length > 0) {
				String strTmp = sArray[1];
				int d = 0;
				int i = 0;
				char[] ch = strTmp.toCharArray();
				for (; i < ch.length; i++) {
					if (ch[i] != '[') {
						break;
					}
				}
				d = i;
				StringBuilder sb = new StringBuilder();
				String repsentType = strTmp.substring(i);
				realType = getArrayComponentTypeByrepstr(repsentType);
				for (; d > 0; d--) {
					sb.append("[]");
				}
				realType = realType + sb.toString();
			} else {
			}
		}
		return realType;
	}
	private static String getArrayComponentTypeJavaName(Class arrayClz) throws Exception {
		boolean b = arrayClz.isArray();
		Class<?> componentType = null;
		if (b) {
			componentType = arrayClz.getComponentType();
			while (componentType.isArray()) {
				componentType = componentType.getComponentType();
			}
		} else {
			throw new Exception("Object is not an array instance");
		}
		String str = componentType.getName();
		return str;
	}
	private static String getIntArrayInitJavaCode(int length) {
		StringBuilder sb = new StringBuilder();
		for (int i = 0; i < length; i++) {
			sb.append(1).append(",");
		}
		if (length > 0) {
			sb.delete(sb.length() - 1, sb.length());
		}
		return sb.toString();
	}
	public static String getDefaultVal(Class c) {
		String defaultVal = null;
		if (c != null) {
			if (c.isArray()) {
				int dn;
				try {
					dn = getArrayDemension(c);
					String arrayDimensionJavaCode = getIntArrayInitJavaCode(dn);
					String arrayComponentTypeName = getArrayComponentTypeJavaName(c);
					defaultVal = "(" + getArrayClzTypeJavaCode(c) + ")Array.newInstance(" + arrayComponentTypeName
							+ ".class ," + arrayDimensionJavaCode + ")";
				} catch (Exception e) {
					defaultVal = "null";
				}
			}
			String typeName = c.getName();
			if (typeName.equals("java.lang.Object")) {
				defaultVal = "new Object()";
			}
			if (typeName.equals("java.lang.String")) {
				defaultVal = "\"\"";
			}
			if (typeName.equals("java.lang.Boolean") || typeName.equals("boolean")) {
				defaultVal = "false";
			}
			if (typeName.equals("java.lang.Long") || typeName.equals("long")) {
				defaultVal = "1L";
			}
			if (typeName.equals("java.lang.Double") || typeName.equals("double")) {
				defaultVal = "1d";
			}
			if (typeName.equals("java.lang.Integer") || typeName.equals("int")) {
				defaultVal = "1";
			}
			if (typeName.equals("java.lang.Short") || typeName.equals("short")) {
				defaultVal = "(short)1";
			}
			if (typeName.equals("java.lang.Float") || typeName.equals("float")) {
				defaultVal = "1f";
			}
			if (typeName.equals("java.lang.Byte") || typeName.equals("byte")) {
				defaultVal = "(byte)1";
			}
			if (typeName.equals("java.lang.Character") || typeName.equals("char")) {
				defaultVal = "'a'";
			}
			if (typeName.equals("java.util.Date")) {
				defaultVal = "new java.util.Date()";
			}
			if (typeName.equals("java.sql.Date") || typeName.equals("java.sql.Timestamp")) {
				defaultVal = "new " + c.getName() + "(new java.util.Date().getTime())";
			}
			if (typeName.startsWith("java.util.Map")) {
				defaultVal = "new java.util.HashMap()";
			}
			if (typeName.startsWith("java.util.Set")) {
				defaultVal = "new java.util.HashSet()";
			}
			if (typeName.equals("java.math.BigInteger")) {
				defaultVal = "java.math.BigInteger.valueOf(1)";
			}
			if (typeName.equals("java.math.BigDecimal")) {
				defaultVal = "java.math.BigDecimal.valueOf(0)";
			}
			if (typeName.equals("javax.xml.datatype.XMLGregorianCalendar")) {
				defaultVal = "javax.xml.datatype.DatatypeFactory.newInstance().newXMLGregorianCalendar(new java.util.GregorianCalendar())";
			}
			if (c != null && c.isEnum()) {
				defaultVal = getEnumCreateStr(c);
			}
			if (defaultVal == null && c != null) {
				defaultVal = getInstanceName(c);
			}
		}
		return defaultVal;
	}
	public static String getEnumCreateStr(Class c) {
		StringBuilder sb = new StringBuilder();
		String classNameForPrint = c.getName().replaceAll("\\$", "\\.");
		Object obj[] = c.getEnumConstants();
		sb.append(classNameForPrint).append(".").append(obj[0].toString());
		return sb.toString();
	}
	public static boolean isPrimitiveType(Class c) {
		return !isComplexType(c);
	}
	public static boolean isComplexType(Class c) {
		boolean b = false;
		if (c.isPrimitive() || c.isEnum()) {
			return b;
		}
		if (c.isArray()) {
			c = c.getComponentType();
		}
		String typeName = c.getName();
		if (typeName.equals("java.lang.Object")) {
			return b;
		}
		if (typeName.equals("java.lang.String") || typeName.equals("java.lang.StringBuilder")
				|| typeName.equals("java.lang.StringBuffer")) {
			return b;
		}
		if (typeName.equals("java.lang.Boolean") || typeName.equals("boolean")) {
			return b;
		}
		if (typeName.equals("java.lang.Character") || typeName.equals("char")) {
			return b;
		}
		if (typeName.equals("java.lang.Long") || typeName.equals("long")) {
			return b;
		}
		if (typeName.equals("java.lang.Double") || typeName.equals("double")) {
			return b;
		}
		if (typeName.equals("java.lang.Integer") || typeName.equals("int")) {
			return b;
		}
		if (typeName.equals("java.lang.Short") || typeName.equals("short")) {
			return b;
		}
		if (typeName.equals("java.lang.Float") || typeName.equals("float")) {
			return b;
		}
		if (typeName.equals("java.lang.Byte") || typeName.equals("byte")) {
			return b;
		}
		if (typeName.equals("java.util.Date") || typeName.equals("java.sql.Date")
				|| typeName.equals("java.sql.Timestamp")) {
			return b;
		}
		if (typeName.equals("java.math.BigInteger")) {
			return b;
		}
		if (typeName.equals("java.math.BigDecimal")) {
			return b;
		}
		if (typeName.equals("javax.xml.datatype.XMLGregorianCalendar")) {
			return b;
		}
		b = true;
		return b;
	}
	public static Method[] getAllDeclaredPublicMethodsForTest(Class clzToTest) {
		Method ms[] = clzToTest.getDeclaredMethods();
		List<Method> list = Arrays.asList(ms);
		list = list.stream().filter(m -> {
			if (Modifier.isPublic(m.getModifiers()) && !m.isBridge()) {
				return true;
			}
			return false;
		}).collect(Collectors.toList());
		int mc = list.size();
		Method publicMethods[] = new Method[mc];
		return list.toArray(publicMethods);
	}
	public static Method[] getAllPublicMethods(Class clzToTest) {
		Method ms[] = clzToTest.getMethods();
		List<Method> list = Arrays.asList(ms);
		list = list.stream().filter(m -> {
			if (Modifier.isPublic(m.getModifiers())) {
				return true;
			}
			return false;
		}).collect(Collectors.toList());
		int mc = list.size();
		Method publicMethods[] = new Method[mc];
		return list.toArray(publicMethods);
	}
	public static List<Method> getAllMethodList(Class c) {
		Method ms[] = c.getMethods();
		Method dms[] = c.getDeclaredMethods();
		Method allM[] = new Method[ms.length + dms.length];
		System.arraycopy(ms, 0, allM, 0, ms.length);
		System.arraycopy(dms, 0, allM, ms.length, dms.length);
		List<Method> list = Arrays.asList(allM);
		return list;
	}
	public static Method[] getAllMethods(Class c) {
		Method ms[] = c.getMethods();
		Method dms[] = c.getDeclaredMethods();
		Method allM[] = new Method[ms.length + dms.length];
		System.arraycopy(ms, 0, allM, 0, ms.length);
		System.arraycopy(dms, 0, allM, ms.length, dms.length);
		List<Method> list = Arrays.asList(allM);
		list = list.stream().distinct().collect(Collectors.toList());
		int mc = list.size();
		Method publicMethods[] = new Method[mc];
		return list.toArray(publicMethods);
	}
	public static String[] getAllMethodsAndConstructorStr(Class<?> c) {
		List<Method> mlist = new ArrayList<>();
		List<String> list = new ArrayList<>();
		Constructor[] cs = c.getConstructors();
		for(Constructor cn : cs) {
			list.add(cn.toGenericString());
		}
		mlist.addAll(Arrays.asList(getAllMethods(c)));
		for(Method m : mlist) {
			list.add(m.toGenericString());
		}
		String publicMethods[] = new String[list.size()];
		return list.toArray(publicMethods);
	}
	public static List<String> getAllMethodQualifiers(Class<?> c) {
		List<Method> mlist = Arrays.asList(getAllMethods(c));
		List<String> list = new ArrayList<>();
		for(Method m : mlist) {
			list.add(m.toString());
		}
		return list;
	}
	public static void getAllClzAnnotation(Class<?> c, List<Annotation> list) {
		list.addAll(Arrays.asList(c.getAnnotations()));
		Class<?> superC = c.getSuperclass();
		if (superC != null) {
			getAllClzAnnotation(superC, list);
		}
	}
	public static boolean isClassArray(Class c) {
		boolean b = false;
		if (c.isArray() && c.getComponentType() == Class.class) {
			b = true;
		}
		return b;
	}
	public static boolean isVoid(Method m) {
		boolean b = false;
		Class c = m.getReturnType();
		if (c.equals(Void.TYPE)) {
			b = true;
		}
		return b;
	}
	public static boolean isStatic(Method m) {
		boolean b = false;
		if ((m.getModifiers() & Modifier.STATIC) == Modifier.STATIC) {
			b = true;
		}
		return b;
	}
	public static boolean isAbstract(Method m) {
		boolean abs = false;
		if ((m.getModifiers() & Modifier.ABSTRACT) == Modifier.ABSTRACT) {
			abs = true;
		}
		return abs;
	}
	public static boolean isAbstractOrInterface(Class clzToTest) {
		boolean abs = false;
		if (clzToTest.isInterface() || isAbstract(clzToTest)) {
			abs = true;
		}
		return abs;
	}
	public static boolean isAbstract(Class clzToTest) {
		boolean abs = false;
		if ((clzToTest.getModifiers() & Modifier.ABSTRACT) == Modifier.ABSTRACT) {
			abs = true;
		}
		return abs;
	}
	public static boolean isFinal(Field f) {
		boolean abs = false;
		if ((f.getModifiers() & Modifier.FINAL) == Modifier.FINAL) {
			abs = true;
		}
		return abs;
	}
	public static Map<String, String> createVariableMap() {
		Map<String, String> variableMap = new HashMap<>();
		variableMap.put(Replacement.ASSIGN_SYMBOL.name(), Syntax.ASSIGN_SYMBOL);
		variableMap.put(Replacement.END_OF_LINE.name(), Syntax.END_OF_LINE);
		variableMap.put(Replacement.NEW_LINE.name(), Syntax.NEW_LINE);
		variableMap.put(Replacement.CLASS_END_LINE.name(), Syntax.CLASS_END_LINE);
		return variableMap;
	}
	public static String replaceAllKeyWord(String syntax, Map<String, String> variableMap) throws Exception {
		String str = syntax;
		Iterator<Entry<String, String>> it = variableMap.entrySet().iterator();
		Entry<String, String> entry;
		while (it.hasNext()) {
			entry = it.next();
			String key = "\\" + Syntax.REFERENCE_SYMBOL + entry.getKey() + "\\" + Syntax.REFERENCE_SYMBOL;
			boolean replaceAble = true;
			if (entry.getValue() == null) {
				System.out.println("stopping");
				replaceAble = false;
			}
			if (replaceAble) {
				String replacement = null;
				try {
					replacement = replacePlaceHolder(entry.getValue(), variableMap);
					if (replacement.indexOf("$") != -1) {
						replacement = Matcher.quoteReplacement(replacement);
					}
					/*
					 * if(key.indexOf("$")!=-1){ key = Pattern.quote(key); }
					 */
					str = str.replaceAll(key, replacement);
				} catch (Exception e) {
					System.out.println(String.format("key=%s,replacement=%s,keyQuote=%s,replacementQuote=%s", key,
							replacement, Pattern.quote(key), Matcher.quoteReplacement(replacement)));
					e.printStackTrace();
				}
			}
		}
		return str;
	}
	private static String replacePlaceHolder(String strContainPlaceHolder, Map<String, String> variableMap) {
		if (strContainPlaceHolder.indexOf("${") != -1) {
			Pattern p = Pattern.compile("\\$\\{[\\w\\.\\(\\)]+\\}");
			Matcher m = p.matcher(strContainPlaceHolder);
			if (m.find()) {
				String value = null;
				if (m.groupCount() >= 1) {
					value = m.group(1);
				} else {
					value = m.group();
				}
				try {
					String keyname = value.substring(2, value.length() - 1);
					if (variableMap.containsKey(keyname)) {
						String regex = "\\" + Syntax.REFERENCE_SYMBOL + "\\{" + keyname + "\\}";
						strContainPlaceHolder = strContainPlaceHolder.replaceFirst(regex, variableMap.get(keyname));
					} else {
						return strContainPlaceHolder;
					}
				} catch (IndexOutOfBoundsException e) {
					return strContainPlaceHolder;
				}
				if (strContainPlaceHolder.indexOf("${") != -1) {
					return replacePlaceHolder(strContainPlaceHolder, variableMap);
				} else {
					return strContainPlaceHolder;
				}
			}
		}
		return strContainPlaceHolder;
	}
	public static String genPackage(Class clzToTest, Map<String, String> variableMap) throws Exception {
		variableMap.put(Replacement.PACKAGE_NAME.name(), clzToTest.getPackage().getName());
		String packageStr = Common.replaceAllKeyWord(Syntax.PACKAGE_DECLARE, variableMap);
		return packageStr;
	}
	public static String genMockClassBegin(Class clzToTest, CodeGenContext context) throws Exception {
		String className = clzToTest.getSimpleName();
		context.getVariableMap().put(Replacement.TMP_CLASS_NAME.name(), className + "Mock");
		String beginstr = Common.replaceAllKeyWord(Syntax.CLASS_BEGIN_LINE, context.getVariableMap());
		return beginstr;
	}
	public static String genClassBegin(Class clzToTest, Map<String, String> variableMap) throws Exception {
		String className = clzToTest.getSimpleName();
		variableMap.put(Replacement.TMP_CLASS_NAME.name(), className);
		String beginstr = Common.replaceAllKeyWord(Syntax.CLASS_BEGIN_LINE, variableMap);
		return beginstr;
	}
	public static String genUnitTestMatchersMethodParamsVariable(Map<String, String> variableMap, Class... cs)
			throws Exception {
		List<String> strList = new ArrayList<>();
		for (Class c : cs) {
			String matchStr = null;
			if (isComplexType(c)) {
				variableMap.put(Replacement.TMP_CLASS_NAME.name(), c.getSimpleName());
				matchStr = Common.replaceAllKeyWord(Syntax.ANY_OF_CLASS_MATCH, variableMap);
			} else {
				matchStr = Common.replaceAllKeyWord(Syntax.ANY_MATCH, variableMap);
			}
			strList.add(matchStr);
		}
		String strArray[] = new String[strList.size()];
		strArray = strList.toArray(strArray);
		return genMethodParamsVariable(strArray);
	}
	public static String genMethodParamsVariable(String... strings) {
		StringBuilder sb = new StringBuilder();
		for (String p : strings) {
			sb.append(p).append(", ");
		}
		if (sb.length() > 0) {
			sb.delete(sb.length() - 2, sb.length());
		}
		return sb.toString();
	}
	public static String genMethodParamsDeclaration(Class... cs) {
		StringBuilder sb = new StringBuilder();
		for (Class p : cs == null ? new Class[] {} : cs) {
			sb.append(p.getSimpleName()).append(" ").append(Common.getInstanceName(p)).append(", ");
		}
		if (sb.length() > 0) {
			sb.delete(sb.length() - 2, sb.length());
		}
		return sb.toString();
	}
	public static String genExceptionThrows(Class<? extends Exception>... cs) {
		StringBuilder sb = new StringBuilder();
		for (Class p : cs == null ? new Class[] {} : cs) {
			sb.append(p.getSimpleName()).append(", ");
		}
		if (sb.length() > 0) {
			sb.insert(0, "throws ");
			sb.delete(sb.length() - 2, sb.length());
		}
		return sb.toString();
	}
	public static String genMethodParamDeclareVariable(Entry<Class, String>... params) {
		if (params == null || params.length == 0) {
			return "";
		}
		StringBuilder sb = new StringBuilder();
		for (Entry<Class, String> e : params) {
			sb.append(e.getKey().getSimpleName()).append("  ").append(e.getValue()).append(", ");
		}
		if (sb.length() > 0) {
			sb.delete(sb.length() - 2, sb.length());
		}
		return sb.toString();
	}
	public static String genimportStr(List<Class> alreadyImportClasses, Map<String, String> variableMap,
			Class... clzToImport) throws Exception {
		StringBuilder sb = new StringBuilder();
		for (Class c : clzToImport) {
			String str = genimportStr(c, alreadyImportClasses, variableMap);
			if (!"".equals(str)) {
				sb.append(str).append(Syntax.NEW_LINE);
			}
		}
		return sb.toString();
	}
	public static void importPack(String packageName, Map<String, String> variableMap, StringBuilder importBuilder)
			throws Exception {
		variableMap.put(Replacement.QUALIFIER.name(), packageName);
		String importStr = Common.replaceAllKeyWord(Syntax.IMPORT_LINE, variableMap);
		importBuilder.append(importStr);
	}
	@Deprecated
	public static void importC(Class clzToImport, List<Class> alreadyImportClasses, Map<String, String> variableMap,
			StringBuilder importBuilder) throws Exception {
		String str = genimportStr(clzToImport, alreadyImportClasses, variableMap);
		if (!"".equals(str)) {
			importBuilder.append(str).append(Syntax.NEW_LINE);
		}
	}
	public static void importC(Class[] classesToImport, CodeGenContext context) throws Exception {
		for (Class p : classesToImport) {
			String str = genimportStr(p, context.getAlreadyImportClasses(), context.getVariableMap());
			if (!"".equals(str)) {
				context.getImportSB().append(str).append(Syntax.NEW_LINE);
			}
		}
	}
	public static void importC(Class clzToImport, CodeGenContext context) throws Exception {
		String str = genimportStr(clzToImport, context.getAlreadyImportClasses(), context.getVariableMap());
		if (!"".equals(str)) {
			context.getImportSB().append(str).append(Syntax.NEW_LINE);
		}
	}
	public static String genimportStr(Class clzToImport, List<Class> alreadyImportClasses,
			Map<String, String> variableMap) throws Exception {
		if (clzToImport.isArray()) {
			clzToImport = clzToImport.getComponentType();
		}
		if (clzToImport.getName().startsWith("java.lang")) {
			String name = clzToImport.getName();
			String packageFragement[] = name.split("\\.");
			if (packageFragement.length == 3)
				return "";
		}
		if (clzToImport.isPrimitive()) {
			return "";
		}
		if (alreadyImportClasses.contains(clzToImport)) {
			return "";
		}
		boolean ambiguousClass = isSameSimpleNameClassImported(clzToImport, alreadyImportClasses);
		if (!ambiguousClass) {
			String className = clzToImport.getName();
			if (clzToImport.getEnclosingClass() != null) {
				className = className.replaceAll("\\$", "\\.");
			}
			variableMap.put(Replacement.QUALIFIER.name(), className);
			String importStr = Common.replaceAllKeyWord(Syntax.IMPORT_LINE, variableMap);
			alreadyImportClasses.add(clzToImport);
			return importStr;
		}
		return "";
	}
	private static boolean isSameSimpleNameClassImported(Class c, List<Class> alreadyImportClasses) {
		boolean b = alreadyImportClasses.stream().anyMatch(a -> {
			String simpleName = c.getSimpleName();
			String existingSimpleName = a.getSimpleName();
			if (existingSimpleName.equals(simpleName))
				return true;
			else
				return false;
		});
		return b;
	}
	@Deprecated
	public static String genImportByQualifier(String qualifier, List<Class> alreadyImportClasses,
			Map<String, String> variableMap) throws Exception {
		Class c = null;
		try {
			c = CodeGenContext.getInstance().getReloadableDynamicClassLoaderOwner().loadClass(qualifier, true);
		} catch (Exception e) {
		}
		if (c != null) {
			return genimportStr(c, alreadyImportClasses, variableMap);
		} else {
			return "";
		}
	}
	public static String genImportByQualifier(String qualifier, CodeGenContext context) throws Exception {
		Class c = null;
		try {
			c = CodeGenContext.getInstance().getReloadableDynamicClassLoaderOwner().loadClass(qualifier, true);
		} catch (Exception e) {
		}
		if (c != null) {
			return genimportStr(c, context.getAlreadyImportClasses(), context.getVariableMap());
		} else {
			return "";
		}
	}
	@Deprecated
	public static String initAClass1(Class c, Map<String, String> variableMap, Map<Class, String> classSimpleNameMap)
			throws Exception {
		return initAClass1(c, null, variableMap, classSimpleNameMap);
	}
	@Deprecated
	public static String initAClass1(Class c, String instanceName, Map<String, String> variableMap,
			Map<Class, String> classSimpleNameMap) throws Exception {
		StringBuilder sb = new StringBuilder();
		if (Common.hasDefaultConstruct(c)) {
			variableMap.put(Replacement.TMP_CLASS_NAME.name(), getClassName1(c, classSimpleNameMap));
			variableMap.put(Replacement.TMP_INSTANCE_NAME.name(),
					instanceName != null ? instanceName : Common.getInstanceName(c));
			String instanceLine = Common.replaceAllKeyWord(Syntax.NEW_INSTANCE_LINE, variableMap);
			sb.append(instanceLine);
		} else {
			String defaultValue = getDefaultVal(c);
			variableMap.put(Replacement.DEFAULT_VALUE.name(), defaultValue);
			variableMap.put(Replacement.TMP_INSTANCE_NAME.name(),
					instanceName != null ? instanceName : Common.getInstanceName(c));
			String initLine = Common.replaceAllKeyWord(Syntax.INIT_CLASS_WITH_DEFAULT_VALUE, variableMap);
			sb.append(initLine);
		}
		return sb.toString();
	}
	public static String initAClass(Class c, CodeGenContext context) throws Exception {
		return initAClass(c, null, context);
	}
	public static String initAClass(Class c, String instanceName, CodeGenContext context) throws Exception {
		return initAClass(c, instanceName, false, context);
	}
	public static String initAClass(Class c, Constructor ct, String instanceName, boolean hasClassNameDeclare,
			CodeGenContext context) throws Exception {
		StringBuilder sb = new StringBuilder();
		if (context.getAbstractConcreteClassMap().get(c) != null) {
			AbstractConcreteClassMapping acMap = context.getAbstractConcreteClassMap().get(c);
			if (hasClassNameDeclare) {
				context.getVariableMap().put(Replacement.SEPERATOR.name(), " ");
				context.getVariableMap().put(Replacement.ABSTRACT_CLASS_NAME.name(), getClassName(c, context));
			} else {
				context.getVariableMap().put(Replacement.ABSTRACT_CLASS_NAME.name(), "");
				context.getVariableMap().put(Replacement.SEPERATOR.name(), "");
			}
			if (instanceName == null) {
				instanceName = acMap.getAbstractClassInstanceName();
				if (instanceName == null) {
					instanceName = Common.getInstanceName(acMap.getAbstractClass());
				}
			}
			context.getVariableMap().put(Replacement.ABSTRACT_INSTANCE_NAME.name(), instanceName);
			context.getVariableMap().put(Replacement.TMP_CLASS_NAME.name(),
					getClassName(acMap.getConcreteClass(), context));
			String initLine = null;
			if (acMap.getConcreteCFactoryMethod() != null) {
				context.getVariableMap().put(Replacement.METHOD_NAME.name(),
						acMap.getConcreteCFactoryMethod().getName());
				if (acMap.getConcreteCFactoryMethod().getParameterCount() > 0) {
					context.getVariableMap().put(Replacement.METHOD_PARAMS_VARIABLE.name(),
							Common.genMethodParamsVariable(acMap.getMethodParamVariables()));
				} else {
					context.getVariableMap().put(Replacement.METHOD_PARAMS_VARIABLE.name(), "");
				}
				initLine = Common.replaceAllKeyWord(Syntax.INIT_CLASS_WITH_CONCRETE_LINE, context.getVariableMap());
			} else {
				if (c.isInterface()) {
					Class concreteClass = acMap.getConcreteClass();
					if (Common.hasConstruct(concreteClass)) {
						if (Common.hasDefaultConstruct(concreteClass)) {
							context.getVariableMap().put(Replacement.METHOD_PARAMS_VARIABLE.name(), "");
							initLine = Common.replaceAllKeyWord(Syntax.ABSTRACT_NEW_INSTANCE_LINE_WITH_DECLARE_OR_NOT,
									context.getVariableMap());
						} else {
							ct = ct == null ? Common.tryGetConstructorHasPrimitiveParam(concreteClass) : ct;
							List<String> params = new ArrayList<>();
							if (ct != null) {
								Class cts[] = ct.getParameterTypes();
								for (Class pt : cts) {
									String dv = Common.getDefaultVal(pt);
									params.add(dv);
								}
							} else {
								ct = concreteClass.getConstructors()[0];
								Parameter pts[] = ct.getParameters();
								for (Parameter p : pts) {
									params.add(p.getName());
								}
							}
							String paramArray[] = params.toArray(new String[params.size()]);
							context.getVariableMap().put(Replacement.METHOD_PARAMS_VARIABLE.name(),
									Common.genMethodParamsVariable(paramArray));
							initLine = Common.replaceAllKeyWord(Syntax.ABSTRACT_NEW_INSTANCE_LINE_WITH_DECLARE_OR_NOT,
									context.getVariableMap());
						}
					}
				}
			}
			sb.append(initLine);
			Common.importC(acMap.getConcreteClass(), context);
		} else {
			Class concreteClass = null;
			if (c.isInterface()) {
				concreteClass = getDefaultConcreteClass(c);
			}
			if (Common.hasConstruct(c) || (concreteClass != null && Common.hasConstruct(concreteClass))) {
				if (hasClassNameDeclare) {
					context.getVariableMap().put(Replacement.SEPERATOR.name(), " ");
					context.getVariableMap().put(Replacement.ABSTRACT_CLASS_NAME.name(), getClassName(c, context));
					context.getVariableMap().put(Replacement.TMP_CLASS_NAME.name(),
							getClassName(c.isInterface() ? concreteClass : c, context));
					context.getVariableMap().put(Replacement.ABSTRACT_INSTANCE_NAME.name(),
							instanceName != null ? instanceName : Common.getInstanceName(c));
					if (Common.hasDefaultConstruct(c)
							|| (concreteClass != null && Common.hasConstruct(concreteClass))) {
						context.getVariableMap().put(Replacement.METHOD_PARAMS_VARIABLE.name(), "");
						String instanceLine = Common.replaceAllKeyWord(
								Syntax.ABSTRACT_NEW_INSTANCE_LINE_WITH_DECLARE_OR_NOT, context.getVariableMap());
						sb.append(instanceLine);
					} else {
						ct = ct == null
								? Common.tryGetConstructorHasPrimitiveParam(!c.isInterface() ? c : concreteClass)
								: ct;
						List<String> params = new ArrayList<>();
						if (ct != null) {
							Class cts[] = ct.getParameterTypes();
							for (Class pt : cts) {
								String dv = Common.getDefaultVal(pt);
								params.add(dv);
							}
						} else {
							ct = !c.isInterface() ? c.getConstructors()[0] : concreteClass.getConstructors()[0];
							Parameter pts[] = ct.getParameters();
							for (Parameter p : pts) {
								params.add(p.getName());
							}
						}
						String paramArray[] = params.toArray(new String[params.size()]);
						context.getVariableMap().put(Replacement.METHOD_PARAMS_VARIABLE.name(),
								Common.genMethodParamsVariable(paramArray));
						String instanceLine = Common.replaceAllKeyWord(
								Syntax.ABSTRACT_NEW_INSTANCE_LINE_WITH_DECLARE_OR_NOT, context.getVariableMap());
						sb.append(instanceLine);
					}
				} else {
					context.getVariableMap().put(Replacement.TMP_CLASS_NAME.name(),
							getClassName(c.isInterface() ? concreteClass : c, context));
					context.getVariableMap().put(Replacement.TMP_INSTANCE_NAME.name(),
							instanceName != null ? instanceName : Common.getInstanceName(c));
					String instanceLine = Common.replaceAllKeyWord(Syntax.NEW_INSTANCE_LINE, context.getVariableMap());
					sb.append(instanceLine);
				}
			} else {
				String defaultValue = getDefaultVal(c);
				context.getVariableMap().put(Replacement.DEFAULT_VALUE.name(), defaultValue);
				context.getVariableMap().put(Replacement.TMP_INSTANCE_NAME.name(),
						instanceName != null ? instanceName : Common.getInstanceName(c));
				if (hasClassNameDeclare) {
					context.getVariableMap().put(Replacement.SEPERATOR.name(), " ");
					context.getVariableMap().put(Replacement.TMP_CLASS_NAME.name(), c.getSimpleName());
				} else {
					context.getVariableMap().put(Replacement.SEPERATOR.name(), "");
					context.getVariableMap().put(Replacement.TMP_CLASS_NAME.name(), "");
				}
				String initLine = Common.replaceAllKeyWord(Syntax.INIT_CLASS_WITH_DEFAULT_VALUE,
						context.getVariableMap());
				sb.append(initLine);
			}
		}
		return sb.toString();
	}
	public static String initAClass(Class c, String instanceName, boolean hasClassNameDeclare, CodeGenContext context)
			throws Exception {
		return initAClass(c, null, instanceName, hasClassNameDeclare, context);
	}
	public static Constructor tryGetConstructorHasPrimitiveParam(Class c) {
		Constructor ct = null;
		Constructor[] cc = c.getConstructors();
		for (Constructor cte : cc) {
			boolean allPrimitiveTypes = true;
			Class pts[] = cte.getParameterTypes();
			for (Class p : pts) {
				if (Common.isComplexType(p)) {
					allPrimitiveTypes = false;
				}
			}
			if (allPrimitiveTypes) {
				ct = cte;
			}
		}
		return ct;
	}
	public static boolean hasConstruct(Class c) {
		boolean b = false;
		Constructor[] cc = c.getConstructors();
		b = cc.length > 0 ? true : false;
		return b;
	}
	public static boolean hasDefaultConstruct(Class c) {
		boolean b = false;
		Constructor[] cc = c.getConstructors();
		for (Constructor cons : cc) {
			if (cons.getParameterCount() == 0) {
				b = true;
				break;
			}
		}
		return b;
	}
	public static String getDefaultCreateMethodName(Class c) {
		String defaultCreateMethodName = "create" + c.getSimpleName();
		return defaultCreateMethodName;
	}
	@Deprecated
	public static String getComplexTypeCreateMethodName(Class target, List<String> createdMethodName) {
		String methodName = "create" + target.getSimpleName();
		int sameMethodNameCound = 0;
		for (String name : createdMethodName) {
			Pattern p = Pattern.compile(methodName + "(\\d*)");
			Matcher m = p.matcher(name);
			if (m.find()) {
				String methodNameIndex = m.group(1);
				if (methodNameIndex != null && !"".equals(methodNameIndex.trim())) {
					try {
						sameMethodNameCound = Integer.valueOf(methodNameIndex);
					} catch (Exception e) {
						throw e;
					}
				}
				sameMethodNameCound++;
			}
		}
		if (sameMethodNameCound > 0)
			methodName = methodName + sameMethodNameCound;
		return methodName;
	}
	public static String getComplexTypeCreateMethodName(Class target, CodeGenContext context) {
		String methodName = "create" + target.getSimpleName();
		int sameMethodNameCound = 0;
		for (String name : context.getCreatedMethodName()) {
			Pattern p = Pattern.compile(methodName + "(\\d*)");
			Matcher m = p.matcher(name);
			if (m.find()) {
				String methodNameIndex = m.group(1);
				if (methodNameIndex != null && !"".equals(methodNameIndex.trim())) {
					try {
						sameMethodNameCound = Integer.valueOf(methodNameIndex);
					} catch (Exception e) {
						throw e;
					}
				}
				sameMethodNameCound++;
			}
		}
		if (sameMethodNameCound > 0)
			methodName = methodName + sameMethodNameCound;
		return methodName;
	}
	public static String getMethodName(String rootMethodName, CodeGenContext context) {
		String methodName = rootMethodName;
		int sameMethodNameCound = 0;
		for (String name : context.getCreatedMethodName()) {
			Pattern p = Pattern.compile(methodName + "(\\d*)");
			Matcher m = p.matcher(name);
			if (m.find()) {
				String methodNameIndex = m.group(1);
				if (methodNameIndex != null && !"".equals(methodNameIndex.trim())) {
					try {
						sameMethodNameCound = Integer.valueOf(methodNameIndex);
					} catch (Exception e) {
						throw e;
					}
				}
				sameMethodNameCound++;
			}
		}
		if (sameMethodNameCound > 0)
			methodName = methodName + sameMethodNameCound;
		return methodName;
	}
	public static String getDefaultMockClassName(Class c, CodeGenContext context) {
		return c.getName() + "Mock";
	}
	public static String getClassName(Class c, CodeGenContext context) {
		String name = null;
		Map<Class, String> classSimpleName = context.getClassSimpleNameMap();
		if (!classSimpleName.containsKey(c)) {
			boolean ambiguousClass = false;
			ambiguousClass = classSimpleName.entrySet().stream().anyMatch(e -> {
				if (c.getSimpleName().equals(e.getValue().trim())) {
					return true;
				}
				return false;
			});
			if ((context != null && context.isGenFullQualifierName()) || ambiguousClass) {
				classSimpleName.put(c, c.getName());
			} else {
				classSimpleName.put(c, c.getSimpleName());
			}
		}
		name = classSimpleName.get(c);
		return name;
	}
	@Deprecated
	/**
	 * use getClassName(Class c, CodeGenContext context) instead
	 *
	 * @param c
	 * @param classSimpleName
	 * @return
	 */
	public static String getClassName1(Class c, Map<Class, String> classSimpleName) {
		String name = null;
		if (!classSimpleName.containsKey(c)) {
			boolean ambiguousClass = false;
			ambiguousClass = classSimpleName.entrySet().stream().anyMatch(e -> {
				if (c.getSimpleName().equals(e.getValue().trim())) {
					return true;
				}
				return false;
			});
			if (ambiguousClass) {
				classSimpleName.put(c, c.getName());
			} else {
				classSimpleName.put(c, c.getSimpleName());
			}
		}
		name = classSimpleName.get(c);
		return name;
	}
	public static Class getConcreteClass(Class c, CodeGenContext context) {
		Class concreteClass = c;
		if (context.getAbstractConcreteClassMap().get(c) != null) {
			AbstractConcreteClassMapping acMap = context.getAbstractConcreteClassMap().get(c);
			concreteClass = acMap.getConcreteClass();
		} else if (c.isInterface() || Common.isAbstract(c)) {
			concreteClass = getDefaultConcreteClass(c);
		}
		return concreteClass;
	}
	public static Class[] getConcreteClass(Class cs[], CodeGenContext context) {
		Class ccs[] = null;
		List<Class> list = new ArrayList<>();
		for (Class c : cs) {
			Class cc = getConcreteClass(c, context);
			if (cc != null) {
				list.add(cc);
			} else {
				System.out.println(String.format("cannot get concrete class for %s, return class itself", c.getName()));
				list.add(c);
			}
		}
		ccs = new Class[list.size()];
		return list.toArray(ccs);
	}
	public static boolean isBlank(String s) {
		return s == null || "".equals(s.trim());
	}
	public static Class getDefaultConcreteClass(Class interfaceC) {
		Class concreteC = null;
		if (!interfaceC.isInterface() && !isAbstract(interfaceC) && !interfaceC.isArray()) {
			return interfaceC;
		}
		if (List.class.isAssignableFrom(interfaceC) || AbstractList.class.isAssignableFrom(interfaceC)
				|| Collection.class == interfaceC) {
			concreteC = ArrayList.class;
		} else if (Map.class.isAssignableFrom(interfaceC) || AbstractMap.class.isAssignableFrom(interfaceC)) {
			concreteC = HashMap.class;
		} else if (Set.class.isAssignableFrom(interfaceC) || AbstractSet.class.isAssignableFrom(interfaceC)) {
			concreteC = HashSet.class;
		}
		return concreteC;
	}
	/*
	 * public static MethodCallingVariable
	 * genIfNotExistAndGetClassCreateMethod(Class c, Class genericTypes[], boolean
	 * forceGenerate,Map<MethodCallingKey, MethodCallingVariable>
	 * complexTypeCreateMapping, List<String> createdMethodName, Map<Class, String>
	 * classSimpleName, Map<String, String> variableMap) throws Exception{ Class
	 * concreteC = getDefaultConcreteClass(c); if(concreteC == null){ throw new
	 * Exception(String.format( "cannot get the concrete class for %s",
	 * c.getName())); } MethodCallingVariable mc = null; String
	 * defaultCreateMethodName = getDefaultCreateMethodName(c); MethodCallingKey
	 * defaultMethodCallingKey = new MethodCallingKey(c, defaultCreateMethodName);
	 * MethodCallingKey newMethodCallingKey = defaultMethodCallingKey;
	 * if(forceGenerate ||
	 * !complexTypeCreateMapping.containsKey(defaultMethodCallingKey)){ String
	 * methodBody = ObjSetCodeGenAfterCreateMethod.generateCode(concreteC,
	 * genericTypes); mc = new MethodCallingVariable(); mc.setC(c);
	 * mc.setMethodBody(methodBody); String methodName =
	 * getComplexTypeCreateMethodName(c, createdMethodName);
	 * mc.setMethodName(methodName); //mc.setParams(new Object[]{});
	 * newMethodCallingKey = new MethodCallingKey(c, methodName);
	 * complexTypeCreateMapping.put(newMethodCallingKey, mc);
	 * variableMap.put(Replacement.PRIVILEDGE_MODIFIER.name(), "private");
	 * if(!variableMap.containsKey(Replacement.STATIC_MODIFIER.name())){
	 * variableMap.put(Replacement.STATIC_MODIFIER.name(), ""); }
	 * variableMap.put(Replacement.METHOD_RETURN_TYPE.name(), getClassName(c,
	 * classSimpleName)); variableMap.put(Replacement.METHOD_NAME.name(),
	 * mc.getMethodName());
	 * variableMap.put(Replacement.METHOD_PARAMS_DECLARE.name(), "");
	 * variableMap.put(Replacement.METHOD_BODY.name(), mc.getMethodBody()); String
	 * instanceName = Common.getInstanceName(concreteC);
	 * variableMap.put(Replacement.METHOD_RETURN_VALUE.name(), instanceName); String
	 * createComplexTypeMethod = Common.replaceAllKeyWord(Syntax.NORMAL_METHOD,
	 * variableMap); mc.setMethodBlock(createComplexTypeMethod);
	 * createdMethodName.add(methodName); } mc =
	 * complexTypeCreateMapping.get(newMethodCallingKey); return mc; }
	 */
	/*
	 * public static MethodCallingVariable
	 * genIfNotExistAndGetClassCreateMethod(Class c, boolean
	 * forceGenerate,Map<MethodCallingKey, MethodCallingVariable>
	 * complexTypeCreateMapping, List<String> createdMethodName, Map<Class, String>
	 * classSimpleName, Map<String, String> variableMap) throws Exception{ return
	 * Common.genIfNotExistAndGetClassCreateMethod(c, null, forceGenerate,
	 * complexTypeCreateMapping, createdMethodName, classSimpleName, variableMap); }
	 */
	public static Class getGenericTypeIfOnlyOne(String typeName) {
		Class g = null;
		String genericType = null;
		int start = typeName.indexOf("<");
		int end = typeName.indexOf(">");
		genericType = typeName.substring(start + 1, end);
		try {
			g = CodeGenContext.getInstance().getReloadableDynamicClassLoaderOwner().loadClass(genericType, true);
		} catch (ClassNotFoundException e) {
			e.printStackTrace();
		}
		return g;
	}
	public static MethodCallingVariable genIfNotExistAndGetClassCreateMethod(Class c, boolean forceGenerate,
			CodeGenContext context) throws Exception {
		return genIfNotExistAndGetClassCreateMethod(c, null, forceGenerate, context);
	}
	public static MethodCallingVariable genIfNotExistAndGetClassCreateMethod(Class c, Class genericTypes[],
			boolean forceGenerate, CodeGenContext context) throws Exception {
		MethodCallingVariable mc = null;
		String defaultCreateMethodName = getDefaultCreateMethodName(c);
		MethodCallingKey defaultMethodCallingKey = new MethodCallingKey(c, defaultCreateMethodName);
		MethodCallingKey newMethodCallingKey = defaultMethodCallingKey;
		if (forceGenerate || !context.getComplexTypeCreateMapping().containsKey(defaultMethodCallingKey)) {
			Class concreteClass = c;
			if (context.getAbstractConcreteClassMap().get(c) != null) {
				AbstractConcreteClassMapping acMap = context.getAbstractConcreteClassMap().get(c);
				concreteClass = acMap.getConcreteClass();
			} else if (c.isInterface() || Common.isAbstract(c)) {
				concreteClass = getDefaultConcreteClass(c);
			}
			if (concreteClass == null) {
				System.out.println(String.format("cannot get concrete class for class %s null", c));
				return mc;
			}
			String methodBody = PojoSetterGenerator
					.generateCode(concreteClass, genericTypes, context);
			mc = new MethodCallingVariable();
			mc.setMethodBody(methodBody);
			String methodName = getComplexTypeCreateMethodName(concreteClass, context);
			mc.setMethodName(methodName);
			newMethodCallingKey = new MethodCallingKey(concreteClass, methodName);
			context.getComplexTypeCreateMapping().put(newMethodCallingKey, mc);
			context.getVariableMap().put(Replacement.METHOD_RETURN_TYPE.name(), Common.getClassName(c, context));
			context.getVariableMap().put(Replacement.METHOD_NAME.name(), mc.getMethodName());
			context.getVariableMap().put(Replacement.METHOD_PARAMS_DECLARE.name(), "");
			context.getVariableMap().put(Replacement.METHOD_BODY.name(), mc.getMethodBody());
			String instanceName = Common.getInstanceName(concreteClass);
			context.getVariableMap().put(Replacement.METHOD_RETURN_VALUE.name(), instanceName);
			context.getVariableMap().put(Replacement.THROWS_EXCEPTION.name(), "");
			String createComplexTypeMethod = Common.replaceAllKeyWord(Syntax.NORMAL_METHOD, context.getVariableMap());
			context.getCreatedComplexTypeMethod().append(createComplexTypeMethod).append(Syntax.NEW_LINE);
			context.getCreatedMethodName().add(methodName);
		}
		mc = context.getComplexTypeCreateMapping().get(newMethodCallingKey);
		return mc;
	}
	public static String readAsStr(File f) throws IOException {
		FileInputStream fis = new FileInputStream(f);
		return readAsStr(fis);
	}
	public static byte[] readAllInputStream(InputStream is) throws IOException {
		int nRead;
		ByteArrayOutputStream bao = new ByteArrayOutputStream();
		byte[] data = new byte[16384];
		while ((nRead = is.read(data, 0, data.length)) != -1) {
			bao.write(data, 0, nRead);
		}
		byte bArray[] = bao.toByteArray();
		return bArray;
	}
	public static String readAsStr(InputStream is) throws IOException {
		StringBuilder sb = new StringBuilder();
		BufferedReader in = null;
		try {
			in = new BufferedReader(new InputStreamReader(is));
			String line = null;
			while ((line = in.readLine()) != null) {
				sb.append(line).append("\r\n");
			}
		} catch (IOException e) {
			e.printStackTrace();
			throw e;
		} finally {
			if (in != null)
				try {
					in.close();
				} catch (IOException e) {
					e.printStackTrace();
				}
		}
		return sb.toString();
	}
	public static void write(File f, String fileStr) throws IOException {
		f.getParentFile().mkdirs();
		FileOutputStream fos = new FileOutputStream(f);
		fos.write(fileStr.getBytes());
		fos.flush();
		fos.close();
	}
	public static void writeInputStreamAllByte(InputStream is, OutputStream os) throws IOException {
		byte[] buffer = new byte[2048];
		int read = 0;
		while ((read = is.read(buffer)) != -1) {
			os.write(buffer, 0, read);
		}
		is.close();
		os.flush();
		os.close();
		return;
	}
	public static boolean isFunctionInterface(Class functionInterface) {
		boolean b = false;
		Method ms[] = Common.getInterfaceAbstractMethods(functionInterface);
		if (ms != null && ms.length == 1) {
			b = true;
		}
		return b;
	}
	public static Method[] getInterfaceAbstractMethods(Class functionInterface) {
		Method ms[] = null;
		if (functionInterface.isInterface()) {
			List<Method> list = Arrays.asList(Common.getAllDeclaredPublicMethodsForTest(functionInterface)).stream()
					.filter(m -> {
						return Common.isAbstract(m);
					}).collect(Collectors.toList());
			ms = list.toArray(new Method[list.size()]);
		}
		return ms;
	}
	public static String genFunctionImplementation(Class functionInterface, String... params) {
		StringBuilder sb = new StringBuilder();
		Method ms[] = Common.getInterfaceAbstractMethods(functionInterface);
		if (ms != null && ms.length == 1) {
			Method m = ms[0];
			String paramStr = Common.genMethodParamsVariable(params);
			sb.append("(").append(paramStr).append(")").append("{").append(Syntax.NEW_LINE);
			if (!Common.isVoid(m)) {
				sb.append("return ").append(Syntax.END_OF_LINE);
			}
			sb.append("}");
		}
		return sb.toString();
	}
	public static String getInstanceName(Class<?> rt, Map<Class<?>, Short> map) {
		short num;
		if (map.containsKey(rt)) {
			num = map.get(rt);
			num++;
		} else {
			num = 0;
		}
		map.put(rt, num);
		String name = Common.getInstanceName(rt) + (num == 0 ? "" : Short.toString(num));
		return name;
	}
	public static Class getClass(Type type) {
		if (type instanceof Class) {
			return (Class) type;
		} else if (type instanceof ParameterizedType) {
			return getClass(((ParameterizedType) type).getRawType());
		} else if (type instanceof GenericArrayType) {
			Type componentType = ((GenericArrayType) type).getGenericComponentType();
			Class componentC = getClass(componentType);
			if (componentC != null) {
				Object object = Array.newInstance(componentC, 0);
				return object.getClass();
			} else {
				return null;
			}
		} else {
			return null;
		}
	}
	public static <T> List<Class<?>> getTypeArguments(Class<T> baseClass, Class<? extends T> childClass) {
		Map<Type, Type> resolvedTypes = new HashMap<>();
		Type type = childClass;
		while (type != null && !getClass(type).equals(baseClass)) {
			if (type instanceof Class) {
				Class tc = (Class) type;
				Type itype[] = tc.getGenericInterfaces();
				type = itype[0];
			} else {
				ParameterizedType pt = (ParameterizedType) type;
				Type rawType = pt.getRawType();
				Class rawT = (Class) rawType;
				Type actualTypeArgs[] = pt.getActualTypeArguments();
				TypeVariable typeParams[] = rawT.getTypeParameters();
				for (int i = 0; i < actualTypeArgs.length; i++) {
					resolvedTypes.put(typeParams[i], actualTypeArgs[i]);
				}
				if (!rawT.equals(baseClass)) {
					type = rawT.getGenericSuperclass();
				} else {
				}
			}
		}
		Type actualTypeArgs[];
		if (type instanceof Class) {
			actualTypeArgs = ((Class) type).getTypeParameters();
		} else {
			actualTypeArgs = ((ParameterizedType) type).getActualTypeArguments();
		}
		List<Class<?>> list = new ArrayList<>();
		for (Type baseType : actualTypeArgs) {
			while (resolvedTypes.containsKey(baseType)) {
				baseType = resolvedTypes.get(baseType);
			}
			list.add(getClass(baseType));
		}
		return list;
	}
	public static List<Class<?>> getInterfaceGenericTypes(Class c) {
		List<Class<?>> list = new ArrayList<>();
		Type type = getClass(c);
		if (type instanceof Class) {
			Class tc = (Class) type;
			Type itypes[] = tc.getGenericInterfaces();
			for (Type t : itypes) {
				System.out.print(t.getTypeName());
				if (t instanceof ParameterizedType) {
					ParameterizedType pt = (ParameterizedType) t;
					Type ts[] = pt.getActualTypeArguments();
					for (Type t1 : ts) {
						if (t instanceof TypeVariable) {
							TypeVariable tv = (TypeVariable) t;
							System.out.print(tv.getName());
						} else {
							list.add(getClass(t1));
						}
					}
				}
			}
		}
		return list;
	}
	public Class[] getRepositorySuperClassActualParam(Class c) {
		Type t = c.getGenericSuperclass();
		if (t instanceof ParameterizedType) {
			ParameterizedType pt = (ParameterizedType) t;
			Type ts[] = pt.getActualTypeArguments();
			if (ts != null) {
				Class cces[] = new Class[ts.length];
				cces = Arrays.copyOf(ts, ts.length, Class[].class);
				return cces;
			} else {
				return null;
			}
		}
		return null;
	}
	public static int createRandom(int min, int max) {
		ThreadLocalRandom threadLocalRandom = ThreadLocalRandom.current();
		int i = threadLocalRandom.nextInt(min, max + 1);
		return i;
	}
	public static void main(String args[]) throws MalformedURLException {
		Common.getRunningJar();
		Map<String, String> variableMap = new HashMap<>();
		variableMap.put("abc", "handlerClass");
		variableMap.put("abc.11shandlerClass", "sss");
		System.out.println(int.class.getSimpleName());
		try {
			List<String> names = Common.getClassesNameFromJar(CodeGenContext.getInstance(), new URL[] {new URL("file://D:\\Java\\jdk1.8.0_131\\jre\\lib\\rt.jar")});
			StringBuilder sb = new StringBuilder();
			names = names.stream().filter(e -> e.startsWith("java.") || e.startsWith("org.") || e.startsWith("javax.")).sorted((String str1, String str2)-> {
				if(str1.startsWith("java.") && str2.startsWith("java.")) {
					if(str1.startsWith("java.lang") && !str2.startsWith("java.lang")) {
						return -1;
					}else if(!str1.startsWith("java.lang") && str2.startsWith("java.lang")) {
						return 1;
					}else {
						if(str1.startsWith("java.util") && !str2.startsWith("java.util")) {
							return -1;
						}else if(!str1.startsWith("java.util") && str2.startsWith("java.util")) {
							return 1;
						}else {
							if(str1.startsWith("java.io") && !str2.startsWith("java.io")) {
								return -1;
							}else if(!str1.startsWith("java.io") && str2.startsWith("java.io")) {
								return 1;
							}else {
								return str1.compareTo(str2);
							}
						}
					}
				}else {
					return str1.compareTo(str2);
				}
			}).collect(Collectors.toList());
			names.forEach(e-> {
				sb.append(e).append("\r\n");
			 });
			File file = new File("d:\\jreclz.txt");
			Common.write(file,sb.toString());
		} catch (ClassNotFoundException | IOException e) {
			e.printStackTrace();
		}
		/*
		 * try { URL url =new
		 * URL("D:\\androidMavenRepository\\junit\\junit\\3.8.1\\junit-3.8.1.jar");
		 * getClassesFromJar(new URL[]{url}, CodeGenContext.newInstance()); } catch
		 * (ClassNotFoundException | IOException e) { // TODO Auto-generated catch block
		 * e.printStackTrace(); }
		 */
	}
	public List<Class> getMethodReturnGenericTypes(Method m) {
		List<Class> list = new ArrayList<>();
		Type returnType = m.getGenericReturnType();
		if (returnType instanceof ParameterizedType) {
			ParameterizedType pt = (ParameterizedType) returnType;
			Type ts[] = pt.getActualTypeArguments();
			for (Type t1 : ts) {
				if (t1 instanceof Class) {
					list.add((Class) t1);
				}
			}
		}
		return list;
	}
	public static void setModifier(int mod, CodeGenContext context) {
		context.getVariableMap().put(Replacement.PRIVILEDGE_MODIFIER.name(), "");
		context.getVariableMap().put(Replacement.STATIC_MODIFIER.name(), "");
		context.getVariableMap().put(Replacement.ABSTRACT_MODIFIER.name(), "");
		context.getVariableMap().put(Replacement.FINAL_MODIFIER.name(), "");
		context.getVariableMap().put(Replacement.SYNC_MODIFIER.name(), "");
		context.getVariableMap().put(Replacement.VOLATILE_MODIFIER.name(), "");
		if (Modifier.isPublic(mod)) {
			context.getVariableMap().put(Replacement.PRIVILEDGE_MODIFIER.name(), "public");
		}
		if (Modifier.isPrivate(mod)) {
			context.getVariableMap().put(Replacement.PRIVILEDGE_MODIFIER.name(), "private");
		}
		if (Modifier.isProtected(mod)) {
			context.getVariableMap().put(Replacement.PRIVILEDGE_MODIFIER.name(), "protected");
		}
		if (Modifier.isStatic(mod)) {
			context.getVariableMap().put(Replacement.STATIC_MODIFIER.name(), " static ");
		}
		if (Modifier.isAbstract(mod)) {
			context.getVariableMap().put(Replacement.ABSTRACT_MODIFIER.name(), " abstract ");
		}
		if (Modifier.isFinal(mod)) {
			context.getVariableMap().put(Replacement.FINAL_MODIFIER.name(), " final ");
		}
		if (Modifier.isVolatile(mod)) {
			context.getVariableMap().put(Replacement.VOLATILE_MODIFIER.name(), " volatile ");
		}
		if (Modifier.isSynchronized(mod)) {
			context.getVariableMap().put(Replacement.SYNC_MODIFIER.name(), " synchronized ");
		}
	}
	public static File getFileByPackage(String baseDir, String packName) {
		String regex = "\\.";
		String path = null;
		try {
			path = baseDir + File.separator + packName.replaceAll(regex, "\\" + File.separator);
		} catch (Exception e) {
			e.printStackTrace();
		}
		return new File(path);
	}
	public static void listAllFiles(File dir, String fileNameRegex, List<File> allFiles) {
		File fileArray[] = dir.listFiles();
		for (File file : fileArray) {
			if (file.isFile()) {
				String s = file.getName();
				boolean b = s.matches(fileNameRegex);
				if (b) {
					allFiles.add(file);
				}
			} else {
				listAllFiles(file, fileNameRegex, allFiles);
			}
		}
	}
	public static boolean isJarFile(File jarfile) {
		String fileName = jarfile.getName().toLowerCase();
		if (!fileName.endsWith("jar")) {
			return false;
		}
		try {
			ZipFile file = new ZipFile(jarfile);
			Enumeration<? extends ZipEntry> e = file.entries();
			if (e.hasMoreElements()) {
				ZipEntry entry = e.nextElement();
				return true;
			}
		} catch (Exception ex) {
			return false;
		}
		return true;
	}
	public static List<String> getClassesNameFromJar(CodeGenContext context, URL... uls)
			throws IOException, ClassNotFoundException {
		return getClassesNameFromJar(uls, null, context);
	}
	public static List<String> getClassesNameFromJar(URL uls[], String clzName, CodeGenContext context) {
		List<String> list = new ArrayList<>();
		for (int i = 0; i < uls.length; i++) {
			JarFile jarFile = null;
			try {
				jarFile = new JarFile(uls[i].getPath());
				list.addAll(getJarFileClassNames(jarFile, context));
			} catch (IOException e2) {
			}
		}
		return list;
	}
	public static List<String> getJarFileClassNames(JarFile jarFile, CodeGenContext context) {
		List<String> list = new ArrayList<>();
		if (jarFile != null) {
			Enumeration<JarEntry> e = jarFile.entries();
			while (e.hasMoreElements()) {
				JarEntry entry = e.nextElement();
				String name = entry.getName();
				if (name.endsWith(".class")) {
					CharSequence charSequence = null;
					name = name.replace(".class", "");
					name = name.replace("/", ".");
					if ("junit.framework.TestCase".equals(name)) {
						System.out.println("***");
					}
					list.add(name);
				}
			}
			try {
				jarFile.close();
			} catch (IOException e1) {
				e1.printStackTrace();
			}
		}
		return list;
	}
	public static Class[] getClassesFromJar(URL uls[], String clzName, CodeGenContext context) {
		List<Class> list = new ArrayList<>();
		for (int i = 0; i < uls.length; i++) {
			JarFile jarFile = null;
			try {
				jarFile = new JarFile(uls[i].getPath());
			} catch (IOException e2) {
			}
			if (jarFile != null) {
				Enumeration<JarEntry> e = jarFile.entries();
				while (e.hasMoreElements()) {
					JarEntry entry = e.nextElement();
					String name = entry.getName();
					if (name.endsWith(".class")) {
						CharSequence charSequence = null;
						name = name.replace(".class", "");
						name = name.replace("/", ".");
						if ("junit.framework.TestCase".equals(name)) {
							System.out.println("***");
						}
						Class c = null;
						try {
							c = CodeGenContext.getInstance().getReloadableDynamicClassLoaderOwner().loadClass(name,
									true);
							if (c != null) {
								String s = c.getCanonicalName();
								if (clzName != null && s != null && s.endsWith(clzName)) {
									list.add(c);
								} else if (clzName == null) {
									list.add(c);
								}
							}
						} catch (Exception e1) {
						}
					}
				}
				try {
					jarFile.close();
				} catch (IOException e1) {
					e1.printStackTrace();
				}
			}
		}
		return (Class[]) list.toArray(new Class[list.size()]);
	}
	public static URL getJarUrlByResource(String resourceName) throws Exception {
		URL url = Common.class.getClassLoader().getResource(resourceName);
		boolean b = false;
		while (!b) {
			String p = url.getProtocol();
			if ("jar".equalsIgnoreCase(p)) {
				return url;
			}
			File pf = new File(url.getPath()).getParentFile();
			url = new URL(pf.getAbsolutePath());
		}
		return null;
	}
	public static List<Constructor> getConstructorWithPrimitiveArgs(Class<?> clz) {
		List<Constructor> list = new ArrayList<>();
		Constructor constructorArray[] = clz.getConstructors();
		for(Constructor constructor : constructorArray){
			Class clzArray[] = constructor.getParameterTypes();
			boolean b = true;
			for(Class pt : clzArray){
				if(!Common.isPrimitiveType(pt)){
					b = false;
					break;
				}
			}
			if(b){
				list.add(constructor);
			}
		}
	    return list;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\codegen\util\MethodCallingKey.java---
package codegen.util;
public class MethodCallingKey {
	Class c;
	String methodName;
	public MethodCallingKey(Class c, String methodName) {
		super();
		this.c = c;
		this.methodName = methodName;
	}
	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + ((c == null) ? 0 : c.hashCode());
		result = prime * result + ((methodName == null) ? 0 : methodName.hashCode());
		return result;
	}
	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		MethodCallingKey other = (MethodCallingKey) obj;
		if (c == null) {
			if (other.c != null)
				return false;
		} else if (!c.equals(other.c))
			return false;
		if (methodName == null) {
			if (other.methodName != null)
				return false;
		} else if (!methodName.equals(other.methodName))
			return false;
		return true;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\codegen\util\PomUtil.java---
package codegen.util;
import org.apache.maven.model.Dependency;
import org.apache.maven.model.DependencyManagement;
import org.apache.maven.model.Model;
import org.apache.maven.model.Parent;
import org.apache.maven.model.io.xpp3.MavenXpp3Reader;
import org.codehaus.plexus.util.xml.pull.XmlPullParserException;
import java.io.*;
import java.util.List;
public class PomUtil {
	public PomUtil() {
	}
	public static Model parsePom(File file) throws FileNotFoundException, IOException, XmlPullParserException {
		MavenXpp3Reader reader = new MavenXpp3Reader();
		Model model = reader.read(new FileReader(file));
		Parent p = model.getParent();
		String path = null;
		if (p != null) {
			path = p.getRelativePath();
		}
		DependencyManagement dm = model.getDependencyManagement();
		List<Dependency> mgtdep = null;
		if (dm != null)
			mgtdep = dm.getDependencies();
		List<Dependency> eependencyLimod = model.getDependencies();
		return model;
	}
	public static Model parsePom(InputStream is) throws IOException, XmlPullParserException {
		MavenXpp3Reader reader = new MavenXpp3Reader();
		Model model = reader.read(is);
		return model;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\codegen\winsys\WinSysService.java---
package codegen.winsys;
import codegen.robot.Service;
import java.awt.event.KeyEvent;
public class WinSysService extends Service {
	public WinSysService() {
		super();
	}
	public void popupContextMenu() {
		this.getkRobot().clickCompositeKey(KeyEvent.VK_SHIFT, KeyEvent.VK_F10);
	}
	public void openExplorer() {
		this.getkRobot().clickCompositeKey(KeyEvent.VK_WINDOWS, KeyEvent.VK_E);
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\com\dgs\ActivatedHyperlinkListener.java---
package com.dgs;
import javax.swing.*;
import javax.swing.event.HyperlinkEvent;
import javax.swing.event.HyperlinkListener;
import javax.swing.text.Document;
import java.io.IOException;
import java.net.URL;
public class ActivatedHyperlinkListener implements HyperlinkListener{
	JEditorPane editorPane;
	public ActivatedHyperlinkListener(JEditorPane editorPane) {
		this.editorPane = editorPane;
	}
	public void hyperlinkUpdate(HyperlinkEvent hyperlinkEvent) {
		HyperlinkEvent.EventType type = hyperlinkEvent.getEventType();
		final URL url = hyperlinkEvent.getURL();
		if (type == HyperlinkEvent.EventType.ENTERED) {
			System.out.println("URL: " + url);
		} else if (type == HyperlinkEvent.EventType.ACTIVATED) {
			System.out.println("Activated");
			Runnable runner = new Runnable() {
				public void run() {
					Document doc = editorPane.getDocument();
					try {
						editorPane.setPage(url);
					} catch (IOException ioException) {
						editorPane.setDocument(doc);
					}
				}
			};
			SwingUtilities.invokeLater(runner);
		}
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\com\dgs\annotation\ComponentFieldAnno.java---
package com.dgs.annotation;
import java.lang.annotation.Documented;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface ComponentFieldAnno {
	String name();
	String value();
}
----strat of file D:\projects\cg\cg-min\src\main\java\com\dgs\annotation\DontActiveIDE.java---
package com.dgs.annotation;
import java.lang.annotation.Documented;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface DontActiveIDE {
}
----strat of file D:\projects\cg\cg-min\src\main\java\com\dgs\annotation\FileChooserAnnotation.java---
package com.dgs.annotation;
import java.lang.annotation.Documented;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface FileChooserAnnotation {
	boolean chooseDirOnly() default false;
}
----strat of file D:\projects\cg\cg-min\src\main\java\com\dgs\annotation\ParamAnno.java---
package com.dgs.annotation;
import java.lang.annotation.Documented;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface ParamAnno {
	String name() default "";
	String description();
}
----strat of file D:\projects\cg\cg-min\src\main\java\com\dgs\annotation\ServiceMethodAnn.java---
package com.dgs.annotation;
import java.lang.annotation.Documented;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface ServiceMethodAnn {
	String[] keyword();
	String description() default "";
	boolean visible() default true;
}
----strat of file D:\projects\cg\cg-min\src\main\java\com\dgs\annotation\UIAnno.java---
package com.dgs.annotation;
import java.lang.annotation.Documented;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
@Retention(RetentionPolicy.RUNTIME)
@Documented
/**
 * used for custom ui pane
 * for method level e.g. 
 * 
 * for param level e.g.
 * @UIAnno(uiClz = "ui.ClassCombBoxpane")
   @ParamAnno(description = "memory area") 
   @ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) 
   String areaName
 * @author osboxes
 *
 */
public @interface UIAnno {
	String uiClz() ;
}
----strat of file D:\projects\cg\cg-min\src\main\java\com\dgs\DatabaseService.java---
package com.dgs;
import javax.sql.DataSource;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
public abstract class DatabaseService {
	public DatabaseService() {
	}
	public String url;
	public String user;
	public String pwd ;
	public Connection getConnection(String driverClzName, String url, String user, String pwd) {
		Connection connection = null;
		try {
			Class.forName(driverClzName);
			this.url = url;
			this.user = user;
			this.pwd = pwd;
			connection = DriverManager.getConnection(url, user, pwd);
		} catch (SQLException | ClassNotFoundException e) {
			e.printStackTrace();
		}
		return connection;
	}
	public abstract DataSource getDataSource( String url, String user, String pwd) ;
	public abstract List<Map<String, String>> getAllShemaAndTableNames() throws SQLException;
	public abstract List<String> getAllTableNames() throws SQLException;
	public abstract Map<String, String> getTableIDColumns(String tableName) throws SQLException;
	public abstract List<String> getTableColumns(String tableName) throws SQLException;
	public abstract Map<String, String> getTableColumnAndType(String s) throws SQLException;
	boolean connectSuccess;
	public void setConnectSuccess(boolean connectSuccess) {;
		this.connectSuccess = connectSuccess;
	}
	public boolean isConnectSuccess() {
		return connectSuccess;
	}
	/**
	 * 
	 * @param selectedCols, key is column name, value is column value
	 * @param tableName
	 * @return
	 */
	public String genInsert(Map<String, String> selectedCols, String tableName) {
		if(selectedCols.isEmpty() || null==tableName) {
			return "";
		}
		Set<String> keys = selectedCols.keySet();
		StringBuilder sb = new StringBuilder();
		sb.append("insert into "+tableName +"(");
		for(String s : keys){
			sb.append(String.format(" %s,", s));
		}
		sb.deleteCharAt(sb.length()-1);
		sb.append(") values (");
		for(String s : keys){
			sb.append(String.format("'%s',", selectedCols.get(s)));
		}
		sb.deleteCharAt(sb.length()-1);
		sb.append(")");
	    return sb.toString();
	}
	public String genUpdate(Map<String, String> selectedCols, Map<String, String> whereCols, String tableName) throws SQLException {
		if(selectedCols.isEmpty() || null==tableName) {
			return "";
		}
		Set<String> keys = selectedCols.keySet();
		StringBuilder sb = new StringBuilder();
		sb.append("update "+tableName + " set ");
		for(String k : keys){
			sb.append(String.format(" %s =%s,", k, selectedCols.get(k)));
		}
		sb.deleteCharAt(sb.length()-1);
		sb.append(" where ");
		Set<String> wk = whereCols.keySet();
		for(String k : wk){
			sb.append(String.format(" %s ='%s' and ", k, whereCols.get(k)));
		}
		if(!wk.isEmpty()) {
			sb.delete(sb.length()-4, sb.length());
		}
	    return sb.toString();
	}
	public String genUpdateById(Map<String, String> selectedCols, String tableName) throws SQLException {
		Map<String, String> whereCols = this.getTableIDColumns(tableName);
		whereCols.replaceAll((k,v) -> "?");
	    return this.genUpdate(selectedCols, whereCols, tableName);
	}
	/**
	 * 
	 * @param selectedCols
	 * @param tableName
	 * @param joinTableNames
	 * @param joinCols tableA.id, tableB.id2
	 * @param whereCols tableA.name, table.name value
	 * @return
	 * @throws SQLException
	 */
	public String genSelect(Map<String, String> selectedCols,String tableName,List<String> joinTableNames, Map<String, String> joinCols, Map<String, String> whereCols) throws SQLException {
		if(selectedCols.isEmpty() || null==tableName) {
			return "";
		}
		Set<String> keys = selectedCols.keySet();
		StringBuilder sb = new StringBuilder("select ");
		for(String k : keys){
			sb.append(String.format(" %s as %s,", k, selectedCols.get(k)));
		}
		sb.deleteCharAt(sb.length()-1);
		sb.append(" from "+tableName);
		if(joinCols.isEmpty() && whereCols.isEmpty()) {
			return sb.toString();
		}
		Set<String> ks = joinCols.keySet();
		for(String k : ks){
			sb.append(String.format(" %s ='%s' and ", k, joinCols.get(k)));
		}
		sb.append(" where ");
		Set<String> whereK = whereCols.keySet();
		for(String k : whereK){
			sb.append(String.format(" %s ='%s' and ", k, whereCols.get(k)));
		}
		if(!whereK.isEmpty()) {
			sb.delete(sb.length()-4, sb.length());
		}
	    return sb.toString();
	}
	public String genSelect(Map<String, String> selectedCols, Map<String, String> whereCols, String tableName) throws SQLException {
		if(selectedCols.isEmpty() || null==tableName) {
			return "";
		}
		Set<String> keys = selectedCols.keySet();
		StringBuilder sb = new StringBuilder("select ");
		for(String k : keys){
			sb.append(String.format(" %s as %s,", k, selectedCols.get(k)));
		}
		sb.deleteCharAt(sb.length()-1);
		sb.append(" from "+tableName);
		if(selectedCols.isEmpty()) {
			return sb.toString();
		}
		sb.append(" where ");
		Set<String> whereK = whereCols.keySet();
		for(String k : whereK){
			sb.append(String.format(" %s ='%s' and ", k, whereCols.get(k)));
		}
		if(!whereK.isEmpty()) {
			sb.delete(sb.length()-4, sb.length());
		}
	    return sb.toString();
	}
	public String genSelectById(Map<String, String> selectedCols, String tableName) throws SQLException {
		Map<String, String> whereCols = this.getTableIDColumns(tableName);
		whereCols.replaceAll((k,v) -> "?");
	    return genSelect(selectedCols, whereCols, tableName);
	}
	public String genDelete(String tableName, Map<String, String> whereCols) throws SQLException {
		StringBuilder sb = new StringBuilder();
		sb.append("delete from " + tableName);
		if(whereCols.isEmpty()) {
			return sb.toString();
		}
		sb.append(" where ");
		Set<String> idk = whereCols.keySet();
		for(String k : idk){
			sb.append(String.format(" %s ='%s' and ", k, whereCols.get(k)));
		}
		if(!idk.isEmpty()) {
			sb.delete(sb.length()-4, sb.length());
		}
	    return sb.toString();
	}
	public String genDeleteById(String tableName) throws SQLException {
		Map<String, String> whereCols = this.getTableIDColumns(tableName);
		whereCols.replaceAll((k,v) -> "?");
	    return genDelete(tableName, whereCols);
	}
	public static void main(String[] args) {
	}
	public String getUrl() {
		return url;
	}
	public void setUrl(String url) {
		this.url = url;
	}
	public String getUser() {
		return user;
	}
	public void setUser(String user) {
		this.user = user;
	}
	public String getPwd() {
		return pwd;
	}
	public void setPwd(String pwd) {
		this.pwd = pwd;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\com\dgs\DragTest.java---
package com.dgs;
import javax.swing.*;
import java.awt.*;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.event.MouseMotionListener;
public class DragTest extends JFrame implements MouseMotionListener, MouseListener {
	private JPanel leftPanel = new JPanel(null);
	private JPanel rightPanel = new JPanel(null);
	JLabel dropLabel;
	public DragTest() {
		this.setLayout(new GridLayout(1, 2));
		leftPanel.setBorder(BorderFactory.createLineBorder(Color.black));
		rightPanel.setBorder(BorderFactory.createLineBorder(Color.black));
		this.add(leftPanel);
		this.add(rightPanel);
		leftPanel.addMouseListener(this);
		leftPanel.addMouseMotionListener(this);
		JTextArea area = new JTextArea();
		rightPanel.setLayout(new GridLayout(1, 1));
		rightPanel.add(area);
		dropLabel = new JLabel("drop");
		dropLabel.setTransferHandler(new TransferHandler("text"));
	}
	@Override
	public void mousePressed(MouseEvent e) {
		System.out.println("mousePressed");
		Dimension labelSize = dropLabel.getPreferredSize();
		dropLabel.setSize(labelSize);
		int x = e.getX() - labelSize.width / 2;
		int y = e.getY() - labelSize.height / 2;
		dropLabel.setLocation(x, y);
		leftPanel.add(dropLabel);
		repaint();
	}
	@Override
	public void mouseDragged(MouseEvent me) {
		System.out.println("mouseDragged");
		dropLabel.getTransferHandler().exportAsDrag(dropLabel, me, TransferHandler.COPY);
	}
	@Override
	public void mouseMoved(MouseEvent e) {
	}
	@Override
	public void mouseClicked(MouseEvent e) {
		System.out.println("mouseClicked");
	}
	@Override
	public void mouseReleased(MouseEvent e) {
		System.out.println("mouseReleased");
	}
	@Override
	public void mouseEntered(MouseEvent e) {
	}
	@Override
	public void mouseExited(MouseEvent e) {
	}
	public static void main(String[] args) {
		DragTest frame = new DragTest();
		frame.setVisible(true);
		frame.setSize(600, 400);
		frame.setResizable(false);
		frame.setLocationRelativeTo(null);
		frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\com\dgs\EPTest.java---
package com.dgs;
import javax.swing.*;
import javax.swing.event.HyperlinkListener;
import javax.swing.text.BadLocationException;
import javax.swing.text.ChangedCharSetException;
import javax.swing.text.html.HTMLDocument;
import javax.swing.text.html.HTMLEditorKit;
import javax.swing.text.html.StyleSheet;
import java.io.*;
import java.net.URL;
import java.nio.charset.Charset;
import java.util.Iterator;
import java.util.Set;
import java.util.SortedMap;
public class EPTest {
	JEditorPane pane;
	HTMLEditorKit kit;
	public EPTest() {
		kit = new HTMLEditorKit();
		pane = new JEditorPane();
		pane.setEditable(false);
		HyperlinkListener hyperlinkListener = new ActivatedHyperlinkListener(pane);
		pane.addHyperlinkListener(hyperlinkListener);
		pane.setEditorKit(kit);
		StyleSheet styleSheet = new StyleSheet();
		ClassLoader classLoader = this.getClass().getClassLoader();
		String arg0 = "css.css";
		URL uRL = classLoader.getResource(arg0);
		try {
			String rules = readAsStr(new File(uRL.getPath()));
		} catch (IOException e) {
			e.printStackTrace();
		}
		loadWithSetPage();
	}
	public static String readAsStr(File f) throws IOException {
		FileInputStream is = new FileInputStream(f);
		StringBuilder sb = new StringBuilder();
		BufferedReader in = null;
		try {
			in = new BufferedReader(new InputStreamReader(is));
			String line = null;
			while ((line = in.readLine()) != null) {
				sb.append(line).append("\r\n");
			}
		} catch (IOException e) {
			e.printStackTrace();
			throw e;
		} finally {
			if (in != null)
				try {
					in.close();
				} catch (IOException e) {
					e.printStackTrace();
				}
		}
		return sb.toString();
		}
	public static void write(File f, String fileStr) throws IOException {
		FileOutputStream fos = new FileOutputStream(f);
		fos.write(fileStr.getBytes());
		fos.flush();
		fos.close();
	}
	/**
	 * works okay with the meta tag in the html file only if the trailing/closing
	 * slash is absent ie, this '...>' instead of this '... />' // edit
	 */
	private void loadWithSetPage() {
		try {
			pane.setPage(getClass().getClassLoader().getResource("tabletest.html"));
		} catch (IOException ioe) {
			System.err.println("setPage read: " + ioe.getMessage());
		}
	}
	private void loadWithReader() {
		Object o = read(); // okay without meta statement
		if (o instanceof Charset) // we get here if file has a meta statement
		{
			String name = ((Charset) o).name();
			read((Charset) o); // cannot get this to work
		} else
			System.out.println("o = " + o.toString());
	}
	private Object read() {
		Reader fin = null;
		try {
			fin = // new BufferedReader(
					new InputStreamReader(new FileInputStream("eptest.html"));
		} catch (FileNotFoundException fnfe) {
			System.err.println("file not found: " + fnfe.getMessage());
			return Boolean.FALSE;
		}
		try {
			System.out.println(((InputStreamReader) fin).getEncoding());
			HTMLDocument doc = (HTMLDocument) pane.getDocument();
			kit.read(fin, doc, 0);
			return Boolean.TRUE;
		} catch (ChangedCharSetException ccse) {
			String s = ccse.getCharSetSpec();
			System.out.println("changed charSet " + s);
			Charset cs = Charset.forName(s.substring(s.indexOf("charset=") + 8));
			System.out.println("cs = " + cs.toString());
			return cs;
		} catch (BadLocationException ble) {
			System.err.println("location: " + ble.getMessage());
			return Boolean.FALSE;
		} catch (IOException ioe) {
			System.err.println("read: " + ioe.getMessage());
			return Boolean.FALSE;
		}
		finally {
			try {
				fin.close();
			} catch (IOException ioe) {
				System.err.println("close: " + ioe.getMessage());
				return Boolean.FALSE;
			}
		}
	}
	/**
	 * all three InputStreamReader constructor forms fail if html file contains a
	 * meta statement for content/charset otherwise they seem to work okay
	 */
	private void read(Charset cs) {
		Reader fin = null;
		try {
			fin = new BufferedReader(new InputStreamReader(new FileInputStream("eptest.html"), cs));
		} catch (FileNotFoundException fnfe) {
			System.err.println("file not found: " + fnfe.getMessage());
		}
		try {
			HTMLDocument doc = (HTMLDocument) pane.getDocument();
			kit.read(fin, doc, 0);
		} catch (BadLocationException ble) {
			System.err.println("location: " + ble.getMessage());
		} catch (IOException ioe) {
			System.err.println("read: " + ioe.getMessage());
		}
		finally {
			try {
				fin.close();
			} catch (IOException ioe) {
				System.err.println("close: " + ioe.getMessage());
			}
		}
	}
	private void showAvailableCharsets() {
		SortedMap<String, Charset> map = Charset.availableCharsets();
		Set<String> keys = map.keySet();
		Iterator it = keys.iterator();
		while (it.hasNext())
			System.out.println((Charset) map.get((String) it.next()));
	}
	public static void main(String[] args) {
		try {
			UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
		} catch (Exception ignored) {
		}
		JFrame f = new JFrame();
		f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		f.getContentPane().add(new EPTest().pane);
		f.setSize(400, 400);
		f.setLocation(200, 200);
		f.setVisible(true);
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\com\dgs\JListExample.java---
package com.dgs;
import javax.swing.*;
import javax.swing.event.ListSelectionEvent;
import javax.swing.event.ListSelectionListener;
public class JListExample extends JFrame {
	static JFrame f;
	static JList b;
	public static void main(String[] args) {
		f = new JFrame("frame");
		JListExample s = new JListExample();
		JPanel p = new JPanel();
		JLabel l = new JLabel("select the day of the week");
		String week[] = { "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday" };
		b = new JList(week);
		b.setVisibleRowCount(5);
		b.setFixedCellHeight(15);
		b.addListSelectionListener(new ListSelectionListener () {
			@Override
			public void valueChanged(ListSelectionEvent e) {
			}
		}); 
		b.setSelectedIndex(2);
		b.setSelectionMode(ListSelectionModel.MULTIPLE_INTERVAL_SELECTION);
		p.add(b);
		f.add(p);
		f.setSize(400, 400);
		try { 
			UIManager.setLookAndFeel("com.sun.java.swing.plaf.windows.WindowsLookAndFeel");
			SwingUtilities.updateComponentTreeUI(f);
	    } catch(Exception e){e.printStackTrace();}
		f.show();
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\com\dgs\jnaforwin32\App.java---
package com.dgs.jnaforwin32;
import com.sun.jna.Native;
import com.sun.jna.platform.win32.WinDef.HWND;
import com.sun.jna.win32.W32APIOptions;
import javax.swing.*;
import java.awt.*;
/**
 * Hello world!
 *
 */
public class App extends JFrame
{
    public static void main( String[] args )
    {
    	try {
			Thread.sleep(3300L);
		} catch (InterruptedException e1) {
			e1.printStackTrace();
		}
    	User32Ext INSTANCE = (User32Ext)Native.loadLibrary("user32", User32Ext.class, W32APIOptions.DEFAULT_OPTIONS);
    	HWND hwnd = INSTANCE.GetDesktopWindow();
    	hwnd = INSTANCE.GetForegroundWindow();
    	char[] chArray = new char[1000];
    	INSTANCE.GetWindowText(hwnd, chArray, 900);
    	System.out.println(new String(chArray));
    	App app = new App();
    	app.setSize(200, 200);
    	JTextField jf = new JTextField();
    	JButton btn = new JButton("ok");
    	app.getContentPane().setLayout(new BorderLayout());
    	app.getContentPane().add(jf, BorderLayout.CENTER);
    	app.getContentPane().add(btn, BorderLayout.SOUTH);
    	jf.setText(new String(chArray));
    	final HWND ecHWND = hwnd;
    	btn.addActionListener(l->{
    		try {
    			Thread.sleep(300L);
    			INSTANCE.SwitchToThisWindow(ecHWND, true);
    			INSTANCE.SetForegroundWindow(ecHWND);
    			HWND activeWinHWND = INSTANCE.GetForegroundWindow();
    			char[] chArray1 = new char[1000];
    	    	int validLen = INSTANCE.GetWindowText(activeWinHWND, chArray1, chArray1.length);
    	    	String str = new String(chArray1, 0, validLen);
    	    	jf.setText(str);
    	    	System.out.println(str);
    		} catch (InterruptedException e) {
    			e.printStackTrace();
    		}
    	});
    	app.setVisible(true);
    	HWND ecWindow = INSTANCE.FindWindow("", "");
    }
}
----strat of file D:\projects\cg\cg-min\src\main\java\com\dgs\jnaforwin32\Kernel32.java---
package com.dgs.jnaforwin32;
import com.sun.jna.Native;
import com.sun.jna.Pointer;
import com.sun.jna.win32.StdCallLibrary;
public interface Kernel32 extends StdCallLibrary {
    Kernel32 INSTANCE = (Kernel32) Native.loadLibrary("Kernel32", Kernel32.class);
    Pointer OpenProcess(int dwDesiredAccess, boolean bInheritHandle, int dwProcessId);
    boolean CloseHandle(Pointer hObject);
}
----strat of file D:\projects\cg\cg-min\src\main\java\com\dgs\jnaforwin32\User32Ext.java---
package com.dgs.jnaforwin32;
import com.sun.jna.platform.win32.User32;
import com.sun.jna.platform.win32.WinDef.HWND;
public interface User32Ext extends User32 {
	HWND FindWindowEx(HWND lpParent, HWND lpChild, String lpClassName, String lpWindowName);
	HWND GetTopWindow(HWND hwnd);
	HWND GetParent(HWND hwnd);
	HWND GetDesktopWindow();
	HWND GetForegroundWindow();
	int SendMessage(HWND hWnd, int dwFlags, byte bVk, int dwExtraInfo);
	int SendMessage(HWND hWnd, int Msg, int wParam, String lParam);
	void keybd_event(byte bVk, byte bScan, int dwFlags, int dwExtraInfo);
	void SwitchToThisWindow(HWND hWnd, boolean fAltTab);
	public HWND GetActiveWindow();
}
----strat of file D:\projects\cg\cg-min\src\main\java\com\dgs\jnaforwin32\WindowService.java---
package com.dgs.jnaforwin32;
import com.sun.jna.Native;
import com.sun.jna.platform.win32.WinDef.HWND;
import com.sun.jna.win32.W32APIOptions;
import java.util.Objects;
public class WindowService {
	public static  final  String ECLIPSE_WINDOW_TEXT_KEY_WORD = "eclipse";
	public User32Ext INSTANCE;
	{
	    try {
            INSTANCE = (User32Ext)Native.loadLibrary("user32", User32Ext.class, W32APIOptions.DEFAULT_OPTIONS);
	    }catch(Error | Exception e) {
            System.out.println("cannot loading user32 lib");
        }
	}
	public String getActiveWindowText() {
	    if(!Objects.isNull(INSTANCE)) {
    		HWND hwnd = INSTANCE.GetForegroundWindow();
    		char[] chArray = new char[1000];
        	INSTANCE.GetWindowText(hwnd, chArray, 900);
        	String text = new String(chArray);
        	if(!Objects.isNull(text)){
        		text = text.trim();
        	}
        	return text;
	    }else {
	        return "";
	    }
	}
	public String switchToWindow() {
	    return null;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\com\dgs\MD5Test.java---
package com.dgs;
import java.io.FileInputStream;
import java.io.InputStream;
import java.security.MessageDigest;
public class MD5Test {
	public static byte[] createChecksum(String filename) throws Exception {
		InputStream fis = new FileInputStream(filename);
		byte[] buffer = new byte[1024];
		MessageDigest complete = MessageDigest.getInstance("MD5");
		int numRead;
		do {
			numRead = fis.read(buffer);
			if (numRead > 0) {
				complete.update(buffer, 0, numRead);
			}
		} while (numRead != -1);
		fis.close();
		return complete.digest();
	}
	public static String getMD5Checksum(String filename) throws Exception {
		byte[] b = createChecksum(filename);
		String result = "";
		for (int i = 0; i < b.length; i++) {
			result += Integer.toString((b[i] & 0xff) + 0x100, 16).substring(1);
		}
		return result;
	}
	public static void main(String args[]) {
		try {
			System.out.println(getMD5Checksum("D:\\netprojects\\clipboardmonitorwindow\\production\\WpfApp1\\WpfApp1\\bin\\Debug\\WpfApp1.pdb"));
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\com\dgs\SplitFrame.java---
package com.dgs;
import javax.swing.*;
class SplitFrame extends JFrame {
	static JFrame f;
	static JTextArea t1, t2;
	public static void main(String[] args) {
		f = new JFrame("frame");
		SplitFrame s = new SplitFrame();
		JPanel p1 = new JPanel();
		JPanel p = new JPanel();
		t1 = new JTextArea(10, 10);
		t2 = new JTextArea(10, 10);
		t1.setText("this is first text area");
		t2.setText("this is second text area");
		p1.add(t1);
		p.add(t2);
		JSplitPane sl = new JSplitPane(SwingConstants.VERTICAL, p1, p);
		sl.setOrientation(SwingConstants.VERTICAL);
		f.add(sl);
		f.setSize(300, 300);
		f.show();
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\com\dgs\SwingFrameService.java---
package com.dgs;
import javax.swing.*;
import java.awt.*;
import java.io.File;
public class SwingFrameService extends JFrame{
	private JTextField jTextField;
	private JButton jButton;
	private JFileChooser jFileChooser;
	public SwingFrameService() {
		jTextField = new JTextField(10);
		jButton =  new JButton("open file");
		jButton.addActionListener(e -> {
            selectFile();
        });
		Container container = this.getContentPane();
		FlowLayout flowLayout = new FlowLayout(FlowLayout.LEFT);
		this.setLayout(flowLayout);
		container.add(jTextField);
		container.add(jButton);
		this.setVisible(true);
		this.setSize(200, 100);
		this.setLocation(200, 100);
	}
	public void selectFile() {
        JFileChooser chooser = new JFileChooser();
        if (chooser.showOpenDialog(this) == JFileChooser.APPROVE_OPTION) {
            File file = chooser.getSelectedFile();
            String s = file.getAbsolutePath();
            jTextField.setText(s);
        } else {
        }
    }
	public static void main(String[] args){
		SwingFrameService swingFrameService = new SwingFrameService();
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\com\dgs\SwingWorker1.java---
package com.dgs;
import javax.swing.*;
import java.util.List;
public class SwingWorker1 extends SwingWorker {
	public SwingWorker1() {
	}
	@Override
	protected Object doInBackground() throws Exception {
		return null;
	}
	@Override
	protected void process(List chunks) {
		super.process(chunks);
	}
	@Override
	protected void done() {
		super.done();
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\com\dgs\TestNetSocket.java---
package com.dgs;
import java.io.*;
import java.net.Socket;
public class TestNetSocket {
	private Socket socket;
	public TestNetSocket() {
	}
	public String sendAndReceive() {
		StringBuilder sb = new StringBuilder();
		try {
			Thread.sleep(3000L);
			socket = new Socket("localhost", 8999);
			socket.setSoTimeout(3000);
			OutputStream outputStream = socket.getOutputStream();
			outputStream.write("switchProcess\r\n".getBytes());
			outputStream.flush();
			InputStream inputStream = socket.getInputStream();
			InputStreamReader inputStreamReader = new InputStreamReader(inputStream);
			BufferedReader bufferedReader = new BufferedReader(inputStreamReader);
			String s = null;
			while((s=bufferedReader.readLine())!=null){
				sb.append(s);
			}
			outputStream.close();
			inputStream.close();
		} catch (Exception e) {
			e.printStackTrace();
		}finally {
			try {
				socket.close();
			} catch (IOException e) {
				e.printStackTrace();
			}
		}
	    return sb.toString();
	}
	public static  void main(String args[]) {
		TestNetSocket tns = new TestNetSocket();
		String s =tns.sendAndReceive();
		System.out.println(String.format("s=%s",s));
	    return ;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\com\github\gemba\artifactresolver\DependencyGraphPrinter.java---
package com.github.gemba.artifactresolver;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Stack;
import org.eclipse.aether.graph.DependencyNode;
import org.eclipse.aether.graph.DependencyVisitor;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
public class DependencyGraphPrinter implements DependencyVisitor {
	private static final Logger log = LoggerFactory.getLogger(DependencyGraphPrinter.class);
	private static final String DEFAULT_INDENT = "|   ";
	private static final String DEFAULT_BRANCH = "+---";
	private static final String DEFAULT_TERMINAL = "\\---";
	private String indent = "";
	private Stack<DependencyNode> nodes = new Stack();
	private HashMap<Integer, Integer> dependencyCounter = new HashMap();
	List<DependencyNode> nodeList = new ArrayList();
	public DependencyGraphPrinter(List<DependencyNode> nodeList) {
		this.nodeList = nodeList;
	}
	public DependencyGraphPrinter() {
	}
	public boolean visitEnter(DependencyNode node) {
		int children = node.getChildren().size();
		int parentChildren = 0;
		if (this.nodes.size() > 0) {
			parentChildren = ((DependencyNode)this.nodes.peek()).getChildren().size();
		}
		this.nodes.push(node);
		Integer count = (Integer)this.dependencyCounter.get(this.indent.length());
		if (count == null) {
			count = 1;
		} else {
			count = count + 1;
		}
		this.dependencyCounter.put(this.indent.length(), count);
		String in;
		if (count == parentChildren) {
			in = this.indent.replace("+---", "\\---");
		} else {
			in = this.indent.replace("\\---", "+---");
		}
		this.nodeList.add(node);
		log.info("  {}{}", in, node);
		if (this.indent.length() == 0) {
			this.indent = "+---";
		} else if (children == 1 && children == parentChildren) {
			this.indent = "|    " + this.indent.substring(1);
		} else {
			this.indent = "|   " + this.indent;
		}
		return true;
	}
	public boolean visitLeave(DependencyNode node) {
		this.dependencyCounter.remove(this.indent.length());
		this.nodes.pop();
		this.indent = this.indent.substring("|   ".length());
		return true;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\com\github\gemba\artifactresolver\DependencyResolver.java---
package com.github.gemba.artifactresolver;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import org.eclipse.aether.artifact.Artifact;
import org.eclipse.aether.artifact.DefaultArtifact;
import org.eclipse.aether.collection.DependencyCollectionException;
import org.eclipse.aether.graph.Dependency;
import org.eclipse.aether.graph.DependencyFilter;
import org.eclipse.aether.graph.DependencyNode;
import org.eclipse.aether.resolution.ArtifactRequest;
import org.eclipse.aether.resolution.ArtifactResult;
import org.eclipse.aether.resolution.DependencyRequest;
import org.eclipse.aether.resolution.DependencyResolutionException;
import org.eclipse.aether.resolution.DependencyResult;
import org.eclipse.aether.util.filter.DependencyFilterUtils;
import org.eclipse.aether.util.graph.visitor.FilteringDependencyVisitor;
import org.eclipse.aether.util.graph.visitor.TreeDependencyVisitor;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
public class DependencyResolver {
	private static final Logger log = LoggerFactory.getLogger(DependencyResolver.class);
	private RepositorySystemHelper repoSystemHelper;
	public DependencyResolver(RepositorySystemHelper repoSystemHelper) {
		this.repoSystemHelper = repoSystemHelper;
	}
	public List<String> getProjDepArtifactFilePath(DefaultArtifact artifact) throws DependencyCollectionException, DependencyResolutionException {
		log.info("Resolving: {} with these dependencies ...", artifact.toString());
		List<String> list = new ArrayList();
		Dependency dependency = new Dependency(artifact, "compile");
		DependencyNode jarNode = this.repoSystemHelper.collectDependencies(dependency);
		DependencyFilter classpathFilter = DependencyFilterUtils.classpathFilter(new String[]{"test"});
		List<DependencyNode> nodeList = new ArrayList();
		jarNode.accept(new TreeDependencyVisitor(new FilteringDependencyVisitor(new DependencyGraphPrinter(nodeList), classpathFilter)));
		nodeList.stream().forEach((dn) -> {
			ArtifactRequest ar = new ArtifactRequest(dn);
			try {
				ArtifactResult aresult = this.repoSystemHelper.resolveArtifact(ar);
				if (aresult.getArtifact() != null && aresult.getArtifact().getFile() != null) {
					list.add(aresult.getArtifact().getFile().getAbsolutePath());
				}
			} catch (Exception var5) {
			}
		});
		return list;
	}
	public static void main(String[] args) {
		String groupId = "brain";
		String artifactId = "knowledge";
		String version = "0.0.1-SNAPSHOT";
		String localRep = "D:\\androidMavenRepository";
		DefaultArtifact artifact = new DefaultArtifact(groupId, artifactId, "jar", version);
		RepositorySystemHelper repoSystemHelper = null;
		try {
			repoSystemHelper = new RepositorySystemHelper(localRep, new HashMap());
		} catch (Exception var10) {
			var10.printStackTrace();
		}
		DependencyResolver dependencyResolver = new DependencyResolver(repoSystemHelper);
		try {
			dependencyResolver.getProjDepArtifactFilePath(artifact);
		} catch (DependencyResolutionException | DependencyCollectionException var9) {
			var9.printStackTrace();
		}
	}
	public void downloadDependencyTree(DefaultArtifact artifact, boolean javadoc, boolean sources) throws DependencyCollectionException, DependencyResolutionException {
		log.info("Resolving: {} with these dependencies ...", artifact.toString());
		Dependency dependency = new Dependency(artifact, "compile");
		DependencyNode jarNode = this.repoSystemHelper.collectDependencies(dependency);
		DependencyFilter classpathFilter = DependencyFilterUtils.classpathFilter(new String[]{"test"});
		jarNode.accept(new TreeDependencyVisitor(new FilteringDependencyVisitor(new DependencyGraphPrinter(), classpathFilter)));
		DependencyRequest dependencyRequest = new DependencyRequest(jarNode, classpathFilter);
		DependencyResult dependencyResult = this.repoSystemHelper.resolveDependencies(dependencyRequest);
		if (javadoc) {
			this.downloadAttachments(dependencyResult, "javadoc");
		}
		if (sources) {
			this.downloadAttachments(dependencyResult, "sources");
		}
	}
	private void downloadAttachments(DependencyResult depResult, String attachment) throws DependencyCollectionException {
		Iterator var4 = depResult.getArtifactResults().iterator();
		while(var4.hasNext()) {
			ArtifactResult artifactResult = (ArtifactResult)var4.next();
			Artifact artifact = artifactResult.getArtifact();
			String artifactId = artifact.getArtifactId();
			String groupId = artifact.getGroupId();
			String extension = artifact.getExtension();
			String version = artifact.getVersion();
			log.info("Resolving {} for {}", attachment, artifact);
			try {
				DefaultArtifact extraArtifact = new DefaultArtifact(groupId, artifactId, attachment, extension, version);
				Dependency attachedDependency = new Dependency(extraArtifact, "compile");
				DependencyNode attachmentNode = this.repoSystemHelper.collectDependencies(attachedDependency);
				DependencyRequest javadocDependencyRequest = new DependencyRequest(attachmentNode, (DependencyFilter)null);
				this.repoSystemHelper.resolveDependencies(javadocDependencyRequest);
			} catch (DependencyResolutionException var14) {
				log.warn("No {} found for {}", attachment, artifact);
			}
		}
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\com\github\gemba\artifactresolver\MavenDependencyDownloader.java---
package com.github.gemba.artifactresolver;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import org.apache.commons.cli.CommandLine;
import org.apache.commons.cli.CommandLineParser;
import org.apache.commons.cli.DefaultParser;
import org.apache.commons.cli.HelpFormatter;
import org.apache.commons.cli.Option;
import org.apache.commons.cli.Options;
import org.apache.commons.cli.ParseException;
import org.apache.commons.io.IOUtils;
import org.eclipse.aether.artifact.DefaultArtifact;
import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
public class MavenDependencyDownloader {
	private static final String DEFAULT_LOCAL_DOWNLOAD_REPO = "D:\\androidMavenRepository";
	private static final String DEFAULT_DEPENDENCY_FILE = "dependencies.json";
	private static final String EXTRA_REPO_FILE = "extra-repos.json";
	private static final Logger log = LoggerFactory.getLogger(MavenDependencyDownloader.class);
	private static Options options;
	private static boolean javadoc = false;
	private static boolean sources = false;
	private static String dependencyFile;
	private static String localRepo;
	private static ArrayList<DefaultArtifact> artifacts;
	private static DependencyResolver dependencyResolver;
	private static Map<String, String> extraRepos = new HashMap();
	private MavenDependencyDownloader() {
		this.createOptions();
	}
	public static void main(String[] args) throws Exception {
		new MavenDependencyDownloader();
		parseCommandLine(args);
		readExtraRepos();
		RepositorySystemHelper repoSystemHelper = new RepositorySystemHelper(localRepo, extraRepos);
		dependencyResolver = new DependencyResolver(repoSystemHelper);
		if (artifacts.isEmpty()) {
			JSONParser jsonParser = new JSONParser();
			FileReader fileReader = new FileReader(new File(dependencyFile));
			JSONArray jsonArray = (JSONArray)jsonParser.parse(fileReader);
			fileReader.close();
			Iterator var6 = jsonArray.iterator();
			while(var6.hasNext()) {
				Object obj = var6.next();
				JSONObject jsonObj = (JSONObject)obj;
				String groupId = (String)jsonObj.get("groupId");
				String artifactId = (String)jsonObj.get("artifactId");
				String classifier = (String)jsonObj.get("classifier");
				String extension = (String)jsonObj.get("extension");
				String version = (String)jsonObj.get("version");
				DefaultArtifact artifact = new DefaultArtifact(groupId, artifactId, classifier, extension, version);
				dependencyResolver.getProjDepArtifactFilePath(artifact);
			}
		} else {
			Iterator var15 = artifacts.iterator();
			while(var15.hasNext()) {
				DefaultArtifact artifact = (DefaultArtifact)var15.next();
				dependencyResolver.downloadDependencyTree(artifact, javadoc, sources);
			}
		}
		log.info("... artifacts downloaded to \"{}\". Finished. Thank you.", localRepo);
	}
	private static void parseCommandLine(String[] args) {
		CommandLineParser parser = new DefaultParser();
		CommandLine line = null;
		try {
			line = parser.parse(options, args);
		} catch (ParseException var8) {
			System.err.println("Parsing failed: " + var8.getMessage());
			System.exit(1);
		}
		if (line.hasOption('h')) {
			HelpFormatter formatter = new HelpFormatter();
			String header = "where each [coord] is expected in the format <groupId>:<artifactId>[:<extension>[:<classifier>]]:<version>, separate multiple [coord] by a space. If [coord] is provided the JSON file will be ignored. Defaults are: <extension>=jar, <classifier>=\"\".\n\n Options are:";
			String footer = "\nAdditonal repositories to be searched for dependencies can be added in file 'extra-repos.json'";
			formatter.printHelp(MavenDependencyDownloader.class.getSimpleName() + " [coords...] [options]", header, options, footer);
			System.exit(0);
		}
		if (line.hasOption('j')) {
			javadoc = true;
		}
		if (line.hasOption('s')) {
			sources = true;
		}
		dependencyFile = line.getOptionValue('f', "dependencies.json");
		localRepo = line.getOptionValue('d', "D:\\androidMavenRepository");
		artifacts = new ArrayList();
		String[] var6;
		int var11 = (var6 = line.getArgs()).length;
		for(int var10 = 0; var10 < var11; ++var10) {
			String arg = var6[var10];
			if (arg.contains(":")) {
				DefaultArtifact artifact = new DefaultArtifact(arg);
				artifacts.add(artifact);
			}
		}
	}
	private void createOptions() {
		options = new Options();
		Option help = new Option("h", "help", false, "print this usage and exit");
		Option jsonFile = Option.builder("f").longOpt("dependency-file").desc("use this JSON dependency file (default:dependencies.json)").hasArg().argName("JSON-File").build();
		Option depDir = Option.builder("d").longOpt("dependency-dir").desc("download dependencies to this folder (default:D:\\androidMavenRepository)").hasArg().argName("Directory").build();
		Option javadoc = Option.builder("j").longOpt("with-javadoc").desc("download javadoc attachment of artifact").build();
		Option sources = Option.builder("s").longOpt("with-sources").desc("download source attachment of artifact").build();
		options.addOption(help);
		options.addOption(depDir);
		options.addOption(jsonFile);
		options.addOption(javadoc);
		options.addOption(sources);
	}
	private static void readExtraRepos() throws Exception {
		JSONParser jsonParser = new JSONParser();
		FileReader fileReader = null;
		try {
			fileReader = new FileReader(new File("extra-repos.json"));
			JSONArray jsonArray = (JSONArray)jsonParser.parse(fileReader);
			fileReader.close();
			Iterator var4 = jsonArray.iterator();
			while(var4.hasNext()) {
				Object obj = var4.next();
				JSONObject jsonObj = (JSONObject)obj;
				String id = (String)jsonObj.get("id");
				String repourl = (String)jsonObj.get("repourl");
				extraRepos.put(id, repourl);
			}
			return;
		} catch (FileNotFoundException var11) {
			log.debug("No extra repositories defined. File not found: {}.", "extra-repos.json");
		} finally {
			IOUtils.closeQuietly(fileReader);
		}
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\com\github\gemba\artifactresolver\RepositorySystemHelper.java---
package com.github.gemba.artifactresolver;
import java.util.Iterator;
import java.util.Map;
import java.util.Map.Entry;
import org.apache.maven.repository.internal.MavenRepositorySystemUtils;
import org.eclipse.aether.DefaultRepositorySystemSession;
import org.eclipse.aether.RepositorySystem;
import org.eclipse.aether.RepositorySystemSession;
import org.eclipse.aether.collection.CollectRequest;
import org.eclipse.aether.collection.DependencyCollectionException;
import org.eclipse.aether.collection.DependencySelector;
import org.eclipse.aether.connector.basic.BasicRepositoryConnectorFactory;
import org.eclipse.aether.graph.Dependency;
import org.eclipse.aether.graph.DependencyNode;
import org.eclipse.aether.impl.DefaultServiceLocator;
import org.eclipse.aether.impl.DefaultServiceLocator.ErrorHandler;
import org.eclipse.aether.repository.LocalRepository;
import org.eclipse.aether.repository.RemoteRepository;
import org.eclipse.aether.repository.RemoteRepository.Builder;
import org.eclipse.aether.resolution.ArtifactRequest;
import org.eclipse.aether.resolution.ArtifactResolutionException;
import org.eclipse.aether.resolution.ArtifactResult;
import org.eclipse.aether.resolution.DependencyRequest;
import org.eclipse.aether.resolution.DependencyResolutionException;
import org.eclipse.aether.resolution.DependencyResult;
import org.eclipse.aether.spi.connector.RepositoryConnectorFactory;
import org.eclipse.aether.spi.connector.transport.TransporterFactory;
import org.eclipse.aether.transport.file.FileTransporterFactory;
import org.eclipse.aether.transport.http.HttpTransporterFactory;
import org.eclipse.aether.util.graph.selector.AndDependencySelector;
import org.eclipse.aether.util.graph.selector.ExclusionDependencySelector;
import org.eclipse.aether.util.graph.selector.OptionalDependencySelector;
import org.eclipse.aether.util.graph.selector.ScopeDependencySelector;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
public class RepositorySystemHelper {
	private RepositorySystem repoSystem = this.newRepositorySystem();
	private RepositorySystemSession session;
	private CollectRequest collectRequest;
	private static final Logger log = LoggerFactory.getLogger(RepositorySystemHelper.class);
	public RepositorySystemHelper(String localRepoDir, Map<String, String> extraRepos) {
		this.session = this.newSession(this.repoSystem, localRepoDir);
		RemoteRepository central = (new Builder("central", "default", "http://central.maven.org/maven2/")).build();
		this.collectRequest = new CollectRequest();
		RemoteRepository repo = null;
		Entry e;
		for(Iterator iterator = extraRepos.entrySet().iterator(); iterator.hasNext(); repo = (new Builder((String)e.getKey(), "default", (String)e.getValue())).build()) {
			e = (Entry)iterator.next();
		}
	}
	public DependencyNode collectDependencies(Dependency dependency) throws DependencyCollectionException {
		this.collectRequest.setRoot(dependency);
		((DefaultRepositorySystemSession)this.session).setIgnoreArtifactDescriptorRepositories(true);
		return this.repoSystem.collectDependencies(this.session, this.collectRequest).getRoot();
	}
	public DependencyResult resolveDependencies(DependencyRequest dependencyRequest) throws DependencyResolutionException {
		return this.repoSystem.resolveDependencies(this.session, dependencyRequest);
	}
	private RepositorySystemSession newSession(RepositorySystem system, String localDownloadDir) {
		DefaultRepositorySystemSession session = MavenRepositorySystemUtils.newSession();
		session.setIgnoreArtifactDescriptorRepositories(true);
		LocalRepository localRepo = new LocalRepository(localDownloadDir);
		session.setLocalRepositoryManager(system.newLocalRepositoryManager(session, localRepo));
		DependencySelector depFilter = new AndDependencySelector(new DependencySelector[]{new ScopeDependencySelector(new String[]{"provided"}), new OptionalDependencySelector(), new ExclusionDependencySelector()});
		session.setDependencySelector(depFilter);
		return session;
	}
	private RepositorySystem newRepositorySystem() {
		DefaultServiceLocator locator = MavenRepositorySystemUtils.newServiceLocator();
		locator.addService(RepositoryConnectorFactory.class, BasicRepositoryConnectorFactory.class);
		locator.addService(TransporterFactory.class, FileTransporterFactory.class);
		locator.addService(TransporterFactory.class, HttpTransporterFactory.class);
		locator.setErrorHandler(new ErrorHandler() {
			public void serviceCreationFailed(Class<?> type, Class<?> impl, Throwable exception) {
				exception.printStackTrace();
			}
		});
		return (RepositorySystem)locator.getService(RepositorySystem.class);
	}
	public ArtifactResult resolveArtifact(ArtifactRequest ar) throws ArtifactResolutionException {
		((DefaultRepositorySystemSession)this.session).setIgnoreArtifactDescriptorRepositories(true);
		return this.repoSystem.resolveArtifact(this.session, ar);
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\objinit\ObjWithDefaultValCreator.java---
package objinit;
import codegen.complexobj.CodeGenContext;
import javax.xml.datatype.DatatypeConfigurationException;
import javax.xml.datatype.DatatypeFactory;
import javax.xml.datatype.XMLGregorianCalendar;
import java.lang.reflect.*;
import java.util.*;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import java.util.stream.Stream;
public class ObjWithDefaultValCreator {
	public static Object getDefaultVal(Class c) {
		Object defaultVal = null;
		if (c != null) {
			String typeName = c.getName();
			if (typeName.equals("java.lang.String")) {
				defaultVal = "";
			}
			if (typeName.equals("java.lang.Boolean") || typeName.equals("boolean")) {
				defaultVal = Boolean.FALSE;
			}
			if (typeName.equals("java.lang.Long") || typeName.equals("long")) {
				defaultVal = Long.valueOf(1L);
			}
			if (typeName.equals("java.lang.Double") || typeName.equals("double")) {
				defaultVal = Double.valueOf(0d);
			}
			if (typeName.equals("java.lang.Integer") || typeName.equals("int")) {
				defaultVal = Integer.valueOf(1);
			}
			if (typeName.equals("java.lang.Short") || typeName.equals("short")) {
				defaultVal = Short.valueOf((short) 1);
			}
			if (typeName.equals("java.lang.Float") || typeName.equals("float")) {
				defaultVal = Float.valueOf(1f);
			}
			if (typeName.equals("java.lang.Character") || typeName.equals("char")) {
				return 'a';
			}
			if (typeName.equals("java.util.Date")) {
				defaultVal = new Date();
			}
			if (typeName.equals("java.sql.Date")) {
				defaultVal = new java.sql.Date(new Date().getTime());
			}
			if (typeName.startsWith("java.util.Map")) {
				defaultVal = new HashMap();
			}
			if (typeName.startsWith("java.util.Set")) {
				defaultVal = new HashSet();
			}
			if (typeName.equals("java.math.BigInteger")) {
				defaultVal = java.math.BigInteger.valueOf(1);
			}
			if (typeName.equals("java.math.BigDecimal")) {
				defaultVal = java.math.BigDecimal.valueOf(0);
			}
			if (typeName.equals("javax.xml.datatype.XMLGregorianCalendar")) {
				defaultVal = toXMLGregorianCalendar(new Date());
			}
			if (c != null && c.isEnum()) {
				defaultVal = getEnum(c);
			}
		}
		return defaultVal;
	}
	private static DatatypeFactory df = null;
	static {
		try {
			df = DatatypeFactory.newInstance();
		} catch (DatatypeConfigurationException dce) {
			throw new IllegalStateException("Exception", dce);
		}
	}
	public static XMLGregorianCalendar toXMLGregorianCalendar(long timeInMillis) {
		GregorianCalendar gc = new GregorianCalendar();
		gc.setTimeInMillis(timeInMillis);
		return df.newXMLGregorianCalendar(gc);
	}
	public static XMLGregorianCalendar toXMLGregorianCalendar(Date date) {
		if (date == null) {
			return null;
		} else {
			return toXMLGregorianCalendar(date.getTime());
		}
	}
	public static boolean isComplexType(Class c) {
		boolean b = false;
		if (c.isPrimitive() || c.isEnum()) {
			return b;
		}
		/*
		 * if (c.isArray()) { c = c.getComponentType(); }
		 */
		String typeName = c.getName();
		if (typeName.equals("java.lang.String")) {
			return b;
		}
		if (typeName.equals("java.lang.Boolean") || typeName.equals("boolean")) {
			return b;
		}
		if (typeName.equals("java.lang.Character") || typeName.equals("char")) {
			return b;
		}
		if (typeName.equals("java.lang.Long") || typeName.equals("long")) {
			return b;
		}
		if (typeName.equals("java.lang.Double") || typeName.equals("double")) {
			return b;
		}
		if (typeName.equals("java.lang.Integer") || typeName.equals("int")) {
			return b;
		}
		if (typeName.equals("java.lang.Short") || typeName.equals("short")) {
			return b;
		}
		if (typeName.equals("java.lang.Float") || typeName.equals("float")) {
			return b;
		}
		if (typeName.equals("java.lang.Byte") || typeName.equals("byte")) {
			return b;
		}
		if (typeName.equals("java.util.Date")) {
			return b;
		}
		if (typeName.equals("java.math.BigInteger")) {
			return b;
		}
		if (typeName.equals("java.math.BigDecimal")) {
			return b;
		}
		if (typeName.equals("javax.xml.datatype.XMLGregorianCalendar")) {
			return b;
		}
		b = true;
		return b;
	}
	public static Object getEnum(Class c) {
		StringBuilder sb = new StringBuilder();
		String classNameForPrint = c.getName().replaceAll("\\$", "\\.");
		Object obj[] = c.getEnumConstants();
		return obj[0];
	}
	public <T> T newInstanceByConstructor(Class<T> qn) {
		T obj = null;
		if (!this.isComplexType(qn)) {
			obj = (T) getDefaultVal(qn);
			return obj;
		}
		try {
			obj = qn.newInstance();
		} catch (InstantiationException | IllegalAccessException e1) {
			Constructor<?> cts[] = qn.getConstructors();
			List<Constructor> list = Arrays.asList(cts);
			list.sort((c1, c2) -> {
				int c1ParamCount = c1.getParameterCount();
				int c2ParamCount = c1.getParameterCount();
				return c1ParamCount - c2ParamCount;
			});
			if (list.size() > 0) {
				Constructor<?> cs = list.get(0);
				Parameter pts[] = cs.getParameters();
				try {
					obj = (T) cs.newInstance();
				} catch (InstantiationException | IllegalAccessException | IllegalArgumentException
						| InvocationTargetException e) {
				}
			}
		}
		return obj;
	}
	public static boolean isAbstractOrInterface(Class clzToTest) {
		boolean abs = false;
		if (!clzToTest.isPrimitive() && (clzToTest.isInterface() || isAbstract(clzToTest))) {
			abs = true;
		}
		return abs;
	}
	public static boolean isAbstract(Class clzToTest) {
		boolean abs = false;
		if ((clzToTest.getModifiers() & Modifier.ABSTRACT) == Modifier.ABSTRACT) {
			abs = true;
		}
		return abs;
	}
	public static Class getDefaultConcreteClass(Class interfaceC) {
		Class concreteC = null;
		if (!interfaceC.isInterface() && !isAbstract(interfaceC) && !interfaceC.isArray()) {
			return interfaceC;
		}
		if (List.class.isAssignableFrom(interfaceC) || AbstractList.class.isAssignableFrom(interfaceC)
				|| Iterable.class.isAssignableFrom(interfaceC)) {
			concreteC = ArrayList.class;
		} else if (Map.class.isAssignableFrom(interfaceC) || AbstractMap.class.isAssignableFrom(interfaceC)) {
			concreteC = HashMap.class;
		} else if (Set.class.isAssignableFrom(interfaceC) || AbstractSet.class.isAssignableFrom(interfaceC)) {
			concreteC = HashSet.class;
		}
		return concreteC;
	}
	class clzRef {
		Class c;
		Class referenceC;
		AtomicInteger passByTimes = new AtomicInteger(0);
		public AtomicInteger getPassByTimes() {
			return passByTimes;
		}
		public void setPassByTimes(AtomicInteger passByTimes) {
			this.passByTimes = passByTimes;
		}
		public Class getC() {
			return c;
		}
		public void setC(Class c) {
			this.c = c;
		}
		public Class getReferenceC() {
			return referenceC;
		}
		public void setReferenceC(Class referenceC) {
			this.referenceC = referenceC;
		}
		public clzRef(Class c, Class referenceC) {
			super();
			this.c = c;
			this.referenceC = referenceC;
			this.passByTimes.getAndSet(0);
		}
		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;
			result = prime * result + getOuterType().hashCode();
			result = prime * result + ((c == null) ? 0 : c.hashCode());
			result = prime * result + ((referenceC == null) ? 0 : referenceC.hashCode());
			return result;
		}
		@Override
		public boolean equals(Object obj) {
			if (this == obj)
				return true;
			if (obj == null)
				return false;
			if (getClass() != obj.getClass())
				return false;
			clzRef other = (clzRef) obj;
			if (!getOuterType().equals(other.getOuterType()))
				return false;
			if (c == null) {
				if (other.c != null)
					return false;
			} else if (!c.equals(other.c))
				return false;
			if (referenceC == null) {
				if (other.referenceC != null)
					return false;
			} else if (!referenceC.equals(other.referenceC))
				return false;
			return true;
		}
		@Override
		public String toString() {
			StringBuilder builder = new StringBuilder();
			builder.append("clzRef [");
			builder.append(c.getSimpleName());
			builder.append("-->");
			builder.append(referenceC.getSimpleName());
			builder.append("]");
			return builder.toString();
		}
		private ObjWithDefaultValCreator getOuterType() {
			return ObjWithDefaultValCreator.this;
		}
	}
	public Map<Class, AtomicInteger> getAllCircularDependencyRelatedClz(Map<clzRef, List<clzRef>> map) {
		List<Class> list = new ArrayList<>();
		map.entrySet().forEach(e -> {
			Class keyC = e.getKey().getC();
			Class keyRefC = e.getKey().getReferenceC();
			List<clzRef> valList = e.getValue();
			if (!list.contains(keyC))
				list.add(keyC);
			if (!list.contains(keyRefC))
				list.add(keyRefC);
			valList.forEach(e1 -> {
				if (!list.contains(e1.getC()))
					list.add(e1.getC());
				if (!list.contains(e1.getReferenceC()))
					list.add(e1.getReferenceC());
			});
		});
		Map<Class, AtomicInteger> circularDependencyRelatedClzMap = list.stream()
				.collect(Collectors.toMap(e -> e, e -> {
					return new AtomicInteger(0);
				}, (e1, e2) -> e1));
		return circularDependencyRelatedClzMap;
	}
	public Map<clzRef, List<clzRef>> getCircularDependencyPath(List<clzRef> clzRefList) {
		Map<clzRef, List<clzRef>> alldependencyPath = new HashMap<>();
		Map<clzRef, List<clzRef>> selfdependencyPath = clzRefList.stream().filter(cr -> {
			return cr.getC().equals(cr.getReferenceC());
		}).collect(Collectors.toMap(e -> clzRef.class.cast(e), e -> {
			return Stream.of(clzRef.class.cast(e)).collect(Collectors.toList());
		}, (e1, e2) -> e1));
		alldependencyPath.putAll(selfdependencyPath);
		List<clzRef> notSelfDependencyList = clzRefList.stream().filter(cr -> {
			if (!cr.getC().equals(cr.getReferenceC())) {
				return true;
			} else {
				return false;
			}
		}).collect(Collectors.toList());
		List<Class> distinctReferenceClz = notSelfDependencyList.stream().map(
				clzRef::getReferenceC).distinct()
				.collect(Collectors.toList());
		List<clzRef> startPointClzRefMayContainsCircularDependency = notSelfDependencyList.stream().filter(cr -> {
			return distinctReferenceClz.contains(cr.getC());
		}).distinct().collect(Collectors.toList());
		Map<clzRef, List<clzRef>> dependencyPath = new HashMap<>();
		startPointClzRefMayContainsCircularDependency.stream().forEach(cr -> {
			List<clzRef> allPath = new ArrayList<>();
			allPath.add(cr);
			dependencyPath.put(cr, allPath);
			getCircularDepencyPath(cr, null, notSelfDependencyList, dependencyPath);
			notSelfDependencyList.stream().forEach(d -> {
				d.getPassByTimes().set(0);
			});
		});
		dependencyPath.keySet().forEach(k -> {
			List<clzRef> tmpdependencyPath = dependencyPath.get(k);
			if (tmpdependencyPath.size() >= 2) {
				clzRef startclzRef = tmpdependencyPath.get(0);
				clzRef lastclzRef = tmpdependencyPath.get(tmpdependencyPath.size() - 1);
				if (startclzRef.getC().equals(lastclzRef.getReferenceC())) {
					alldependencyPath.put(k, tmpdependencyPath);
				}
			}
		});
		return alldependencyPath;
	}
	public void getCircularDepencyPath(clzRef startClzRef, clzRef nextClzRef, List<clzRef> notSelfDependencyList,
			Map<clzRef, List<clzRef>> dependencyPath) {
		if (nextClzRef == null) {
			startClzRef.getPassByTimes().incrementAndGet();
			List<clzRef> nextClzRefList = notSelfDependencyList.stream().filter(cr -> {
				return cr.getPassByTimes().get() == 0 && cr.getC().equals(startClzRef.getReferenceC());
			}).collect(Collectors.toList());
			nextClzRefList.forEach(cr -> {
				getCircularDepencyPath(startClzRef, cr, notSelfDependencyList, dependencyPath);
			});
		} else {
			nextClzRef.getPassByTimes().incrementAndGet();
			if (dependencyPath.containsKey(startClzRef)) {
				dependencyPath.get(startClzRef).add(nextClzRef);
			}
			if (nextClzRef.getReferenceC().equals(startClzRef.getC())) {
				return;
			}
			List<clzRef> nextClzRefList = notSelfDependencyList.stream().filter(cr -> {
				return cr.getPassByTimes().get() == 0 && cr.getC().equals(nextClzRef.getReferenceC());
			}).collect(Collectors.toList());
			nextClzRefList.forEach(cr -> {
				getCircularDepencyPath(startClzRef, cr, notSelfDependencyList, dependencyPath);
			});
		}
	}
	/*
	 * public void getCircularDepencyPath(clzRef startClzRef, clzRef nextClzRef,
	 * List<clzRef> notSelfDependencyList, Map<clzRef, List<clzRef>> dependencyPath)
	 * { if (nextClzRef == null) { startClzRef.getPassByTimes().incrementAndGet();
	 * List<clzRef> nextClzRefList = notSelfDependencyList.stream().filter(cr -> {
	 * return cr.getPassByTimes().get() == 0 &&
	 * cr.getC().equals(startClzRef.getReferenceC());
	 * }).collect(Collectors.toList()); nextClzRefList.forEach(cr -> {
	 * getCircularDepencyPath(startClzRef, cr, notSelfDependencyList,
	 * dependencyPath); }); } else { nextClzRef.getPassByTimes().incrementAndGet();
	 * if (dependencyPath.containsKey(startClzRef)) {
	 * dependencyPath.get(startClzRef).add(nextClzRef); } if
	 * (nextClzRef.getReferenceC().equals(startClzRef.getC())) { return; }
	 * List<clzRef> nextClzRefList = notSelfDependencyList.stream().filter(cr -> {
	 * return cr.getPassByTimes().get() == 0 &&
	 * cr.getC().equals(nextClzRef.getReferenceC());
	 * }).collect(Collectors.toList()); nextClzRefList.forEach(cr -> {
	 * getCircularDepencyPath(startClzRef, cr, notSelfDependencyList,
	 * dependencyPath); }); } }
	 */
	public void findCircularDependcy(Class c1, List<Class<?>> alreadyWalkThrough, List<clzRef> clzRefList) {
		List<Field> list = new ArrayList<>();
		if (alreadyWalkThrough.contains(c1)) {
			return;
		}
		if (isComplexType(c1)) {
			alreadyWalkThrough.add(c1);
			list = getAllFields(c1);
			list.forEach(f -> {
				Class c = f.getType();
				if (isComplexType(c)) {
					Object complexObj = null;
					boolean isArray = c.isArray();
					boolean isAbstractOrInterface = isAbstractOrInterface(c);
					if (!isAbstractOrInterface && !isArray) {
						complexObj = newInstanceByConstructor(c);
						if (complexObj != null) {
							boolean isComplexType = isComplexType(complexObj.getClass());
							if (isComplexType) {
								clzRefList.add(new clzRef(c1, complexObj.getClass()));
								findCircularDependcy(complexObj.getClass(), alreadyWalkThrough, clzRefList);
							}
						}
					} else if (isArray) {
						complexObj = Array.newInstance(c.getComponentType(), 1);
					} else if (isAbstractOrInterface) {
						Class<?> concreteC = getDefaultConcreteClass(c);
						if (concreteC != null) {
							complexObj = this.newInstanceByConstructor(concreteC);
						}
					}
					if (complexObj != null) {
						if (isArray) {
							Class componentType = c.getComponentType();
							Class concreteC = componentType;
							if (isAbstractOrInterface(componentType)) {
								concreteC = getDefaultConcreteClass(c);
							}
							if (concreteC != null) {
								Object componentTypeObj = this.newInstanceByConstructor(concreteC);
								if (componentTypeObj != null) {
									boolean isComplexType = isComplexType(componentTypeObj.getClass());
									if (isComplexType) {
										clzRefList.add(new clzRef(c1, componentTypeObj.getClass()));
										findCircularDependcy(componentTypeObj.getClass(), alreadyWalkThrough,
												clzRefList);
									}
								}
							}
						}
						if (java.util.Collection.class.isAssignableFrom(c)) {
							String genericTypeName = f.getGenericType().getTypeName();
							String genericType = null;
							Pattern p = Pattern.compile("<(.+)>");
							Matcher m = p.matcher(genericTypeName);
							if (m.find()) {
								genericType = m.group(1);
								try {
									String javaformatgenericType = genericType;// genericType.replaceAll("\\$",
									Class genericTypeC = CodeGenContext.getInstance()
											.getReloadableDynamicClassLoaderOwner()
											.loadClass(javaformatgenericType, true);
									Class concreteC = genericTypeC;
									if (isAbstractOrInterface(genericTypeC)) {
										concreteC = getDefaultConcreteClass(c);
									}
									if (concreteC != null) {
										Object componentTypeObj = this.newInstanceByConstructor(concreteC);
										if (componentTypeObj != null) {
											boolean isComplexType = isComplexType(componentTypeObj.getClass());
											boolean at = alreadyWalkThrough.contains(componentTypeObj.getClass());
											if (isComplexType) {
												clzRefList.add(new clzRef(c1, componentTypeObj.getClass()));
												findCircularDependcy(componentTypeObj.getClass(), alreadyWalkThrough,
														clzRefList);
											}
										}
									}
								} catch (Exception e) {
								}
							}
						}
						if (Map.class.isAssignableFrom(c)) {
							String genericTypeName = f.getGenericType().getTypeName();
							String genericType = null;
							Pattern p = Pattern.compile("<(.+)>");
							Matcher m = p.matcher(genericTypeName);
							Class keyType = null;
							Class valType = null;
							if (m.find()) {
								try {
									genericType = m.group(1);
								} catch (Exception e1) {
									e1.printStackTrace();
								}
								if (genericType != null) {
									try {
										String javaformatgenericType = genericType;// genericType.replaceAll("\\$",
										String gt[] = javaformatgenericType.split(",", -1);
										keyType = CodeGenContext.getInstance().getReloadableDynamicClassLoaderOwner()
												.loadClass(gt[0].trim(), true);
										valType = CodeGenContext.getInstance().getReloadableDynamicClassLoaderOwner()
												.loadClass(gt[1].trim(), true);
									} catch (Exception e) {
									}
								}
							}
							if (keyType != null && valType != null) {
								Class concreteKeyC = keyType;
								Class concreteValC = valType;
								if (isAbstractOrInterface(keyType)) {
									concreteKeyC = getDefaultConcreteClass(keyType);
								}
								if (isAbstractOrInterface(valType)) {
									concreteValC = getDefaultConcreteClass(valType);
								}
								if (concreteKeyC != null && concreteValC != null) {
									Object keyObj = this.newInstanceByConstructor(concreteKeyC);
									Object valObj = this.newInstanceByConstructor(concreteValC);
									if (keyObj != null && valObj != null) {
										boolean isComplexType = isComplexType(keyObj.getClass());
										if (isComplexType) {
											clzRefList.add(new clzRef(c1, keyObj.getClass()));
											findCircularDependcy(keyObj.getClass(), alreadyWalkThrough, clzRefList);
										}
										boolean isvalObjComplexType = isComplexType(valObj.getClass());
										if (isvalObjComplexType) {
											clzRefList.add(new clzRef(c1, valObj.getClass()));
											findCircularDependcy(valObj.getClass(), alreadyWalkThrough, clzRefList);
										}
									}
								}
							}
						}
					}
				}
			});
		}
	}
	public Map<Class, AtomicInteger> getAllCircularDependencyClzMap(Class c) {
		List<Class<?>> alreadyWalkThrough = new ArrayList<>();
		List<clzRef> clzRefList = new ArrayList<>();
		this.findCircularDependcy(c, alreadyWalkThrough, clzRefList);
		Map<clzRef, List<clzRef>> circularDependencyMap = this.getCircularDependencyPath(clzRefList);
		Map<Class, AtomicInteger> allCircularDependencyClz = this
				.getAllCircularDependencyRelatedClz(circularDependencyMap);
		return allCircularDependencyClz;
	}
	public static boolean isExclusive(String expression, String exclusiveRegex) {
		if (exclusiveRegex == null || "".equals(exclusiveRegex)) {
			return false;
		}
		Pattern p = Pattern.compile(exclusiveRegex);
		Matcher m = p.matcher(expression);
		return m.matches();
	}
	public void newInstanceRecusively(Object tobj, List allComplexTypeObj,
			Map<Class, AtomicInteger> circularDependencyRelatedClzMap, int defaultSize, String exclusiveRegex) {
		List<Field> list = new ArrayList<>();
		Class c1 = tobj.getClass();
		if (isComplexType(c1)) {
			allComplexTypeObj.add(tobj);
			if (circularDependencyRelatedClzMap.containsKey(c1)) {
				if (circularDependencyRelatedClzMap.get(c1).get() > 0) {
					return;
				} else {
					circularDependencyRelatedClzMap.get(c1).incrementAndGet();
				}
			}
			list = getAllFields(c1, exclusiveRegex);
			list.forEach(f -> {
				Class c = f.getType();
				boolean isExclusive = isExclusive(c.getName(), exclusiveRegex);
				if (!isExclusive && isComplexType(c)) {
					Object complexObj = null;
					boolean isArray = c.isArray();
					boolean isAbstractOrInterface = isAbstractOrInterface(c);
					if (!isAbstractOrInterface && !isArray) {
						complexObj = newInstanceByConstructor(c);
						if (complexObj != null) {
							boolean isComplexType = isComplexType(complexObj.getClass());
							if (isComplexType) {
								allComplexTypeObj.add(complexObj);
								newInstanceRecusively(complexObj, allComplexTypeObj, circularDependencyRelatedClzMap,
										defaultSize, exclusiveRegex);
							}
						}
					} else if (isArray) {
						complexObj = Array.newInstance(c.getComponentType(), defaultSize);
					} else if (isAbstractOrInterface) {
						Class<?> concreteC = getDefaultConcreteClass(c);
						if (concreteC != null) {
							complexObj = this.newInstanceByConstructor(concreteC);
						}
					}
					if (complexObj != null) {
						f.setAccessible(true);
						try {
							isExclusive = isExclusive(complexObj.getClass().getName(), exclusiveRegex);
							if (!isExclusive)
								f.set(tobj, complexObj);
						} catch (Exception e) {
						}
					}
					if (isArray) {
						Class componentType = c.getComponentType();
						Class concreteC = componentType;
						if (isAbstractOrInterface(componentType)) {
							concreteC = getDefaultConcreteClass(c);
						}
						if (concreteC != null) {
							for (int i = 0; i < defaultSize; i++) {
								Object componentTypeObj = this.newInstanceByConstructor(concreteC);
								if (componentTypeObj != null) {
									Array.set(complexObj, i, componentTypeObj);
									boolean isComplexType = isComplexType(componentTypeObj.getClass());
									if (isComplexType) {
										allComplexTypeObj.add(componentTypeObj);
										newInstanceRecusively(componentTypeObj, allComplexTypeObj,
												circularDependencyRelatedClzMap, defaultSize, exclusiveRegex);
									}
								}
							}
						}
					}
					if (java.util.Collection.class.isAssignableFrom(c)) {
						String genericTypeName = f.getGenericType().getTypeName();
						String genericType = null;
						Pattern p = Pattern.compile("<(.+)>");
						Matcher m = p.matcher(genericTypeName);
						if (m.find()) {
							genericType = m.group(1);
							try {
								String javaformatgenericType = genericType;// genericType.replaceAll("\\$",
								Class genericTypeC = CodeGenContext.getInstance().getReloadableDynamicClassLoaderOwner()
										.loadClass(javaformatgenericType, true);
								Class concreteC = genericTypeC;
								if (isAbstractOrInterface(genericTypeC)) {
									concreteC = getDefaultConcreteClass(c);
								}
								isExclusive = isExclusive(concreteC.getName(), exclusiveRegex);
								if (!isExclusive && concreteC != null) {
									for (int i = defaultSize; i > 0; i--) {
										Object componentTypeObj = this.newInstanceByConstructor(concreteC);
										if (componentTypeObj != null) {
											List listTmp = (List) complexObj;
											listTmp.add(componentTypeObj);
											boolean isComplexType = isComplexType(componentTypeObj.getClass());
											if (isComplexType) {
												allComplexTypeObj.add(componentTypeObj);
												newInstanceRecusively(componentTypeObj, allComplexTypeObj,
														circularDependencyRelatedClzMap, defaultSize, exclusiveRegex);
											}
										}
									}
								}
							} catch (Exception e) {
							}
						}
					}
					if (Map.class.isAssignableFrom(c)) {
						String genericTypeName = f.getGenericType().getTypeName();
						String genericType = null;
						Pattern p = Pattern.compile("<(.+)>");
						Matcher m = p.matcher(genericTypeName);
						Class keyType = null;
						Class valType = null;
						if (m.find()) {
							try {
								genericType = m.group(1);
							} catch (Exception e1) {
								e1.printStackTrace();
							}
							if (genericType != null) {
								try {
									String javaformatgenericType = genericType;// genericType.replaceAll("\\$",
									String gt[] = javaformatgenericType.split(",", -1);
									keyType = CodeGenContext.getInstance().getReloadableDynamicClassLoaderOwner()
											.loadClass(gt[0].trim(), true);
									valType = CodeGenContext.getInstance().getReloadableDynamicClassLoaderOwner()
											.loadClass(gt[1].trim(), true);
								} catch (Exception e) {
								}
							}
						}
						if (keyType != null && valType != null) {
							Class concreteKeyC = keyType;
							Class concreteValC = valType;
							if (isAbstractOrInterface(keyType)) {
								concreteKeyC = getDefaultConcreteClass(keyType);
							}
							if (isAbstractOrInterface(valType)) {
								concreteValC = getDefaultConcreteClass(valType);
							}
							boolean isKeyConcern = isExclusive(concreteKeyC.getName(), exclusiveRegex);
							boolean isValConcern = isExclusive(concreteValC.getName(), exclusiveRegex);
							if (isKeyConcern && isValConcern && concreteKeyC != null && concreteValC != null) {
								for (int i = defaultSize; i > 0; i--) {
									Object keyObj = this.newInstanceByConstructor(concreteKeyC);
									Object valObj = this.newInstanceByConstructor(concreteValC);
									if (keyObj != null && valObj != null) {
										Map tmp = (Map) complexObj;
										tmp.put(keyObj, valObj);
										boolean isComplexType = isComplexType(keyObj.getClass());
										if (isComplexType) {
											allComplexTypeObj.add(keyObj);
											newInstanceRecusively(keyObj, allComplexTypeObj,
													circularDependencyRelatedClzMap, defaultSize, exclusiveRegex);
										}
										boolean isvalObjComplexType = isComplexType(valObj.getClass());
										if (isvalObjComplexType) {
											allComplexTypeObj.add(valObj);
											newInstanceRecusively(valObj, allComplexTypeObj,
													circularDependencyRelatedClzMap, defaultSize, exclusiveRegex);
										}
									}
								}
							}
						}
					}
				}
			});
		}
	}
	public static List<Field> getAllFields(Class c) {
		return getAllFields(c, null);
	}
	public static List<Field> getAllFields(Class c, String exclusiveRegex) {
		List<Field> allFieldList = new ArrayList<>();
		while (c != Object.class) {
			boolean isExclusive = isExclusive(c.getName(), exclusiveRegex);
			if (isExclusive) {
				break;
			}
			allFieldList.addAll(Arrays.asList(c.getDeclaredFields()));
			c = c.getSuperclass();
		}
		return allFieldList;
	}
	public void assignPrimitiveTypes(Object tobj) {
		assignPrimitiveTypes(tobj, null);
	}
	public void assignPrimitiveTypes(Object tobj, String exclusiveRegex) {
		List<Field> list = new ArrayList<>();
		Class c1 = tobj.getClass();
		list = getAllFields(c1, exclusiveRegex);
		list.forEach(f -> {
			Class c = f.getType();
			boolean isExclusive = isExclusive(c.getName(), exclusiveRegex);
			if (!isExclusive && !isComplexType(c)) {
				Object obj = null;
				f.setAccessible(true);
				/*
				 * try { obj = f.get(tobj); } catch (Exception e) { e.printStackTrace(); }
				 */
				Object value = this.getDefaultVal(c);
				try {
					f.set(tobj, value);
				} catch (Exception e) {
				}
			}
		});
	}
	public void assignComplextTypes(Object tobj, List<?> allComplexTypeObj) {
		assignComplextTypes(tobj, allComplexTypeObj, null);
	}
	public void assignComplextTypes(Object tobj, List<?> allComplexTypeObj, String exclusiveRegex) {
		List<Field> list = new ArrayList<>();
		Class c1 = tobj.getClass();
		list = getAllFields(c1, exclusiveRegex);
		list.forEach(f -> {
			try {
				f.setAccessible(true);
				Object fval = f.get(tobj);
				if (fval == null) {
					Class c = f.getType();
					Object alreadyCreatedInstance = null;
					try {
						alreadyCreatedInstance = allComplexTypeObj.stream().filter(e -> {
							return c.isInstance(e);
						}).findAny().get();
					} catch (Exception e1) {
					}
					boolean isExclusive = isExclusive(alreadyCreatedInstance.getClass().getCanonicalName(),
							exclusiveRegex) || isExclusive(c.getCanonicalName(), exclusiveRegex);
					if (alreadyCreatedInstance != null && !isExclusive) {
						try {
							f.set(tobj, alreadyCreatedInstance);
						} catch (Exception e) {
						}
					}
				}
			} catch (Exception e1) {
			}
		});
	}
	public <T> List<Class<?>> getAllReferComplexType(Class<T> t){
		List<Class<?>> allComplexTypeObj = new ArrayList<>();
		List<Class<?>> alreadyWalkThrough = new ArrayList<>();
		T obj = newInstanceByConstructor(t);
		if (obj != null) {
			List<clzRef> clzRefList = new ArrayList<>();
			this.findCircularDependcy(t, alreadyWalkThrough, clzRefList);
			for(clzRef cr : clzRefList){
				if(null!=cr.getC()){
					allComplexTypeObj.add(cr.getC());
				}
				if(null!=cr.getReferenceC()){
					allComplexTypeObj.add(cr.getReferenceC());
				}
			}
			allComplexTypeObj=allComplexTypeObj.stream().distinct().collect(Collectors.toList());
		}
		return allComplexTypeObj;
	}
	public <T> T newInstance(Class<T> t) {
		return newInstance(t, 2);
	}
	public <T> T newInstance(Class<T> t, int defaultSize) {
		return newInstance(t, defaultSize, null);
	}
	public <T> T newInstance(Class<T> t, int defaultSize, String exclusiveRegex) {
		List<?> allComplexTypeObj = new ArrayList<>();
		List<Class<?>> alreadyWalkThrough = new ArrayList<>();
		T obj = newInstanceByConstructor(t);
		if (obj != null) {
			List<clzRef> clzRefList = new ArrayList<>();
			this.findCircularDependcy(t, alreadyWalkThrough, clzRefList);
			Map<clzRef, List<clzRef>> circularDependencyMap = this.getCircularDependencyPath(clzRefList);
			Map<Class, AtomicInteger> allCircularDependencyClz = this
					.getAllCircularDependencyRelatedClz(circularDependencyMap);
			newInstanceRecusively(obj, allComplexTypeObj, allCircularDependencyClz, defaultSize, exclusiveRegex);
			allComplexTypeObj.forEach(ct -> {
				assignPrimitiveTypes(ct, exclusiveRegex);
				assignComplextTypes(ct, allComplexTypeObj, exclusiveRegex);
			});
		}
		return obj;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\objinit\ObjWithDefaultValCreatorStandAlone.java---
package objinit;
import javax.xml.datatype.DatatypeConfigurationException;
import javax.xml.datatype.DatatypeFactory;
import javax.xml.datatype.XMLGregorianCalendar;
import java.lang.reflect.*;
import java.util.*;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import java.util.stream.Stream;
public class ObjWithDefaultValCreatorStandAlone {
	public static Object getDefaultVal(Class c) {
		Object defaultVal = null;
		if (c != null) {
			String typeName = c.getName();
			if (typeName.equals("java.lang.String")) {
				defaultVal = "";
			}
			if (typeName.equals("java.lang.Boolean") || typeName.equals("boolean")) {
				defaultVal = Boolean.FALSE;
			}
			if (typeName.equals("java.lang.Long") || typeName.equals("long")) {
				defaultVal = Long.valueOf(1L);
			}
			if (typeName.equals("java.lang.Double") || typeName.equals("double")) {
				defaultVal = Double.valueOf(0d);
			}
			if (typeName.equals("java.lang.Integer") || typeName.equals("int")) {
				defaultVal = Integer.valueOf(1);
			}
			if (typeName.equals("java.lang.Short") || typeName.equals("short")) {
				defaultVal = Short.valueOf((short) 1);
			}
			if (typeName.equals("java.lang.Float") || typeName.equals("float")) {
				defaultVal = Float.valueOf(1f);
			}
			if (typeName.equals("java.lang.Character") || typeName.equals("char")) {
				return 'a';
			}
			if (typeName.equals("java.util.Date")) {
				defaultVal = new Date();
			}
			if (typeName.equals("java.sql.Date")) {
				defaultVal = new java.sql.Date(new Date().getTime());
			}
			if (typeName.startsWith("java.util.Map")) {
				defaultVal = new HashMap();
			}
			if (typeName.startsWith("java.util.Set")) {
				defaultVal = new HashSet();
			}
			if (typeName.equals("java.math.BigInteger")) {
				defaultVal = java.math.BigInteger.valueOf(1);
			}
			if (typeName.equals("java.math.BigDecimal")) {
				defaultVal = java.math.BigDecimal.valueOf(0);
			}
			if (typeName.equals("javax.xml.datatype.XMLGregorianCalendar")) {
				defaultVal = toXMLGregorianCalendar(new Date());
			}
			if (c != null && c.isEnum()) {
				defaultVal = getEnum(c);
			}
		}
		return defaultVal;
	}
	private static DatatypeFactory df = null;
	static {
		try {
			df = DatatypeFactory.newInstance();
		} catch (DatatypeConfigurationException dce) {
			throw new IllegalStateException("Exception", dce);
		}
	}
	public static XMLGregorianCalendar toXMLGregorianCalendar(long timeInMillis) {
		GregorianCalendar gc = new GregorianCalendar();
		gc.setTimeInMillis(timeInMillis);
		return df.newXMLGregorianCalendar(gc);
	}
	public static XMLGregorianCalendar toXMLGregorianCalendar(Date date) {
		if (date == null) {
			return null;
		} else {
			return toXMLGregorianCalendar(date.getTime());
		}
	}
	public static boolean isComplexType(Class c) {
		boolean b = false;
		if (c.isPrimitive() || c.isEnum()) {
			return b;
		}
		/*
		 * if (c.isArray()) { c = c.getComponentType(); }
		 */
		String typeName = c.getName();
		if (typeName.equals("java.lang.String")) {
			return b;
		}
		if (typeName.equals("java.lang.Boolean") || typeName.equals("boolean")) {
			return b;
		}
		if (typeName.equals("java.lang.Character") || typeName.equals("char")) {
			return b;
		}
		if (typeName.equals("java.lang.Long") || typeName.equals("long")) {
			return b;
		}
		if (typeName.equals("java.lang.Double") || typeName.equals("double")) {
			return b;
		}
		if (typeName.equals("java.lang.Integer") || typeName.equals("int")) {
			return b;
		}
		if (typeName.equals("java.lang.Short") || typeName.equals("short")) {
			return b;
		}
		if (typeName.equals("java.lang.Float") || typeName.equals("float")) {
			return b;
		}
		if (typeName.equals("java.lang.Byte") || typeName.equals("byte")) {
			return b;
		}
		if (typeName.equals("java.util.Date")) {
			return b;
		}
		if (typeName.equals("java.math.BigInteger")) {
			return b;
		}
		if (typeName.equals("java.math.BigDecimal")) {
			return b;
		}
		if (typeName.equals("javax.xml.datatype.XMLGregorianCalendar")) {
			return b;
		}
		b = true;
		return b;
	}
	public static Object getEnum(Class c) {
		StringBuilder sb = new StringBuilder();
		String classNameForPrint = c.getName().replaceAll("\\$", "\\.");
		Object obj[] = c.getEnumConstants();
		return obj[0];
	}
	public <T> T newInstanceByConstructor(Class<T> qn) {
		T obj = null;
		if (!this.isComplexType(qn)) {
			obj = (T) getDefaultVal(qn);
			return obj;
		}
		try {
			obj = qn.newInstance();
		} catch (InstantiationException | IllegalAccessException e1) {
			Constructor<?> cts[] = qn.getConstructors();
			List<Constructor> list = Arrays.asList(cts);
			list.sort((c1, c2) -> {
				int c1ParamCount = c1.getParameterCount();
				int c2ParamCount = c1.getParameterCount();
				return c1ParamCount - c2ParamCount;
			});
			if (list.size() > 0) {
				Constructor<?> cs = list.get(0);
				Parameter pts[] = cs.getParameters();
				try {
					obj = (T) cs.newInstance();
				} catch (InstantiationException | IllegalAccessException | IllegalArgumentException
						| InvocationTargetException e) {
				}
			}
		}
		return obj;
	}
	public static boolean isAbstractOrInterface(Class clzToTest) {
		boolean abs = false;
		if (!clzToTest.isPrimitive() && (clzToTest.isInterface() || isAbstract(clzToTest))) {
			abs = true;
		}
		return abs;
	}
	public static boolean isAbstract(Class clzToTest) {
		boolean abs = false;
		if ((clzToTest.getModifiers() & Modifier.ABSTRACT) == Modifier.ABSTRACT) {
			abs = true;
		}
		return abs;
	}
	public static Class getDefaultConcreteClass(Class interfaceC) {
		Class concreteC = null;
		if (!interfaceC.isInterface() && !isAbstract(interfaceC) && !interfaceC.isArray()) {
			return interfaceC;
		}
		if (List.class.isAssignableFrom(interfaceC) || AbstractList.class.isAssignableFrom(interfaceC)
				|| Iterable.class.isAssignableFrom(interfaceC)) {
			concreteC = ArrayList.class;
		} else if (Map.class.isAssignableFrom(interfaceC) || AbstractMap.class.isAssignableFrom(interfaceC)) {
			concreteC = HashMap.class;
		} else if (Set.class.isAssignableFrom(interfaceC) || AbstractSet.class.isAssignableFrom(interfaceC)) {
			concreteC = HashSet.class;
		}
		return concreteC;
	}
	class clzRef {
		Class c;
		Class referenceC;
		AtomicInteger passByTimes = new AtomicInteger(0);
		public AtomicInteger getPassByTimes() {
			return passByTimes;
		}
		public void setPassByTimes(AtomicInteger passByTimes) {
			this.passByTimes = passByTimes;
		}
		public Class getC() {
			return c;
		}
		public void setC(Class c) {
			this.c = c;
		}
		public Class getReferenceC() {
			return referenceC;
		}
		public void setReferenceC(Class referenceC) {
			this.referenceC = referenceC;
		}
		public clzRef(Class c, Class referenceC) {
			super();
			this.c = c;
			this.referenceC = referenceC;
			this.passByTimes.getAndSet(0);
		}
		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;
			result = prime * result + getOuterType().hashCode();
			result = prime * result + ((c == null) ? 0 : c.hashCode());
			result = prime * result + ((referenceC == null) ? 0 : referenceC.hashCode());
			return result;
		}
		@Override
		public boolean equals(Object obj) {
			if (this == obj)
				return true;
			if (obj == null)
				return false;
			if (getClass() != obj.getClass())
				return false;
			clzRef other = (clzRef) obj;
			if (!getOuterType().equals(other.getOuterType()))
				return false;
			if (c == null) {
				if (other.c != null)
					return false;
			} else if (!c.equals(other.c))
				return false;
			if (referenceC == null) {
				if (other.referenceC != null)
					return false;
			} else if (!referenceC.equals(other.referenceC))
				return false;
			return true;
		}
		@Override
		public String toString() {
			StringBuilder builder = new StringBuilder();
			builder.append("clzRef [");
			builder.append(c.getSimpleName());
			builder.append("-->");
			builder.append(referenceC.getSimpleName());
			builder.append("]");
			return builder.toString();
		}
		private ObjWithDefaultValCreatorStandAlone getOuterType() {
			return ObjWithDefaultValCreatorStandAlone.this;
		}
	}
	public Map<Class, AtomicInteger> getAllCircularDependencyRelatedClz(Map<clzRef, List<clzRef>> map) {
		List<Class> list = new ArrayList<>();
		map.entrySet().forEach(e -> {
			Class keyC = e.getKey().getC();
			Class keyRefC = e.getKey().getReferenceC();
			List<clzRef> valList = e.getValue();
			if (!list.contains(keyC))
				list.add(keyC);
			if (!list.contains(keyRefC))
				list.add(keyRefC);
			valList.forEach(e1 -> {
				if (!list.contains(e1.getC()))
					list.add(e1.getC());
				if (!list.contains(e1.getReferenceC()))
					list.add(e1.getReferenceC());
			});
		});
		Map<Class, AtomicInteger> circularDependencyRelatedClzMap = list.stream()
				.collect(Collectors.toMap(e -> e, e -> {
					return new AtomicInteger(0);
				}, (e1, e2) -> e1));
		return circularDependencyRelatedClzMap;
	}
	public Map<clzRef, List<clzRef>> getCircularDependencyPath(List<clzRef> clzRefList) {
		Map<clzRef, List<clzRef>> alldependencyPath = new HashMap<>();
		Map<clzRef, List<clzRef>> selfdependencyPath = clzRefList.stream().filter(cr -> {
			return cr.getC().equals(cr.getReferenceC());
		}).collect(Collectors.toMap(e -> clzRef.class.cast(e), e -> {
			return Stream.of(clzRef.class.cast(e)).collect(Collectors.toList());
		}, (e1, e2) -> e1));
		alldependencyPath.putAll(selfdependencyPath);
		List<clzRef> notSelfDependencyList = clzRefList.stream().filter(cr -> {
			if (!cr.getC().equals(cr.getReferenceC())) {
				return true;
			} else {
				return false;
			}
		}).collect(Collectors.toList());
		List<Class> distinctReferenceClz = notSelfDependencyList.stream().map(
				clzRef::getReferenceC).distinct()
				.collect(Collectors.toList());
		List<clzRef> startPointClzRefMayContainsCircularDependency = notSelfDependencyList.stream().filter(cr -> {
			return distinctReferenceClz.contains(cr.getC());
		}).distinct().collect(Collectors.toList());
		Map<clzRef, List<clzRef>> dependencyPath = new HashMap<>();
		startPointClzRefMayContainsCircularDependency.stream().forEach(cr -> {
			List<clzRef> allPath = new ArrayList<>();
			allPath.add(cr);
			dependencyPath.put(cr, allPath);
			getCircularDepencyPath(cr, null, notSelfDependencyList, dependencyPath);
			notSelfDependencyList.stream().forEach(d -> {
				d.getPassByTimes().set(0);
			});
		});
		dependencyPath.keySet().forEach(k -> {
			List<clzRef> tmpdependencyPath = dependencyPath.get(k);
			if (tmpdependencyPath.size() >= 2) {
				clzRef startclzRef = tmpdependencyPath.get(0);
				clzRef lastclzRef = tmpdependencyPath.get(tmpdependencyPath.size() - 1);
				if (startclzRef.getC().equals(lastclzRef.getReferenceC())) {
					alldependencyPath.put(k, tmpdependencyPath);
				}
			}
		});
		return alldependencyPath;
	}
	public void getCircularDepencyPath(clzRef startClzRef, clzRef nextClzRef, List<clzRef> notSelfDependencyList,
			Map<clzRef, List<clzRef>> dependencyPath) {
		if (nextClzRef == null) {
			startClzRef.getPassByTimes().incrementAndGet();
			List<clzRef> nextClzRefList = notSelfDependencyList.stream().filter(cr -> {
				return cr.getPassByTimes().get() == 0 && cr.getC().equals(startClzRef.getReferenceC());
			}).collect(Collectors.toList());
			nextClzRefList.forEach(cr -> {
				getCircularDepencyPath(startClzRef, cr, notSelfDependencyList, dependencyPath);
			});
		} else {
			nextClzRef.getPassByTimes().incrementAndGet();
			if (dependencyPath.containsKey(startClzRef)) {
				dependencyPath.get(startClzRef).add(nextClzRef);
			}
			if (nextClzRef.getReferenceC().equals(startClzRef.getC())) {
				return;
			}
			List<clzRef> nextClzRefList = notSelfDependencyList.stream().filter(cr -> {
				return cr.getPassByTimes().get() == 0 && cr.getC().equals(nextClzRef.getReferenceC());
			}).collect(Collectors.toList());
			nextClzRefList.forEach(cr -> {
				getCircularDepencyPath(startClzRef, cr, notSelfDependencyList, dependencyPath);
			});
		}
	}
	/*
	 * public void getCircularDepencyPath(clzRef startClzRef, clzRef nextClzRef,
	 * List<clzRef> notSelfDependencyList, Map<clzRef, List<clzRef>> dependencyPath)
	 * { if (nextClzRef == null) { startClzRef.getPassByTimes().incrementAndGet();
	 * List<clzRef> nextClzRefList = notSelfDependencyList.stream().filter(cr -> {
	 * return cr.getPassByTimes().get() == 0 &&
	 * cr.getC().equals(startClzRef.getReferenceC());
	 * }).collect(Collectors.toList()); nextClzRefList.forEach(cr -> {
	 * getCircularDepencyPath(startClzRef, cr, notSelfDependencyList,
	 * dependencyPath); }); } else { nextClzRef.getPassByTimes().incrementAndGet();
	 * if (dependencyPath.containsKey(startClzRef)) {
	 * dependencyPath.get(startClzRef).add(nextClzRef); } if
	 * (nextClzRef.getReferenceC().equals(startClzRef.getC())) { return; }
	 * List<clzRef> nextClzRefList = notSelfDependencyList.stream().filter(cr -> {
	 * return cr.getPassByTimes().get() == 0 &&
	 * cr.getC().equals(nextClzRef.getReferenceC());
	 * }).collect(Collectors.toList()); nextClzRefList.forEach(cr -> {
	 * getCircularDepencyPath(startClzRef, cr, notSelfDependencyList,
	 * dependencyPath); }); } }
	 */
	public void findCircularDependcy(Class c1, List<Class<?>> alreadyWalkThrough, List<clzRef> clzRefList) {
		List<Field> list = new ArrayList<>();
		if (alreadyWalkThrough.contains(c1)) {
			return;
		}
		if (isComplexType(c1)) {
			alreadyWalkThrough.add(c1);
			list = getAllFields(c1);
			list.forEach(f -> {
				Class c = f.getType();
				if (isComplexType(c)) {
					Object complexObj = null;
					boolean isArray = c.isArray();
					boolean isAbstractOrInterface = isAbstractOrInterface(c);
					if (!isAbstractOrInterface && !isArray) {
						complexObj = newInstanceByConstructor(c);
						if (complexObj != null) {
							boolean isComplexType = isComplexType(complexObj.getClass());
							if (isComplexType) {
								clzRefList.add(new clzRef(c1, complexObj.getClass()));
								findCircularDependcy(complexObj.getClass(), alreadyWalkThrough, clzRefList);
							}
						}
					} else if (isArray) {
						complexObj = Array.newInstance(c.getComponentType(), 1);
					} else if (isAbstractOrInterface) {
						Class<?> concreteC = getDefaultConcreteClass(c);
						if (concreteC != null) {
							complexObj = this.newInstanceByConstructor(concreteC);
						}
					}
					if (complexObj != null) {
						if (isArray) {
							Class componentType = c.getComponentType();
							Class concreteC = componentType;
							if (isAbstractOrInterface(componentType)) {
								concreteC = getDefaultConcreteClass(c);
							}
							if (concreteC != null) {
								Object componentTypeObj = this.newInstanceByConstructor(concreteC);
								if (componentTypeObj != null) {
									boolean isComplexType = isComplexType(componentTypeObj.getClass());
									if (isComplexType) {
										clzRefList.add(new clzRef(c1, componentTypeObj.getClass()));
										findCircularDependcy(componentTypeObj.getClass(), alreadyWalkThrough,
												clzRefList);
									}
								}
							}
						}
						if (java.util.Collection.class.isAssignableFrom(c)) {
							String genericTypeName = f.getGenericType().getTypeName();
							String genericType = null;
							Pattern p = Pattern.compile("<(.+)>");
							Matcher m = p.matcher(genericTypeName);
							if (m.find()) {
								genericType = m.group(1);
								try {
									String javaformatgenericType = genericType;// genericType.replaceAll("\\$",
									Class genericTypeC = this.getClass().getClassLoader().loadClass(javaformatgenericType);
									Class concreteC = genericTypeC;
									if (isAbstractOrInterface(genericTypeC)) {
										concreteC = getDefaultConcreteClass(c);
									}
									if (concreteC != null) {
										Object componentTypeObj = this.newInstanceByConstructor(concreteC);
										if (componentTypeObj != null) {
											boolean isComplexType = isComplexType(componentTypeObj.getClass());
											boolean at = alreadyWalkThrough.contains(componentTypeObj.getClass());
											if (isComplexType) {
												clzRefList.add(new clzRef(c1, componentTypeObj.getClass()));
												findCircularDependcy(componentTypeObj.getClass(), alreadyWalkThrough,
														clzRefList);
											}
										}
									}
								} catch (Exception e) {
								}
							}
						}
						if (Map.class.isAssignableFrom(c)) {
							String genericTypeName = f.getGenericType().getTypeName();
							String genericType = null;
							Pattern p = Pattern.compile("<(.+)>");
							Matcher m = p.matcher(genericTypeName);
							Class keyType = null;
							Class valType = null;
							if (m.find()) {
								try {
									genericType = m.group(1);
								} catch (Exception e1) {
									e1.printStackTrace();
								}
								if (genericType != null) {
									try {
										String javaformatgenericType = genericType;// genericType.replaceAll("\\$",
										String gt[] = javaformatgenericType.split(",", -1);
										keyType =  this.getClass().getClassLoader().loadClass(gt[0].trim());
										valType = this.getClass().getClassLoader().loadClass(gt[1].trim());
									} catch (Exception e) {
									}
								}
							}
							if (keyType != null && valType != null) {
								Class concreteKeyC = keyType;
								Class concreteValC = valType;
								if (isAbstractOrInterface(keyType)) {
									concreteKeyC = getDefaultConcreteClass(keyType);
								}
								if (isAbstractOrInterface(valType)) {
									concreteValC = getDefaultConcreteClass(valType);
								}
								if (concreteKeyC != null && concreteValC != null) {
									Object keyObj = this.newInstanceByConstructor(concreteKeyC);
									Object valObj = this.newInstanceByConstructor(concreteValC);
									if (keyObj != null && valObj != null) {
										boolean isComplexType = isComplexType(keyObj.getClass());
										if (isComplexType) {
											clzRefList.add(new clzRef(c1, keyObj.getClass()));
											findCircularDependcy(keyObj.getClass(), alreadyWalkThrough, clzRefList);
										}
										boolean isvalObjComplexType = isComplexType(valObj.getClass());
										if (isvalObjComplexType) {
											clzRefList.add(new clzRef(c1, valObj.getClass()));
											findCircularDependcy(valObj.getClass(), alreadyWalkThrough, clzRefList);
										}
									}
								}
							}
						}
					}
				}
			});
		}
	}
	public Map<Class, AtomicInteger> getAllCircularDependencyClzMap(Class c) {
		List<Class<?>> alreadyWalkThrough = new ArrayList<>();
		List<clzRef> clzRefList = new ArrayList<>();
		this.findCircularDependcy(c, alreadyWalkThrough, clzRefList);
		Map<clzRef, List<clzRef>> circularDependencyMap = this.getCircularDependencyPath(clzRefList);
		Map<Class, AtomicInteger> allCircularDependencyClz = this
				.getAllCircularDependencyRelatedClz(circularDependencyMap);
		return allCircularDependencyClz;
	}
	public static boolean isExclusive(String expression, String exclusiveRegex) {
		if (exclusiveRegex == null || "".equals(exclusiveRegex)) {
			return false;
		}
		Pattern p = Pattern.compile(exclusiveRegex);
		Matcher m = p.matcher(expression);
		return m.matches();
	}
	public void newInstanceRecusively(Object tobj, List allComplexTypeObj,
			Map<Class, AtomicInteger> circularDependencyRelatedClzMap, int defaultSize, String exclusiveRegex) {
		List<Field> list = new ArrayList<>();
		Class c1 = tobj.getClass();
		if (isComplexType(c1)) {
			allComplexTypeObj.add(tobj);
			if (circularDependencyRelatedClzMap.containsKey(c1)) {
				if (circularDependencyRelatedClzMap.get(c1).get() > 0) {
					return;
				} else {
					circularDependencyRelatedClzMap.get(c1).incrementAndGet();
				}
			}
			list = getAllFields(c1, exclusiveRegex);
			list.forEach(f -> {
				Class c = f.getType();
				boolean isExclusive = isExclusive(c.getName(), exclusiveRegex);
				if (!isExclusive && isComplexType(c)) {
					Object complexObj = null;
					boolean isArray = c.isArray();
					boolean isAbstractOrInterface = isAbstractOrInterface(c);
					if (!isAbstractOrInterface && !isArray) {
						complexObj = newInstanceByConstructor(c);
						if (complexObj != null) {
							boolean isComplexType = isComplexType(complexObj.getClass());
							if (isComplexType) {
								allComplexTypeObj.add(complexObj);
								newInstanceRecusively(complexObj, allComplexTypeObj, circularDependencyRelatedClzMap,
										defaultSize, exclusiveRegex);
							}
						}
					} else if (isArray) {
						complexObj = Array.newInstance(c.getComponentType(), defaultSize);
					} else if (isAbstractOrInterface) {
						Class<?> concreteC = getDefaultConcreteClass(c);
						if (concreteC != null) {
							complexObj = this.newInstanceByConstructor(concreteC);
						}
					}
					if (complexObj != null) {
						f.setAccessible(true);
						try {
							isExclusive = isExclusive(complexObj.getClass().getName(), exclusiveRegex);
							if (!isExclusive)
								f.set(tobj, complexObj);
						} catch (Exception e) {
						}
					}
					if (isArray) {
						Class componentType = c.getComponentType();
						Class concreteC = componentType;
						if (isAbstractOrInterface(componentType)) {
							concreteC = getDefaultConcreteClass(c);
						}
						if (concreteC != null) {
							for (int i = 0; i < defaultSize; i++) {
								Object componentTypeObj = this.newInstanceByConstructor(concreteC);
								if (componentTypeObj != null) {
									Array.set(complexObj, i, componentTypeObj);
									boolean isComplexType = isComplexType(componentTypeObj.getClass());
									if (isComplexType) {
										allComplexTypeObj.add(componentTypeObj);
										newInstanceRecusively(componentTypeObj, allComplexTypeObj,
												circularDependencyRelatedClzMap, defaultSize, exclusiveRegex);
									}
								}
							}
						}
					}
					if (java.util.Collection.class.isAssignableFrom(c)) {
						String genericTypeName = f.getGenericType().getTypeName();
						String genericType = null;
						Pattern p = Pattern.compile("<(.+)>");
						Matcher m = p.matcher(genericTypeName);
						if (m.find()) {
							genericType = m.group(1);
							try {
								String javaformatgenericType = genericType;// genericType.replaceAll("\\$",
								Class genericTypeC = this.getClass().getClassLoader().loadClass(javaformatgenericType);
								Class concreteC = genericTypeC;
								if (isAbstractOrInterface(genericTypeC)) {
									concreteC = getDefaultConcreteClass(c);
								}
								isExclusive = isExclusive(concreteC.getName(), exclusiveRegex);
								if (!isExclusive && concreteC != null) {
									for (int i = defaultSize; i > 0; i--) {
										Object componentTypeObj = this.newInstanceByConstructor(concreteC);
										if (componentTypeObj != null) {
											List listTmp = (List) complexObj;
											listTmp.add(componentTypeObj);
											boolean isComplexType = isComplexType(componentTypeObj.getClass());
											if (isComplexType) {
												allComplexTypeObj.add(componentTypeObj);
												newInstanceRecusively(componentTypeObj, allComplexTypeObj,
														circularDependencyRelatedClzMap, defaultSize, exclusiveRegex);
											}
										}
									}
								}
							} catch (Exception e) {
							}
						}
					}
					if (Map.class.isAssignableFrom(c)) {
						String genericTypeName = f.getGenericType().getTypeName();
						String genericType = null;
						Pattern p = Pattern.compile("<(.+)>");
						Matcher m = p.matcher(genericTypeName);
						Class keyType = null;
						Class valType = null;
						if (m.find()) {
							try {
								genericType = m.group(1);
							} catch (Exception e1) {
								e1.printStackTrace();
							}
							if (genericType != null) {
								try {
									String javaformatgenericType = genericType;// genericType.replaceAll("\\$",
									String gt[] = javaformatgenericType.split(",", -1);
									keyType =this.getClass().getClassLoader().loadClass(gt[0].trim());
									valType = this.getClass().getClassLoader().loadClass(gt[1].trim());
								} catch (Exception e) {
								}
							}
						}
						if (keyType != null && valType != null) {
							Class concreteKeyC = keyType;
							Class concreteValC = valType;
							if (isAbstractOrInterface(keyType)) {
								concreteKeyC = getDefaultConcreteClass(keyType);
							}
							if (isAbstractOrInterface(valType)) {
								concreteValC = getDefaultConcreteClass(valType);
							}
							boolean isKeyConcern = isExclusive(concreteKeyC.getName(), exclusiveRegex);
							boolean isValConcern = isExclusive(concreteValC.getName(), exclusiveRegex);
							if (isKeyConcern && isValConcern && concreteKeyC != null && concreteValC != null) {
								for (int i = defaultSize; i > 0; i--) {
									Object keyObj = this.newInstanceByConstructor(concreteKeyC);
									Object valObj = this.newInstanceByConstructor(concreteValC);
									if (keyObj != null && valObj != null) {
										Map tmp = (Map) complexObj;
										tmp.put(keyObj, valObj);
										boolean isComplexType = isComplexType(keyObj.getClass());
										if (isComplexType) {
											allComplexTypeObj.add(keyObj);
											newInstanceRecusively(keyObj, allComplexTypeObj,
													circularDependencyRelatedClzMap, defaultSize, exclusiveRegex);
										}
										boolean isvalObjComplexType = isComplexType(valObj.getClass());
										if (isvalObjComplexType) {
											allComplexTypeObj.add(valObj);
											newInstanceRecusively(valObj, allComplexTypeObj,
													circularDependencyRelatedClzMap, defaultSize, exclusiveRegex);
										}
									}
								}
							}
						}
					}
				}
			});
		}
	}
	public static List<Field> getAllFields(Class c) {
		return getAllFields(c, null);
	}
	public static List<Field> getAllFields(Class c, String exclusiveRegex) {
		List<Field> allFieldList = new ArrayList<>();
		while (c != Object.class) {
			boolean isExclusive = isExclusive(c.getName(), exclusiveRegex);
			if (isExclusive) {
				break;
			}
			allFieldList.addAll(Arrays.asList(c.getDeclaredFields()));
			c = c.getSuperclass();
		}
		return allFieldList;
	}
	public void assignPrimitiveTypes(Object tobj) {
		assignPrimitiveTypes(tobj, null);
	}
	public void assignPrimitiveTypes(Object tobj, String exclusiveRegex) {
		List<Field> list = new ArrayList<>();
		Class c1 = tobj.getClass();
		list = getAllFields(c1, exclusiveRegex);
		list.forEach(f -> {
			Class c = f.getType();
			boolean isExclusive = isExclusive(c.getName(), exclusiveRegex);
			if (!isExclusive && !isComplexType(c)) {
				Object obj = null;
				f.setAccessible(true);
				/*
				 * try { obj = f.get(tobj); } catch (Exception e) { e.printStackTrace(); }
				 */
				Object value = this.getDefaultVal(c);
				try {
					f.set(tobj, value);
				} catch (Exception e) {
				}
			}
		});
	}
	public void assignComplextTypes(Object tobj, List<?> allComplexTypeObj) {
		assignComplextTypes(tobj, allComplexTypeObj, null);
	}
	public void assignComplextTypes(Object tobj, List<?> allComplexTypeObj, String exclusiveRegex) {
		List<Field> list = new ArrayList<>();
		Class c1 = tobj.getClass();
		list = getAllFields(c1, exclusiveRegex);
		list.forEach(f -> {
			try {
				f.setAccessible(true);
				Object fval = f.get(tobj);
				if (fval == null) {
					Class c = f.getType();
					Object alreadyCreatedInstance = null;
					try {
						alreadyCreatedInstance = allComplexTypeObj.stream().filter(e -> {
							return c.isInstance(e);
						}).findAny().get();
					} catch (Exception e1) {
					}
					boolean isExclusive = isExclusive(alreadyCreatedInstance.getClass().getCanonicalName(),
							exclusiveRegex) || isExclusive(c.getCanonicalName(), exclusiveRegex);
					if (alreadyCreatedInstance != null && !isExclusive) {
						try {
							f.set(tobj, alreadyCreatedInstance);
						} catch (Exception e) {
						}
					}
				}
			} catch (Exception e1) {
			}
		});
	}
	public <T> List<Class<?>> getAllReferComplexType(Class<T> t){
		List<Class<?>> allComplexTypeObj = new ArrayList<>();
		List<Class<?>> alreadyWalkThrough = new ArrayList<>();
		T obj = newInstanceByConstructor(t);
		if (obj != null) {
			List<clzRef> clzRefList = new ArrayList<>();
			this.findCircularDependcy(t, alreadyWalkThrough, clzRefList);
			for(clzRef cr : clzRefList){
				if(null!=cr.getC()){
					allComplexTypeObj.add(cr.getC());
				}
				if(null!=cr.getReferenceC()){
					allComplexTypeObj.add(cr.getReferenceC());
				}
			}
			allComplexTypeObj=allComplexTypeObj.stream().distinct().collect(Collectors.toList());
		}
		return allComplexTypeObj;
	}
	public <T> T newInstance(Class<T> t) {
		return newInstance(t, 2);
	}
	public <T> T newInstance(Class<T> t, int defaultSize) {
		return newInstance(t, defaultSize, null);
	}
	public <T> T newInstance(Class<T> t, int defaultSize, String exclusiveRegex) {
		List<?> allComplexTypeObj = new ArrayList<>();
		List<Class<?>> alreadyWalkThrough = new ArrayList<>();
		T obj = newInstanceByConstructor(t);
		if (obj != null) {
			List<clzRef> clzRefList = new ArrayList<>();
			this.findCircularDependcy(t, alreadyWalkThrough, clzRefList);
			Map<clzRef, List<clzRef>> circularDependencyMap = this.getCircularDependencyPath(clzRefList);
			Map<Class, AtomicInteger> allCircularDependencyClz = this
					.getAllCircularDependencyRelatedClz(circularDependencyMap);
			newInstanceRecusively(obj, allComplexTypeObj, allCircularDependencyClz, defaultSize, exclusiveRegex);
			allComplexTypeObj.forEach(ct -> {
				assignPrimitiveTypes(ct, exclusiveRegex);
				assignComplextTypes(ct, allComplexTypeObj, exclusiveRegex);
			});
		}
		return obj;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\qj\blog\classreloading\example1\StaticInt.java---
package qj.blog.classreloading.example1;
import qj.util.ReflectUtil;
import qj.util.lang.DynamicClassLoader;
import static java.lang.System.out;
/**
 * Created by Quan on 26/10/2014.
 */
public class StaticInt {
	public static void main(String[] args) {
		Class<?> userClass1 = User.class;
		Class<?> userClass2 = new DynamicClassLoader("target/classes")
				.load("qj.blog.classreloading.example1.StaticInt$User");
		out.println("Seems to be the same class:");
		out.println(userClass1.getName());
		out.println(userClass2.getName());
		out.println();
		out.println("But why there are 2 different class loaders:");
		out.println(userClass1.getClassLoader());
		out.println(userClass2.getClassLoader());
		out.println();
		User.age = 11;
		out.println("And different age values:");
		out.println((int) ReflectUtil.getStaticFieldValue("age", userClass1));
		out.println((int) ReflectUtil.getStaticFieldValue("age", userClass2));
	}
	public static class User {
		public static int age = 10;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\qj\blog\classreloading\example2\ReloadingContinuously.java---
package qj.blog.classreloading.example2;
import qj.util.ReflectUtil;
import qj.util.ThreadUtil;
import qj.util.lang.DynamicClassLoader;
/**
 * Created by Quan on 31/10/2014.
 */
public class ReloadingContinuously {
	public static void main(String[] args) {
		for (;;) {
			Class<?> userClass = new DynamicClassLoader("target/classes")
				.load("qj.blog.classreloading.example2.ReloadingContinuously$User");
			ReflectUtil.invokeStatic("hobby", userClass);
			ThreadUtil.sleep(2000);
		}
	}
	@SuppressWarnings("UnusedDeclaration")
	public static class User {
		public static void hobby() {
			playFootball(); // Will comment during runtime
		}
		public static void playFootball() {
			System.out.println("Play Football");
		}
		public static void playBasketball() {
			System.out.println("Play Basketball");
		}
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\qj\blog\classreloading\example3\ContextReloading.java---
package qj.blog.classreloading.example3;
import qj.util.ThreadUtil;
import qj.util.lang.DynamicClassLoader;
import static qj.util.ReflectUtil.*;
/**
 * Created by Quan on 31/10/2014.
 */
public class ContextReloading {
	public static void main(String[] args) {
		for (;;) {
			Object context = createContext();
			invokeHobbyService(context);
			ThreadUtil.sleep(2000);
		}
	}
	private static Object createContext() {
		Class<?> contextClass = new DynamicClassLoader("target/classes")
				.load("qj.blog.classreloading.example3.ContextReloading$Context");
		Object context = newInstance(contextClass);
		invoke("init", context);
		return context;
	}
	private static void invokeHobbyService(Object context) {
		Object hobbyService = getFieldValue("hobbyService", context);
		invoke("hobby", hobbyService);
	}
	@SuppressWarnings("UnusedDeclaration")
	public static class Context {
		public HobbyService hobbyService = new HobbyService();
		public void init() {
			hobbyService.user = new User();
		}
	}
	public static class HobbyService {
		public User user;
		public void hobby() {
			user.hobby();
		}
	}
	public static class User {
		public static void hobby() {
			playBasketball(); // Will uncomment during runtime
		}
		public static void playBasketball() {
			System.out.println("Play Basketball");
		}
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\qj\blog\classreloading\example3\ContextReloadingTest.java---
package qj.blog.classreloading.example3;
import qj.util.ThreadUtil;
import qj.util.lang.DynamicClassLoader;
import java.io.File;
/**
 * Created by Quan on 31/10/2014.
 */
public class ContextReloadingTest {
	public static void main(String[] args) {
		for (;;) {
			try {
				Class<?> testJarClz = new DynamicClassLoader(
						new File("D:\\androidMavenRepository\\codegen\\classreloadtest\\1.0\\classreloadtest-1.0.jar")
								.toURI().toURL()).load("test.Test2");
				Class<?> clz = new DynamicClassLoader(
						"D:\\project\\codegen\\production\\classreloadtest\\target\\classes").load("test.Test");
				Class<?> clz1 = new DynamicClassLoader(
						"D:\\project\\codegen\\production\\classreloadtest\\target\\test-classes")
								.load("test.UnitTest1");
				ContextReloadingTest.printClzInfo(testJarClz);
			} catch (Exception e) {
				e.printStackTrace();
			}
		}
	}
	public static void printClzInfo(Class clz) {
		int fieldSize = clz.getDeclaredFields().length;
		int methodSize = clz.getMethods().length;
		System.out.println(
				String.format("clz=%s, fieldSize=%s, methodSize=%s", clz.getCanonicalName(), fieldSize, methodSize));
		ThreadUtil.sleep(2000);
		return;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\qj\blog\classreloading\example3\RunAppClzReloadingTest.java---
package qj.blog.classreloading.example3;
import qj.util.ThreadUtil;
import qj.util.lang.DynamicClassLoader;
import java.io.File;
import java.net.URI;
import java.net.URL;
/**
 * Created by Quan on 31/10/2014.
 */
public class RunAppClzReloadingTest {
	public static void main(String[] args) {
		for (;;) {
			try {
				File file = new File("D:\\project\\deployment\\production\\runapp\\target\\classes");
				URL uRL = null;
				if (file.exists()) {
					URI uRI = file.toURI();
					uRL = uRI.toURL();
				}
				DynamicClassLoader dc = new DynamicClassLoader(RunAppClzReloadingTest.class.getClassLoader(), uRL);
				Class<?> clz = dc.load("servlet.deployment.RunParam");
				Class clz2 = dc.load("qj.tool.web.ReloadingContext");
				Class<?> clz1 = new DynamicClassLoader(
						"D:\\project\\codegen\\production\\classreloadtest\\target\\test-classes")
								.load("test.UnitTest1");
				ContextReloadingTest.printClzInfo(clz);
			} catch (Exception e) {
				e.printStackTrace();
			}
		}
	}
	public static void printClzInfo(Class clz) {
		int fieldSize = clz.getDeclaredFields().length;
		int methodSize = clz.getMethods().length;
		System.out.println(
				String.format("clz=%s, fieldSize=%s, methodSize=%s", clz.getCanonicalName(), fieldSize, methodSize));
		ThreadUtil.sleep(2000);
		return;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\qj\blog\classreloading\example4\crossing\Connection.java---
package qj.blog.classreloading.example4.crossing;
public class Connection {
    public String getUserName() {
        return "Joe";
    }
}
----strat of file D:\projects\cg\cg-min\src\main\java\qj\blog\classreloading\example4\crossing\ConnectionPool.java---
package qj.blog.classreloading.example4.crossing;
public class ConnectionPool {
    Connection conn = new Connection();
    public Connection getConnection() {
        return conn;
    }
}
----strat of file D:\projects\cg\cg-min\src\main\java\qj\blog\classreloading\example4\KeepConnectionPool.java---
package qj.blog.classreloading.example4;
import qj.blog.classreloading.example4.crossing.ConnectionPool;
import qj.util.ThreadUtil;
import qj.util.lang.ExceptingClassLoader;
import static qj.util.ReflectUtil.*;
/**
 * Created by Quan on 01/11/2014.
 */
public class KeepConnectionPool {
	public static void main(String[] args) {
		ConnectionPool pool = new ConnectionPool();
		for (;;) {
			Object context = createContext(pool);
			invokeService(context);
			ThreadUtil.sleep(2000);
		}
	}
	private static Object createContext(ConnectionPool pool) {
		ExceptingClassLoader classLoader = new ExceptingClassLoader(
				(className) -> className.contains(".crossing."),
				"target/classes");
		Class<?> contextClass = classLoader.load("qj.blog.classreloading.example4.reloadable.Context");
		Object context = newInstance(contextClass);
		setFieldValue(pool, "pool", context);
		invoke("init", context);
		return context;
	}
	private static void invokeService(Object context) {
		Object hobbyService = getFieldValue("userService", context);
		invoke("hello", hobbyService);
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\qj\blog\classreloading\example4\reloadable\Context.java---
package qj.blog.classreloading.example4.reloadable;
import qj.blog.classreloading.example4.crossing.ConnectionPool;
@SuppressWarnings("UnusedDeclaration")
public class Context {
    public ConnectionPool pool;
    public UserService userService = new UserService();
    public void init() {
        userService.pool = pool;
    }
}
----strat of file D:\projects\cg\cg-min\src\main\java\qj\blog\classreloading\example4\reloadable\UserService.java---
package qj.blog.classreloading.example4.reloadable;
import qj.blog.classreloading.example4.crossing.ConnectionPool;
public class UserService {
    ConnectionPool pool;
    @SuppressWarnings("UnusedDeclaration")
    public void hello() {
        System.out.println("Hi " + pool.getConnection().getUserName());
    }
}
----strat of file D:\projects\cg\cg-min\src\main\java\qj\blog\classreloading\example5\LittlePhoneBookMain.java---
package qj.blog.classreloading.example5;
import org.eclipse.jetty.server.Server;
import org.eclipse.jetty.servlet.FilterHolder;
import org.eclipse.jetty.servlet.ServletContextHandler;
import org.eclipse.jetty.servlet.ServletHolder;
import qj.tool.web.ReloadingWebContext;
import qj.tool.web.ResourceFilter;
import qj.util.PropertiesUtil;
import qj.util.SystemUtil;
import qj.util.ThreadUtil;
import qj.util.funct.F0;
import qj.util.funct.P0;
import qj.util.lang.ExceptingClassLoader;
import javax.servlet.DispatcherType;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.EnumSet;
import java.util.Properties;
public class LittlePhoneBookMain {
	public static boolean development = true;
	public static String version = "1.0.0";
	public static void main(String[] args) throws Exception {
        Properties config = PropertiesUtil.loadPropertiesFromFile("data/example5/config.properties");
		startServer(config);
	}
	public static void startServer(Properties config) throws Exception {
		final ServerControl webServer = startWebServer(config);
		SystemUtil.onReturn(line -> {
			if ("exit".equals(line)) {
				System.out.print("Stopping web server...");
				webServer.closeF.run();
				System.out.print(" done.");
				System.exit(0);
			}
		});
	}
	public static ServerControl startWebServer(Properties config) throws Exception {
		int port = Integer.parseInt(config.getProperty("web.port"));
		DbPool dbPool = initDatabase(config);
		ServletContextHandler servletContext = new ServletContextHandler(ServletContextHandler.SESSIONS);
        servletContext.setContextPath("/");
		ReloadingWebContext contextLoader = new ReloadingWebContext(
				"qj.blog.classreloading.example5.reloadable.Context",
				() -> ( development ?
						new ExceptingClassLoader(
							(className) -> className.startsWith("qj.util"),
							"target/classes"
						) :
						LittlePhoneBookMain.class.getClassLoader()
				),
				development ? 
						(req) -> req.getMethod().equalsIgnoreCase("GET") && req.getRequestURI().equals("/") : 
						null
		);
		contextLoader.setField("development", development);
		contextLoader.setField("buildVersion", version);
		contextLoader.setField("connF", dbPool.connF);
		contextLoader.initWith("init", "data/example5/web");
		contextLoader.beforeClose("close");
		servletContext.addServlet( new ServletHolder(contextLoader.stubServlet("jade")), "/");
		servletContext.addServlet( new ServletHolder(wrapServlet(contextLoader.stubServlet("contact"), dbPool.closeThreadConn)),
				"/contact");
		servletContext.addServlet( new ServletHolder(contextLoader.stubServlet("jade")), "*.jade");
		ResourceFilter resourceFilter = resourceFilter("data/example5/web");
		servletContext.addFilter(
				new FilterHolder(resourceFilter),
				"/*", EnumSet.<DispatcherType>of(DispatcherType.REQUEST));
		final Server server = new Server(port);
		server.setHandler(servletContext);
		server.start();
		System.out.println("Server started on port " + port);
		final Runnable closeF = () -> {
			System.out.print("Stopping box server...");
			try {
				server.stop();
			} catch (Exception e1) {
				e1.printStackTrace();
			}
			dbPool.closePool.e();
			System.out.print(" done.");
		};
		return new ServerControl(closeF);
	}
	private static DbPool initDatabase(Properties config) throws SQLException, ClassNotFoundException {
		DbPool dbPool = new DbPool(config);
		Connection connection = dbPool.connF.e();
		initDb(connection);
		dbPool.closeThreadConn.e();
		return dbPool;
	}
	public static ResourceFilter resourceFilter(String boxWebLoc) {
		return new ResourceFilter(
				req -> null,
				boxWebLoc
				);
	}
	public static class ServerControl {
		Runnable closeF;
		public ServerControl(Runnable closeF) {
			this.closeF = closeF;
		}
	}
	/**
	 * This is pool provide only 1 shared connection to the SQLite memory database
	 */
	static class DbPool {
		public F0<Connection> connF;
		public P0 closeThreadConn;
		protected P0 closePool;
		public DbPool(Properties config) throws SQLException, ClassNotFoundException {
			Class.forName(config.getProperty("db.driver"));
            Connection connection = DriverManager.getConnection(config.getProperty("db.url"));
			ThreadUtil.ThreadLocalCache<Connection> threadLocal = ThreadUtil.threadLocalCache(() -> connection);
			connF = threadLocal.cacheF;
			closeThreadConn = () -> {
			};
			closePool = () -> {
				try {
					connection.close();
				} catch (SQLException e1) {
				}
			};
		}
	}
	/**
	 * The SQLite memory db is initialized before use
	 * @throws SQLException
	 */
	private static void initDb(Connection connection) throws SQLException {
		Statement statement = connection.createStatement();
		statement.setQueryTimeout(30);  // set timeout to 30 sec.
		statement.executeUpdate("drop table if exists contact");
		statement.executeUpdate("create table contact (id integer PRIMARY KEY AUTOINCREMENT, name string, phone string)");
		statement.executeUpdate("insert into contact values(1, 'Andrew King', '0648 6815 1654')");
		statement.executeUpdate("insert into contact values(2, 'William Shakespeare', '0234 5234 3264')");
	}
	private static HttpServlet wrapServlet(HttpServlet servlet, P0 closeThreadConn) {
		return new HttpServlet() {
			protected void service(HttpServletRequest req,
			                       HttpServletResponse resp) throws ServletException,
					IOException {
				try {
					servlet.service(req, resp);
				} finally {
					closeThreadConn.e();
				}
			}
		};
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\qj\blog\classreloading\example5\reloadable\Context.java---
package qj.blog.classreloading.example5.reloadable;
import qj.blog.classreloading.example5.reloadable.servlet.ContactServlet;
import qj.blog.classreloading.example5.reloadable.servlet.JadeServlet;
import qj.util.funct.F0;
import java.sql.Connection;
@SuppressWarnings("UnusedDeclaration")
public class Context {
	public String buildVersion;
	public boolean development;
	public F0<Connection> connF;
	public JadeServlet jadeServlet = new JadeServlet();
	public ContactServlet contactServlet = new ContactServlet();
	public void init(String webLoc) {
		jadeServlet.version = buildVersion;
		jadeServlet.init(webLoc);
		contactServlet.connF = connF;
	}
	public void close() {
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\qj\blog\classreloading\example5\reloadable\dao\ContactDAO.java---
package qj.blog.classreloading.example5.reloadable.dao;
import qj.blog.classreloading.example5.reloadable.model.Contact;
import qj.tool.sql.Builder;
import qj.tool.sql.Template;
import java.sql.Connection;
import java.util.List;
/**
 * Created by Quan on 22/12/2014.
 */
public class ContactDAO {
	static Template<Contact> template = new Builder<>(Contact.class)
			.build();
	public static List<Contact> selectAll(Connection conn) {
		return template.selectAll(conn);
	}
    public static void insert(Contact contact, Connection conn) {
        template.insert(contact, conn);
    }
    public static void delete(Long id, Connection conn) {
        template.deleteById(id, conn);
    }
}
----strat of file D:\projects\cg\cg-min\src\main\java\qj\blog\classreloading\example5\reloadable\model\Contact.java---
package qj.blog.classreloading.example5.reloadable.model;
/**
 * Created by Quan on 22/12/2014.
 */
public class Contact {
	public Long id;
	public String name;
	public String phone;
}
----strat of file D:\projects\cg\cg-min\src\main\java\qj\blog\classreloading\example5\reloadable\servlet\ContactServlet.java---
package qj.blog.classreloading.example5.reloadable.servlet;
import com.google.gson.Gson;
import qj.blog.classreloading.example5.reloadable.dao.ContactDAO;
import qj.blog.classreloading.example5.reloadable.model.Contact;
import qj.util.funct.F0;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.sql.Connection;
/**
 * Created by Quan on 22/12/2014.
 */
public class ContactServlet extends HttpServlet {
	public F0<Connection> connF;
	@Override
	protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        String action = req.getParameter("action");
        switch (action) {
            case "getAll":
                getAll(resp);
                break;
            case "add":
                add(req, resp);
                break;
            case "remove":
                remove(req, resp);
                break;
        }
	}
    private void getAll(HttpServletResponse resp) throws IOException {
        new Gson().toJson(ContactDAO.selectAll(connF.e()), resp.getWriter());
    }
    private void add(HttpServletRequest req, HttpServletResponse resp) throws IOException {
        Gson gson = new Gson();
        Contact contact = gson.fromJson(req.getReader(), Contact.class);
        ContactDAO.insert(contact, connF.e());
        gson.toJson(contact, resp.getWriter());
    }
    private void remove(HttpServletRequest req, HttpServletResponse resp) throws IOException {
        Long id = Long.valueOf(req.getParameter("id"));
        ContactDAO.delete(id, connF.e());
        resp.getWriter().write(0);
    }
}
----strat of file D:\projects\cg\cg-min\src\main\java\qj\blog\classreloading\example5\reloadable\servlet\JadeServlet.java---
package qj.blog.classreloading.example5.reloadable.servlet;
import de.neuland.jade4j.Jade4J;
import de.neuland.jade4j.model.JadeModel;
import de.neuland.jade4j.template.JadeTemplate;
import qj.util.Cols;
import qj.util.FileUtil;
import qj.util.StringUtil;
import qj.util.funct.P2;
import qj.util.math.Range;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.File;
import java.io.IOException;
import java.io.StringWriter;
import java.util.LinkedList;
public class JadeServlet extends HttpServlet {
	public String version = null;
	private String webLoc;
	@Override
	public void doGet(HttpServletRequest req, HttpServletResponse resp)
			throws ServletException, IOException {
		resp.setContentType("text/html; charset=UTF-8");
		if (StringUtil.countHappens('.', req.getServerName()) == 1) {
			resp.sendRedirect("http://www." + req.getServerName()); // Fix ui-sref urls
			return;
		}
		String requestURI = req.getRequestURI();
		if (requestURI.equals("/")) {
			requestURI = "/spa.jade";
		}
		File file = new File(webLoc + "/spa" + requestURI);
		if (!file.exists()) {
			resp.sendRedirect("/#!" + requestURI.replaceFirst("/$", "")); // Fix ui-sref urls
			return;
		}
		JadeTemplate template = Jade4J.getTemplate(file.getPath());
		if ("/spa.jade".equals(requestURI)) {
			StringWriter buffer = new StringWriter();
			template.process(new JadeModel(Cols.map(
					"version", version
					)), buffer);
			String target = "<!--spa-js-->";
			String scriptLocations = allJs();
			String content = buffer.toString();
			resp.getWriter().write(
					StringUtil.replace(scriptLocations, Range.fromlength(content.indexOf(target), target.length()), content)
			);
		} else {
			template.process(new JadeModel(null), resp.getWriter());
		}
	}
	private String allJs() {
		LinkedList<String> col = new LinkedList<>();
		P2<File,String> collect = (file, path) -> {
			if (file.getName().endsWith(".js")) {
				if (StringUtil.isEmpty(path)) {
					col.add("/" + file.getName());
				} else {
					col.add("/" + path.replaceAll("\\\\", "/") + "/" + file.getName());
				}
			}
		};
		FileUtil.eachFile(new File(webLoc + "/spa"), collect);
		return Cols.join((Iterable<String>)Cols.yield(col, s -> "<script src=\"/spa" + s + "?v=" + version + "\"></script>"), "");
	}
	public void init(String webLoc) {
		this.webLoc = webLoc;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\qj\tool\sql\Builder.java---
package qj.tool.sql;
import com.google.gson.Gson;
import qj.tool.sql.Template.Field1;
import qj.util.Cols;
import qj.util.NameCaseUtil;
import qj.util.ReflectUtil;
import qj.util.StringUtil;
import qj.util.funct.F1;
import qj.util.funct.F2;
import qj.util.funct.P1;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.lang.reflect.Type;
import java.sql.Blob;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.*;
public class Builder<M> {
	private Class<M> clazz;
	private List<String> idFields = Arrays.asList("id");
	private String tableName;
	boolean autoIncrement = true;
	public Builder(Class<M> clazz) {
		this.clazz = clazz;
		tableName = NameCaseUtil.camelToHyphen(clazz.getSimpleName());
	}
	public static void main(String[] args) {
		System.out.println(NameCaseUtil.camelToHyphen("ChatLastRead"));
	}
	public Builder<M> id(String... idFields) {
		this.idFields = Arrays.asList(idFields);
		return this;
	}
	HashSet<String> dontStore = new HashSet<>();
	public Template<M> build() {
		Template<M> template = new Template<>(clazz);
		template.idFields = Cols.yield(idFields, (fName) -> field1(ReflectUtil.getField(fName, clazz)));
		template.dataFields = new LinkedList<>();
		template.tableName = tableName;
		template.autoIncrement = autoIncrement;
		eachField(clazz, (f) -> {
			if (dontStore.contains(f.getName())) {
				return;
			}
			template.dataFields.add(field1(f));
		});
		return template;
	}
	@SuppressWarnings("UnusedDeclaration")
	public Builder<M> noId() {
		idFields = Collections.emptyList();
		return this;
	}
	public Builder<M> tableName(String tableName) {
		this.tableName = tableName;
		return this;
	}
	public Field1<M> field1(Field field) {
		Field1<M> raw = field1_raw(field);
		F1<Field1<M>, Field1<M>> decor = fieldDecors.get(field.getName());
		if (decor != null) {
			return decor.e(raw);
		}
		return raw;
	}
	public static <M> Field1<M> field1_raw(Field field) {
		Field1<M> field1 = new Field1<M>() {
			@Override
			void setValue(Object val, M m) {
				if (boolean.class.equals(field.getType())) {
					if (val == null) {
						val = Boolean.FALSE;
					}
				}
				ReflectUtil.setFieldValue(val, field, m);
			}
			@Override
			Object getValue(M m) {
				return ReflectUtil.getFieldValue(field, m);
			}
		};
		field1.type = field.getGenericType();
		field1.sqlName = NameCaseUtil.camelToHyphen(field.getName());
		field1.psSetter = SQLUtil.setter(field.getType());
		field1.rsGet = rsGet(field.getType());
		return field1;
	}
	Map<String,F1<Field1<M>,Field1<M>>> fieldDecors = new HashMap<>();
	private Builder<M> embeded(String fieldName, F1<Field1<M>,Type> convertTypeF,
			F1<Object, Object> afterDeserialized) {
		fieldDecors.put(fieldName, f1 -> {
			Field1<M> newField1 = new Field1<M>() {
				@Override
				void setValue(Object val, M m) {
					if (val == null || "null".equals(val)) {
						f1.setValue(null, m);
						return;
					}
					Object o = new Gson().fromJson(((String)val), convertTypeF.e(f1));
					Object value = afterDeserialized==null ? o : afterDeserialized.e(o);
					f1.setValue(value, m);
				}
				@Override
				Object getValue(M m) {
					Object val = f1.getValue(m);
					return new Gson().toJson(val);
				}
			};
			newField1.psSetter = SQLUtil.setter(String.class);
			newField1.rsGet = rsGet(String.class);
			newField1.sqlName = f1.sqlName;
			return newField1;
		});
		return this;
	}
	public Builder<M> embeded(String fieldName) {
		return embeded(fieldName, (f1) -> f1.type, null);
	}
	@SuppressWarnings("UnusedDeclaration")
	public Builder<M> dontStore(String fieldName) {
		dontStore.add(fieldName);
		return this;
	}
	private void eachField(Class<?> clazz, P1<Field> p1) {
		for (final Field field : clazz.getDeclaredFields()) {
			int modifiers = field.getModifiers();
			if ((modifiers & (Modifier.STATIC | Modifier.FINAL | Modifier.TRANSIENT)) > 0
					|| (modifiers & Modifier.PUBLIC) == 0
					) {
				continue;
			}
			if (idFields.contains(field.getName())) {
				continue;
			}
			p1.e(field);
		}
		if (!clazz.equals(Object.class)) {
			eachField(clazz.getSuperclass(), p1);
		}
	}
	private static F2<ResultSet,Integer,Object> rsGet(Class<?> type) {
		if (type.equals(Date.class)) {
			return (rs, index) -> {
				try {
					return rs.getTimestamp(index);
				} catch (SQLException e) {
					throw new RuntimeException(e);
				}
			};
		}
		if (type.equals(byte[].class)) {
			return (rs, index) -> {
				try {
					Blob blob = rs.getBlob(index);
					return blob.getBytes(1, (int) blob.length());
				} catch (SQLException e) {
					throw new RuntimeException(e);
				}
			};
		}
		Method methodWasNull = ReflectUtil.getMethod("wasNull", ResultSet.class);
		Method methodGet = ReflectUtil.getMethod(rsGetMethodName(type), new Class[] {int.class}, ResultSet.class);
		return (rs, index) -> {
			Object val = ReflectUtil.invoke(methodGet, rs, index);
			Boolean wasNull = ReflectUtil.invoke(methodWasNull, rs);
			return wasNull ? null : val;
		};
	}
	private static String rsGetMethodName(Class<?> type) {
		String simpleName = type.getSimpleName();
		if (simpleName.equals("Integer")) {
			simpleName = "Int";
		}
		return "get" + StringUtil.upperCaseFirstChar(simpleName);
	}
	public <MT> Builder<M> fieldConvert(String fieldName, FieldConverter<MT> converter) {
		fieldDecors.put(fieldName, (f1) -> {
			Field1<M> newField1 = new Field1<M>() {
				@Override
				void setValue(Object val, M m) {
					if (val == null) {
						f1.setValue(null, m);
						return;
					}
					f1.setValue(converter.fromDB(val),m);
				}
				@Override
				Object getValue(M m) {
					MT val = (MT) f1.getValue(m);
					return converter.toDB(val);
				}
			};
			newField1.psSetter = SQLUtil.setter(converter.dbType());
			newField1.rsGet = rsGet(converter.dbType());
			newField1.sqlName = f1.sqlName;
			return newField1;
		});
		return this;
	}
	public static interface FieldConverter<MT> {
		MT fromDB(Object val);
		Object toDB(MT val);
		Class<?> dbType();
	}
	public Builder<M> autoIncrement(boolean b) {
		autoIncrement = b;
		return this;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\qj\tool\sql\SQLUtil.java---
package qj.tool.sql;
import qj.util.IOUtil;
import qj.util.ReflectUtil;
import qj.util.StringUtil;
import qj.util.funct.P0;
import qj.util.funct.P3;
import javax.sql.rowset.serial.SerialBlob;
import java.lang.reflect.Method;
import java.sql.*;
import java.util.Date;
@SuppressWarnings("UnusedDeclaration")
public class SQLUtil {
	public static void transaction(P0 run, Connection conn) {
		try {
			conn.setAutoCommit(false);
			run.e();
			conn.commit();
			conn.setAutoCommit(true);
		} catch (SQLException e) {
			try {
				conn.rollback();
				conn.setAutoCommit(true);
			} catch (SQLException ignored) {
			}
			throw new RuntimeException(e);
		}
	}
	public static Long selectLong(Connection conn, String query, Object... params) {
		PreparedStatement ps = null;
		ResultSet rs = null;
		try {
			ps = conn.prepareStatement(query);
			psSet1(params, ps);
			rs = ps.executeQuery();
			if (rs.next()) {
				return rs.getLong(1);
			}
			return null;
		} catch (SQLException e) {
			throw new RuntimeException(e);
		} finally {
			IOUtil.close(rs);
			IOUtil.close(ps);
		}
	}
	public static void update(Connection conn, String query, Object... params) {
		PreparedStatement ps = null;
		try {
			ps = conn.prepareStatement(query);
			psSet1(params, ps);
			ps.executeUpdate();
		} catch (SQLException e) {
			throw new RuntimeException(e);
		} finally {
			IOUtil.close(ps);
		}
	}
	public static P3<PreparedStatement, Integer, Object> setter(Class<?> type) {
		if (type.equals(Date.class)) {
			return (ps, index, val) -> {
				try {
					if (val==null) {
						ps.setNull(index, Types.DATE);
					} else {
						ps.setTimestamp(index, new Timestamp(((Date)val).getTime()));
					}
				} catch (SQLException e) {
					throw new RuntimeException(e);
				}
			};
		}
		if (type.equals(boolean.class)) {
			return (ps, index, val) -> {
				try {
					ps.setInt(index, (Boolean) val ? 1 : 0);
				} catch (SQLException e) {
					throw new RuntimeException(e);
				}
			};
		}
		if (type.equals(byte[].class)) {
			return (ps, index, val) -> {
				try {
					ps.setBlob(index, new SerialBlob((byte[])val));
				} catch (SQLException e) {
					throw new RuntimeException(e);
				}
			};
		}
		String methodName = "set" + StringUtil.upperCaseFirstChar(type.getSimpleName());
		Method method = ReflectUtil.findMethod(PreparedStatement.class, (m) -> m.getName().equals(methodName) && m.getParameterCount() == 2);
		if (method == null) {
			return null;
		}
		return (ps, index, val) -> {
			if (val==null) {
				try {
					ps.setNull(index, Types.VARCHAR);
				} catch (SQLException e) {
					throw new RuntimeException(e);
				}
			} else {
				ReflectUtil.invoke(method, ps, index, val);
			}
		};
	}
	static int psSet(Object[] params, PreparedStatement ps, int index)
			throws SQLException {
		if (params == null) {
			return index;
		}
		for (Object val : params) {
			if (val == null) {
				ps.setNull(index++, Types.INTEGER);
			} else {
				P3<PreparedStatement, Integer, Object> setter = setter(val.getClass());
				setter.e(ps, index++, val);
			}
		}
		return index;
	}
	static void psSet1(Object[] params, PreparedStatement ps) throws SQLException {
		psSet(params, ps, 1);
	}
	public static int execute(String query, Connection conn) {
		PreparedStatement ps = null;
		try {
			ps = conn.prepareStatement(query);
			return ps.executeUpdate();
		} catch (SQLException e) {
			throw new RuntimeException(e);
		} finally {
			IOUtil.close(ps);
		}
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\qj\tool\sql\Template.java---
package qj.tool.sql;
import qj.util.Cols;
import qj.util.IOUtil;
import qj.util.ReflectUtil;
import qj.util.RegexUtil;
import qj.util.funct.*;
import java.lang.reflect.Type;
import java.sql.*;
import java.util.Arrays;
import java.util.Collection;
import java.util.LinkedList;
import java.util.List;
import java.util.concurrent.atomic.AtomicReference;
import java.util.regex.Matcher;
@SuppressWarnings("UnusedDeclaration")
public class Template<M> {
	Class<M> clazz;
	List<Field1<M>> idFields;
	List<Field1<M>> dataFields;
	String tableName;
	boolean autoIncrement = true;
	Template(Class<M> clazz) {
		this.clazz = clazz;
	}
	static abstract class Field1<M> {
		F2<ResultSet,Integer,Object> rsGet = null;
		P3<PreparedStatement, Integer, Object> psSetter = null;
		String sqlName = null;
		Type type;
		abstract void setValue(Object val, M m);
		abstract Object getValue(M m);
	}
	public static <M> Builder<M> builder(Class<M> clazz) {
		return new Builder<>(clazz);
	}
	public M insert(M m, Connection conn) {
		boolean hasId = getId(m) != null;
		List<Field1<M>> fields = hasId ? allFields() : dataFields;
		PreparedStatement ps = null;
		ResultSet rs = null;
		try {
			String sql = "INSERT INTO `" + tableName + "`(" + fieldNames(fields) + ") VALUES(" + fieldsPH(fields) + ")";
			ps = conn.prepareStatement(sql, Cols.isEmpty(idFields) ? Statement.NO_GENERATED_KEYS : Statement.RETURN_GENERATED_KEYS); // new String[] {"id"}
			psSet1(fields, m, ps);
			int result = ps.executeUpdate();
			if (result != 1) {
				throw new RuntimeException("Failed to insert record into " + tableName + " table");
			}
			if (!hasId && Cols.isNotEmpty(idFields)) {
				rs = ps.getGeneratedKeys();
				if (rs.next()){
					setId(m, rs.getLong(1));
				}
			}
			return m;
		} catch (SQLException e) {
			throw new RuntimeException(e);
		} finally {
			IOUtil.close(rs);
			IOUtil.close(ps);
		}
	}
	public void insert(Collection<M> col, Connection conn) {
		if (Cols.isEmpty(col)) {
			return;
		}
		List<Field1<M>> fields = allFields();
		PreparedStatement ps = null;
		try {
			String sql = "INSERT INTO `" + tableName + "`(" + fieldNames(fields) + ") VALUES(" + fieldsPH(fields) + ")";
			ps = conn.prepareStatement(sql, Cols.isEmpty(idFields) ? Statement.NO_GENERATED_KEYS : Statement.RETURN_GENERATED_KEYS); // new String[] {"id"}
			for (M m : col) {
				psSet1(fields, m, ps);
				ps.addBatch();
			}
			ps.executeBatch();
		} catch (SQLException e) {
			throw new RuntimeException(e);
		} finally {
			IOUtil.close(ps);
		}
	}
	private void setId(M m, long id) {
		Cols.getSingle(idFields).setValue(id, m);
	}
	public Object getId(M m) {
		Field1<M> idField = Cols.getSingle(idFields);
		return idField != null ? idField.getValue(m) : null;
	}
	private void psSet1(List<Field1<M>> fields, M m, PreparedStatement ps) throws SQLException {
		int index = 1;
		for (Field1 field : fields) {
			Object val = field.getValue(m);
			if (val == null) {
				ps.setNull(index++, Types.INTEGER);
			} else {
				P3<PreparedStatement, Integer, Object> setter = field.psSetter;
				setter.e(ps, index++, val);
			}
		}
	}
	private String fieldsPH(List<Field1<M>> fields) {
		return Cols.join(Cols.createList(fields.size(), () -> "?"), ",");
	}
	private String fieldNames(List<Field1<M>> fields) {
		return Cols.join((Iterable<String>) Cols.yield(fields, (f) -> "`" + f.sqlName + "`"), ",");
	}
	public int delete(Connection conn, String cond, Object... params) {
		PreparedStatement ps = null;
		try {
			ps = conn.prepareStatement("DELETE FROM `" + tableName + "` " + (cond != null ? cond : ""));
			SQLUtil.psSet1(params, ps);
			return ps.executeUpdate();
		} catch (SQLException e) {
			throw new RuntimeException(e);
		} finally {
			IOUtil.close(ps);
		}
	}
	/**
	 * SET state=? WHERE id=?
	 */
	public int update(Connection conn, String query, Object... params) {
		PreparedStatement ps = null;
		try {
			ps = conn.prepareStatement("UPDATE `" + tableName + "` " + query);
			SQLUtil.psSet1(params, ps);
			return ps.executeUpdate();
		} catch (SQLException e) {
			throw new RuntimeException(e);
		} finally {
			IOUtil.close(ps);
		}
	}
	public int update(M m, Connection conn, String cond, Object... params) {
		return update(m, allFields(), conn, cond, params);
	}
	public int update(M m, List<Field1<M>> fields, Connection conn, String cond, Object... params) {
		PreparedStatement ps = null;
		try {
			ps = conn.prepareStatement("UPDATE `" + tableName + "` SET " + psSetUpdate(fields) + " " + cond);
			psSet1(fields, m, ps);
			SQLUtil.psSet(params, ps, fields.size() + 1);
			return ps.executeUpdate();
		} catch (SQLException e) {
			throw new RuntimeException(e);
		} finally {
			IOUtil.close(ps);
		}
	}
	private String psSetUpdate(List<Field1<M>> fields) {
		return Cols.join((Iterable<String>)Cols.yield(fields, (f) -> "`" + f.sqlName + "`=?"), ",");
	}
	public M selectById(Object id, Connection conn) {
		if (id == null) {
			return null;
		}
		return select(conn, "WHERE `" + Cols.getSingle(idFields).sqlName + "`=?", id);
	}
	public M select(Connection conn, String query, Object... params) {
		Query<M> parseQuery = parseSelectQuery(query);
		AtomicReference<M> ret = new AtomicReference<>();
		F1<M, Boolean> f1 = Fs.f1(Fs.setter(ret), true);
		String cond = (parseQuery.cond != null ? parseQuery.cond : "") + " LIMIT 1";
		each(f1, conn, parseQuery.fields, cond, params);
		return ret.get();
	}
	public List<M> selectAll(Connection conn) {
		List<Field1<M>> fields = allFields();
		String cond = "";
		return selectList(conn, fields, cond, null);
	}
	private List<M> selectList(Connection conn, List<Field1<M>> fields,
	                           String cond, Object[] params) {
		LinkedList<M> list = new LinkedList<>();
		each(Fs.store(list), conn, fields, cond, params);
		return list;
	}
	private void each(P1<M> p1, Connection conn, List<Field1<M>> fields,
			String cond, Object[] params) {
		each(Fs.f1(p1, false), conn, fields, cond, params);
	}
	private void each(F1<M,Boolean> f1, Connection conn, List<Field1<M>> fields,
			String cond, Object[] params) {
		PreparedStatement ps = null;
		ResultSet rs = null;
		String sql = "SELECT " + fieldNames(fields) + " FROM `" + tableName + "`" + (cond == null ? "" : " " + cond);
		try {
			ps = conn.prepareStatement(sql);
			SQLUtil.psSet1(params, ps);
			rs = ps.executeQuery();
			while (rs.next()) {
				M m = ReflectUtil.newInstance(clazz);
				rsSet(fields, m, rs);
				if (f1.e(m)) {
					break;
				}
			}
		} catch (SQLException e) {
			throw new RuntimeException(e + ", sql=" + sql, e);
		} finally {
			IOUtil.close(rs);
			IOUtil.close(ps);
		}
	}
	private void rsSet(List<Field1<M>> fields, M m, ResultSet rs) {
		int index = 1;
		for (Field1 field : fields) {
			field.setValue(field.rsGet.e(rs, index++), m);
		}
	}
	private List<Field1<M>> allFields() {
		LinkedList<Field1<M>> ret = new LinkedList<>();
		ret.addAll(idFields);
		ret.addAll(dataFields);
		return ret;
	}
	public List<M> selectList(Connection conn, String query, Object... params) {
		Query<M> parseQuery = parseSelectQuery(query);
		return selectList(conn, parseQuery.fields, parseQuery.cond, params);
	}
	private Query<M> parseSelectQuery(String query) {
		if (query == null) {
			return new Query<>(allFields(), null);
		}
		Matcher matcher = RegexUtil.matcher("^(?i)(?:SELECT (.+?) *)?(?:FROM .+? *)?((?:WHERE .+)?(?:ORDER BY .+)?)$", query);
		if (!matcher.matches()) {
			throw new RuntimeException("Can not parse this query: " + query);
		}
		return new Query<>(parseFields(matcher.group(1)), matcher.group(2));
	}
	private List<Field1<M>> parseFields(String fields) {
		if (fields == null) {
			return allFields();
		}
		LinkedList<Field1<M>> ret = new LinkedList<>();
		for (String sqlName : fields.split("\\s*,\\s*")) {
			ret.add(getField(sqlName));
		}
		return ret;
	}
	private Field1<M> getField(String sqlName) {
		for (Field1<M> field1 : idFields) {
			if (field1.sqlName.equals(sqlName)) {
				return field1;
			}
		}
		for (Field1<M> field1 : dataFields) {
			if (field1.sqlName.equals(sqlName)) {
				return field1;
			}
		}
		throw new RuntimeException("Can not find this field: " + sqlName);
	}
	static class Query<M> {
		List<Field1<M>> fields;
		String cond;
		public Query(List<Field1<M>> fields, String cond) {
			this.fields = fields;
			this.cond = cond;
		}
	}
	public boolean exists(Connection conn, String cond, Object... params) {
		PreparedStatement ps = null;
		ResultSet rs = null;
		try {
			ps = conn.prepareStatement("SELECT 1 FROM `" + tableName + "` " + cond + " LIMIT 1");
			SQLUtil.psSet1(params, ps);
			rs = ps.executeQuery();
			return rs.next();
		} catch (SQLException e) {
			throw new RuntimeException(e);
		} finally {
			IOUtil.close(rs);
			IOUtil.close(ps);
		}
	}
	public void save(M m, Connection conn) {
		Object id = getId(m);
		if (id != null) {
			int result = update(m, allFields(), conn, "WHERE " + Cols.getSingle(idFields).sqlName + "=?", id);
			if (result != 1) {
				throw new RuntimeException("Failed to update record into " + tableName + " table");
			}
		} else {
			insert(m, conn);
		}
	}
	public void each(P1<M> p1, Connection conn) {
		each(p1, conn, null);
	}
	public void each(P1<M> p1, Connection conn,
			String query, Object... params) {
		Query<M> parseQuery = parseSelectQuery(query);
		each(p1, conn, parseQuery.fields, parseQuery.cond, params);
	}
	public <IDT> F1<IDT, M> selectByIdF(Connection conn) {
		return id -> selectById(id, conn);
	}
	public void update(M m, Connection conn) {
		int result = update(m, allFields(), conn, "WHERE " + Cols.getSingle(idFields).sqlName + "=?", getId(m));
		if (result != 1) {
			throw new RuntimeException("Failed to update record into " + tableName + " table");
		}
	}
	/**
	 * 
	 * @param fields SET name, age
	 */
	public void update(M m, String fields, Connection conn) {
		List<Field1<M>> fields1 = Cols.yield(Arrays.asList(fields.replaceFirst("(?i)^SET ","").split(",\\s*")), this::getField);
		int result = update(m, fields1, conn, "WHERE " + Cols.getSingle(idFields).sqlName + "=?", getId(m));
		if (result != 1) {
			throw new RuntimeException("Failed to update record into " + tableName + " table");
		}
	}
	public void delete(M m, Connection conn) {
		delete(conn, "WHERE " + Cols.getSingle(idFields).sqlName + "=?", getId(m));
	}
	public void deleteById(Object id, Connection conn) {
		delete(conn, "WHERE " + Cols.getSingle(idFields).sqlName + "=?", id);
	}
	public void deleteAll(Connection conn) {
		delete(conn, null);
	}
	public String tableName() {
		return tableName;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\qj\tool\web\ReloadingContext.java---
package qj.tool.web;
import qj.util.ReflectUtil;
import qj.util.funct.F0;
import qj.util.funct.Fs;
import qj.util.funct.P0;
import qj.util.funct.P1;
import qj.util.lang.DynamicClassLoader;
import java.lang.reflect.Field;
import java.util.LinkedList;
@SuppressWarnings("UnusedDeclaration")
public class ReloadingContext {
	protected String contextClassName;
	protected Object contextO;
	F0<ClassLoader> classLoaderF;
	LinkedList<P1<Object>> afterCreateContext = new LinkedList<>();
	LinkedList<P1<Object>> beforeCloseContext = new LinkedList<>();
	@SuppressWarnings("UnusedDeclaration")
	public ReloadingContext(String contextClass, final String... classpaths) {
		this.contextClassName = contextClass;
		classLoaderF = () -> new DynamicClassLoader(classpaths);
	}
	public ReloadingContext(String contextClass, F0<ClassLoader> classLoaderF) {
		this.contextClassName = contextClass;
		this.classLoaderF = classLoaderF;
	}
	public void reload() {
		close();
		contextO = createContextObj();
		Fs.invokeAll(afterCreateContext, contextO);
	}
	public void close() {
		if (contextO!= null) {
			Fs.invokeAll(beforeCloseContext, contextO);
			contextO = null;
		}
	}
	private Object createContextObj() {
		try {
			Class<?> contextClass = classLoaderF.e().loadClass(contextClassName);
			return ReflectUtil.newInstance(contextClass);
		} catch (ClassNotFoundException e) {
			throw new RuntimeException(e);
		}
	}
	public void initWith(final String methodName, Object... params) {
		afterCreateContext.add(obj -> {
			ReflectUtil.invoke(methodName, obj, params);
		});
	}
	public void beforeClose(final String methodName, Object... params) {
		beforeCloseContext.add(obj -> {
			ReflectUtil.invoke(methodName, obj, params);
		});
	}
	@SuppressWarnings("UnusedDeclaration")
	public void setField(final String fieldName, Object value) {
		afterCreateContext.add(obj -> ReflectUtil.setFieldValue(value, fieldName, obj));
	}
	public <A> A get(String fieldName) {
		if (contextO == null) {
			reload();
		}
		Field field = ReflectUtil.getField(fieldName, contextO.getClass());
		return ReflectUtil.getFieldValue(field, contextO);
	}
	public void initWith(P0 afterCreateContext) {
		this.afterCreateContext.add(Fs.p1(afterCreateContext));
	}
	public void beforeClose(P0 beforeClose) {
		this.beforeCloseContext.add(Fs.p1(beforeClose));
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\qj\tool\web\ReloadingWebContext.java---
package qj.tool.web;
import qj.util.funct.F0;
import qj.util.funct.F1;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
@SuppressWarnings("UnusedDeclaration")
public class ReloadingWebContext extends ReloadingContext {
	F1<HttpServletRequest, Boolean> shouldReload;
	@SuppressWarnings("UnusedDeclaration")
	public ReloadingWebContext(String contextClass, final String... classpaths) {
		super(contextClass, classpaths);
		shouldReload = req -> req.getMethod().equalsIgnoreCase("GET") && "true".equals(req.getParameter("rc"));
	}
	public ReloadingWebContext(String contextClass, F0<ClassLoader> classLoaderF, F1<HttpServletRequest, Boolean> shouldReload) {
		super(contextClass, classLoaderF);
		this.shouldReload = shouldReload;
	}
	public HttpServlet stubServlet(final String servletName) {
		return new HttpServlet() {
			protected void service(HttpServletRequest req,
			                       HttpServletResponse resp) throws ServletException,
					IOException {
				if (shouldReload != null && shouldReload.e(req)) {
					reload();
				}
				((HttpServlet)get(servletName + "Servlet")).service(req, resp);
			}
		};
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\qj\tool\web\ResourceFilter.java---
package qj.tool.web;
import qj.util.FileUtil;
import qj.util.IOUtil;
import qj.util.funct.F1;
import javax.servlet.*;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.File;
import java.io.IOException;
import java.nio.charset.Charset;
import java.util.LinkedList;
import java.util.concurrent.TimeoutException;
public class ResourceFilter implements Filter {
	private F1<HttpServletRequest, String> rootRedirect;
	LinkedList<F1<String, File>> locationFs = new LinkedList<>();
	public ResourceFilter(F1<HttpServletRequest,String> rootRedirect, String... locations) {
		this.rootRedirect = rootRedirect;
		for (final String loc : locations) {
			if (loc != null) {
				locationFs.add(locF(loc));
			}
		}
	}
	@Override
	public void destroy() {
	}
	@Override
	public void init(FilterConfig filterConfig) throws ServletException {
	}
	@Override
	public void doFilter(ServletRequest req1, ServletResponse resp1,
			FilterChain chain) throws IOException, ServletException {
		HttpServletRequest req = (HttpServletRequest) req1;
		HttpServletResponse resp = (HttpServletResponse) resp1;
		String uri = req.getRequestURI();
		String redirectLocation;
		if (uri.equals("/") && (redirectLocation = rootRedirect.e(req)) != null) {
			resp.sendRedirect(redirectLocation);
			return;
		}
		File file = getFile(uri);
		if (file != null) {
			serve((HttpServletResponse) resp1, file, uri);
		} else if (uri.endsWith(".js") || uri.endsWith(".css") || uri.endsWith(".jpg") || uri.endsWith(".png")) {
			resp.sendError(404);
		} else {
			chain.doFilter(req1, resp1);
		}
	}
	private void serve(HttpServletResponse resp, File file, String uri) throws IOException {
		resp.setContentType(
					uri.endsWith(".js" ) ? "application/javascript" : 
					uri.endsWith(".css") ? "text/css" :
					uri.endsWith(".svg") ? "image/svg+xml" :
					uri.endsWith(".ttf") ? "application/octet-stream" :
					uri.endsWith(".woff") ? "font/woff" :
					null
				);
		F1<String, String> contentFilter = getContentFilter(uri);
		if (contentFilter != null) {
			String content = contentFilter.e(IOUtil.toString(FileUtil.fileInputStream(file), "UTF-8"));
			resp.getOutputStream().write(content.getBytes(Charset.forName("UTF-8")));
		} else {
			ServletOutputStream out = resp.getOutputStream();
			try {
				IOUtil.connect(FileUtil.fileInputStream(file), out);
			} catch (IOException e) {
				if (e.getCause() != null && e.getCause() instanceof TimeoutException) {
					;
				} else {
					throw e;
				}
			}
		}
	}
	LinkedList<ContentFilterHolder> filters = new LinkedList<>();
	@SuppressWarnings("UnusedDeclaration")
	public void addContentFilter(F1<String,Boolean> uriCheck, F1<String,String> contentFilter) {
		filters.add(new ContentFilterHolder(uriCheck, contentFilter));
	}
	public F1<String,String> getContentFilter(String uri) {
		for (ContentFilterHolder filter : filters) {
			if (filter.uriCheck.e(uri)) {
				return filter.contentFilter;
			}
		}
		return null;
	}
	public static F1<String, Boolean> js = uri -> uri.endsWith(".js" );
	static class ContentFilterHolder {
		F1<String,Boolean> uriCheck;
		F1<String,String> contentFilter;
		public ContentFilterHolder(
				F1<String, Boolean> uriCheck,
				F1<String, String> contentFilter
				) {
			this.uriCheck = uriCheck;
			this.contentFilter = contentFilter;
		}
	}
	private File getFile(String uri) {
		if (uri.contains("//") || uri.contains("..") || uri.contains("./") || uri.contains("\\")) {
			return null;
		}
		for (F1<String, File> locF : locationFs) {
			File file = locF.e(uri);
			if (file != null) {
				return file;
			}
		}
		return null;
	}
	public F1<String, File> locF(final String loc) {
		return uri -> {
			File file = new File(loc + uri);
			if (file.exists() && file.isFile()) {
				return file;
			}
			return null;
		};
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\qj\util\Cols.java---
package qj.util;
import qj.util.funct.F0;
import qj.util.funct.F1;
import java.util.*;
/**
 * Created by QuanLA
 * Date: Mar 2, 2006
 * Time: 9:10:49 AM
 */
@SuppressWarnings({"rawtypes","unchecked"})
public class Cols {
	/**
	 * If a collection is empty
	 * @param objs
	 * @return
	 */
	public static boolean isEmpty(Collection<?> objs) {
		return objs == null || objs.isEmpty();
	}
	/**
	 * If a collection is not empty
	 * @param col
	 * @return
	 */
    public static boolean isNotEmpty(Collection<?> col) {
        return !isEmpty(col);
    }
    /**
     * Get single element, or null if Col is empty
     * @param collection
     * @return
     */
    public static <A> A getSingle(
            Collection<A> collection) {
    	if (collection == null) {
    		return null;
    	}
        for (A a : collection) {
            return a;
        }
        return null;
    }
    public static <A> List<A> createList(int size, F0<A> f) {
        ArrayList<A> list = new ArrayList<A>(size);
        for (int i = 0; i < size; i++) {
            list.add(f.e());
        }
        return list;
    }
    /**
     * Create a string connecting all values in collection, separated with delimiter
     * @param objs
     * @param delimiter
     * @return
     */
	public static <A> String join(Iterable<A> objs, String delimiter) {
        if (objs == null) {
            return "";
        }
		StringBuilder sb = new StringBuilder();
		for (A a : objs) {
			sb.append(a).append(delimiter);
		}
		if (sb.length() > 0) {
			sb.setLength(sb.length() - delimiter.length());
		}
		return sb.toString();
	}
	public static <A,T> List<T> yield(List<A> col, F1<A, T> f1) {
        if (col!=null) {
            return yield(col, new ArrayList<T>(col.size()), f1);
        } else {
            return null;
        }
    }
	/**
	 * Apply function on every elements to get new collection of returned value
	 * @param <A>
	 * @param <T>
	 * @param <C>
	 * @param inputs
	 * @param col
	 * @param f1
	 * @return
	 */
	public static <A,T,C extends Collection<T>> C yield(Iterable<A> inputs, C col, F1<A, T> f1) {
		if (inputs!=null) {
            for (A a : inputs) {
                T e = f1.e(a);
				if (e != null) {
					col.add(e);
				}
            }
		}
		return col;
	}
	/**
     * Create a map based on the Object... param. Each 2 values is an entry
     * which is a pair of key then value
     * @param objects The params that will be converted to map.
     * 					Format: [key1, value1, key2, value2]
     * @return The map after converted from param objects
     */
    public static <A, B> Map<A, B> map(Object... objects) {
    	if (objects==null) {
    		return null;
    	}
        Map<A, B> map = new LinkedHashMap<A, B>(objects.length / 2);
        for (int i = 0; i < objects.length; i+=2) {
            map.put((A)objects[i], (B)objects[i + 1]);
        }
        return map;
    }
}
----strat of file D:\projects\cg\cg-min\src\main\java\qj\util\FileUtil.java---
package qj.util;
import qj.util.funct.F1;
import qj.util.funct.F2;
import qj.util.funct.Fs;
import qj.util.funct.P2;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Enumeration;
import java.util.List;
import java.util.jar.JarEntry;
import java.util.jar.JarFile;
@SuppressWarnings("UnusedDeclaration")
public class FileUtil {
	/**
	 * 
	 * @param fileToRead
	 * @return
	 * @throws IOException
	 */
	public static byte[] readFileToBytes(File fileToRead) {
		try {
			return IOUtil.readData(new FileInputStream(fileToRead));
		} catch (IOException e) {
			throw new RuntimeException(e);
		}
	}
	public static FileInputStream fileInputStream(File file) {
		try {
			return new FileInputStream(file);
		} catch (FileNotFoundException e) {
			throw new RuntimeException(e);
		}
	}
	public static FileInputStream fileInputStream(String file) {
		try {
			return new FileInputStream(file);
		} catch (FileNotFoundException e) {
			throw new RuntimeException(e);
		}
	}
	public static void eachFile(File path, P2<File, String> f) {
		eachFile(path, f, null);
	}
	public static void eachFile(File path, P2<File, String> f, F1<File, Boolean> exclude) {
		eachFile(path, Fs.f2(f, true), exclude);
	}
	public static void eachFile(File path, F2<File, String, Boolean> f, F1<File, Boolean> exclude) {
		ArrayList<String> relPath = new ArrayList<>();
		if (path.isFile()) {
			f.e(path, Cols.join(relPath, File.separator));
		} else {
			if (!eachFileInDir(path, f, relPath, exclude))
				return;
		}
	}
	private static boolean eachFileInDir(File path, F2<File, String, Boolean> f, ArrayList<String> relPath,
			F1<File, Boolean> exclude) {
		if (!path.exists() || !path.isDirectory()) {
			throw new RuntimeException("Invalid path: " + path);
		}
		for (File child : path.listFiles()) {
			if (exclude != null && exclude.e(child)) {
				continue;
			}
			if (child.isFile()) {
				if (!f.e(child, Cols.join(relPath, File.separator)))
					return false;
			} else {
				relPath.add(child.getName());
				if (!eachFileInDir(child, f, relPath, exclude))
					return false;
				relPath.remove(relPath.size() - 1);
			}
		}
		return true;
	}
	public static List<String> getJarFileClassNames(JarFile jarFile) {
		List<String> list = new ArrayList<>();
		if (jarFile != null) {
			Enumeration<JarEntry> e = jarFile.entries();
			while (e.hasMoreElements()) {
				JarEntry entry = e.nextElement();
				String name = entry.getName();
				if (name.endsWith(".class")) {
					name = name.replace(".class", "");
					name = name.replace("/", ".");
					if ("junit.framework.TestCase".equals(name)) {
						System.out.println("***");
					}
					list.add(name);
				}
			}
		}
		return list;
	}
	public static String getPathRegex() {
		String pathRegex = File.separator;
		if ("\\".equals(pathRegex)) {
			pathRegex = "\\\\";
		}
		return pathRegex;
	}
	public static void listAllFiles(File dir, String fileNameRegex, List<File> allFiles) {
		File fileArray[] = dir.listFiles();
		for (File file : fileArray) {
			if (file.isFile()) {
				String s = file.getName();
				boolean b = s.matches(fileNameRegex);
				if (b) {
					allFiles.add(file);
				}
			} else {
				listAllFiles(file, fileNameRegex, allFiles);
			}
		}
	}
	public static List<String> getClassNamesUnderDir(File dir) {
		String pathRegex = getPathRegex();
		List<String> list = new ArrayList<>();
		String folderPath = dir.getAbsolutePath() + File.separator;
		List<File> classFileList = new ArrayList<>();
		listAllFiles(dir, "[\\w\\$]+\\.class", classFileList);
		for (File classFile : classFileList) {
			String clzFilePath;
			try {
				clzFilePath = classFile.getCanonicalPath();
				clzFilePath = clzFilePath.replace(folderPath, "");
				clzFilePath = clzFilePath.replaceAll(pathRegex, "\\.");
				clzFilePath = clzFilePath.replaceAll(".class", "");
				list.add(clzFilePath);
			} catch (IOException e2) {
				e2.printStackTrace();
			}
		}
		return list;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\qj\util\funct\F0.java---
package qj.util.funct;
/**
 * Represent a function that accept no parameter and return value
 * @param <T> The return value
 */
public interface F0<T> {
    /**
     * Evaluate or execute the function
     * @return Result of execution
     */
    T e();
}
----strat of file D:\projects\cg\cg-min\src\main\java\qj\util\funct\F1.java---
package qj.util.funct;
/**
 * Represent a function that accept one parameter and return value
 * @param <A> The only parameter
 * @param <T> The return value
 */
public interface F1<A, T> {
    /**
     * Evaluate or execute the function
     * @param obj The parameter
     * @return Result of execution
     */
	T e(A obj);
}
----strat of file D:\projects\cg\cg-min\src\main\java\qj\util\funct\F2.java---
package qj.util.funct;
public interface F2<A, B, T>{
	T e(A a, B b);
}
----strat of file D:\projects\cg\cg-min\src\main\java\qj\util\funct\Fs.java---
package qj.util.funct;
import java.util.Collection;
import java.util.concurrent.atomic.AtomicReference;
/**
 * The utility that employ idea of functional programming
 *
 */
@SuppressWarnings({"unchecked", "rawtypes"})
public class Fs extends FsGenerated {
    public static Runnable runnable(final P0 action) {
        return new Runnable() {
            public void run() {
                action.e();
            }
        };
    }
	/**
	 * Just store the object to collection
	 * @param col
	 * @return
	 */
    public static <A> P1<A> store(final Collection<A> col) {
        return new P1<A>() {public void e(A a) {
            col.add(a);
        }};
    }
	public static <A> P1<A> setter(
			final AtomicReference<A> ref) {
		return new P1<A>() {public void e(A obj) {
			ref.set(obj);
		}};
	}
	public static <A> void invokeAll(final Collection<P1<A>> col, A a) {
		for (P1<A> p1 : col) {
			p1.e(a);
		}
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\qj\util\funct\FsGenerated.java---
package qj.util.funct;
public class FsGenerated {
	/**
	 * Convert from a p0 to p1
	 * @return p1
	 */
	public static <A> P1<A> p1(final P0 p0) {
		return new P1<A>(){public void e(final A a) {
			p0.e();
		}};
	}
	/**
	 * Call to p and return fixed value
	 * @param p1 the function to call before return value
	 * @param ret the fixed value to return
	 * @return ret
	 */
	public static <A, R> F1<A, R> f1(final P1<A> p1, final R ret) {
		return new F1<A, R>(){public R e(final A a) {
			p1.e(a);
			return ret;
		}};
	}
	/**
	 * Call to p and return fixed value
	 * @param p2 the function to call before return value
	 * @param ret the fixed value to return
	 * @return ret
	 */
	public static <A, B, R> F2<A, B, R> f2(final P2<A, B> p2, final R ret) {
		return new F2<A, B, R>(){public R e(final A a, final B b) {
			p2.e(a, b);
			return ret;
		}};
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\qj\util\funct\P0.java---
package qj.util.funct;
public interface P0 {
	void e();
}
----strat of file D:\projects\cg\cg-min\src\main\java\qj\util\funct\P1.java---
package qj.util.funct;
/**
 * Function that accept 1 objects and return nothing
 * @author QuanLA
 *
 * @param <A>
 */
public interface P1<A> {
	void e(A obj);
}
----strat of file D:\projects\cg\cg-min\src\main\java\qj\util\funct\P2.java---
package qj.util.funct;
/**
 * Function that accept 2 objects and return nothing
 * @author QuanLA
 *
 * @param <A>
 * @param <B>
 */
public interface P2<A, B> {
	void e(A a, B b);
}
----strat of file D:\projects\cg\cg-min\src\main\java\qj\util\funct\P3.java---
package qj.util.funct;
public interface P3<A, B, C> {
	void e(A a, B b, C c);
}
----strat of file D:\projects\cg\cg-min\src\main\java\qj\util\IOUtil.java---
package qj.util;
import java.io.*;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
/**
 * Created by Quan on 22/12/2014.
 */
public class IOUtil {
	/**
	 * Read the stream into byte array
	 * @param inputStream
	 * @return
	 * @throws IOException
	 */
    public static byte[] readData(InputStream inputStream) {
        try {
			return readDataNice(inputStream);
		} finally {
        	close(inputStream);
		}
    }
    public static byte[] readDataNice(InputStream inputStream) {
		ByteArrayOutputStream boTemp = null;
        byte[] buffer = null;
        try {
            int read;
			buffer = new byte[8192];
            boTemp = new ByteArrayOutputStream();
            while ((read=inputStream.read(buffer, 0, 8192)) > -1) {
                boTemp.write(buffer, 0, read);
            }
            return boTemp.toByteArray();
        } catch (IOException e) {
			throw new RuntimeException(e);
        }
	}
    /**
     * Close streams (in or out)
     * @param stream
     */
    public static void close(Closeable stream) {
        if (stream != null) {
            try {
                if (stream instanceof Flushable) {
                    ((Flushable)stream).flush();
                }
                stream.close();
            } catch (IOException e) {
            }
        }
    }
	public static void close(Connection conn) {
        if (conn != null) {
            try {
                conn.close();
            } catch (SQLException e) {
			}
        }
	}
    public static void close(ResultSet rs) {
    	if (rs != null) {
    		try {
    			rs.close();
    		} catch (SQLException e) {
    		}
    	}
    }
    public static void close(PreparedStatement ps) {
    	if (ps != null) {
    		try {
    			ps.close();
    		} catch (SQLException e) {
    		}
    	}
    }
	/**
	 * Will close stream
	 * @param in
	 * @param charSet
	 * @return
	 */
	public static String toString(InputStream in, String charSet) {
		return inputStreamToString_force(in, charSet);
	}
	/**
	 * Will close stream
	 * @param in
	 * @param charSet
	 * @return
	 */
	public static String inputStreamToString_force(InputStream in, String charSet) {
		try {
			return inputStreamToString(in, charSet);
		} catch (IOException e) {
			return null;
		}
	}
    /**
     * Reads in whole input stream and returns as a string<br>
     * Will close stream
     * @param in The input stream to read in, will be closed 
     * 				by this method at finish
     * @param charSet charset to convert the input bytes into string
     * @return the result string
     * @throws IOException
     */
	public static String inputStreamToString(InputStream in, String charSet) throws IOException {
		InputStreamReader inputStreamReader = null;
		try {
			inputStreamReader = charSet == null? new InputStreamReader(in) : new InputStreamReader(in, charSet);
			return toString(inputStreamReader);
		} catch (UnsupportedEncodingException e1) {
			throw new RuntimeException(e1);
		} finally {
			close(in);
		}
	}
    /**
     * Reads in whole input stream and returns as a string
     * @param reader The input reader to read in, will be closed 
     * 				by this method at finish
     * @return the result string
     * @throws IOException
     */
	public static String toString(Reader reader) {
		try {
			StringBuilder sb = new StringBuilder();
			char[] buffer = new char[4096];
			for (int read; (read = reader.read(buffer)) > -1;) {
				sb.append(buffer, 0, read);
			}
			return sb.toString();
		} catch (IOException e) {
			throw new RuntimeException(e);
		} finally {
			close(reader);
		}
	}
	/**
	 * Read the input stream and write to output stream
	 * @param inputStream
	 * @param out
	 * @return
	 * @throws IOException
	 */
    public static long connect(InputStream inputStream, OutputStream out) throws IOException {
        try {
            return dump(inputStream, out);
        } finally {
            close(inputStream);
        }
    }
    private static long dump(InputStream inputStream, OutputStream out) throws IOException {
        long total = 0;
        int read;
        int bufferSize = 8192;
        byte[] buffer = new byte[bufferSize];
        while ((read=inputStream.read(buffer, 0, bufferSize)) > -1) {
            out.write(buffer, 0, read);
            total+=read;
        }
        out.flush();
        return total;
    }
}
----strat of file D:\projects\cg\cg-min\src\main\java\qj\util\lang\AggressiveClassLoader.java---
package qj.util.lang;
import java.util.HashSet;
import java.util.Set;
/**
 * Load all classes it can, leave the rest to the Parent ClassLoader
 */
public abstract class AggressiveClassLoader extends ClassLoader {
	Set<String> loadedClasses = new HashSet<>();
	Set<String> unavaiClasses = new HashSet<>();
	public AggressiveClassLoader() {
		super();
	}
	public AggressiveClassLoader(ClassLoader parent) {
		super(parent);
	}
	@Override
	public Class<?> loadClass(String name) throws ClassNotFoundException {
		if (loadedClasses.contains(name) || unavaiClasses.contains(name)) {
			return super.loadClass(name); // Use default CL cache
		}
		byte[] newClassData = loadNewClass(name);
		if (newClassData != null) {
			loadedClasses.add(name);
			return loadClass(newClassData, name);
		} else {
			unavaiClasses.add(name);
			return super.loadClass(name, true);
		}
	}
	@Override
	public Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {
		if (loadedClasses.contains(name) || unavaiClasses.contains(name)) {
			return super.loadClass(name, resolve); // Use default CL cache
		}
		byte[] newClassData = loadNewClass(name);
		if (newClassData != null) {
			loadedClasses.add(name);
			return loadClass(newClassData, name);
		} else {
			unavaiClasses.add(name);
			return super.loadClass(name, true);
		}
	}
	/**
	 * Handle exception
	 * 
	 * @param name
	 * @return
	 */
	public Class<?> load(String name) {
		try {
			return loadClass(name);
		} catch (ClassNotFoundException e) {
			throw new RuntimeException(e);
		}
	}
	/**
	 * Handle exception
	 * 
	 * @param name
	 * @return
	 */
	public Class<?> load(String name, boolean resolve) {
		try {
			return loadClass(name, resolve);
		} catch (ClassNotFoundException e) {
			throw new RuntimeException(e);
		}
	}
	protected abstract byte[] loadNewClass(String name);
	public Class<?> loadClass(byte[] classData, String name) {
		Class<?> clazz = defineClass(name, classData, 0, classData.length);
		if (clazz != null) {
			if (clazz.getPackage() == null) {
				definePackage(name.replaceAll("\\.\\w+$", ""), null, null, null, null, null, null, null);
			}
			resolveClass(clazz);
		}
		return clazz;
	}
	public Set<String> getLoadedClasses() {
		return loadedClasses;
	}
	public Set<String> getUnavaiClasses() {
		return unavaiClasses;
	}
	public static String toFilePath(String name) {
		return name.replaceAll("\\.", "/") + ".class";
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\qj\util\lang\DynamicClassLoader.java---
package qj.util.lang;
import qj.util.FileUtil;
import qj.util.IOUtil;
import qj.util.funct.F1;
import java.io.File;
import java.io.IOException;
import java.lang.reflect.Method;
import java.net.URL;
import java.util.ArrayList;
import java.util.Collection;
import java.util.LinkedList;
import java.util.List;
import java.util.jar.JarFile;
import java.util.zip.ZipEntry;
public class DynamicClassLoader extends AggressiveClassLoader {
	LinkedList<F1<String, byte[]>> loaders = new LinkedList<>();
	private List<String> allClassNamesInJar = new ArrayList<>();
	private List<String> allClassNamesInDir = new ArrayList<>();
	public DynamicClassLoader(URL... urls) {
		String[] paths = new String[urls.length];
		for (int i = 0; i < urls.length; i++) {
			if (null != urls[i]) {
				paths[i] = urls[i].getPath();
			}
		}
		for (String path : paths) {
			if (null != path) {
				File file = new File(path);
				F1<String, byte[]> loader = loader(file);
				if (loader == null) {
					throw new RuntimeException("Path not exists " + path);
				}
				loaders.add(loader);
			}
		}
	}
	public DynamicClassLoader(ClassLoader parent, URL... urls) {
		super(parent);
		String[] paths = new String[urls.length];
		for (int i = 0; i < urls.length; i++) {
			if (null != urls[i]) {
				paths[i] = urls[i].getPath();
			}
		}
		for (String path : paths) {
			if (null != path) {
				File file = new File(path);
				F1<String, byte[]> loader = loader(file);
				if (loader == null) {
					throw new RuntimeException("Path not exists " + path);
				}
				loaders.add(loader);
			}
		}
	}
	public DynamicClassLoader(String... paths) {
		for (String path : paths) {
			if (null != path) {
				File file = new File(path);
				F1<String, byte[]> loader = loader(file);
				if (loader == null) {
					throw new RuntimeException("Path not exists " + path);
				}
				loaders.add(loader);
			}
		}
	}
	public DynamicClassLoader(ClassLoader parent, String... paths) {
		super(parent);
		for (String path : paths) {
			if (null != path) {
				File file = new File(path);
				F1<String, byte[]> loader = loader(file);
				if (loader == null) {
					throw new RuntimeException("Path not exists " + path);
				}
				loaders.add(loader);
			}
		}
	}
	@SuppressWarnings("UnusedDeclaration")
	public DynamicClassLoader(Collection<File> paths) {
		for (File file : paths) {
			F1<String, byte[]> loader = loader(file);
			if (loader == null) {
				throw new RuntimeException("Path not exists " + file.getPath());
			}
			loaders.add(loader);
		}
	}
	public F1<String, byte[]> loader(File file) {
		if (!file.exists()) {
			return null;
		} else if (file.isDirectory()) {
			allClassNamesInDir.addAll(FileUtil.getClassNamesUnderDir(file));
			return dirLoader(file);
		} else {
			try {
				final JarFile jarFile = new JarFile(file);
				allClassNamesInJar.addAll(FileUtil.getJarFileClassNames(jarFile));
				return jarLoader(jarFile);
			} catch (IOException e) {
				throw new RuntimeException(e);
			}
		}
	}
	private static File findFile(String filePath, File classPath) {
		File file = new File(classPath, filePath);
		return file.exists() ? file : null;
	}
	public static F1<String, byte[]> dirLoader(final File dir) {
		return filePath -> {
			File file = findFile(filePath, dir);
			if (file == null) {
				return null;
			}
			return FileUtil.readFileToBytes(file);
		};
	}
	private static F1<String, byte[]> jarLoader(final JarFile jarFile) {
		return new F1<String, byte[]>() {
			public byte[] e(String filePath) {
				ZipEntry entry = jarFile.getJarEntry(filePath);
				if (entry == null) {
					return null;
				}
				try {
					return IOUtil.readData(jarFile.getInputStream(entry));
				} catch (IOException e) {
					throw new RuntimeException(e);
				}
			}
			@Override
			protected void finalize() throws Throwable {
				IOUtil.close(jarFile);
				super.finalize();
			}
		};
	}
	@Override
	protected byte[] loadNewClass(String name) {
		for (F1<String, byte[]> loader : loaders) {
			String path = AggressiveClassLoader.toFilePath(name);
			byte[] data = loader.e(path);
			if (data != null) {
				return data;
			}
		}
		return null;
	}
	public LinkedList<F1<String, byte[]>> getLoaders() {
		return loaders;
	}
	public List<String> getAllClassNamesInJar() {
		return allClassNamesInJar;
	}
	public List<String> getAllClassNamesInDir() {
		return allClassNamesInDir;
	}
	public static void main(String[] args) {
		for (;;) {
			String[] sa = new String[] { "D:\\project\\codegen\\production\\winSTSRobot\\target\\classes",
					"D:\\androidMavenRepository\\deployment\\common\\1.0\\common-1.0.jar",
					"D:\\androidMavenRepository\\com\\dgs\\customobfuscator\\1.0\\customobfuscator-1.0.jar" };
			DynamicClassLoader dynamicClassLoader = new DynamicClassLoader(sa);
			try {
				Class<?> clz = dynamicClassLoader.loadClass("ui.UI");
				Method methodArray[] = clz.getDeclaredMethods();
				System.out.println(methodArray.length);
				Thread.sleep(2000L);
			} catch (ClassNotFoundException | InterruptedException e) {
				e.printStackTrace();
			}
		}
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\qj\util\lang\ExceptingClassLoader.java---
package qj.util.lang;
import qj.util.funct.F1;
/**
 * This class loader will not load certain classes, instead delegate to parent
 * class loader to do the job
 */
@SuppressWarnings("UnusedDeclaration")
public class ExceptingClassLoader extends DynamicClassLoader {
	private F1<String, Boolean> except;
	public ExceptingClassLoader(F1<String, Boolean> except, String... paths) {
		super(paths);
		this.except = except;
	}
	@Override
	protected byte[] loadNewClass(String name) {
		if (except.e(name)) {
            return null;
		}
		return super.loadNewClass(name);
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\qj\util\lang\ReloadableDynamicClassLoaderOwner.java---
package qj.util.lang;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.*;
public class ReloadableDynamicClassLoaderOwner {
	ClassLoader parent;// both classloader's parent
	private Set<URL> jarUrls = new HashSet<>();
	private Set<URL> dirUrls = new HashSet<>();
	private DynamicClassLoader dirDynamicClassLoader;// by default, dirDynamicClassLoader should has its parent as
	private DynamicClassLoader jarDynamicClassLoader;
	public void addJarUrl(URL... jarUrlArray) {
		for (URL url : jarUrlArray) {
			jarUrls.add(url);
		}
	}
	public DynamicClassLoader loadAllJar(ClassLoader parent, URL... urlArray) {
		for (URL url : urlArray) {
			jarUrls.add(url);
		}
		jarDynamicClassLoader = new DynamicClassLoader(parent, jarUrls.toArray(new URL[this.jarUrls.size()]));
		return jarDynamicClassLoader;
	}
	public DynamicClassLoader reloadAllJar() throws Exception {
		if (null == this.jarUrls) {
			throw new Exception("urls cannot be null");
		}
		return loadAllJar(parent, this.jarUrls.toArray(new URL[this.jarUrls.size()]));
	}
	public void addDirUrl(URL... urlArray) {
		for (URL url : urlArray) {
			dirUrls.add(url);
		}
	}
	public DynamicClassLoader loadAllClzInDirectory(ClassLoader parent, URL... dirArray) {
		for (URL url : dirArray) {
			dirUrls.add(url);
		}
		dirDynamicClassLoader = new DynamicClassLoader(parent, dirUrls.toArray(new URL[this.dirUrls.size()]));
		return dirDynamicClassLoader;
	}
	public DynamicClassLoader reloadAllClzInDirectory() throws Exception {
		if (null == this.dirUrls) {
			throw new Exception("urls cannot be null");
		}
		if (null != jarDynamicClassLoader) {
			return loadAllClzInDirectory(jarDynamicClassLoader, this.dirUrls.toArray(new URL[this.dirUrls.size()]));
		} else {
			return loadAllClzInDirectory(parent, this.dirUrls.toArray(new URL[this.dirUrls.size()]));
		}
	}
	public void loadAllClzIntervallyInDirectory(int interval, ClassLoader parent, URL... dirArray) {
		Timer timer = new Timer("loaddirintervally");
		timer.scheduleAtFixedRate(new TimerTask() {
			@Override
			public void run() {
				loadAllClzInDirectory(parent, dirArray);
			}
		}, 0, interval);
	}
	public void reloadAll() {
		loadAllJar(parent);
		loadAllClzInDirectory(parent);
	}
	public DynamicClassLoader getDirDynamicClassLoader() {
		return dirDynamicClassLoader;
	}
	public DynamicClassLoader getJarDynamicClassLoader() {
		return jarDynamicClassLoader;
	}
	public ClassLoader getParent() {
		return parent;
	}
	public void clear() {
		this.jarUrls.clear();
		this.dirUrls.clear();
	}
	public Class<?> loadClassFromDirURLs(String name, boolean resolve) throws ClassNotFoundException {
		Class<?> c = null;
		if (null != dirDynamicClassLoader) {
			try {
				c = dirDynamicClassLoader.loadClass(name, resolve);
			} catch (Exception e) {
				throw new ClassNotFoundException();
			}
		}
		if (null == c) {
			throw new ClassNotFoundException();
		}
		return c;
	}
	public Class<?> loadClassFromJarURLs(String name, boolean resolve) throws ClassNotFoundException {
		Class<?> c = null;
		try {
			if (null != jarDynamicClassLoader) {
				c = jarDynamicClassLoader.loadClass(name, resolve);
			}
		} catch (Exception e) {
			throw new ClassNotFoundException();
		}
		if (null == c) {
			throw new ClassNotFoundException();
		}
		return c;
	}
	public Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {
		Class<?> c = loadClassFromDirURLs(name, resolve);
		if (null == c) {
			c = loadClassFromJarURLs(name, resolve);
		}
		if (null == c) {
			throw new ClassNotFoundException();
		}
		return c;
	}
	public Set<URL> getJarUrls() {
		return jarUrls;
	}
	public Set<URL> getDirUrls() {
		return dirUrls;
	}
	public static void main(String[] args) throws MalformedURLException {
		URL[] urls = new URL[] {
			new URL("file://D:/Java/openjdk-12.0.2_windows-x64_bin/jdk-12.0.2/lib/jrt-fs.jar"),
		};
		ReloadableDynamicClassLoaderOwner rdcl = new ReloadableDynamicClassLoaderOwner();
		rdcl.loadAllJar(ReloadableDynamicClassLoaderOwner.class.getClassLoader(), urls);
		List<String> list = rdcl.getJarDynamicClassLoader().getAllClassNamesInJar();
		List<String> list2 = rdcl.getJarDynamicClassLoader().getAllClassNamesInDir();
		for(String str : list) {
			System.out.println(str);
		}
		System.out.print("*************");
		for(String str : list2) {
			System.out.println(str);
		}
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\qj\util\math\Range.java---
package qj.util.math;
import qj.util.ObjectUtil;
/**
 */
public class Range implements Comparable<Range> {
	private Integer from;
	private Integer to;
    public Range() {
    }
    public Range(Integer from, Integer to) {
        this.from = from;
        this.to = to;
        if (to != null && to < from) {
        	throw new RuntimeException("to(" + to + ") < from(" + from + ")");
        }
    }
    public Range(Long start, Long end) {
        this.from 	= start	== null ? null : start.intValue();
        this.to 	= end   == null ? null : end.intValue();
        if (to != null && to < from) {
        	throw new RuntimeException();
        }
	}
	public Integer getFrom() {
        return from;
    }
    public void setFrom(Integer from) {
        this.from = from;
    }
    public Integer getTo() {
        return to;
    }
    public void setTo(Integer to) {
        this.to = to;
    }
    public String toString() {
        return from + "-" + to;
    }
    @Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + ((from == null) ? 0 : from.hashCode());
		result = prime * result + ((to == null) ? 0 : to.hashCode());
		return result;
	}
    @Override
    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }
        if (!(obj instanceof Range)) {
            return false;
        }
        Range o2 = (Range) obj;
        return ObjectUtil.equals(from, o2.from)
                && ObjectUtil.equals(to, o2.to);
    }
    public int length() {
        return to - from;
    }
    public boolean isEmpty() {
        return to.equals(from);
    }
    public boolean isNotEmpty() {
        return !isEmpty();
    }
    public int compareTo(Range o) {
        return from.compareTo(((Range)o).getFrom());
    }
	public static Range fromlength(int from, int length) {
		return new Range(from, from + length);
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\qj\util\NameCaseUtil.java---
package qj.util;
import qj.util.funct.F1;
import java.util.regex.Matcher;
public class NameCaseUtil {
	public static String camelToHyphen(String name) {
		return RegexUtil.replaceAll(name, "[A-Z]|[0-9]+", new F1<Matcher, String>() {public String e(Matcher m) {
			return (m.start() == 0 ? "" : "_") + m.group().toLowerCase();
		}});
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\qj\util\ObjectUtil.java---
package qj.util;
/**
 * Created by QuanLA
 * Date: Apr 5, 2006
 * Time: 5:46:44 PM
 */
public class ObjectUtil {
	public static boolean equals(Object o1, Object o2) {
		return o1==null ? o2 == null : (o1 == o2 || o1.equals(o2));
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\qj\util\PropertiesUtil.java---
package qj.util;
import java.io.*;
import java.util.Properties;
public class PropertiesUtil {
	public static Properties loadPropertiesFromFile(String fileName) {
        return loadPropertiesFromFile(new File(fileName));
	}
	/**
	 * 
	 * @param file
	 * @return
	 */
    public static Properties loadPropertiesFromFile(File file) {
    	if (!file.exists()) {
    		return null;
    	}
		FileInputStream fis;
		try {
			fis = new FileInputStream(file);
			return load(fis);
		} catch (FileNotFoundException e) {
			throw new RuntimeException(e);
		}
    }
    /**
     * Load a Properties object from inputstream. Close the stream afterward
     * @param is
     * @return
     */
	public static Properties load(InputStream is) {
		Properties properties = new Properties();
        try {
            properties.load(is);
        } catch (IOException e) {
            throw new RuntimeException(e);
        } finally {
	        try {
		        is.close();
	        } catch (IOException e) {
		        ;
	        }
        }
		return properties;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\qj\util\ReflectUtil.java---
package qj.util;
import qj.util.funct.F1;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.concurrent.atomic.AtomicReference;
/**
 * Created by Quan on 22/12/2014.
 */
public class ReflectUtil {
	public static <A> A newInstance(Class<A> cla) {
        return (A) newInstance4(cla);
	}
    public static Object newInstance4(Class clazz) {
		try {
			return clazz.newInstance();
		} catch (InstantiationException e) {
            Throwable cause = e.getCause();
            if (cause==null) {
            	cause = e;
            }
			throw new RuntimeException(cause);
		} catch (IllegalAccessException e) {
			throw new RuntimeException(e);
		}
    }
    public static Method getMethod(String methodName, Class clazz) {
		for (Method method : clazz.getMethods()) {
			if (method.getName().equals(methodName)) {
				return method;
			}
		}
		if (!clazz.equals(Object.class)) {
			Class superclass = clazz.getSuperclass();
			if (superclass != null) {
				return getMethod(methodName, superclass);
			} else {
				return null;
			}
		} else {
			return null;
		}
	}
    public static Method getMethod(String methodName, Class[] paramClasses, Class<?> clazz) {
        try {
            return clazz.getMethod(methodName, paramClasses);
        } catch (NoSuchMethodException e) {
            if (!clazz.equals(Object.class)) {
				Class<?> superclass = clazz.getSuperclass();
				if (superclass != null) {
					return getMethod(methodName, paramClasses, superclass);
				}
				return null;
			} else {
				return null;
			}
        }
    }
	/**
	 * Invoke the method with given params
	 * @param method
	 * @param o
	 * @param params
	 * @return
	 */
    public static <T> T invoke(Method method, Object o, Object... params) {
        try {
            return (T) method.invoke(o, params);
        } catch (IllegalAccessException e) {
            throw new RuntimeException(e);
        } catch (InvocationTargetException e) {
            throw new RuntimeException(e.getCause());
        }
    }
    public static void setFieldValue(Object value, Field field, Object obj) {
        try {
            field.set(obj, value);
        } catch (IllegalAccessException e) {
            throw new RuntimeException(e);
        }
    }
	public static <A> A getFieldValue(String field, Object obj) {
		return getFieldValue(getField(field, obj.getClass()), obj);
	}
    public static <A> A getFieldValue(Field field, Object obj) {
        try {
            return (A) field.get(obj);
        } catch (IllegalAccessException e) {
            throw new RuntimeException(e);
        }
    }
    public static Field getField(String name, Class<?> clazz) {
        try {
            return clazz.getDeclaredField(name);
        } catch (NoSuchFieldException e) {
            Class<?> superClass = clazz.getSuperclass();
            if (Object.class.equals(superClass)) {
                return null;
            } else {
                return getField(name, superClass);
            }
        }
    }
	public static Method findMethod(Class clazz, F1<Method,Boolean> f1) {
		AtomicReference<Method> m = new AtomicReference<>();
		eachMethod(clazz, (Method obj) -> {
			if (f1.e(obj)) {
				m.set(obj);
				return true;
			}
			return false;
		});
		return m.get();
	}
	public static void eachMethod(Class clazz, F1<Method,Boolean> f1) {
		for (Method method : clazz.getMethods()) {
			if (f1.e(method)) {
				return;
			}
		}
		if (!clazz.equals(Object.class)) {
			Class superclass = clazz.getSuperclass();
			if (superclass != null) {
				eachMethod(superclass, f1);
			}
		}
	}
	/**
	 * Invoke the method with given params
	 */
	public static Object invoke(String methodName, Object o, Object... params) {
		return invoke(getMethod(methodName, o.getClass()), o, params);
	}
    public static void setFieldValue(Object value, String field, Object obj) {
        try {
            setFieldValue(value, obj.getClass().getDeclaredField(field), obj);
        } catch (NoSuchFieldException e) {
            throw new RuntimeException(e);
        }
    }
	public static void invokeStatic(String methodName, Class<?> clazz) {
		invoke(getMethod(methodName, clazz), null, null);
	}
    public static <A> A getStaticFieldValue(String field, Class clazz) {
        try {
            return (A) getFieldValue(clazz.getDeclaredField(field), null);
        } catch (NoSuchFieldException e) {
            throw new RuntimeException(e);
        }
    }
}
----strat of file D:\projects\cg\cg-min\src\main\java\qj\util\RegexUtil.java---
package qj.util;
import qj.util.funct.F1;
import java.util.ArrayList;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
public class RegexUtil {
    public static F1<Object,Pattern> compileF = new F1<Object, Pattern>() {
        public Pattern e(Object obj) {
            return Pattern.compile(obj.toString());
        }
    };
	public static boolean matches(String key, String ptn) {
		return compileF.e(ptn).matcher(key).matches();		
	}
	public static Matcher matcher(String regex, String str) {
		return compileF.e(regex).matcher(str);
	}
	public static String replaceAll(String text,String ptn, F1<Matcher, String> f1) {
		return StringChange.apply(replaceAll(f1, compileF.e(ptn), text), text);
	}
	public static List<StringChange> replaceAll(
			F1<Matcher, String> f1, 
			Pattern ptn,
			String text) {
		return replaceAll(f1, ptn, text, 0, -1);
	}
	public static List<StringChange> replaceAll(
			F1<Matcher, String> f1, 
			Pattern ptn,
			String text,
			int from,
			int to) {
		Matcher matcher = ptn.matcher(text);
		ArrayList<StringChange> changes = new ArrayList<>();
		if (matcher.find(from)) {
			do {
				changes.add(StringChange.replace(matcher.start(), matcher.end(), f1.e(matcher)));
			} while (matcher.find() && (to==-1 || matcher.start() < to));
		}
		return changes;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\qj\util\StringChange.java---
package qj.util;
import qj.util.math.Range;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.LinkedList;
public abstract class StringChange implements Comparable<StringChange> {
	int priority = 0;
	public static StringChange replace(int start, int end, String replace) {
		return new ReplaceStringChange(start, end, replace);
	}
	public static StringChange replace(Range range, String replace) {
		return new ReplaceStringChange(range.getFrom(), range.getTo(), replace);
	}
	public abstract int pos();
	public abstract void apply(StringBuilder sb);
	public int compareTo(StringChange o) {
		int ret = pos() - o.pos();
		if (ret==0
		) {
			if (this instanceof ReplaceStringChange) {
				return 1;
			} else {
				return -this.priority + o.priority;
			}
		}
		return ret;
	}
	public static class ReplaceStringChange extends StringChange {
		private final int start;
		private final int end;
		private final String replace;
		public ReplaceStringChange(int start, int end, String replace) {
			this.start = start;
			this.end = end;
			this.replace = replace;
		}
		public int pos() {
			return start;
		}
		public void apply(StringBuilder sb) {
			sb.replace(start, end, replace);
		}
	}
	public static class InsertStringChange extends StringChange {
		private final int pos;
		private final String value;
		public InsertStringChange(int pos, String value) {
			this.pos = pos;
			this.value = value;
		}
		public InsertStringChange(int pos, String value, int priority) {
			this.pos = pos;
			this.value = value;
			this.priority = priority;
		}
		public int pos() {
			return pos;
		}
		public void apply(StringBuilder sb) {
			sb.insert(pos, value);
		}
	}
	/**
	 * @param replaces
	 * @param text No need to sort first
	 * @return
	 */
	public static String apply(Collection<StringChange> replaces, String text) {
		ArrayList<StringChange> list = new ArrayList<StringChange>(replaces);
		Collections.sort(list);
		StringBuilder sb = new StringBuilder(text);
		for (int i = list.size() - 1; i > -1; i--) {
			StringChange change = list.get(i);
			change.apply(sb);
		}
		return sb.toString();
	}
	public static StringChange insert(String string, int pos, int priority) {
		return new InsertStringChange(pos, string, priority);
	}
	public static StringChange insert(String string, int pos) {
		return new InsertStringChange(pos, string);
	}
	public static StringChange delete(final Range selection) {
		return new StringChange() {
			public int pos() {
				return selection.getFrom();
			}
			@Override
			public void apply(StringBuilder sb) {
				sb.replace(selection.getFrom(), selection.getTo(), "");
			}
		};
	}
	public static LinkedList<StringChange> replaceAll(String replaceFrom, String replaceTo,
			String to) {
		LinkedList<StringChange> ret = new LinkedList<StringChange>();
		for (int indexOf=0; (indexOf = to.indexOf(replaceFrom, indexOf)) > -1;) {
			ret.add(replace(indexOf, indexOf + replaceFrom.length(), replaceTo));
			indexOf+=replaceFrom.length();
		}
		return ret;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\qj\util\StringUtil.java---
package qj.util;
import qj.util.math.Range;
/**
 * Created by Quan on 22/12/2014.
 */
public class StringUtil {
	/**
	 * Trim the source and uppercase it's first character
	 *
	 * @param source -
	 *            The string to be malnipulated
	 * @return The result String, null if the source String is null
	 */
	public static String upperCaseFirstChar(String source) {
		if (source == null)
			return null;
		source = source.trim();
		if (source.length() == 0)
			return "";
		else
			return Character.toUpperCase(source.charAt(0)) + source.substring(1, source.length());
	}
	/**
	 *
	 * @return count
	 */
	public static int countHappens(char chr, CharSequence string) {
		if (string==null) {
			return 0;
		}
		int length = string.length();
		int count = 0;
		for (int i = 0; i < length; i++) {
			if (string.charAt(i) == chr)
				count++;
		}
		return count;
	}
	public static boolean isEmpty(String str) {
		return str == null || str.length() == 0;
	}
	public static String replace(String replace, Range range, String text) {
		return text.substring(0, range.getFrom()) + replace + text.substring(range.getTo());
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\qj\util\SystemUtil.java---
package qj.util;
import qj.util.funct.P0;
import qj.util.funct.P1;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
public class SystemUtil {
	static BufferedReader br;
	public static String readLine() {
		if (br==null) {
			br = new BufferedReader(new InputStreamReader(System.in));
		}
		try {
			return br.readLine();
		} catch (IOException e) {
			throw new RuntimeException(e);
		}
	}
	public static void onReturn(final P1<String> p1) {
		ThreadUtil.runStrong(new P0() {
			public void e() {
				while (true) {
					try {
						String readLine = readLine();
						p1.e(readLine);
					} catch (Exception e1) {
						return;
					}
				}
			}
		});
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\qj\util\ThreadUtil.java---
package qj.util;
import qj.util.funct.F0;
import qj.util.funct.Fs;
import qj.util.funct.P0;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
public class ThreadUtil {
	private static final ExecutorService executorService = Executors.newCachedThreadPool();
	public static void runStrong(final P0 p0) {
		executorService.execute(Fs.runnable(p0));
	}
	public static <A> ThreadLocalCache<A> threadLocalCache(final F0<A> f) {
		final ThreadLocal<A> threadLocal = new ThreadLocal<A>();
		ThreadLocalCache<A> ret = new ThreadLocalCache<A>();
		ret.cacheF = new F0<A>() {public A e() {
			A a = threadLocal.get();
			if (a==null) {
				a = f.e();
				threadLocal.set(a);
			}
			return a;
		}};
		ret.removeF = new F0<A>() {public A e() {
			A a = threadLocal.get();
			threadLocal.set(null);
			return a;
		}};
		return ret;
	}
	public static class ThreadLocalCache <A> {
		public F0<A> cacheF;
		public F0<A> removeF;
	}
	/**
	 * Sleep and wake on InterruptedException
	 * @param timeToSleep in milliseconds
	 */
	public static void sleep(long timeToSleep) {
		if (timeToSleep <=0)
			return;
		try {
			Thread.sleep(timeToSleep);
		} catch (InterruptedException e) {
		}
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\ui\ActivatedHyperlinkListener.java---
package ui;
import codegen.eclipseRobot.DataModel;
import javax.swing.*;
import javax.swing.event.HyperlinkEvent;
import javax.swing.event.HyperlinkListener;
import java.net.URL;
public class ActivatedHyperlinkListener implements HyperlinkListener {
	HtmlEditorPane editorPane;
	DataModel model;
	public ActivatedHyperlinkListener(DataModel model, HtmlEditorPane editorPane) {
		this.model = model;
		this.editorPane = editorPane;
	}
	public void hyperlinkUpdate(HyperlinkEvent hyperlinkEvent) {
		HyperlinkEvent.EventType type = hyperlinkEvent.getEventType();
		final URL url = hyperlinkEvent.getURL();
		if (type == HyperlinkEvent.EventType.ENTERED) {
			System.out.println("URL: " + url);
		} else if (type == HyperlinkEvent.EventType.ACTIVATED) {
			System.out.println("Activated");
			if (url.toString().endsWith("action=clear")) {
				Runnable runner = new Runnable() {
					public void run() {
						editorPane.loadWithSetPage();
					}
				};
				SwingUtilities.invokeLater(runner);
			}
			if (url.toString().endsWith("action=reload")) {
				model.setEventObject(hyperlinkEvent);
			}
		}
	}
	public DataModel getModel() {
		return model;
	}
	public void setModel(DataModel model) {
		this.model = model;
	}
	public HtmlEditorPane getEditorPane() {
		return editorPane;
	}
	public void setEditorPane(HtmlEditorPane editorPane) {
		this.editorPane = editorPane;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\ui\ArraySupportClassCombBoxpane.java---
package ui;
import javax.swing.*;
import java.awt.*;
import java.util.List;
public class ArraySupportClassCombBoxpane extends ParamPane {
	ClassCombBox classCombBox;
	public ArraySupportClassCombBoxpane(List<String> strList) {
		super();
		this.classCombBox = new ClassCombBox((List)strList);
		FlowLayout fl = new FlowLayout(FlowLayout.LEFT);
		this.setLayout(fl);
		this.add(paramLabel);
		this.add(tipLabel);
		this.add(classCombBox);
	}
	@Override
	public JComponent getInputComponent() {
		return classCombBox;
	}
	public ClassCombBox getClassCombBox() {
		return classCombBox;
	}
	public void cleanModelData() {
		classCombBox.cleanModelData();
		super.cleanModelData();
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\ui\ArraySupportReturnTypeCombBoxPane.java---
package ui;
import javax.swing.*;
import java.awt.*;
public class ArraySupportReturnTypeCombBoxPane extends ParamPane {
	ReturnTypeCombBox classCombBox;
	public ArraySupportReturnTypeCombBoxPane() {
		super();
		this.classCombBox = new ReturnTypeCombBox();
		FlowLayout fl = new FlowLayout(FlowLayout.LEFT);
		this.setLayout(fl);
		this.add(paramLabel);
		this.add(tipLabel);
		this.add(classCombBox);
	}
	@Override
	public JComponent getInputComponent() {
		return classCombBox;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\ui\CheckBoxPane.java---
package ui;
import javax.swing.*;
public class CheckBoxPane extends ParamPane {
	public JCheckBox checkBox;
	public CheckBoxPane() {
		checkBox = new JCheckBox();
		this.addComponent(paramLabel);
		this.addComponent(tipLabel);
		this.addComponent(checkBox);
	}
	public JCheckBox getCheckBox() {
		return checkBox;
	}
	public void setCheckBox(JCheckBox checkBox) {
		this.checkBox = checkBox;
	}
	@Override
	public JComponent getInputComponent() {
		return checkBox;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\ui\ClassCombBox.java---
package ui;
import codegen.eclipseRobot.FilterCombBox;
import java.util.List;
public class ClassCombBox extends FilterCombBox {
	public ClassCombBox(List<Object> classNameList) {
		super(classNameList);
	}
	public void cleanModelData() {
		super.cleanModelData();
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\ui\ClassCombBoxpane.java---
package ui;
import javax.swing.*;
import java.util.List;
public class ClassCombBoxpane extends ParamPane {
	ClassCombBox classCombBox;
	public ClassCombBoxpane(List<Object> strList) {
		super();
		this.classCombBox = new ClassCombBox(strList);
		this.addComponent(paramLabel);
		this.addComponent(tipLabel);
		this.addComponent(classCombBox);
	}
	@Override
	public JComponent getInputComponent() {
		return classCombBox;
	}
	public static void main(String args[]) {
		Class<JComponent>[] cs = new Class[] { ClassCombBox.class };
		Class c = cs.getClass();
		boolean b = c.isArray();
		System.out.println(String.format("c", c.getCanonicalName()));
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\ui\CollectionOfStringPane.java---
package ui;
import javax.swing.*;
import java.util.List;
public class CollectionOfStringPane  extends ParamPane{
	private static final long serialVersionUID = -5719340230240065218L;
	private JList<String> jList;
	private DefaultListModel<String> listModel;
	public CollectionOfStringPane(List<String> list) {
		listModel = new DefaultListModel<>();
		jList = new JList<>(listModel);
	}
	@Override
	public JComponent getInputComponent() {
		return jList;
	}
	public void addItem(int index, String item) {
		listModel.add(index, item);
	}
	public void addItem(String item) {
		listModel.addElement(item);
	}
	public void removeItem(String item) {
		listModel.removeElement(item);
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\ui\ColNamePickerPane.java---
package ui;
import codegen.eclipseRobot.FilterCombBox;
import java.util.Map;
public class ColNamePickerPane extends MapTextFieldPane {
	private static final long serialVersionUID = -7511088985813056672L;
	FilterCombBox tableNameCombBox;
	public ColNamePickerPane(Map<String, String> map) {
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\ui\CombBoxPane.java---
package ui;
import javax.swing.*;
public class CombBoxPane extends ParamPane {
	public JComboBox combBox;
	public CombBoxPane() {
		init();
	}
	public void init() {
		combBox = new JComboBox();
		this.addComponent(paramLabel);
		this.addComponent(tipLabel);
		this.addComponent(combBox);
	}
	public JComboBox getCombBox() {
		return combBox;
	}
	public void setCombBox(JComboBox combBox) {
		this.combBox = combBox;
	}
	@Override
	public JComponent getInputComponent() {
		return combBox;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\ui\CustomComboBoxEditor.java---
package ui;
import ui.model.CustomCombboxItem;
import javax.swing.plaf.basic.BasicComboBoxEditor;
import java.util.Objects;
public class CustomComboBoxEditor extends BasicComboBoxEditor {
	@Override
	public void setItem(Object anObject) {
		super.setItem(anObject);
		if (anObject instanceof CustomCombboxItem) {
			CustomCombboxItem item = (CustomCombboxItem) anObject;
			editor.setText(item.getItemText());
		} else if(!Objects.isNull(anObject)){
		    editor.setText(anObject.toString());
		}
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\ui\DefaultParamConverter.java---
package ui;
import codegen.complexobj.CodeGenContext;
import codegen.eclipseRobot.Converter;
import codegen.eclipseRobot.DataModel;
import codegen.eclipseRobot.FilterCombBox;
import ui.validation.ValidatablePane;
import ui.validation.ViolationResultItem;
import javax.swing.*;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.List;
public class DefaultParamConverter {
	public void convert(DataModel model, ParamPane[] pps, JComponent paramComps[]) {
		Method m = model.getSelectedMethod();
		System.out.println("gonna exec method " + m.getName());
		List<Object> list = new ArrayList<>();
		Class mp[] = m.getParameterTypes();
		boolean isValidInput = true;
		for (int i = 0; i < pps.length; i++) {
			ParamPane pp = pps[i];
			if (pp instanceof ValidatablePane) {
				ValidatablePane ppv = (ValidatablePane) pp;
				ViolationResultItem ri = ppv.validateVal();
				if (ri != null) {
					ppv.markInvaidInput();
					isValidInput = ri.isPass();
					break;
				}
			}
		}
		if (isValidInput) {
			for (int i = 0; i < paramComps.length; i++) {
				if (mp[i] != CodeGenContext.class) {
					if (paramComps[i] instanceof JCheckBox) {
						JCheckBox tf = (JCheckBox) paramComps[i];
						list.add(tf.isSelected());
					} else {
						if (paramComps[i] instanceof JTextField) {
							JTextField tf = (JTextField) paramComps[i];
							try {
								list.add(Converter.convert(tf.getText().trim(), mp[i]));
							} catch (Exception e1) {
								e1.printStackTrace();
							}
						} else if (paramComps[i] instanceof JTextArea) {
							JTextArea ta = (JTextArea) paramComps[i];
							try {
								list.add(Converter.convert(ta.getText().trim(), mp[i], "\n"));
							} catch (Exception e1) {
								e1.printStackTrace();
							}
						} else if (paramComps[i] instanceof ModifierPanel) {
							ModifierPanel modifierPanel = (ModifierPanel) paramComps[i];
							try {
								list.add(Converter.convert(modifierPanel.getVal(), mp[i], "\n"));
							} catch (Exception e1) {
								e1.printStackTrace();
							}
						} else if (paramComps[i] instanceof FilterCombBox) {
							FilterCombBox fc = (FilterCombBox) paramComps[i];
							try {
								list.add(Converter.convert(fc.getSelectedItem().toString(), mp[i]));
							} catch (Exception e1) {
								e1.printStackTrace();
							}
						}
					}
				} else {
					JTextField tf = (JTextField) paramComps[i];
					CodeGenContext context = null;
					try {
						context = (CodeGenContext) Converter.convert(tf.getText().trim(), mp[i]);
					} catch (Exception e1) {
						e1.printStackTrace();
					}
					if (context == null)
						list.add(model.getContext());
					else
						list.add(context);
				}
			}
			model.setParams(list.toArray(new Object[] {}));
		}
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\ui\FilePane.java---
package ui;
import javax.swing.*;
import java.io.File;
public class FilePane extends ParamPane {
	private JTextField textField;
	private JButton jButton = new JButton("browse");
	boolean chooseDirOnly = false;
	public FilePane() {
		init(-1, false);
	}
	public FilePane(int fieldSize) {
		init(fieldSize, false);
	}
	public FilePane(int fieldSize, boolean chooseDirOnly) {
		init(fieldSize, chooseDirOnly);
	}
	public void init(int fieldSize, boolean chooseDirOnly) {
		if (fieldSize == -1) {
			textField = new JTextField();
		} else {
			textField = new JTextField(fieldSize);
		}
		this.chooseDirOnly = chooseDirOnly;
		this.addComponent(paramLabel);
		this.addComponent(tipLabel);
		this.addComponent(textField);
		this.jButton.addActionListener(l -> {
			JFileChooser jFileChooser = new JFileChooser("./");
			if (chooseDirOnly) {
				jFileChooser.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);
			}
			this.addComponent(jFileChooser);
			int val = jFileChooser.showOpenDialog(jFileChooser);
			if (val == JFileChooser.APPROVE_OPTION) {
				File file = jFileChooser.getSelectedFile();
				String s = file.getAbsolutePath();
				textField.setText(s);
			}
			if (val == JFileChooser.CANCEL_OPTION) {
			}
		});
		this.addComponent(jButton);
	}
	@Override
	public JComponent getInputComponent() {
		return this.textField;
	}
	public JTextField getTextField() {
		return textField;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\ui\FilterCombBoxPane.java---
package ui;
import codegen.eclipseRobot.FilterCombBox;
import javax.swing.*;
import java.util.ArrayList;
import java.util.List;
public class FilterCombBoxPane extends ParamPane {
	FilterCombBox filterCombBox;
	public FilterCombBoxPane() {
		super();
		List<String> list = new ArrayList<>();
		this.filterCombBox = new FilterCombBox((List)list);
		this.addComponent(paramLabel);
		this.addComponent(tipLabel);
		this.addComponent(filterCombBox);
	}
	public FilterCombBoxPane(List<String> strList) {
		super();
		this.filterCombBox = new FilterCombBox((List)strList);
		this.addComponent(paramLabel);
		this.addComponent(tipLabel);
		this.addComponent(filterCombBox);
	}
	@Override
	public JComponent getInputComponent() {
		return filterCombBox;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\ui\GenAnnotationPane.java---
package ui;
import codegen.complexobj.CodeGenContext;
import javax.swing.*;
import java.util.List;
public class GenAnnotationPane extends TablePane {
	private ClassCombBox classCombBox;
	private TablePane tablePane;
	private JButton jButton;
	public GenAnnotationPane() {
		initView(CodeGenContext.getInstance().getLoadedClassesName());
		this.showData();
	}
	void initView(List<String> list) {
		classCombBox = new ClassCombBox((List)list);
		jButton = new JButton("gen annotation");
		tablePane = new TablePane();
		this.addComponent(new JLabel("Annotation"), classCombBox);
		this.newRow();
		this.addComponent(tablePane);
		this.newRow();
		this.addComponent(jButton);
		this.showData();
	}
	public GenAnnotationPane(int defaultHAlign, int defaultVAlign) {
		super(defaultHAlign, defaultVAlign);
	}
	public ClassCombBox getClassCombBox() {
		return classCombBox;
	}
	public JButton getjButton() {
		return jButton;
	}
	public TablePane getTablePane() {
		return tablePane;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\ui\GenCodePane.java---
package ui;
import codegen.complexobj.CodeGenContext;
import codegen.eclipseRobot.FilterCombBox;
import javax.swing.*;
import java.util.ArrayList;
import java.util.List;
public class GenCodePane extends TablePane{
	private ClassCombBox classCombBox;
	private FilterCombBox methodCombBox;
	private JButton gen;
	private JTextArea codeLine;
	private JCheckBox initClzByConstructor;
	private JCheckBox omitReturn;
	private JCheckBox arroundTryCatch;
	private JButton dump;
	public GenCodePane() {
		initView(CodeGenContext.getInstance().getLoadedClassesName());
		this.showData();
	}
	void initView(List<String> list) {
		classCombBox = new ClassCombBox((List)list);
		methodCombBox = new FilterCombBox(new ArrayList<>());
		gen = new JButton("gen code");
		codeLine = new JTextArea(10, 35);
		initClzByConstructor = new JCheckBox();
		omitReturn = new JCheckBox();
		arroundTryCatch = new JCheckBox();
		dump = new JButton("dump to IDE");
		JScrollPane jScrollPane = new JScrollPane(codeLine, ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS,
				ScrollPaneConstants.HORIZONTAL_SCROLLBAR_AS_NEEDED);
		this.addComponent(new JLabel("Class"), classCombBox);
		this.newRow();
		this.addComponent(new JLabel("Method"), methodCombBox);
		this.newRow();
		this.newRow();
		this.addComponent(new JLabel("omit return"), omitReturn);
		this.newRow();
		this.newRow();
		this.addComponent(gen);
		this.newRow();
		this.addComponent(jScrollPane);
		this.newRow();
		this.addComponent(dump);
	}
	public ClassCombBox getClassCombBox() {
		return classCombBox;
	}
	public JCheckBox getInitClzByConstructor() {
		return initClzByConstructor;
	}
	public JCheckBox getOmitReturn() {
		return omitReturn;
	}
	public JCheckBox getArroundTryCatch() {
		return arroundTryCatch;
	}
	public FilterCombBox getMethodCombBox() {
		return methodCombBox;
	}
	public JButton getGen() {
		return gen;
	}
	public JTextArea getCodeLine() {
		return codeLine;
	}
	public JButton getDump() {
		return dump;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\ui\HtmlEditorPane.java---
package ui;
import codegen.eclipseRobot.DataModel;
import javax.swing.*;
import javax.swing.event.HyperlinkListener;
import javax.swing.text.BadLocationException;
import javax.swing.text.ChangedCharSetException;
import javax.swing.text.Document;
import javax.swing.text.Element;
import javax.swing.text.html.HTMLDocument;
import javax.swing.text.html.HTMLEditorKit;
import java.io.*;
import java.nio.charset.Charset;
import java.util.Iterator;
import java.util.Set;
import java.util.SortedMap;
public class HtmlEditorPane extends JEditorPane {
	private HTMLEditorKit kit;
	private HyperlinkListener hyperlinkListener;
	public HtmlEditorPane(DataModel model) {
		kit = new HTMLEditorKit();
		this.setEditable(false);
		this.setEditorKit(kit);
		loadWithSetPage();
	}
	public void addRow(String s) {
		HTMLDocument doc = (HTMLDocument) this.getDocument();
		Element e = doc.getElement("trstart");
		try {
			doc.insertAfterEnd(e, String.format("<tr><td>%s</td></tr>", s));
		} catch (BadLocationException | IOException e1) {
			e1.printStackTrace();
		}
		return;
	}
	public static String readAsStr(File f) throws IOException {
		FileInputStream is = new FileInputStream(f);
		StringBuilder sb = new StringBuilder();
		BufferedReader in = null;
		try {
			in = new BufferedReader(new InputStreamReader(is));
			String line = null;
			while ((line = in.readLine()) != null) {
				sb.append(line).append("\r\n");
			}
		} catch (IOException e) {
			e.printStackTrace();
			throw e;
		} finally {
			if (in != null)
				try {
					in.close();
				} catch (IOException e) {
					e.printStackTrace();
				}
		}
		return sb.toString();
	}
	public static void write(File f, String fileStr) throws IOException {
		FileOutputStream fos = new FileOutputStream(f);
		fos.write(fileStr.getBytes());
		fos.flush();
		fos.close();
	}
	/**
	 * works okay with the meta tag in the html file only if the trailing/closing
	 * slash is absent ie, this '...>' instead of this '... />' // edit
	 */
	public void loadWithSetPage() {
		try {
			Document doc = this.getDocument();
			doc.putProperty(Document.StreamDescriptionProperty, null);
			this.setPage(getClass().getClassLoader().getResource("tableforpanel.html"));
		} catch (IOException ioe) {
			System.err.println("setPage read: " + ioe.getMessage());
		}
	}
	private void loadWithReader() {
		Object o = read(); // okay without meta statement
		if (o instanceof Charset) // we get here if file has a meta statement
		{
			String name = ((Charset) o).name();
			read((Charset) o); // cannot get this to work
		} else
			System.out.println("o = " + o.toString());
	}
	private Object read() {
		Reader fin = null;
		try {
			fin = // new BufferedReader(
					new InputStreamReader(new FileInputStream("eptest.html"));
		} catch (FileNotFoundException fnfe) {
			System.err.println("file not found: " + fnfe.getMessage());
			return Boolean.FALSE;
		}
		try {
			System.out.println(((InputStreamReader) fin).getEncoding());
			HTMLDocument doc = (HTMLDocument) this.getDocument();
			kit.read(fin, doc, 0);
			return Boolean.TRUE;
		} catch (ChangedCharSetException ccse) {
			String s = ccse.getCharSetSpec();
			System.out.println("changed charSet " + s);
			Charset cs = Charset.forName(s.substring(s.indexOf("charset=") + 8));
			System.out.println("cs = " + cs.toString());
			return cs;
		} catch (BadLocationException ble) {
			System.err.println("location: " + ble.getMessage());
			return Boolean.FALSE;
		} catch (IOException ioe) {
			System.err.println("read: " + ioe.getMessage());
			return Boolean.FALSE;
		}
		finally {
			try {
				fin.close();
			} catch (IOException ioe) {
				System.err.println("close: " + ioe.getMessage());
				return Boolean.FALSE;
			}
		}
	}
	/**
	 * all three InputStreamReader constructor forms fail if html file contains a
	 * meta statement for content/charset otherwise they seem to work okay
	 */
	private void read(Charset cs) {
		Reader fin = null;
		try {
			fin = new BufferedReader(new InputStreamReader(new FileInputStream("eptest.html"), cs));
		} catch (FileNotFoundException fnfe) {
			System.err.println("file not found: " + fnfe.getMessage());
		}
		try {
			HTMLDocument doc = (HTMLDocument) this.getDocument();
			kit.read(fin, doc, 0);
		} catch (BadLocationException ble) {
			System.err.println("location: " + ble.getMessage());
		} catch (IOException ioe) {
			System.err.println("read: " + ioe.getMessage());
		} finally {
			try {
				fin.close();
			} catch (IOException ioe) {
				System.err.println("close: " + ioe.getMessage());
			}
		}
	}
	private void showAvailableCharsets() {
		SortedMap<String, Charset> map = Charset.availableCharsets();
		Set<String> keys = map.keySet();
		Iterator it = keys.iterator();
		while (it.hasNext())
			System.out.println((Charset) map.get((String) it.next()));
	}
	public HTMLEditorKit getKit() {
		return kit;
	}
	public void setKit(HTMLEditorKit kit) {
		this.kit = kit;
	}
	public HyperlinkListener getHyperlinkListener() {
		return hyperlinkListener;
	}
	public void setHyperlinkListener(HyperlinkListener hyperlinkListener) {
		this.hyperlinkListener = hyperlinkListener;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\ui\HtmlEditorPane2.java---
package ui;
import codegen.eclipseRobot.DataModel;
import javax.swing.*;
import javax.swing.event.HyperlinkListener;
import javax.swing.text.BadLocationException;
import javax.swing.text.ChangedCharSetException;
import javax.swing.text.Document;
import javax.swing.text.Element;
import javax.swing.text.html.HTMLDocument;
import javax.swing.text.html.HTMLEditorKit;
import java.io.*;
import java.nio.charset.Charset;
import java.util.Iterator;
import java.util.Set;
import java.util.SortedMap;
public class HtmlEditorPane2 extends JEditorPane {
	private HTMLEditorKit kit;
	private HyperlinkListener hyperlinkListener;
	public HtmlEditorPane2(DataModel model) {
		kit = new HTMLEditorKit();
		this.setEditable(false);
		this.addHyperlinkListener(hyperlinkListener);
		this.setEditorKit(kit);
		loadWithSetPage();
	}
	public void addRow(String s) {
		HTMLDocument doc = (HTMLDocument) this.getDocument();
		Element e = doc.getElement("trstart");
		try {
			doc.insertAfterEnd(e, String.format("<tr><td>%s</td></tr>", s));
		} catch (BadLocationException | IOException e1) {
			e1.printStackTrace();
		}
		return;
	}
	public static String readAsStr(File f) throws IOException {
		FileInputStream is = new FileInputStream(f);
		StringBuilder sb = new StringBuilder();
		BufferedReader in = null;
		try {
			in = new BufferedReader(new InputStreamReader(is));
			String line = null;
			while ((line = in.readLine()) != null) {
				sb.append(line).append("\r\n");
			}
		} catch (IOException e) {
			e.printStackTrace();
			throw e;
		} finally {
			if (in != null)
				try {
					in.close();
				} catch (IOException e) {
					e.printStackTrace();
				}
		}
		return sb.toString();
	}
	public static void write(File f, String fileStr) throws IOException {
		FileOutputStream fos = new FileOutputStream(f);
		fos.write(fileStr.getBytes());
		fos.flush();
		fos.close();
	}
	/**
	 * works okay with the meta tag in the html file only if the trailing/closing
	 * slash is absent ie, this '...>' instead of this '... />' // edit
	 */
	public void loadWithSetPage() {
		try {
			Document doc = this.getDocument();
			doc.putProperty(Document.StreamDescriptionProperty, null);
			this.setPage(getClass().getClassLoader().getResource("tableforpanel.html"));
		} catch (IOException ioe) {
			System.err.println("setPage read: " + ioe.getMessage());
		}
	}
	private void loadWithReader() {
		Object o = read(); // okay without meta statement
		if (o instanceof Charset) // we get here if file has a meta statement
		{
			String name = ((Charset) o).name();
			read((Charset) o); // cannot get this to work
		} else
			System.out.println("o = " + o.toString());
	}
	private Object read() {
		Reader fin = null;
		try {
			fin = // new BufferedReader(
					new InputStreamReader(new FileInputStream("eptest.html"));
		} catch (FileNotFoundException fnfe) {
			System.err.println("file not found: " + fnfe.getMessage());
			return Boolean.FALSE;
		}
		try {
			System.out.println(((InputStreamReader) fin).getEncoding());
			HTMLDocument doc = (HTMLDocument) this.getDocument();
			kit.read(fin, doc, 0);
			return Boolean.TRUE;
		} catch (ChangedCharSetException ccse) {
			String s = ccse.getCharSetSpec();
			System.out.println("changed charSet " + s);
			Charset cs = Charset.forName(s.substring(s.indexOf("charset=") + 8));
			System.out.println("cs = " + cs.toString());
			return cs;
		} catch (BadLocationException ble) {
			System.err.println("location: " + ble.getMessage());
			return Boolean.FALSE;
		} catch (IOException ioe) {
			System.err.println("read: " + ioe.getMessage());
			return Boolean.FALSE;
		}
		finally {
			try {
				fin.close();
			} catch (IOException ioe) {
				System.err.println("close: " + ioe.getMessage());
				return Boolean.FALSE;
			}
		}
	}
	/**
	 * all three InputStreamReader constructor forms fail if html file contains a
	 * meta statement for content/charset otherwise they seem to work okay
	 */
	private void read(Charset cs) {
		Reader fin = null;
		try {
			fin = new BufferedReader(new InputStreamReader(new FileInputStream("eptest.html"), cs));
		} catch (FileNotFoundException fnfe) {
			System.err.println("file not found: " + fnfe.getMessage());
		}
		try {
			HTMLDocument doc = (HTMLDocument) this.getDocument();
			kit.read(fin, doc, 0);
		} catch (BadLocationException ble) {
			System.err.println("location: " + ble.getMessage());
		} catch (IOException ioe) {
			System.err.println("read: " + ioe.getMessage());
		} finally {
			try {
				fin.close();
			} catch (IOException ioe) {
				System.err.println("close: " + ioe.getMessage());
			}
		}
	}
	private void showAvailableCharsets() {
		SortedMap<String, Charset> map = Charset.availableCharsets();
		Set<String> keys = map.keySet();
		Iterator it = keys.iterator();
		while (it.hasNext())
			System.out.println((Charset) map.get((String) it.next()));
	}
	public HTMLEditorKit getKit() {
		return kit;
	}
	public void setKit(HTMLEditorKit kit) {
		this.kit = kit;
	}
	public HyperlinkListener getHyperlinkListener() {
		return hyperlinkListener;
	}
	public void setHyperlinkListener(HyperlinkListener hyperlinkListener) {
		this.hyperlinkListener = hyperlinkListener;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\ui\IParamPane.java---
package ui;
import javax.swing.*;
public interface IParamPane {
	public JComponent getInputComponent();
	public JLabel getParamLabel() ;
	public JLabel getTipLabel() ;
}
----strat of file D:\projects\cg\cg-min\src\main\java\ui\MapStringPane.java---
package ui;
import javax.swing.*;
import java.util.Map;
import java.util.Map.Entry;
public class MapStringPane extends ParamPane {
	private static final long serialVersionUID = 1577312452259818734L;
	private JList<String> jList;
	private DefaultListModel<String> listModel;
	public MapStringPane(Map<String, String> map) {
		listModel = new DefaultListModel<>();
		for(Entry<String, String> en : map.entrySet()){
			listModel.addElement(getKVPair(en.getKey(), en.getValue()));
		}
		jList = new JList<>(listModel);
	}
	private String getKVPair( String key, String value) {
		String kvPairStr =String.format("%s=%s",key,value);
		return kvPairStr;
	}
	@Override
	public JComponent getInputComponent() {
		return jList;
	}
	public void addItem(int index, String key, String value) {
		listModel.add(index, getKVPair(key, value));
	}
	public void addItem( String key, String value) {
		listModel.addElement(getKVPair(key, value));
	}
	public void removeItem( String key, String value) {
		listModel.removeElement(getKVPair(key, value));
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\ui\MapTextFieldPane.java---
package ui;
import javax.swing.*;
public class MapTextFieldPane extends ParamPane {
	private JTextField keyField;
	private JTextField valueField;
	private JButton addBtn;
	public MapTextFieldPane() {
	}
	@Override
	public JComponent getInputComponent() {
		return null;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\ui\MemoryPane.java---
package ui;
import codegen.Const;
import codegen.complexobj.CodeGenContext;
import codegen.eclipseRobot.DataModel;
import ui.model.CustomCombItemRenderer;
import ui.model.UIMemoryItemKey;
import javax.swing.*;
import java.util.ArrayList;
import java.util.List;
public class MemoryPane extends TablePane {
    private ClassCombBoxpane tableCombBoxPane;
	private ClassCombBoxpane keywordsCombBoxPane;
	private JButton dumpJButton;
	private JButton updateJButton;
	private JButton deleteJButton;
	private JTextField newKeyWords;
	private JTextArea contentArea;
	public MemoryPane() {
		super();
		DataModel model = (DataModel) CodeGenContext.getInstance().getUiModelMap().get(DataModel.class);
		initView(model);
	}
	@SuppressWarnings("unchecked")
	private void initView(DataModel model) {
	    List<String> tableNames = CodeGenContext.getMemoryAreas();
        tableCombBoxPane = new ClassCombBoxpane((List)tableNames);
        ClassCombBox tableCcb = (ClassCombBox) tableCombBoxPane.getInputComponent();
        tableCcb.setEditor(new CustomComboBoxEditor());
        tableCcb.addEditorListener();
        tableCombBoxPane.showData();
        this.addComponent(new JLabel("table"), tableCombBoxPane);
	    List<UIMemoryItemKey> keywordsList;
	    if(CodeGenContext.getInstance().getParamPossibleValsMap().containsKey(Const.MEMORY_KEYWORD_MAPPING_KEY)) {
	        keywordsList = (List<UIMemoryItemKey>) CodeGenContext.getInstance().getParamPossibleValsMap().get(Const.MEMORY_KEYWORD_MAPPING_KEY);
	    }else {
	        keywordsList = new ArrayList<>();
	    }
		keywordsCombBoxPane = new ClassCombBoxpane((List)keywordsList);
		ClassCombBox ccb = (ClassCombBox) keywordsCombBoxPane.getInputComponent();
		ccb.setRenderer(new CustomCombItemRenderer());
		ccb.setEditor(new CustomComboBoxEditor());
		ccb.addEditorListener();
		keywordsCombBoxPane.showData();
		contentArea = new JTextArea(10, 25);
		JScrollPane jScrollPane = new JScrollPane(contentArea, ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS,
				ScrollPaneConstants.HORIZONTAL_SCROLLBAR_ALWAYS);
		newKeyWords = new JTextField(25);
		dumpJButton = new JButton("dump");
		updateJButton = new JButton("update");
		deleteJButton = new JButton("delete");
		this.addInNextRow(new JLabel("keywords"), keywordsCombBoxPane);
		this.addInNextRow(new JLabel("content"),jScrollPane);
		this.addInNextRow(new JLabel("new keywords"),newKeyWords);
		this.addInNextRow(dumpJButton, updateJButton, deleteJButton);
		this.showData();
	}
	public static void main(String[] args) {
	}
	public ClassCombBoxpane getKeywordsCombBoxPane() {
		return keywordsCombBoxPane;
	}
	public JButton getDumpJButton() {
		return dumpJButton;
	}
	public void setDumpJButton(JButton dumpJButton) {
		this.dumpJButton = dumpJButton;
	}
	public JButton getUpdateJButton() {
		return updateJButton;
	}
	public void setUpdateJButton(JButton updateJButton) {
		this.updateJButton = updateJButton;
	}
	public JButton getDeleteJButton() {
		return deleteJButton;
	}
	public void setDeleteJButton(JButton deleteJButton) {
		this.deleteJButton = deleteJButton;
	}
	public JTextArea getContentArea() {
		return contentArea;
	}
	public JTextField getNewKeyWords() {
		return newKeyWords;
	}
	public void setNewKeyWords(JTextField newKeyWords) {
		this.newKeyWords = newKeyWords;
	}
	public void setContentArea(JTextArea contentArea) {
		this.contentArea = contentArea;
	}
    public ClassCombBoxpane getTableCombBoxPane() {
        return tableCombBoxPane;
    }
}
----strat of file D:\projects\cg\cg-min\src\main\java\ui\MethodTypePane.java---
package ui;
import clipboardclient.IClipboardObserver;
import codegen.complexobj.CodeGenContext;
import codegen.eclipseRobot.DataModel;
import codegen.eclipseRobot.EclipseService;
import codegen.eclipseRobot.FilterCombBox;
import codegen.eclipseRobot.QualifierName;
import codegen.util.Common;
import com.dgs.annotation.FileChooserAnnotation;
import com.dgs.annotation.ParamAnno;
import com.dgs.annotation.UIAnno;
import ui.model.TextAreaPaneModel;
import ui.validation.*;
import javax.swing.*;
import javax.swing.event.DocumentEvent;
import javax.swing.event.DocumentListener;
import javax.swing.text.DefaultCaret;
import java.awt.*;
import java.awt.event.*;
import java.io.File;
import java.lang.annotation.Annotation;
import java.lang.reflect.Constructor;
import java.lang.reflect.Method;
import java.lang.reflect.Parameter;
import java.util.Arrays;
import java.util.Date;
import java.util.List;
public class MethodTypePane extends TablePane implements IClipboardObserver, SubmitBtnPane{
	JComponent paramComps[];
	ParamPane pps[];
	DataModel model;
	JComponent componentWhichSwitchProcess;
	private JButton okBtn;
	public MethodTypePane() {
		DataModel model = (DataModel) CodeGenContext.getInstance().getUiModelMap().get(DataModel.class);
		initView(model);
	}
	public void removeAllFocusListener(Component c) {
		FocusListener ls[] = c.getFocusListeners();
		for (FocusListener l : ls) {
			c.removeFocusListener(l);
		}
	}
	@Override
	public void onUpdate(String content) {
		QualifierName qn = model.extractQualifierName(content);
		if (qn == null || qn.getClassQualifierName() == null) {
			return;
		}
		Method m = model.getSelectedMethod();
		if (m != null) {
			SwingUtilities.invokeLater(new Runnable() {
				@Override
				public void run() {
					Class mp[] = m.getParameterTypes();
					int paramCount = m.getParameterCount();
					Parameter[] ps = m.getParameters();
					boolean isClzSwitchProcess = false;
					for (int i = 0; i < paramCount; i++) {
						boolean switchProcess = false;
						switchProcess = componentWhichSwitchProcess == paramComps[i];
						if (switchProcess && (mp[i] == Class.class || mp[i] == CodeGenContext.class)
								&& paramComps[i] instanceof JTextField) {
							JTextField jf = ((JTextField) paramComps[i]);
							if (jf.getText().trim().equals("")) {
								jf.setText(qn.getClassQualifierName());
								isClzSwitchProcess = true;
								removeAllFocusListener(jf);
							}
						} else if (switchProcess && (mp[i] == Class.class) && paramComps[i] instanceof FilterCombBox) {
							FilterCombBox jf = ((FilterCombBox) paramComps[i]);
							String addedItem = qn.getClassQualifierName();
							if (!jf.getArray().contains(addedItem))
								jf.addCustomItem(addedItem);
							ParamPane panel = (ParamPane) paramComps[i].getParent();
							if (panel.getClass().isAssignableFrom(ArraySupportClassCombBoxpane.class)
									|| panel.getClass().isAssignableFrom(ArraySupportReturnTypeCombBoxPane.class)) {
								String addedItemArray = qn.getClassQualifierName() + "[]";
								if (!jf.getArray().contains(addedItemArray)) {
									jf.addCustomItem(addedItemArray);
								}
							}
							jf.setSelectedItem(addedItem);
							isClzSwitchProcess = true;
						} else if (("fieldName".equalsIgnoreCase(ps[i].getName())
								|| "field".equalsIgnoreCase(ps[i].getName())) && paramComps[i] instanceof JTextField) {
							JTextField jf = ((JTextField) paramComps[i]);
							if (jf.getText().trim().equals("")) {
								jf.setText(qn.getFieldName());
							}
							if (isClzSwitchProcess && "".equals(jf.getText()) && qn.getClz() != null) {
								jf.setText(Common.getInstanceName(qn.getClz()));
							}
						} else if ("objName".equalsIgnoreCase(ps[i].getName())
								|| "instanceName".equalsIgnoreCase(ps[i].getName())
										&& paramComps[i] instanceof JTextField) {
							if (qn.getMethodName() != null) {
								JTextField jf = ((JTextField) paramComps[i]);
								if (jf.getText().trim().equals("")) {
									Method m = QualifierName.getMethodByQualifierName(qn);
									if (Common.isStatic(m)) {
										jf.setText(m.getDeclaringClass().getSimpleName());
									} else {
										jf.setText(Common.getInstanceName(m.getDeclaringClass()));
									}
								}
							}
						} else if ("methodName".equalsIgnoreCase(ps[i].getName())
								&& paramComps[i] instanceof JTextField) {
							JTextField jf = ((JTextField) paramComps[i]);
							if (jf.getText().trim().equals("")) {
								jf.setText(qn.getMethodName());
							}
						} else if (switchProcess && "params".equalsIgnoreCase(ps[i].getName())
								&& paramComps[i] instanceof JTextField) {
							JTextField jf = ((JTextField) paramComps[i]);
							StringBuilder sb = new StringBuilder(jf.getText());
							if (jf.getText().trim().equals("")) {
								if (jf.getText().trim().equals("")) {
									Method m = QualifierName.getMethodByQualifierName(qn);
									if (m != null) {
										Parameter pts[] = m.getParameters();
										for (Parameter p : pts) {
											sb.append(p.getName()).append(", ");
										}
										if (sb.length() > 0) {
											sb.delete(sb.length() - 2, sb.length());
										}
									}
								}
							}
							if (null != qn.getClassQualifierName() && !"".equals(qn.getClassQualifierName())) {
								if (sb.length() > 0) {
									sb.append(", ");
								}
								sb.append(qn.getClassQualifierName()).append(", ");
							}
							if (sb.length() > 0) {
								sb.delete(sb.length() - 2, sb.length());
							}
							jf.setText(sb.toString());
						} else if (switchProcess && Common.isClassArray(mp[i]) && paramComps[i] instanceof JTextField) {
							if (qn.getClassQualifierName() != null) {
								JTextField jf = ((JTextField) paramComps[i]);
								String text = jf.getText();
								if (!"".equals(text.trim()) && !text.contains(qn.getClassQualifierName())) {
									text = text + ", " + qn.getClassQualifierName();
								} else if ("".equals(text.trim())) {
									text = qn.getClassQualifierName();
								}
								jf.setText(text);
								removeAllFocusListener(jf);
							}
						}
					}
				}
			});
		}
	}
	private void initView(DataModel model) {
		if (model.getMethods() == null || model.getMethods().length == 0) {
			return;
		}
		Method m = model.getSelectedMethod();
		if (m != null) {
			Class mp[] = m.getParameterTypes();
			int paramCount = m.getParameterCount();
			paramComps = new JComponent[paramCount];
			pps = new ParamPane[paramCount];
			{
				for (int i = 0; i < paramCount; i++) {
					Parameter[] ps = m.getParameters();
					ParamPane pp = getParamPaneByParamType(mp[i], m, ps[i], model);
					JComponent jc = pp.getInputComponent();
					if (mp[i] == Class.class || "qualifierNames".equals(ps[i].getName()) || Common.isClassArray(mp[i])) {
						if (jc instanceof JTextArea) {
							((JTextArea) jc).getDocument().addDocumentListener(new DocumentListener() {
								private void validate() {
									if (pp instanceof ValidatablePane) {
										ValidatablePane vpp = (ValidatablePane) pp;
										ViolationResultItem vr = vpp.validateVal();
										if (vr.isPass()) {
											vpp.removeMark();
										} else {
											vpp.markInvaidInput();
										}
									}
								}
								@Override
								public void insertUpdate(DocumentEvent e) {
									validate();
								}
								@Override
								public void removeUpdate(DocumentEvent e) {
									validate();
								}
								@Override
								public void changedUpdate(DocumentEvent e) {
									validate();
								}
							});
						}
						jc.addFocusListener(new FocusAdapter() {
							public void focusLost(FocusEvent e) {
								if (pp instanceof ValidatablePane) {
									ValidatablePane vpp = (ValidatablePane) pp;
									ViolationResultItem vr = vpp.validateVal();
									if (vr.isPass()) {
										vpp.removeMark();
									} else {
										vpp.markInvaidInput();
									}
								}
							}
						});
					} else {
						jc.addFocusListener(new FocusAdapter() {
							public void focusLost(FocusEvent e) {
								if (pp instanceof ValidatablePane) {
									ValidatablePane vpp = (ValidatablePane) pp;
									ViolationResultItem vr = vpp.validateVal();
									if (vr.isPass()) {
										vpp.removeMark();
									} else {
										vpp.markInvaidInput();
									}
								}
							}
						});
						jc.addKeyListener(new KeyAdapter() {
							public void keyReleased(KeyEvent e) {
								if (e.getKeyChar() == KeyEvent.VK_ENTER
										&& !jc.getClass().isAssignableFrom(JTextArea.class)) {
									System.out.println("JTextArea enter trigger method call at " + new Date());
								} else {
									if (pp instanceof ValidatablePane) {
										ValidatablePane vpp = (ValidatablePane) pp;
										ViolationResultItem vr = vpp.validateVal();
										if (vr.isPass()) {
											vpp.removeMark();
										} else {
											vpp.markInvaidInput();
										}
									}
								}
							}
						});
					}
					paramComps[i] = jc;
					pps[i] = pp;
					this.newRow();
					pps[i].showData();
					this.addComponent(pps[i]);
				}
			}
		}
		okBtn = new JButton("ok");
		this.addInNextRow(okBtn);
	}
	public ParamPane getParamPaneByParamType(Class c, Method m, Parameter param, DataModel model2) {
		String paramName = param.getName();
		ParamPane jc = null;
		boolean isMandatory = false;
		Class c1 = EclipseService.class;
		Validation v = null;
		Method m1;
		try {
			m1 = m;
			Annotation panns1[] = param.getAnnotations();
			for (Annotation an : panns1) {
				try {
					if (an instanceof ValidationAnn) {
						ValidationAnn va = (ValidationAnn) an;
						Class[] vs = Common.getClassByName(va.validations());
						if (vs != null) {
							for (Class<? extends Validation> vc : vs) {
								if (vc.isAssignableFrom(MandatoryCheck.class)) {
									isMandatory = true;
									v = new MandatoryCheck();
								} else if (vc.isAssignableFrom(ModifierCheck.class)) {
									isMandatory = true;
									v = new ModifierCheck();
								}
							}
						}
					} else if (an instanceof UIAnno) {
						UIAnno uiAnno = (UIAnno) an;
						Class[] uiClzz = Common.getClassByName(uiAnno.uiClz());
						if(uiClzz.length>0) {
							Class uiClz = uiClzz[0];
							if(ParamPane.class.isAssignableFrom(uiClz)) {
								Constructor[] cts = uiClz.getConstructors();
								Constructor defaultCt = null;
								for(Constructor ct : cts) {
									if(ct.getParameterCount()==0) {
										defaultCt = ct;
										break;
									}else if(ct.getParameters().length==1){
									    jc= new ClassCombBoxpane(Arrays.asList(model2.getParamPossibleVals()));
									}
								}
								if(null!=defaultCt) {
									jc = (ParamPane) defaultCt.newInstance();
								}
							}
						}
					}
				} catch (Exception e) {
				}
			}
		} catch (Exception e1) {
		}
		if (Boolean.class == c || boolean.class == c) {
			jc = new CheckBoxPane();
		} else {
			int size = 8;
			if (Common.isClassArray(c)) {
				size = size * 4;
				jc = new ArraySupportClassCombBoxpane(CodeGenContext.getInstance().getLoadedClassesName());
			} else if (c.isArray() && paramName.equals("qualifierNames")) {
				size = size * 3;
				TextAreaPaneModel model = new TextAreaPaneModel();
				model.setRows(codegen.eclipseRobot.DataModel.DEFAULT_TEXTAREA_ROWS);
				model.setColumns(codegen.eclipseRobot.DataModel.DEFAULT_TEXTAREA_COLS);
				model.setHowManyRowsInTextArea(0);
				TextAreaPane ja = isMandatory ? new ValidatableTextAreaPane(v, model) : new TextAreaPane(model);
				jc = ja;
				DefaultCaret dc = (DefaultCaret) ja.getTextArea().getCaret();
				dc.setUpdatePolicy(DefaultCaret.NEVER_UPDATE);
			} else if (paramName.equals("modifier") && c == int.class) {
				jc = isMandatory ? new ValidatableModifierPanel(v) : new ModifierPanel();
			} else if (paramName.equals("content") && c == String.class) {
				int areaSize = 100;
				TextAreaPaneModel model = new TextAreaPaneModel();
				model.setRows(codegen.eclipseRobot.DataModel.DEFAULT_TEXTAREA_ROWS);
				model.setColumns(areaSize);
				model.setHowManyRowsInTextArea(0);
				TextAreaPane ja = isMandatory ? new ValidatableTextAreaPane(v, model) : new TextAreaPane(model);
				jc = ja;
			} else if (paramName.equals("keyword") && c == String.class
					&& ("showCodeSyntaxMemory".equalsIgnoreCase(m.getName())
					|| "showMiscAreaMemory".equalsIgnoreCase(m.getName())
					|| "showCommandMemory".equalsIgnoreCase(m.getName())
					|| "showConfigMemory".equalsIgnoreCase(m.getName()))) {
				ClassCombBoxpane ccp = new ClassCombBoxpane((List<Object>) model2.getParamPossibleVals()[0]);
				jc = ccp;
			} else if (c == File.class) {
				boolean chooseDirOnly = false;
				FileChooserAnnotation fca = Common.getParameterAnnotationByType(FileChooserAnnotation.class, param);
				if (fca != null) {
					chooseDirOnly = fca.chooseDirOnly();
				}
				jc = isMandatory ? new ValidatableFilePane(v, size, chooseDirOnly) : new FilePane(size, chooseDirOnly);
			} else if (c == Class.class) {
				ParamAnno fca = Common.getParameterAnnotationByType(ParamAnno.class, param);
				if (fca != null) {
					jc = new ClassCombBoxpane((List)CodeGenContext.getInstance().getLoadedClassesName());
				} else if (paramName.equalsIgnoreCase("returntype")) {
					jc = isMandatory ? new ValidatableArraySupportReturnTypeCombBoxPane()
							: new ArraySupportReturnTypeCombBoxPane();
				} else {
					jc = isMandatory
							? new ValidatableArraySupportClassCombBoxpane(
									CodeGenContext.getInstance().getLoadedClassesName())
							: new ArraySupportClassCombBoxpane(CodeGenContext.getInstance().getLoadedClassesName());
				}
				if (jc instanceof IParamPane) {
					IParamPane ipp = jc;
					FilterCombBox fc = (FilterCombBox) ipp.getInputComponent();
				}
			} else if(null==jc){
				jc = isMandatory ? new ValidatableTextFieldPane(v, size) : new TextFieldPane(size);
			}
		}
		if (isMandatory && jc instanceof ValidatablePane) {
			ValidatablePane vp = (ValidatablePane) jc;
			vp.markInvaidInput();
		}
		ParamAnno annotation = param.getAnnotation(ParamAnno.class);
		String labelText = annotation != null && !Common.isBlank(annotation.description()) ? annotation.description()
				: paramName;
		jc.getParamLabel().setText(labelText);
		jc.getTipLabel().setText("");
		jc.getInputComponent().setName(paramName);
		return jc;
	}
	public JComponent[] getParamComps() {
		return paramComps;
	}
	public void setParamComps(JComponent[] paramComps) {
		this.paramComps = paramComps;
	}
	public ParamPane[] getPps() {
		return pps;
	}
	public void setPps(ParamPane[] pps) {
		this.pps = pps;
	}
	public JComponent getComponentWhichSwitchProcess() {
		return componentWhichSwitchProcess;
	}
	public void setComponentWhichSwitchProcess(JComponent componentWhichSwitchProcess) {
		this.componentWhichSwitchProcess = componentWhichSwitchProcess;
	}
	@Override
	public JButton getSubmitBtn() {
		return okBtn;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\ui\model\ComponentAndLayoutConstraints.java---
package ui.model;
import javax.swing.*;
import java.awt.*;
public class ComponentAndLayoutConstraints {
	private GridBagConstraints gbc;
	private JComponent[] components;
	public GridBagConstraints getGbc() {
		return gbc;
	}
	public void setGbc(GridBagConstraints gbc) {
		this.gbc = gbc;
	}
	public JComponent[] getComponents() {
		return components;
	}
	public void setComponents(JComponent... components) {
		this.components = components;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\ui\model\CustomCombboxItem.java---
package ui.model;
public interface CustomCombboxItem {
	public String getItemText();
	public String toString();
}
----strat of file D:\projects\cg\cg-min\src\main\java\ui\model\CustomCombItemRenderer.java---
package ui.model;
import javax.swing.*;
import javax.swing.plaf.basic.BasicComboBoxRenderer;
import java.awt.*;
public class CustomCombItemRenderer extends BasicComboBoxRenderer {
	public Component getListCellRendererComponent(
            JList list, Object value, int index,
            boolean isSelected, boolean cellHasFocus)
        {
            super.getListCellRendererComponent(list, value, index,
                isSelected, cellHasFocus);
            if (value != null)
            {
            	CustomCombboxItem item = (CustomCombboxItem)value;
                setText( item.getItemText() );
            }
			if (index == -1) {
				CustomCombboxItem item = (CustomCombboxItem)value;
                setText( item.getItemText() );
			}
            return this;
        }
}
----strat of file D:\projects\cg\cg-min\src\main\java\ui\model\TextAreaPaneModel.java---
package ui.model;
public class TextAreaPaneModel {
	int rows;
	int columns;
	private int howManyRowsInTextArea;
	public int getRows() {
		return rows;
	}
	public void setRows(int rows) {
		this.rows = rows;
	}
	public int getColumns() {
		return columns;
	}
	public void setColumns(int columns) {
		this.columns = columns;
	}
	public int getHowManyRowsInTextArea() {
		return howManyRowsInTextArea;
	}
	public void setHowManyRowsInTextArea(int howManyRowsInTextArea) {
		this.howManyRowsInTextArea = howManyRowsInTextArea;
	}
	public int increasehowManyRowsInTextArea() {
		howManyRowsInTextArea++;
		return howManyRowsInTextArea;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\ui\model\UIMemoryItemKey.java---
package ui.model;
import codegen.eclipseRobot.model.MemoryItemKey;
public class UIMemoryItemKey extends MemoryItemKey  implements CustomCombboxItem{
	public UIMemoryItemKey(MemoryItemKey parentObj) {
		super();
		setId(parentObj.getId());
		setKeywords(parentObj.getKeywords());
		setTable(parentObj.getTable());
	}
	@Override
	public String getItemText() {
		return getKeywords();
	}
	@Override
	public String toString() {
		return getKeywords();
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\ui\ModifierPanel.java---
package ui;
import javax.swing.*;
import java.awt.*;
public class ModifierPanel extends ParamPane {
	private JCheckBox staticBox;
	private JCheckBox abstractBox;
	private JCheckBox finalBox;
	private JCheckBox volatileBox;
	private JCheckBox syncBox;
	private JRadioButton privateButton;
	private JRadioButton protectedButton;
	private JRadioButton publicButton;
	private ButtonGroup bg;
	public ModifierPanel() {
		staticBox = new JCheckBox("static");
		abstractBox = new JCheckBox("abstract");
		finalBox = new JCheckBox("final");
		volatileBox = new JCheckBox("volatile");
		syncBox = new JCheckBox("synchronized");
		privateButton = new JRadioButton("private");
		publicButton = new JRadioButton("public");
		protectedButton = new JRadioButton("protected");
		bg = new ButtonGroup();
		bg.add(privateButton);
		bg.add(publicButton);
		bg.add(protectedButton);
		this.addComponent(paramLabel, tipLabel);
		this.newRow();
		JPanel jp = newJPanelWithLeftFlowLayout();
		this.addComponent( publicButton);
		JPanel jp2 = newJPanelWithLeftFlowLayout();
		this.addComponent( protectedButton);
		this.addComponent( privateButton);
		this.newRow();
		this.addComponent( staticBox);
		this.addComponent( abstractBox);
		this.addComponent( finalBox);
		this.addComponent(volatileBox);
		this.addComponent( syncBox);
		this.newRow();
		this.showData();
	}
	public JPanel newJPanelWithLeftFlowLayout() {
		JPanel jp = new JPanel();
		FlowLayout fl = new FlowLayout(FlowLayout.LEFT);
		jp.setLayout(fl);
		return jp;
	}
	public int getModifier() {
		int m = 0;
		if (publicButton.isSelected()) {
			m = m | java.lang.reflect.Modifier.PUBLIC;
		}
		if (protectedButton.isSelected()) {
			m = m | java.lang.reflect.Modifier.PROTECTED;
		}
		if (privateButton.isSelected()) {
			m = m | java.lang.reflect.Modifier.PRIVATE;
		}
		if (staticBox.isSelected()) {
			m = m | java.lang.reflect.Modifier.STATIC;
		}
		if (abstractBox.isSelected()) {
			m = m | java.lang.reflect.Modifier.ABSTRACT;
		}
		if (finalBox.isSelected()) {
			m = m | java.lang.reflect.Modifier.FINAL;
		}
		if (volatileBox.isSelected()) {
			m = m | java.lang.reflect.Modifier.VOLATILE;
		}
		if (syncBox.isSelected()) {
			m = m | java.lang.reflect.Modifier.SYNCHRONIZED;
		}
		return m;
	}
	public int getVal() {
		return getModifier();
	}
	@Override
	public JComponent getInputComponent() {
		return this;
	}
	public static void main(String[] args) {
		/*
		 * int i = 1; BitSet bitSet = new BitSet(6); bitSet.set(0); int m =
		 * getModifier(); System.out.println(m);
		 * System.out.println(Modifier.isPrivate(m));
		 * System.out.println(Modifier.isProtected(m));
		 * System.out.println(Modifier.isPublic(m));
		 * System.out.println(Modifier.isAbstract(m));
		 * System.out.println(Modifier.isFinal(m));
		 * System.out.println(Modifier.isStatic(m));
		 * System.out.println(Modifier.isSynchronized(m));
		 * System.out.println(Modifier.isVolatile(m));
		 */
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\ui\ParamPane.java---
package ui;
import javax.swing.*;
public abstract class ParamPane extends TablePane implements IParamPane{
	public JLabel paramLabel;
	public JLabel tipLabel;
	public ParamPane() {
		init();
	}
	public void init() {
		paramLabel = new JLabel();
		tipLabel = new JLabel();
	}
	public JLabel getParamLabel() {
		return paramLabel;
	}
	public void setParamLabel(JLabel paramLabel) {
		this.paramLabel = paramLabel;
	}
	public JLabel getTipLabel() {
		return tipLabel;
	}
	public void setTipLabel(JLabel tipLabel) {
		this.tipLabel = tipLabel;
	}
	public void cleanModelData() {
		this.removeAll();
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\ui\ReturnTypeCombBox.java---
package ui;
import codegen.eclipseRobot.FilterCombBox;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Set;
public class ReturnTypeCombBox extends FilterCombBox {
	private static List<String> list = new ArrayList<>();
	static {
		List<Class<?>> clist = codegen.eclipseRobot.Const.returnTypePrimitiveClz;
		list.add(" ");
		list.add(codegen.Const.SPECIFY_CLASS);
		for (Class c : clist) {
			list.add(c.getCanonicalName());
			if (void.class != c) {
				list.add(c.getCanonicalName() + "[]");
			}
		}
		list.add(Map.class.getCanonicalName());
		list.add(Map.class.getCanonicalName() + "[]");
		list.add(List.class.getCanonicalName());
		list.add(List.class.getCanonicalName() + "[]");
		list.add(Set.class.getCanonicalName());
		list.add(Set.class.getCanonicalName() + "[]");
	}
	public ReturnTypeCombBox() {
		super((List)list);
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\ui\ReturnTypeCombBoxPane.java---
package ui;
import javax.swing.*;
public class ReturnTypeCombBoxPane extends ParamPane {
	ReturnTypeCombBox classCombBox;
	public ReturnTypeCombBoxPane() {
		super();
		this.classCombBox = new ReturnTypeCombBox();
		this.addComponent(paramLabel);
		this.addComponent(tipLabel);
		this.addComponent(classCombBox);
	}
	@Override
	public JComponent getInputComponent() {
		return classCombBox;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\ui\StringTypesPane.java---
package ui;
public class StringTypesPane extends TablePane {
}
----strat of file D:\projects\cg\cg-min\src\main\java\ui\SubmitBtnPane.java---
package ui;
import javax.swing.*;
public interface SubmitBtnPane {
	public JButton getSubmitBtn();
}
----strat of file D:\projects\cg\cg-min\src\main\java\ui\TablePane.java---
package ui;
import ui.model.ComponentAndLayoutConstraints;
import javax.swing.*;
import javax.swing.border.Border;
import java.awt.*;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
public class TablePane extends JPanel {
	private List<ComponentAndLayoutConstraints> componentAndLayoutConstraintsList = new ArrayList<>();
	public static final int ALIGN_LEFT = 0;
	public static final int ALIGN_CENTER = 1;
	public static final int ALIGN_RIGHT = 2;
	public static int DEFAULT_HORIZONTAL_ALIGN = ALIGN_CENTER;
	public static final int ALIGN_TOP = 0;
	public static final int ALIGN_MIDDLE = 1;
	public static final int ALIGN_BUTTOM = 2;
	public static int DEFAULT_VERTICAL_ALIGN = ALIGN_MIDDLE;
	private int currentGridX = 0;
	private int currentGridY = 0;
	public TablePane() {
		super();
		GridBagLayout gridBagLayout = new GridBagLayout();
		this.setLayout(gridBagLayout);
	}
	public TablePane(int defaultHAlign, int defaultVAlign) {
		super();
		setDefaultAlign(defaultHAlign, defaultVAlign);
		GridBagLayout gridBagLayout = new GridBagLayout();
		this.setLayout(gridBagLayout);
	}
	/**
	 * it doesn't affect the align of added cells align
	 * @param defaultHAlign
	 * @param defaultVAlign
	 */
	public void setDefaultAlign(int defaultHAlign, int defaultVAlign) {
		switch(defaultHAlign){
			case ALIGN_LEFT:
				DEFAULT_HORIZONTAL_ALIGN = ALIGN_LEFT;
			break;
			case  ALIGN_CENTER:
				DEFAULT_HORIZONTAL_ALIGN = ALIGN_CENTER;
			break;
			case ALIGN_RIGHT:
				DEFAULT_HORIZONTAL_ALIGN = ALIGN_RIGHT;
			break;
			default :
			break;
		}
		switch(defaultVAlign){
			case ALIGN_TOP:
				DEFAULT_VERTICAL_ALIGN = ALIGN_TOP;
			break;
			case  ALIGN_MIDDLE:
				DEFAULT_VERTICAL_ALIGN = ALIGN_MIDDLE;
			break;
			case  ALIGN_BUTTOM:
				DEFAULT_VERTICAL_ALIGN = ALIGN_BUTTOM;
			break;
			default :
			break;
		}
	}
	private void setDefaultAlign() {
		setAlign(DEFAULT_HORIZONTAL_ALIGN, DEFAULT_VERTICAL_ALIGN);
	}
	/***
	 * set last added ComponentAndLayoutConstraints's GridBagConstraints anchor
	 * @param halign
	 * @param valign
	 */
	private void setAlign(int halign, int valign) {
		if(componentAndLayoutConstraintsList.isEmpty()) {
			return;
		}
		ComponentAndLayoutConstraints calc = componentAndLayoutConstraintsList.get(componentAndLayoutConstraintsList.size()-1);
		switch(DEFAULT_HORIZONTAL_ALIGN){
			case ALIGN_LEFT:
				switch(DEFAULT_VERTICAL_ALIGN){
					case ALIGN_TOP:
						calc.getGbc().anchor = GridBagConstraints.NORTHWEST;
					break;
					case  ALIGN_MIDDLE:
						calc.getGbc().anchor = GridBagConstraints.WEST;
					break;
					case  ALIGN_BUTTOM:
						calc.getGbc().anchor = GridBagConstraints.SOUTHWEST;
					break;
					default :
					break;
				}
			break;
			case  ALIGN_CENTER:
				switch(DEFAULT_VERTICAL_ALIGN){
					case ALIGN_TOP:
						calc.getGbc().anchor = GridBagConstraints.NORTH;
					break;
					case  ALIGN_MIDDLE:
						calc.getGbc().anchor = GridBagConstraints.CENTER;
					break;
					case  ALIGN_BUTTOM:
						calc.getGbc().anchor = GridBagConstraints.SOUTH;
					break;
					default :
					break;
				}
			break;
			case ALIGN_RIGHT:
				switch(DEFAULT_VERTICAL_ALIGN){
					case ALIGN_TOP:
						calc.getGbc().anchor = GridBagConstraints.NORTHEAST;
					break;
					case  ALIGN_MIDDLE:
						calc.getGbc().anchor = GridBagConstraints.EAST;
					break;
					case  ALIGN_BUTTOM:
						calc.getGbc().anchor = GridBagConstraints.SOUTHEAST;
					break;
					default :
					break;
				}
			break;
			default :
			break;
		}
	}
	public GridBagConstraints addComponent(JComponent... component) {
		GridBagConstraints gbc = new GridBagConstraints();
		gbc.gridy = currentGridY;
		gbc.gridx = currentGridX++;
		gbc.ipadx = 0;
		gbc.ipady = 0;
		ComponentAndLayoutConstraints calc = new ComponentAndLayoutConstraints();
		calc.setComponents(component);
		calc.setGbc(gbc);
		componentAndLayoutConstraintsList.add(calc);
		setDefaultAlign();
		return gbc;
	}
	public GridBagConstraints addInNextRow(JComponent... component) {
		newRow();
		return this.addComponent(component);
	}
	public void newRow() {
		if(currentGridX==0) {
			return;
		}
		currentGridX = 0;
		currentGridY++;
	}
	public void swithToRow(int gridY) {
		currentGridY = gridY;
	}
	public GridBagConstraints add(JComponent component, int gridX, int gridY) {
		GridBagConstraints gbc = new GridBagConstraints();
		gbc.gridy = gridY;
		gbc.gridx = gridX;
		gbc.ipadx = 0;
		gbc.ipady = 0;
		ComponentAndLayoutConstraints calc = new ComponentAndLayoutConstraints();
		calc.setComponents(component);
		calc.setGbc(gbc);
		componentAndLayoutConstraintsList.add(calc);
		setDefaultAlign();
		return gbc;
	}
	public GridBagConstraints add(JComponent component, int gridX, int gridY, int gridheight, int gridwidth) {
		GridBagConstraints gbc = new GridBagConstraints();
		gbc.gridy = gridY;
		gbc.gridx = gridX;
		gbc.gridheight = gridheight;
		gbc.gridwidth = gridwidth;
		if (gridwidth > 1 || gridheight > 1) {
			gbc.fill = GridBagConstraints.BOTH;
		}
		ComponentAndLayoutConstraints calc = new ComponentAndLayoutConstraints();
		calc.setComponents(component);
		calc.setGbc(gbc);
		componentAndLayoutConstraintsList.add(calc);
		setDefaultAlign();
		return gbc;
	}
	public GridBagConstraints add(JComponent component, int gridX, int gridY, int gridheight, int gridwidth, int weightX,
			int weightY) {
		GridBagConstraints gbc = new GridBagConstraints();
		gbc.gridy = gridY;
		gbc.gridx = gridX;
		gbc.weightx = weightX;
		gbc.weighty = weightY;
		gbc.gridheight = gridheight;
		gbc.gridwidth = gridwidth;
		if (gridwidth > 1 || gridheight > 1) {
			gbc.fill = GridBagConstraints.BOTH;
		}
		ComponentAndLayoutConstraints calc = new ComponentAndLayoutConstraints();
		calc.setComponents(component);
		calc.setGbc(gbc);
		componentAndLayoutConstraintsList.add(calc);
		setDefaultAlign();
		return gbc;
	}
	public GridBagConstraints add(JComponent component, int gridX, int gridY, int gridheight, int gridwidth, int weightX, int weightY,
			Border border) {
		GridBagConstraints gbc = new GridBagConstraints();
		gbc.gridy = gridY;
		gbc.gridx = gridX;
		gbc.weightx = weightX;
		gbc.weighty = weightY;
		gbc.gridheight = gridheight;
		gbc.gridwidth = gridwidth;
		if (gridwidth > 1 || gridheight > 1) {
			gbc.fill = GridBagConstraints.BOTH;
		}
		component.setBorder(border);
		ComponentAndLayoutConstraints calc = new ComponentAndLayoutConstraints();
		calc.setComponents(component);
		calc.setGbc(gbc);
		componentAndLayoutConstraintsList.add(calc);
		setDefaultAlign();
		return gbc;
	}
	public Optional<ComponentAndLayoutConstraints> get(int gridX, int gridY) {
		Optional<ComponentAndLayoutConstraints> calc = componentAndLayoutConstraintsList.stream().filter(e->(e.getGbc().gridx==gridX && e.getGbc().gridy==gridY )).findFirst();
		return calc;
	}
	public boolean removeIf(int gridX, int gridY) {
		return componentAndLayoutConstraintsList.removeIf(e->e.getGbc().gridx==gridX && e.getGbc().gridy==gridY);
	}
	public void alignCol(int gridX, int halign, int valign) {
		componentAndLayoutConstraintsList.stream().filter(e->(e.getGbc().gridx==gridX)).forEach(e->{
			setAlign(halign, valign);
		});
	}
	public void alignRow(int gridY, int halign, int valign) {
		componentAndLayoutConstraintsList.stream().filter(e->(e.getGbc().gridy==gridY)).forEach(e->{
			setAlign(halign, valign);
		});
	}
	public void alignCell(int gridX, int gridY, int halign, int valign) {
		componentAndLayoutConstraintsList.stream().filter(e->(e.getGbc().gridy==gridY && e.getGbc().gridx==gridX)).forEach(e->{
			setAlign(halign, valign);
		});
	}
	public void showAllLineBorder(Border border) {
		componentAndLayoutConstraintsList.stream().forEach(e->{
			for(JComponent jc : e.getComponents()) {
				jc.setBorder(border);
			}
		});
	}
	public JPanel newJPanelWithFlowLayout(int flowLayoutAlign) {
		JPanel jp = new JPanel();
		FlowLayout fl;
		switch(FlowLayout.LEFT){
		case FlowLayout.LEFT:
			fl = new FlowLayout(FlowLayout.LEFT);
		break;
		case  FlowLayout.CENTER:
			fl = new FlowLayout(FlowLayout.CENTER);
		break;
		case  FlowLayout.RIGHT:
			fl = new FlowLayout(FlowLayout.RIGHT);
		break;
		default :
			fl = new FlowLayout(FlowLayout.CENTER);
		break;
		}
		jp.setLayout(fl);
		return jp;
	}
	public JPanel newJPanelWithDefaultFlowLayout() {
		JPanel jp = new JPanel();
		FlowLayout fl;
		switch(DEFAULT_HORIZONTAL_ALIGN){
			case ALIGN_LEFT:
				fl = new FlowLayout(FlowLayout.LEFT);
			break;
			case ALIGN_CENTER:
				fl = new FlowLayout(FlowLayout.CENTER);
			break;
			case ALIGN_RIGHT:
				fl = new FlowLayout(FlowLayout.RIGHT);
			break;
			default :
				fl = new FlowLayout(FlowLayout.LEFT);
			break;
		}
		jp.setLayout(fl);
		return jp;
	}
	public void showData() {
		for (ComponentAndLayoutConstraints calc : componentAndLayoutConstraintsList) {
			if(calc.getComponents().length==1) {
				this.add(calc.getComponents()[0], calc.getGbc());
			}else if(calc.getComponents().length>1) {
				JPanel jp = newJPanelWithDefaultFlowLayout();
				for(JComponent jc : calc.getComponents()) {
					jp.add(jc);
				}
				this.add(jp, calc.getGbc());
			}
		}
	}
	public void cleanModelData() {
		componentAndLayoutConstraintsList.clear();
		this.removeAll();
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\ui\TablePane4Test.java---
package ui;
import javax.swing.*;
import java.awt.*;
public class TablePane4Test extends JFrame {
	public void init() {
		Container pane = getContentPane();
		BorderLayout bl = new BorderLayout();
		pane.setLayout(bl);
		JPanel jp = new JPanel();
		jp.setLayout(new FlowLayout(FlowLayout.CENTER));
		ModifierPanel tp = new ModifierPanel();
		pane.add(tp, BorderLayout.CENTER);
		tp.showData();
		setSize(640, 480);
		this.pack();
		this.setVisible(true);
		this.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
	    return ;
	}
	public static void main(String[] args) {
		TablePane4Test gt = new TablePane4Test();
		gt.init();
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\ui\TextAreaPane.java---
package ui;
import ui.model.TextAreaPaneModel;
import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.AdjustmentEvent;
import java.awt.event.AdjustmentListener;
public class TextAreaPane extends ParamPane {
	JScrollPane jScrollPane;
	public JTextArea textArea;
	private JPanel addtionalJpanel;
	private JButton removeOneBtn;
	private JButton clearAll;
	TextAreaPaneModel model;
	public TextAreaPane(TextAreaPaneModel model) {
		this.model = model;
		textArea = new JTextArea(model.getRows(), model.getColumns());
		FlowLayout fl = new FlowLayout(FlowLayout.LEFT);
		this.setLayout(fl);
		this.addComponent(paramLabel);
		this.addComponent(tipLabel);
		jScrollPane = new JScrollPane(textArea, ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS,
				ScrollPaneConstants.HORIZONTAL_SCROLLBAR_AS_NEEDED);
		this.addComponent(jScrollPane);
		addAdjustmentValueChangedListener();
		addtionalJpanel = new JPanel();
		BoxLayout bl = new BoxLayout(addtionalJpanel, BoxLayout.Y_AXIS);
		addtionalJpanel.setLayout(bl);
		removeOneBtn = new JButton("remove item");
		clearAll = new JButton("clear all");
		addtionalJpanel.add(clearAll);
		addtionalJpanel.add(removeOneBtn);
		clearAll.addActionListener(new ActionListener() {
			@Override
			public void actionPerformed(ActionEvent e) {
				textArea.setText("");
				model.setHowManyRowsInTextArea(0);
			}
		});
		removeOneBtn.addActionListener(new ActionListener() {
			@Override
			public void actionPerformed(ActionEvent e) {
			}
		});
		this.addComponent(addtionalJpanel);
	}
	public void addAdjustmentValueChangedListener() {
		JScrollBar vScrollBar = jScrollPane.getVerticalScrollBar();
		AdjustmentListener listener = new AdjustmentListener() {
			@Override
			public void adjustmentValueChanged(AdjustmentEvent e) {
				if (model.getHowManyRowsInTextArea() >= model.getRows()) {
					Adjustable adjustable = e.getAdjustable();
					int max = adjustable.getMaximum();
					adjustable.setValue(max);
				}
				vScrollBar.removeAdjustmentListener(this);
			}
		};
		vScrollBar.addAdjustmentListener(listener);
	}
	public JTextArea getTextArea() {
		return textArea;
	}
	public void setTextArea(JTextArea textArea) {
		this.textArea = textArea;
	}
	public JScrollPane getjScrollPane() {
		return jScrollPane;
	}
	@Override
	public JComponent getInputComponent() {
		return textArea;
	}
	public TextAreaPaneModel getModel() {
		return model;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\ui\TextFieldPane.java---
package ui;
import javax.swing.*;
public class TextFieldPane extends ParamPane {
	public JTextField textField;
	public TextFieldPane() {
		init(-1);
	}
	public TextFieldPane(int fieldSize) {
		init(fieldSize);
	}
	public void init(int fieldSize) {
		if(fieldSize == -1){
			textField= new JTextField();
		}else{
			textField= new JTextField(fieldSize);
		}
		this.addComponent(paramLabel);
		this.addComponent(tipLabel);
		this.addComponent(textField);
	}
	public JTextField getTextField() {
		return textField;
	}
	public void setTextField(JTextField textField) {
		this.textField = textField;
	}
	@Override
	public JComponent getInputComponent() {
		return textField;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\ui\UI.java---
package ui;
import codegen.eclipseRobot.DataModel;
import codegen.eclipseRobot.FilterCombBox;
import codegen.eclipseRobot.UIContext;
import codegen.util.Common;
import com.dgs.annotation.UIAnno;
import javax.swing.*;
import javax.swing.text.html.HTMLEditorKit;
import java.awt.*;
import java.awt.event.AdjustmentEvent;
import java.awt.event.AdjustmentListener;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.awt.image.BufferedImage;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.List;
public class UI extends WindowAdapter  {
	private JFrame frame;
	TablePane tablePane;
	private FilterCombBox jComboBox;
	private JPanel northPanel;
	private JPanel inputPanel;
	private JPanel centerPanel;
	private DataModel model;
	JScrollPane jScrollPane;
	HtmlEditorPane editorPane;
	HTMLEditorKit kit;
	public UI(DataModel model) {
		super();
		this.model = model;
	}
	public void initView() {
		frame = new JFrame();
		frame.addWindowListener(this);
		Dimension d = Toolkit.getDefaultToolkit().getScreenSize();
		double width = d.getWidth();
		double height = d.getHeight();
		int frameWidth = 400;
		int taskBarTopY = tryGetTaskBarTopY(height);
		if (taskBarTopY == -1) {
			taskBarTopY = 80;
		}
		int frameHeight = taskBarTopY - 1;
		int frameX = (int) (width - frameWidth);
		int frameY = 0;
		frame.setSize(frameWidth, frameHeight);
		frame.setLocation(frameX, frameY);
		UIContext.frameX = frameX;
		UIContext.frameY = frameY;
		frame.getContentPane().setLayout(new BorderLayout());
		jComboBox = new FilterCombBox((List)this.model.getItems());
		jComboBox.setEditable(true);
		northPanel = new JPanel();
		northPanel.setLayout(new BorderLayout());
		tablePane = new TablePane(TablePane.ALIGN_LEFT, TablePane.ALIGN_MIDDLE);
		inputPanel = new JPanel();
		inputPanel.setLayout(new BorderLayout());
		frame.getContentPane().add(northPanel, BorderLayout.NORTH);
		northPanel.add(jComboBox, BorderLayout.NORTH);
		northPanel.add(inputPanel, BorderLayout.CENTER);
		centerPanel = new JPanel();
		centerPanel.setLayout(new BorderLayout());
		/*
		 * centerPanel.setLayout(new FlowLayout(FlowLayout.LEFT)); JPanel contentPanel =
		 * new JPanel(); contentPanel.setLayout(new
		 * BoxLayout(contentPanel,BoxLayout.X_AXIS)); centerPanel.add(contentPanel);
		 */
		kit = new HTMLEditorKit();
		editorPane = new HtmlEditorPane(this.model);
		editorPane.setEditable(false);
		jScrollPane = new JScrollPane(editorPane, ScrollPaneConstants.VERTICAL_SCROLLBAR_AS_NEEDED,
				ScrollPaneConstants.HORIZONTAL_SCROLLBAR_AS_NEEDED);
		System.out.println("going to create ActivatedHyperlinkListener ");
		editorPane.setContentType("text/html");
		editorPane.setEditorKit(kit);
		System.out.println("end create editorPane ");
		centerPanel.add(jScrollPane, BorderLayout.CENTER);
		frame.getContentPane().add(centerPanel, BorderLayout.CENTER);
		this.frame.setDefaultCloseOperation(WindowConstants.DO_NOTHING_ON_CLOSE);
		this.frame.setVisible(true);
		this.frame.setAlwaysOnTop(true);
		this.frame.toFront();
		this.frame.requestFocus();
	}
	public void addRowInHtmlEditorPane(String s) {
		this.editorPane.addRow(s);
	}
	public void addAdjustmentValueChangedListener(JScrollPane jScrollPane) {
		JScrollBar vScrollBar = jScrollPane.getVerticalScrollBar();
		AdjustmentListener listener = new AdjustmentListener() {
			@Override
			public void adjustmentValueChanged(AdjustmentEvent e) {
				Adjustable adjustable = e.getAdjustable();
				int max = adjustable.getMaximum();
				adjustable.setValue(max);
				vScrollBar.removeAdjustmentListener(this);
			}
		};
		vScrollBar.addAdjustmentListener(listener);
	}
	public void refeedFilterCombBox() {
		this.jComboBox.resetArray((List)this.model.getItems());
		return;
	}
	public Integer tryGetTaskBarTopY(double screenHeight) {
		Integer taskBarTopY = 1000;
		return taskBarTopY;
	}
	public void show(DataModel model) {
		if (model.getMethods() == null || model.getMethods().length == 0) {
			return;
		}
		Method m = model.getSelectedMethod();
		if (m != null) {
			inputPanel.removeAll();
			if(null!=tablePane) {
				tablePane.cleanModelData();
			}
		}
		UIAnno[] uiAnno = m.getAnnotationsByType(UIAnno.class);
		if(uiAnno.length>0) {
			try {
				Class[] vs = Common.getClassByName(uiAnno[0].uiClz());
				if(vs.length>0) {
					Constructor[] cts = vs[0].getConstructors();
					Constructor defaultCt = null;
					for(Constructor ct : cts) {
						if(ct.getParameterCount()==0) {
							defaultCt = ct;
							break;
						}
					}
					if(null!=defaultCt) {
						JPanel jp = (JPanel) defaultCt.newInstance();
						tablePane.newRow();
						tablePane.addComponent(jp);
					}
				}
			} catch (InstantiationException | IllegalAccessException | IllegalArgumentException
					| InvocationTargetException | SecurityException e) {
				e.printStackTrace();
			}
		}else {
			MethodTypePane tp = new MethodTypePane();
			tp.showData();
			tablePane.newRow();
			tablePane.addComponent(tp);
		}
		tablePane.showData();
		JPanel jp = new JPanel();
		jp.setLayout(new FlowLayout(FlowLayout.LEFT));
		jp.add(tablePane);
		inputPanel.add(jp);
		inputPanel.updateUI();
		return;
	}
	public String getSeletedItem() {
		return (String) jComboBox.getSelectedItem();
	}
	@Override
	public void windowClosing(WindowEvent e) {
		this.frame.dispose();
		System.exit(0);
	}
	public DataModel getModel() {
		return model;
	}
	public void setModel(DataModel model) {
		this.model = model;
	}
	public FilterCombBox getjComboBox() {
		return jComboBox;
	}
	public HtmlEditorPane getEditorPane() {
		return editorPane;
	}
	public HTMLEditorKit getKit() {
		return kit;
	}
	public TablePane getTablePane() {
		return tablePane;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\ui\validation\MandatoryCheck.java---
package ui.validation;
public class MandatoryCheck implements Validation{
	public ViolationResultItem check(ValidatablePane component, Object val) {
		ViolationResultItem vri = new ViolationResultItem();
		if(val==null || "".equals(val.toString().trim())){
			vri.setTip(component.getComponentName() +" cannot be blank");
		}else{
			vri.setPass(true);
		}
		return vri;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\ui\validation\ModifierCheck.java---
package ui.validation;
import java.util.BitSet;
public class ModifierCheck  implements Validation{
	public ModifierCheck() {
	}
	@Override
	public ViolationResultItem check(ValidatablePane validatablePane, Object val) {
		ViolationResultItem vri = new ViolationResultItem();
		BitSet bs = (BitSet) val;
		if(bs.isEmpty()){
			vri.setTip(validatablePane.getParamLabel().getText() +" cannot be blank");
		}else{
			vri.setPass(true);
		}
		return vri;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\ui\validation\NotVisibleInUI.java---
package ui.validation;
import java.lang.annotation.Documented;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Deprecated
public @interface NotVisibleInUI {
}
----strat of file D:\projects\cg\cg-min\src\main\java\ui\validation\ValidatableArraySupportClassCombBoxpane.java---
package ui.validation;
import ui.ArraySupportClassCombBoxpane;
import java.util.List;
public class ValidatableArraySupportClassCombBoxpane extends ArraySupportClassCombBoxpane implements ValidatablePane {
	public ValidatableArraySupportClassCombBoxpane(List<String> strList) {
		super(strList);
	}
	@Override
	public Validation getValidation() {
		return null;
	}
	@Override
	public String getComponentName() {
		return null;
	}
	@Override
	public ViolationResultItem validateVal() {
		return null;
	}
	@Override
	public void removeMark() {
	}
	@Override
	public void markInvaidInput() {
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\ui\validation\ValidatableArraySupportReturnTypeCombBoxPane.java---
package ui.validation;
import ui.ArraySupportReturnTypeCombBoxPane;
import javax.swing.*;
public class ValidatableArraySupportReturnTypeCombBoxPane extends ArraySupportReturnTypeCombBoxPane
		implements ValidatablePane {
	@Override
	public JComponent getInputComponent() {
		return null;
	}
	@Override
	public JLabel getParamLabel() {
		return null;
	}
	@Override
	public JLabel getTipLabel() {
		return null;
	}
	@Override
	public Validation getValidation() {
		return null;
	}
	@Override
	public String getComponentName() {
		return null;
	}
	@Override
	public ViolationResultItem validateVal() {
		return null;
	}
	@Override
	public void removeMark() {
	}
	@Override
	public void markInvaidInput() {
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\ui\validation\ValidatableFilePane.java---
package ui.validation;
import ui.FilePane;
import javax.swing.*;
import javax.swing.border.Border;
import java.awt.*;
public class ValidatableFilePane extends FilePane implements ValidatablePane {
	Validation va;
	public ValidatableFilePane(Validation va, int fieldSize, boolean chooseDirOnly) {
		super(fieldSize, chooseDirOnly);
		this.va = va;
	}
	@Override
	public Validation getValidation() {
		return va;
	}
	@Override
	public String getComponentName() {
		return this.getName();
	}
	@Override
	public ViolationResultItem validateVal() {
		return va.check(this, this.getTextField().getText().trim());
	}
	@Override
	public void removeMark() {
		this.setBorder(null);
	}
	@Override
	public void markInvaidInput() {
		Border b = BorderFactory.createLineBorder(Color.red);
		this.setBorder(b);
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\ui\validation\ValidatableModifierPanel.java---
package ui.validation;
import ui.ModifierPanel;
import javax.swing.*;
import javax.swing.border.Border;
import java.awt.*;
public class ValidatableModifierPanel extends ModifierPanel  implements ValidatablePane{
	Validation va;
	public ValidatableModifierPanel(Validation va) {
		super();
		this.va = va;
	}
	@Override
	public Validation getValidation() {
		return va;
	}
	@Override
	public String getComponentName() {
		return this.getName();
	}
	@Override
	public ViolationResultItem validateVal() {
		return va.check(this, this.getVal());
	}
	@Override
	public void removeMark() {
		this.setBorder(null);
	}
	@Override
	public void markInvaidInput() {
		Border b = BorderFactory.createLineBorder(Color.red);
		this.setBorder(b);
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\ui\validation\ValidatablePane.java---
package ui.validation;
import ui.IParamPane;
public interface ValidatablePane extends IParamPane {
	public Validation getValidation();
	public String getComponentName();
	public ViolationResultItem validateVal();
	public void removeMark();
	public void markInvaidInput();
}
----strat of file D:\projects\cg\cg-min\src\main\java\ui\validation\ValidatableTextAreaPane.java---
package ui.validation;
import ui.TextAreaPane;
import ui.model.TextAreaPaneModel;
import javax.swing.*;
import javax.swing.border.Border;
import java.awt.*;
public class ValidatableTextAreaPane extends TextAreaPane implements ValidatablePane {
	public ValidatableTextAreaPane(Validation va, TextAreaPaneModel model) {
		super(model);
		this.va = va;
	}
	Validation va;
	public void removeMark() {
		this.textArea.setBorder(null);
	}
	public void markInvaidInput() {
		Border b = BorderFactory.createLineBorder(Color.red);
		this.textArea.setBorder(b);
	}
	public ViolationResultItem validateVal() {
		return va.check(this, textArea.getText());
	}
	@Override
	public String getComponentName() {
		return this.getName();
	}
	@Override
	public Validation getValidation() {
		return va;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\ui\validation\ValidatableTextFieldPane.java---
package ui.validation;
import ui.TextFieldPane;
import javax.swing.*;
import javax.swing.border.Border;
import java.awt.*;
public class ValidatableTextFieldPane extends TextFieldPane implements ValidatablePane {
	Validation va;
	public ValidatableTextFieldPane(Validation va, int fieldSize) {
		super(fieldSize);
		this.va = va;
	}
	public ViolationResultItem validateVal() {
		return va.check(this, textField.getText());
	}
	public void removeMark() {
		textField.setBorder(null);
	}
	public void markInvaidInput() {
		Border b = BorderFactory.createLineBorder(Color.red);
		textField.setBorder(b);
	}
	@Override
	public String getComponentName() {
		return textField.getName();
	}
	@Override
	public Validation getValidation() {
		return va;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\ui\validation\Validation.java---
package ui.validation;
public interface Validation {
	public ViolationResultItem check(ValidatablePane validatablePane, Object val);
}
----strat of file D:\projects\cg\cg-min\src\main\java\ui\validation\ValidationAnn.java---
package ui.validation;
import java.lang.annotation.Documented;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface ValidationAnn {
	String[] validations() default {};;
}
----strat of file D:\projects\cg\cg-min\src\main\java\ui\validation\ValidationResult.java---
package ui.validation;
import java.util.ArrayList;
import java.util.List;
public class ValidationResult {
	List<ViolationResultItem> validationViolations = new ArrayList<>();
	public List<ViolationResultItem> getValidationViolations() {
		return validationViolations;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\ui\validation\ValidationViolation.java---
package ui.validation;
public class ValidationViolation {
	public ValidationViolation() {
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\ui\validation\ValueCheck.java---
package ui.validation;
public class ValueCheck implements Validation{
	public ViolationResultItem check(ValidatablePane component, Object val) {
		ViolationResultItem vri = new ViolationResultItem();
		if(val==null || "".equals(val.toString().trim())){
			vri.setTip(component.getParamLabel().getText() +" cannot be blank");
		}else{
			vri.setPass(true);
		}
		return vri;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\ui\validation\VdalidatableCreateAnnotationPanel.java---
package ui.validation;
import ui.ParamPane;
import javax.swing.*;
public class VdalidatableCreateAnnotationPanel extends ParamPane implements ValidatablePane {
	private JCheckBox document;
	private JCheckBox retention;
	private JCheckBox finalBox;
	@Override
	public JComponent getInputComponent() {
		return null;
	}
	@Override
	public Validation getValidation() {
		return null;
	}
	@Override
	public String getComponentName() {
		return null;
	}
	@Override
	public ViolationResultItem validateVal() {
		return null;
	}
	@Override
	public void removeMark() {
	}
	@Override
	public void markInvaidInput() {
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\ui\validation\ViolationResultItem.java---
package ui.validation;
public class ViolationResultItem {
	private boolean pass;
	private String tip;
	private Object obj;
	public ViolationResultItem() {
	}
	public String getTip() {
		return tip;
	}
	public void setTip(String tip) {
		this.tip = tip;
	}
	public Object getObj() {
		return obj;
	}
	public void setObj(Object obj) {
		this.obj = obj;
	}
	public boolean isPass() {
		return pass;
	}
	public void setPass(boolean pass) {
		this.pass = pass;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\resources\application.yml---
## Development configuration
server:
  port: 8082
  servlet:
    contextPath: /test
spring:
  main:
    allow-bean-definition-overriding: true
  application:
    name: example
  security:
    enabled: false
  mvc:
    view:
      prefix: /WEB-INF/jsp/
      suffix: .jsp
  datasource:
    #platform: oracle
    #url: jdbc:oracle:thin:@hostname:1521:dbname
    #username: LTMASTER
    ##password: ''
    #password: Cp4#7a7T
    #driver-class-name: oracle.jdbc.OracleDriver
    #type: com.zaxxer.hikari.HikariDataSource
    #hikari:
    #minimumIdle: 1
    #maximumPoolSize: 20
    #idleTimeout: 60000
    #poolName: SpringBootJPAHikariCP
    #maxLifetime: 2000000
    #connectionTimeout: 30000
    driver-class-name: org.h2.Driver
    username: sa
    password:
    url: jdbc:h2:file:D:/projects/cg/cg-5.6/bb
    #url: jdbc:h2:mem:test_db
    #url: jdbc:h2:tcp://dbserv:8084/~/test_db
  h2:
    console:
      enabled: true
      #access h2-console via link http://localhost:8080/test/h2-console/
      path: /h2-console
----strat of file D:\projects\cg\cg-min\src\main\resources\tableforpanel.html---
<html>
<head>
<!-- <link rel="stylesheet" type="text/css" href="css.css" > -->
<style>
.divTable {
  display: table;         
  width: auto;         
  background-color: #eee;         
  border: 1px solid #666666;         
  border-spacing: 5px; /* cellspacing:poor IE support for  this */
}
</style>
</head>
<body>
	<form id="form1">
		<table>
			<tr id="trstart">
			<td><a href="?action=clear">clear</a>&nbsp;<a href="?action=reload">reload</a></td>
			</tr>
		</table>
	</form>
</body>
</html>
----strat of file D:\projects\cg\cg-min\src\pom.xml---
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>
  <groupId>cg</groupId>
  <artifactId>cgm</artifactId>
  <version>1.0</version>
  <packaging>jar</packaging>
  <properties>
    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
<!--    <org.apache.maven.plugins.maven-assembly-plugin.version>2.6</org.apache.maven.plugins.maven-assembly-plugin.version>-->
     <maven.compiler.source>1.8</maven.compiler.source>
    <maven.compiler.target>1.8</maven.compiler.target>
      <aetherVersion>1.1.0</aetherVersion>
      <mavenVersion>3.3.9</mavenVersion>
<!--    <junit.jupiter.version>5.5.2</junit.jupiter.version>-->
<!--    <junit.platform.version>1.5.2</junit.platform.version>-->
  </properties>
  <dependencies>
      <!-- maven realted -->
      <dependency>
          <groupId>com.jcabi</groupId>
          <artifactId>jcabi-aether</artifactId>
          <version>0.10.1</version>
      </dependency>
      <dependency>
          <groupId>org.codehaus.plexus</groupId>
          <artifactId>plexus-utils</artifactId>
          <version>3.0.15</version>
      </dependency>
      <dependency>
          <groupId>org.apache.maven</groupId>
          <artifactId>maven-model</artifactId>
          <version>3.0.4</version>
      </dependency>
      <dependency>
          <groupId>org.apache.maven</groupId>
          <version>3.0.4</version>
          <artifactId>maven-core</artifactId>
      </dependency>
<!--      <dependency>-->
<!--          <groupId>com.github.artifactresolver</groupId>-->
<!--          <version>0.3</version>-->
<!--          <artifactId>mvn-dependency-downloader</artifactId>-->
<!--          <exclusions>-->
<!--              <exclusion>-->
<!--                  <groupId>org.eclipse.aether</groupId>-->
<!--                  <artifactId>aether-impl</artifactId>-->
<!--              </exclusion>-->
<!--          </exclusions>-->
<!--      </dependency>-->
<!--      <dependency>-->
<!--          <groupId>org.eclipse.aether</groupId>-->
<!--          <artifactId>aether-impl-custom</artifactId>-->
<!--          <version>${aetherVersion}</version>-->
<!--      </dependency>-->
      <dependency>
          <groupId>org.eclipse.aether</groupId>
          <artifactId>aether-api</artifactId>
          <version>${aetherVersion}</version>
      </dependency>
      <dependency>
          <groupId>org.eclipse.aether</groupId>
          <artifactId>aether-util</artifactId>
          <version>${aetherVersion}</version>
      </dependency>
      <dependency>
          <groupId>org.eclipse.aether</groupId>
          <artifactId>aether-connector-basic</artifactId>
          <version>${aetherVersion}</version>
      </dependency>
      <dependency>
          <groupId>org.eclipse.aether</groupId>
          <artifactId>aether-transport-file</artifactId>
          <version>${aetherVersion}</version>
      </dependency>
      <dependency>
          <groupId>org.eclipse.aether</groupId>
          <artifactId>aether-transport-http</artifactId>
          <version>${aetherVersion}</version>
      </dependency>
      <dependency>
          <groupId>org.eclipse.aether</groupId>
          <artifactId>aether-transport-wagon</artifactId>
          <version>${aetherVersion}</version>
      </dependency>
      <dependency>
          <groupId>org.apache.maven</groupId>
          <artifactId>maven-aether-provider</artifactId>
          <version>${mavenVersion}</version>
          <exclusions>
              <exclusion>
                  <groupId>org.eclipse.aether</groupId>
                  <artifactId>aether-impl</artifactId>
              </exclusion>
          </exclusions>
      </dependency>
      <dependency>
          <groupId>com.h2database</groupId>
          <artifactId>h2</artifactId>
          <version>1.4.200</version>
      </dependency>
<!--      <dependency>-->
<!--          <groupId>qj.blog</groupId>-->
<!--          <artifactId>classreloading</artifactId>-->
<!--          <version>1.0-SNAPSHOT</version>-->
<!--      </dependency>-->
      <dependency>
          <groupId>org.apache.maven</groupId>
          <artifactId>maven-model</artifactId>
          <version>3.3.9</version>
      </dependency>
	  <dependency>
		  <groupId>net.java.dev.jna</groupId>
		  <artifactId>jna</artifactId>
		  <version>5.5.0</version>
	  </dependency>
	  <dependency>
		  <groupId>net.java.dev.jna</groupId>
		  <artifactId>jna-platform</artifactId>
		  <version>5.5.0</version>
	  </dependency>
      <!--below is for class loading-->
      <dependency>
          <groupId>de.neuland-bfi</groupId>
          <artifactId>jade4j</artifactId>
          <version>0.4.0</version>
      </dependency>
      <dependency>
          <groupId>javax</groupId>
          <artifactId>javaee-api</artifactId>
          <version>7.0</version>
      </dependency>
      <dependency>
          <groupId>org.eclipse.jetty</groupId>
          <artifactId>jetty-server</artifactId>
          <version>9.2.2.v20140723</version>
      </dependency>
      <dependency>
          <groupId>org.eclipse.jetty</groupId>
          <artifactId>jetty-servlet</artifactId>
          <version>9.2.2.v20140723</version>
      </dependency>
      <dependency>
          <groupId>org.eclipse.jetty</groupId>
          <artifactId>jetty-webapp</artifactId>
          <version>9.2.2.v20140723</version>
          <scope>test</scope>
      </dependency>
      <dependency>
          <groupId>org.xerial</groupId>
          <artifactId>sqlite-jdbc</artifactId>
          <version>3.8.7</version>
      </dependency>
      <dependency>
          <groupId>com.google.code.gson</groupId>
          <artifactId>gson</artifactId>
          <version>2.3</version>
      </dependency>
      <!--for replace mvn-dependency-downloader artifactor-->
      <dependency>
          <groupId>org.eclipse.aether</groupId>
          <artifactId>aether-api</artifactId>
          <version>${aetherVersion}</version>
      </dependency>
      <dependency>
          <groupId>org.eclipse.aether</groupId>
          <artifactId>aether-util</artifactId>
          <version>${aetherVersion}</version>
      </dependency>
      <dependency>
          <groupId>org.eclipse.aether</groupId>
          <artifactId>aether-impl</artifactId>
          <version>${aetherVersion}</version>
      </dependency>
      <dependency>
          <groupId>org.eclipse.aether</groupId>
          <artifactId>aether-connector-basic</artifactId>
          <version>${aetherVersion}</version>
      </dependency>
      <dependency>
          <groupId>org.eclipse.aether</groupId>
          <artifactId>aether-transport-file</artifactId>
          <version>${aetherVersion}</version>
      </dependency>
      <dependency>
          <groupId>org.eclipse.aether</groupId>
          <artifactId>aether-transport-http</artifactId>
          <version>${aetherVersion}</version>
      </dependency>
      <dependency>
          <groupId>org.eclipse.aether</groupId>
          <artifactId>aether-transport-wagon</artifactId>
          <version>${aetherVersion}</version>
      </dependency>
      <dependency>
          <groupId>org.apache.maven</groupId>
          <artifactId>maven-aether-provider</artifactId>
          <version>${mavenVersion}</version>
      </dependency>
      <dependency>
          <groupId>com.googlecode.json-simple</groupId>
          <artifactId>json-simple</artifactId>
          <version>1.1.1</version>
      </dependency>
      <dependency>
          <groupId>commons-cli</groupId>
          <artifactId>commons-cli</artifactId>
          <version>1.3.1</version>
      </dependency>
      <dependency>
          <groupId>commons-io</groupId>
          <artifactId>commons-io</artifactId>
          <version>2.4</version>
      </dependency>
      <dependency>
          <groupId>ch.qos.logback</groupId>
          <artifactId>logback-classic</artifactId>
          <version>1.1.6</version>
      </dependency>
      <dependency>
          <groupId>org.slf4j</groupId>
          <artifactId>slf4j-api</artifactId>
          <version>1.7.18</version>
      </dependency>
<!--    <dependency>-->
<!--      <groupId>com.github.javafaker</groupId>-->
<!--      <artifactId>javafaker</artifactId>-->
<!--      <version>1.0.2</version>-->
<!--      <scope>test</scope>-->
<!--    </dependency>-->
<!--    <dependency>-->
<!--      <groupId>uk.co.jemos.podam</groupId>-->
<!--      <artifactId>podam</artifactId>-->
<!--      <version>7.2.3.RELEASE</version>-->
<!--      <scope>test</scope>-->
<!--    </dependency>-->
  </dependencies>
<!--  <build>-->
<!--  	<plugins>-->
<!--  		<plugin>-->
<!--  			<groupId>org.apache.maven.plugins</groupId>-->
<!--			  <artifactId>maven-assembly-plugin</artifactId>-->
<!--			  <version>${org.apache.maven.plugins.maven-assembly-plugin.version}</version>-->
<!--			  <configuration>-->
<!--			  	<descriptorRefs>-->
<!--			  		<descriptorRef>jar-with-dependencies</descriptorRef>-->
<!--			  	</descriptorRefs>-->
<!--			  </configuration>-->
<!--			  <executions>-->
<!--			  	<execution>-->
<!--			  		<id>make-assembly</id>-->
<!--			  		<phase>package</phase>-->
<!--			  		<goals>-->
<!--			  			<goal>single</goal>-->
<!--			  		</goals>-->
<!--			  	</execution>-->
<!--			  </executions>-->
<!--  		</plugin>-->
<!--  		<plugin>-->
<!--	  		<artifactId>maven-source-plugin</artifactId>-->
<!--	  		<executions>-->
<!--	  			<execution>-->
<!--	  				<id>attach-source</id>-->
<!--	  				<phase>verify</phase>-->
<!--	  				<goals>-->
<!--	  					<goal>jar</goal>-->
<!--	  				</goals>-->
<!--	  			</execution>-->
<!--	  		</executions>-->
<!--  		</plugin>-->
<!--  	</plugins>-->
<!--  </build>-->
</project>
----strat of file D:\projects\cg\cg-min\src\main\java\app\Main.java---
package app;
import codegen.complexobj.CodeGenContext;
import codegen.eclipseRobot.UIController;
import java.io.*;
public class Main {
	public static byte[] bytes = null;
	public static void setBytes(byte[] abytes) throws FileNotFoundException {
		bytes = abytes;
	}
	public static void write(File f, String fileStr) throws IOException {
		FileOutputStream fos = new FileOutputStream(f);
		fos.write(fileStr.getBytes());
		fos.flush();
		fos.close();
	}
	public static void main(String[] args) throws FileNotFoundException {
		StringBuilder sb = new StringBuilder();
		if (null != args && args.length > 0) {
			System.out.println(args[0]);
			for (String p : args) {
				String sArray[] = p.split("=");
				if (sArray[0].startsWith("-D")) {
					String propName = sArray[0].replaceFirst("-D", "");
					System.setProperty(propName, sArray[1]);
				}
				sb.append(String.format("set property %s, %s", sArray[0], sArray[1]));
			}
		}
		if (bytes != null) {
			CodeGenContext codeGenContext = CodeGenContext.getInstance();
			codeGenContext.setAppBytes(bytes);
		}
		String s = System.getProperty(codegen.Const.OUTPUT_SYS_PROPERTY_NAME);
		if (s != null) {
			File f = new File(s);
			File parentFile = f.getParentFile();
			if (!parentFile.exists()) {
				parentFile.mkdirs();
			}
			if (!f.exists()) {
			}
			if (parentFile.exists()) {
				FileOutputStream fileOutputStream = new FileOutputStream(f);
				BufferedOutputStream bufferedOutputStream = new BufferedOutputStream(fileOutputStream);
				PrintStream printStream = new PrintStream(bufferedOutputStream, true);
				System.setOut(printStream);
				System.setErr(printStream);
				System.out.println(String.format("setting log file as %s", f.getAbsolutePath()));
			}
		}
		UIController c = new UIController();
		c.start();
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\clipboardclient\AbstractClipboardMonitor.java---
package clipboardclient;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.ServerSocket;
import java.net.Socket;
public abstract class AbstractClipboardMonitor {
	private String host;
	private int port;
	private static int defaultPort = 8888;
	public String getHost() {
		return host;
	}
	public void setHost(String host) {
		this.host = host;
	}
	public int getPort() {
		return port;
	}
	public void setPort(int port) {
		this.port = port;
	}
	ServerSocket ss;
	public AbstractClipboardMonitor() {
		super();
	}
	public AbstractClipboardMonitor(int port) {
		super();
		this.port = port;
	}
	protected abstract void onChange(String content) throws Exception;
	public synchronized void start() {
		while (true) {
			try {
				try {
					ss = new ServerSocket(defaultPort);
				} catch (Exception e1) {
					ss = new ServerSocket(0);
				}
				this.port = ss.getLocalPort();
				Socket s = ss.accept();
				InputStream is = s.getInputStream();
				OutputStream os = s.getOutputStream();
				ByteArrayOutputStream bos = new ByteArrayOutputStream();
				try {
					do {
						byte[] buffer = new byte[1024];
						is.read(buffer);
						bos.write(buffer);
					} while (is.available() > 0);
					byte[] allBy = bos.toByteArray();
					String content = new String(allBy, "UTF-8");
					os.write(new byte[] { 1 });
					os.flush();
					try {
						onChange(content);
					} catch (Exception e) {
						System.out.println("clipboard content change handle throws exception");
					}
				} catch (IOException e) {
				}
			} catch (IOException e) {
				e.printStackTrace();
			} finally {
				close();
			}
		}
	}
	public synchronized void close() {
		if (ss != null) {
			try {
				ss.close();
			} catch (IOException e) {
				e.printStackTrace();
			}
		}
	}
	public static void main(String[] args) {
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\clipboardclient\ClientSocketManager.java---
package clipboardclient;
import java.net.Socket;
import java.util.ArrayList;
import java.util.List;
public class ClientSocketManager implements Runnable {
  List<Socket> socketClientList = new ArrayList<>();
  @Override
  public void run() {
  }
}
----strat of file D:\projects\cg\cg-min\src\main\java\clipboardclient\ConcreteClipboardMonitor.java---
package clipboardclient;
import java.util.ArrayList;
public class ConcreteClipboardMonitor extends AbstractClipboardMonitor implements Runnable {
  private ArrayList<IClipboardObserver> observers;
  public ConcreteClipboardMonitor() {
    super();
    observers = new ArrayList<IClipboardObserver>();
  }
  public ConcreteClipboardMonitor(int port) {
    super(port);
    observers = new ArrayList<IClipboardObserver>();
  }
  /**
   * Register an observer.
   * 
   * @param observer
   */
  public void addObserver(IClipboardObserver observer) {
    observers.add(observer);
  }
  /**
   * Remove an observer from list.
   * 
   * @param observer
   */
  public void removeObserver(IClipboardObserver observer) {
    int i = observers.indexOf(observer);
    if (i >= 0)
      observers.remove(i);
  }
  @Override
  protected void onChange(String content) {
    if (observers != null) {
      for (IClipboardObserver observer : observers) {
        observer.onUpdate(content);
      }
    }
  }
  @Override
  public synchronized void start() {
    Thread t1 = new Thread(this, "clip board monitor");
    t1.start();
  }
  @Override
  public void run() {
    super.start();
  }
}
----strat of file D:\projects\cg\cg-min\src\main\java\clipboardclient\IClipboardObserver.java---
package clipboardclient;
public interface IClipboardObserver {
  public void onUpdate(String content);
}
----strat of file D:\projects\cg\cg-min\src\main\java\codegen\AbstractConcreteClassMapping.java---
package codegen;
import java.lang.reflect.Method;
public class AbstractConcreteClassMapping {
	Class abstractClass;
	String abstractClassInstanceName;
	Class concreteClass;
	String concreteClassInstanceName;
	Method concreteCFactoryMethod;
	/** support $ symbol **/
	String methodParamVariables[];
	public Class getAbstractClass() {
		return abstractClass;
	}
	public void setAbstractClass(Class abstractClass) {
		this.abstractClass = abstractClass;
	}
	public String getAbstractClassInstanceName() {
		return abstractClassInstanceName;
	}
	public void setAbstractClassInstanceName(String abstractClassInstanceName) {
		this.abstractClassInstanceName = abstractClassInstanceName;
	}
	public Class getConcreteClass() {
		return concreteClass;
	}
	public void setConcreteClass(Class concreteClass) {
		this.concreteClass = concreteClass;
	}
	public String getConcreteClassInstanceName() {
		return concreteClassInstanceName;
	}
	public void setConcreteClassInstanceName(String concreteClassInstanceName) {
		this.concreteClassInstanceName = concreteClassInstanceName;
	}
	public Method getConcreteCFactoryMethod() {
		return concreteCFactoryMethod;
	}
	public void setConcreteCFactoryMethod(Method concreteCFactoryMethod) {
		this.concreteCFactoryMethod = concreteCFactoryMethod;
	}
	public String[] getMethodParamVariables() {
		return methodParamVariables;
	}
	public void setMethodParamVariables(String[] methodParamVariables) {
		this.methodParamVariables = methodParamVariables;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\codegen\complexobj\CodeGenContext.java---
package codegen.complexobj;
import codegen.AbstractConcreteClassMapping;
import codegen.MethodMatcher;
import codegen.unittest.MethodCallingVariable;
import codegen.util.Common;
import codegen.util.MethodCallingKey;
import qj.util.lang.ReloadableDynamicClassLoaderOwner;
import java.io.BufferedReader;
import java.io.File;
import java.io.IOException;
import java.io.InputStreamReader;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.net.URL;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
public class CodeGenContext {
	public byte[] appBytes;
	boolean genFullQualifierName;
	private static String mavenHome = System.getProperty("mavenHome");
	private static String localRepoDir = System.getProperty("repositoryPath");
	private static String CGKeyAppPath;
	private static String IDEProcNameKeyword;
	File pomFile;
	List<String> jrePrimitiveTypes;
	List<String> jreClasses;
	ReloadableDynamicClassLoaderOwner reloadableDynamicClassLoaderOwner;
	StringBuilder packageSB;
	StringBuilder importSB;
	StringBuilder fieldsSB;
	StringBuilder setupSB;
	StringBuilder allTestCaseSB;
	StringBuilder createdComplexTypeMethod;
	StringBuilder addtionalMethods;
	List<String> createdMethodName;
	Map<String, String> variableMap;
	List<Class> alreadyImportClasses;
	Map<Class, String> classSimpleNameMap;
	Map<Class<?>, Short> sameTypeCreatedTimesMap;
	Map<MethodCallingKey, MethodCallingVariable> complexTypeCreateMapping;
	public List<Field> allFieldList;
	/**
	 * global param
	 **/
	private Map<Class<?>, AbstractConcreteClassMapping> abstractConcreteClassMap;
	Map<Class, MethodMatcher> methodMatchers;
	List<URL> loadedJarList = new ArrayList<>();
	List<Class> attachedClzList;
	private static CodeGenContext codeGenContext;
	private int clipBoardMonitorServerPort;
	private static List<String> memoryAreas;
	Map<Class<?>, Object> uiModelMap;
	private Map<String, Object> paramPossibleValsMap;
	public CodeGenContext() {
		init();
	}
	public static CodeGenContext getInstance() {
		if (codeGenContext == null) {
			return newInstance();
		} else {
			return codeGenContext;
		}
	}
	public static CodeGenContext newInstance() {
		CodeGenContext context = new CodeGenContext();
		context.init();
		codeGenContext = context;
		return context;
	}
	public void init() {
		packageSB = new StringBuilder();
		importSB = new StringBuilder();
		fieldsSB = new StringBuilder();
		setupSB = new StringBuilder();
		allTestCaseSB = new StringBuilder();
		createdComplexTypeMethod = new StringBuilder();
		addtionalMethods = new StringBuilder();
		createdMethodName = new ArrayList<>();
		variableMap = Common.createVariableMap();
		alreadyImportClasses = new ArrayList<Class>();
		classSimpleNameMap = new HashMap<>();
		complexTypeCreateMapping = new HashMap<>();
		allFieldList = new ArrayList<>();
		abstractConcreteClassMap = new HashMap<>();
		methodMatchers = new HashMap<>();
		sameTypeCreatedTimesMap = new HashMap<>();
		attachedClzList = new ArrayList<Class>();
		reloadableDynamicClassLoaderOwner = new ReloadableDynamicClassLoaderOwner();
		jreClasses = new ArrayList<>();
		jrePrimitiveTypes = Arrays
				.asList("int", "boolean", "long", "double", "short", "float",
						"byte", "char");
		uiModelMap = new HashMap<>();
		paramPossibleValsMap = new HashMap<String, Object>();
		memoryAreas = new ArrayList<>();
	}
	public void clearExceptGlobalParam() {
		packageSB.delete(0, packageSB.length());
		importSB.delete(0, importSB.length());
		fieldsSB.delete(0, fieldsSB.length());
		setupSB.delete(0, setupSB.length());
		allTestCaseSB.delete(0, allTestCaseSB.length());
		createdComplexTypeMethod.delete(0, createdComplexTypeMethod.length());
		addtionalMethods.delete(0, addtionalMethods.length());
		createdMethodName.clear();
		variableMap = Common.createVariableMap();
		alreadyImportClasses.clear();
		classSimpleNameMap.clear();
		complexTypeCreateMapping.clear();
		allFieldList.clear();
		methodMatchers.clear();
		sameTypeCreatedTimesMap.clear();
		paramPossibleValsMap.clear();
	}
	public void clear() {
		clearExceptGlobalParam();
		/** global param **/
		abstractConcreteClassMap.clear();
		methodMatchers.clear();
		attachedClzList.clear();
	}
	public void extractJREClassesByJavaVerbose() {
		try {
			Process p = Runtime.getRuntime()
					.exec("java -verbose --show-version");
			StringBuilder sb = new StringBuilder();
			BufferedReader in = null;
			try {
				in = new BufferedReader(
						new InputStreamReader(p.getInputStream()));
				String line = null;
				while ((line = in.readLine()) != null) {
					sb.append(line).append("\r\n");
				}
			} catch (IOException e) {
				e.printStackTrace();
				throw e;
			} finally {
				if (in != null)
					try {
						in.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
			}
			String output = sb.toString();
			Pattern pattern = Pattern
					.compile("\\[class,load\\]\\s*([\\w\\.\\$]+)[ ]+source:");
			Matcher matcher = pattern.matcher(output);
			while (matcher.find()) {
				String className = matcher.group(1);
				try {
					Class c = Class.forName(className, false,
							this.getClass().getClassLoader());
					if (null == c.getCanonicalName()) {
						System.out.print(c);
					} else {
						jreClasses.add(c.getCanonicalName());
					}
				} catch (ClassNotFoundException e) {
					e.printStackTrace();
				}
			}
		} catch (IOException e) {
			e.printStackTrace();
		}
		System.out.print(jreClasses.size());
	}
	public void renewSameTypeCreatedTimesMap() {
		sameTypeCreatedTimesMap.clear();
	}
	public void registerAbstractConcreteClassMappingSimple(
			Class<?> abstractClass, Class<?> concreteClass) {
		registerAbstractConcreteClassMappingSimple(abstractClass, concreteClass,
				(Method) null, null);
	}
	public void registerAbstractConcreteClassMappingSimple(
			Class<?> abstractClass, Class<?> concreteClass,
			String factoryMethodName) {
		registerAbstractConcreteClassMappingSimple(abstractClass, concreteClass,
				factoryMethodName, null);
	}
	public void registerAbstractConcreteClassMappingSimple(
			Class<?> abstractClass, Class<?> concreteClass,
			String factoryMethodName, String methodParamVariables[]) {
		Method ms[] = Common.getAllDeclaredPublicMethodsForTest(concreteClass);
		for (Method m : ms) {
			if (m.getName().equals(factoryMethodName)) {
				registerAbstractConcreteClassMappingSimple(abstractClass,
						concreteClass, m, methodParamVariables);
				break;
			}
		}
	}
	public void registerAbstractConcreteClassMappingSimple(
			Class<?> abstractClass, Class<?> concreteClass,
			Method factoryMethod, String methodParamVariables[]) {
		AbstractConcreteClassMapping mapping = new AbstractConcreteClassMapping();
		mapping.setAbstractClass(abstractClass);
		mapping.setConcreteClass(concreteClass);
		if (factoryMethod != null) {
			mapping.setConcreteCFactoryMethod(factoryMethod);
			if (factoryMethod.getParameterCount() > 0)
				mapping.setMethodParamVariables(methodParamVariables);
		}
		register(mapping);
	}
	public void register(
			AbstractConcreteClassMapping abstractConcreteClassMapping) {
		abstractConcreteClassMap
				.put(abstractConcreteClassMapping.getAbstractClass(),
						abstractConcreteClassMapping);
	}
	public void resetVariableMap() {
		variableMap = Common.createVariableMap();
	}
	public Map<Class<?>, AbstractConcreteClassMapping> getAbstractConcreteClassMap() {
		return abstractConcreteClassMap;
	}
	public void setAbstractConcreteClassMap(
			Map<Class<?>, AbstractConcreteClassMapping> abstractConcreteClassMap) {
		this.abstractConcreteClassMap = abstractConcreteClassMap;
	}
	public List<String> getCreatedMethodName() {
		return createdMethodName;
	}
	public void setCreatedMethodName(List<String> createdMethodName) {
		this.createdMethodName = createdMethodName;
	}
	public Map<String, String> getVariableMap() {
		return variableMap;
	}
	public void setVariableMap(Map<String, String> variableMap) {
		this.variableMap = variableMap;
	}
	public List<Class> getAlreadyImportClasses() {
		return alreadyImportClasses;
	}
	public void setAlreadyImportClasses(List<Class> alreadyImportClasses) {
		this.alreadyImportClasses = alreadyImportClasses;
	}
	public Map<Class, String> getClassSimpleNameMap() {
		return classSimpleNameMap;
	}
	public void setClassSimpleNameMap(Map<Class, String> classSimpleNameMap) {
		this.classSimpleNameMap = classSimpleNameMap;
	}
	public Map<MethodCallingKey, MethodCallingVariable> getComplexTypeCreateMapping() {
		return complexTypeCreateMapping;
	}
	public void setComplexTypeCreateMapping(
			Map<MethodCallingKey, MethodCallingVariable> complexTypeCreateMapping) {
		this.complexTypeCreateMapping = complexTypeCreateMapping;
	}
	public List<Field> getAllFieldList() {
		return allFieldList;
	}
	public void setAllFieldList(List<Field> allFieldList) {
		this.allFieldList = allFieldList;
	}
	public StringBuilder getPackageSB() {
		return packageSB;
	}
	public void setPackageSB(StringBuilder packageSB) {
		this.packageSB = packageSB;
	}
	public StringBuilder getImportSB() {
		return importSB;
	}
	public void setImportSB(StringBuilder importSB) {
		this.importSB = importSB;
	}
	public StringBuilder getFieldsSB() {
		return fieldsSB;
	}
	public void setFieldsSB(StringBuilder fieldsSB) {
		this.fieldsSB = fieldsSB;
	}
	public StringBuilder getSetupSB() {
		return setupSB;
	}
	public void setSetupSB(StringBuilder setupSB) {
		this.setupSB = setupSB;
	}
	public StringBuilder getAllTestCaseSB() {
		return allTestCaseSB;
	}
	public void setAllTestCaseSB(StringBuilder allTestCaseSB) {
		this.allTestCaseSB = allTestCaseSB;
	}
	public StringBuilder getCreatedComplexTypeMethod() {
		return createdComplexTypeMethod;
	}
	public void setCreatedComplexTypeMethod(
			StringBuilder createdComplexTypeMethod) {
		this.createdComplexTypeMethod = createdComplexTypeMethod;
	}
	public StringBuilder getAddtionalMethods() {
		return addtionalMethods;
	}
	public void setAddtionalMethods(StringBuilder addtionalMethods) {
		this.addtionalMethods = addtionalMethods;
	}
	public Map<Class, MethodMatcher> getMethodMatchers() {
		return methodMatchers;
	}
	public Map<Class<?>, Short> getSameTypeCreatedTimesMap() {
		return sameTypeCreatedTimesMap;
	}
	public void setSameTypeCreatedTimesMap(
			Map<Class<?>, Short> sameTypeCreatedTimesMap) {
		this.sameTypeCreatedTimesMap = sameTypeCreatedTimesMap;
	}
	public boolean isGenFullQualifierName() {
		return genFullQualifierName;
	}
	public void setGenFullQualifierName(boolean genFullQualifierName) {
		this.genFullQualifierName = genFullQualifierName;
	}
	public void setMethodMatchers(Map<Class, MethodMatcher> methodMatchers) {
		this.methodMatchers = methodMatchers;
	}
	public static String getLocalRepoDir() {
		return localRepoDir;
	}
	public static void setLocalRepoDir(String localRepoDir) {
		CodeGenContext.localRepoDir = localRepoDir;
	}
	public static String getPathRegex() {
		String pathRegex = File.separator;
		if ("\\".equals(pathRegex)) {
			pathRegex = "\\\\";
		}
		return pathRegex;
	}
	public List<String> getLoadedClassesName() {
		List<String> loadedClassesName = new ArrayList<>();
		loadedClassesName.add("");
		loadedClassesName.addAll(this.jrePrimitiveTypes);
		if (null != this.reloadableDynamicClassLoaderOwner
				.getDirDynamicClassLoader()) {
			loadedClassesName.addAll(this.reloadableDynamicClassLoaderOwner
					.getDirDynamicClassLoader().getAllClassNamesInDir());
		}
		loadedClassesName.addAll(this.jreClasses);
		if (null != this.reloadableDynamicClassLoaderOwner
				.getJarDynamicClassLoader()) {
			loadedClassesName.addAll(this.reloadableDynamicClassLoaderOwner
					.getJarDynamicClassLoader().getAllClassNamesInJar());
		} else {
		}
		return loadedClassesName;
	}
	public int getClipBoardMonitorServerPort() {
		return clipBoardMonitorServerPort;
	}
	public void setClipBoardMonitorServerPort(int clipBoardMonitorServerPort) {
		this.clipBoardMonitorServerPort = clipBoardMonitorServerPort;
	}
	public List<Class> getAttachedClzList() {
		return attachedClzList;
	}
	public Map<Class<?>, Object> getUiModelMap() {
		return uiModelMap;
	}
	public static String getMavenHome() {
		return mavenHome;
	}
	public static void setMavenHome(String mavenHome) {
		CodeGenContext.mavenHome = mavenHome;
	}
	public byte[] getAppBytes() {
		return appBytes;
	}
	public void setAppBytes(byte[] appBytes) {
		this.appBytes = appBytes;
	}
	public ReloadableDynamicClassLoaderOwner getReloadableDynamicClassLoaderOwner() {
		return reloadableDynamicClassLoaderOwner;
	}
	public void setReloadableDynamicClassLoaderOwner(
			ReloadableDynamicClassLoaderOwner reloadableDynamicClassLoaderOwner) {
		this.reloadableDynamicClassLoaderOwner = reloadableDynamicClassLoaderOwner;
	}
	public List<String> getJreClasses() {
		return jreClasses;
	}
	public void setJreClasses(List<String> jreClasses) {
		this.jreClasses = jreClasses;
	}
	public File getPomFile() {
		return pomFile;
	}
	public void setPomFile(File pomFile) {
		this.pomFile = pomFile;
	}
	public List<String> getJrePrimitiveTypes() {
		return jrePrimitiveTypes;
	}
	public static List<String> getMemoryAreas() {
		return memoryAreas;
	}
	public Map<String, Object> getParamPossibleValsMap() {
		return paramPossibleValsMap;
	}
	public static void setCGKeyAppPath(String cgKeyAppPath) {
		CodeGenContext.CGKeyAppPath = cgKeyAppPath;
	}
	public static String getCGKeyAppPath() {
		return CGKeyAppPath;
	}
	public static String getIDEProcNameKeyword() {
		return IDEProcNameKeyword;
	}
	public static void setIDEProcNameKeyword(String IDEProcNameKeyword) {
		CodeGenContext.IDEProcNameKeyword = IDEProcNameKeyword;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\codegen\complexobj\PojoSetterGenerator.java---
package codegen.complexobj;
import codegen.AbstractConcreteClassMapping;
import codegen.Replacement;
import codegen.Syntax;
import codegen.util.Common;
import objinit.ObjWithDefaultValCreator;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.lang.reflect.Parameter;
import java.util.*;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Collectors;
public class PojoSetterGenerator {
	private static StringBuilder allSetSB = new StringBuilder();
	private static final int START_DEEP_INDEX = 1;
	private static List<String> concernedPackageNames = new ArrayList<String>();
	private static List<ClzRefDeep> deepList = new ArrayList<ClzRefDeep>();
	public static List<String> allFieldList = new ArrayList<String>();
	private static CodeGenContext context;
	public static List<Class> calcedList = new ArrayList<>();
	public static Map<Class, AtomicInteger> circularDependencyClz = new HashMap<>();
	public static void init() {
	}
	public static void clear() {
		allSetSB = new StringBuilder();
		calcedList.clear();
		circularDependencyClz.clear();
		concernedPackageNames.clear();
		deepList.clear();
		allFieldList.clear();
		context.getSameTypeCreatedTimesMap().clear();
	}
	public static String getInstanceName(Class c) {
		return Common.getInstanceName(c);
	}
	public static String printAllListFields(Class c) {
		if (c.getSimpleName().equals("String") || c.getSimpleName().equals("Integer")
				|| c.getSimpleName().equals("Long")) {
			return "";
		}
		String instanceName = getInstanceName(c);
		StringBuilder sb = new StringBuilder();
		Field fArray[] = c.getDeclaredFields();
		List<Field> fList = (List) Arrays.asList(fArray);
		fList.forEach(f -> {
			String simpleName = f.getType().getSimpleName();
			String genericTypeName = f.getGenericType().getTypeName();
			if (genericTypeName.startsWith("java.util.List")) {
				String genericType = null;
				String genericTypeNameForPrint = null;
				int start = genericTypeName.indexOf("<");
				int end = genericTypeName.indexOf(">");
				genericType = genericTypeName.substring(start + 1, end);
				genericTypeNameForPrint = genericType.replaceAll("\\$", "\\.");
				String listName = null;
				try {
					listName = getInstanceName(CodeGenContext.getInstance().getReloadableDynamicClassLoaderOwner()
							.loadClass(genericType, true)) + "List";
				} catch (Exception e1) {
					e1.printStackTrace();
				}
				StringBuilder refType = new StringBuilder();
				refType.append("List<").append(genericTypeNameForPrint).append("> ").append(listName).append("=")
						.append(" new ").append(" ArrayList<").append(genericTypeNameForPrint).append(">();\r\n");
				allSetSB.append(refType.toString());
			}
		});
		return sb.toString();
	}
	public class ClzRefDeep<T> {
		int i;
		Class<T> c;
		Class genericTypes[];
		boolean hasCollectionReturn;
		public int getI() {
			return i;
		}
		public void setI(int i) {
			this.i = i;
		}
		public Class<T> getC() {
			return c;
		}
		public void setC(Class<T> c) {
			this.c = c;
		}
		public boolean isHasCollectionReturn() {
			return hasCollectionReturn;
		}
		public void setHasCollectionReturn(boolean hasCollectionReturn) {
			this.hasCollectionReturn = hasCollectionReturn;
		}
		public Class[] getGenericTypes() {
			return genericTypes;
		}
		public void setGenericTypes(Class[] genericTypes) {
			this.genericTypes = genericTypes;
		}
		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;
			result = prime * result + ((c == null) ? 0 : c.hashCode());
			result = prime * result + Arrays.hashCode(genericTypes);
			result = prime * result + i;
			return result;
		}
		@Override
		public boolean equals(Object obj) {
			if (this == obj)
				return true;
			if (obj == null)
				return false;
			if (getClass() != obj.getClass())
				return false;
			ClzRefDeep other = (ClzRefDeep) obj;
			/*
			 * if (!getOuterType().equals(other.getOuterType())) return false;
			 */
			if (c == null) {
				if (other.c != null)
					return false;
			} else if (!c.equals(other.c))
				return false;
			if (!Arrays.equals(genericTypes, other.genericTypes))
				return false;
			if (i != other.i)
				return false;
			return true;
		}
		/*
		 * private ObjSetCodeGenAfterCreateMethod getOuterType() { return
		 * ObjSetCodeGenAfterCreateMethod.this; }
		 */
	}
	public static boolean containsIgnoreCase(Collection<String> coll, final String val) {
		return coll.stream().anyMatch(e -> {
			boolean b = e.equalsIgnoreCase(val);
			return b;
		});
	}
	public static String getClassCreateStr(Class c) {
		if (c.isEnum()) {
			return Common.getEnumCreateStr(c);
		} else if (c.isArray()) {
			return getObjCreateStrWithNew(c);
		} else {
			return getObjCreateStrWithNew(c);
		}
	}
	public static String getObjCreateStrWithNew(Class c) {
		StringBuilder sb = new StringBuilder();
		String classNameForPrint = Common.getClassName(c, context);
		if (classNameForPrint.indexOf("$") != -1) {
			classNameForPrint = classNameForPrint.replaceAll("\\$", "\\.");
		}
		sb.append(" new ").append(classNameForPrint).append("()");
		return sb.toString();
	}
	public static  String genNewClz(Class c) {
		StringBuilder sb = new StringBuilder();
		String classNameForPrint = Common.getClassName(c, context);
		if (classNameForPrint.indexOf("$") != -1) {
			classNameForPrint = classNameForPrint.replaceAll("\\$", "\\.");
		}
		String instanceName = Common.getInstanceName(c, context.getSameTypeCreatedTimesMap());
		sb.append(classNameForPrint).append(" ").append(instanceName).append(" = ").append(getClassCreateStr(c))
				.append(";\r\n");
	    return sb.toString();
	}
	public static String printAllSet(Class c, CodeGenContext context) {
		return printAllSet(c, new HashMap(), null, context);
	}
	public static String printAllSet(Class c, Map<Class, String> typeInstanceNames, Class genericTypes[],
			CodeGenContext context) {
		if (!Common.isComplexType(c)) {
			return "";
		}
		String instanceName = Common.getInstanceName(c);
		StringBuilder sb = new StringBuilder();
		typeInstanceNames.put(c, instanceName);
		allFieldList.clear();
		Common.getAllFieldNames(c, concernedPackageNames, allFieldList);
		List<String> incompleteFieldNames = allFieldList;
		Method methods[] = c.getMethods();
		List<Method> methodList = (List) Arrays.asList(methods);
		List<Method> allSetMethods = methodList.stream().filter(m -> {
			boolean isFieldSet = false;
			if (m.getName().startsWith("set") || m.getName().startsWith("is") || m.getName().startsWith("has")) {
				int paramCount = m.getParameterCount();
				if (paramCount == 1) {
					isFieldSet = true;
					String fieldName = null;
					if (m.getName().startsWith("set") || m.getName().startsWith("has")) {
						fieldName = m.getName().substring(3, m.getName().length());
					} else if (m.getName().startsWith("is")) {
						fieldName = m.getName().substring(2, m.getName().length());
					}
					incompleteFieldNames.remove(Common.makeFirstCharInLowercase(fieldName));
				}
			}
			return isFieldSet;
		}).collect(Collectors.toList());
		allSetMethods.forEach(m -> {
			Parameter p[] = m.getParameters();
			if (p != null) {
				Parameter p1 = p[0];
				String typeName = null;
				typeName = p1.getParameterizedType().getTypeName();
				if (typeName.startsWith("java.util.List")) {
					String genericType = null;
					int start = typeName.indexOf("<");
					int end = typeName.indexOf(">");
					genericType = typeName.substring(start + 1, end);
					String listName = null;
					String listItemName = null;
					Class pClass = null;
					try {
						pClass = CodeGenContext.getInstance().getReloadableDynamicClassLoaderOwner()
								.loadClass(genericType, true);
						listItemName = Common.getInstanceName(pClass, context.getSameTypeCreatedTimesMap());
						listName = listItemName + "List";
					} catch (Exception e1) {
						e1.printStackTrace();
					}
					StringBuilder refType = new StringBuilder();
					String genericTypeForPrint = genericType.replaceAll("\\$", "\\.");
					refType.append("List<").append(genericTypeForPrint).append("> ").append(listName).append("=")
							.append(" new ").append(" ArrayList<").append(genericTypeForPrint).append(">();\r\n");
					String defaultVal = null;
					if (typeInstanceNames.containsKey(pClass)) {
						defaultVal = typeInstanceNames.get(pClass);
					} else {
						defaultVal = Common.getDefaultVal(pClass);
					}
					refType.append(listName).append(".add(").append(defaultVal).append(");\r\n");
					allSetSB.append(refType.toString());
					sb.append(instanceName).append(".").append(m.getName()).append("(").append(listName)
							.append(");\r\n");
				} else {
					if (Common.isComplexType(p1.getType())) {
						if (context.getAbstractConcreteClassMap().containsKey(p1.getType())) {
							AbstractConcreteClassMapping cm = context.getAbstractConcreteClassMap().get(p1.getType());
							Class cc = cm.getConcreteClass();
							sb.append(instanceName).append(".").append(m.getName()).append("(")
									.append(Common.getInstanceName(cc)).append(");\r\n");
						} else {
							sb.append(instanceName).append(".").append(m.getName()).append("(")
									.append(Common.getDefaultVal(p1)).append(");\r\n");
						}
					} else {
						sb.append(instanceName).append(".").append(m.getName()).append("(")
								.append(Common.getDefaultVal(p1)).append(");\r\n");
					}
				}
			}
		});
		if (incompleteFieldNames.size() > 0) {
			List<Method> listGetMethods = methodList.stream().filter(m -> {
				boolean isListFieldGet = false;
				if (m.getName().startsWith("get")) {
					int paramCount = m.getParameterCount();
					if (paramCount == 0) {
						String fieldNameInMethod = m.getName().substring(3);
						String fieldInstanceName = Common.makeFirstCharInLowercase(fieldNameInMethod);
						if (containsIgnoreCase(incompleteFieldNames, fieldInstanceName)
								&& Common.isMethodReturnCollectionType(m)) {
							isListFieldGet = true;
							incompleteFieldNames.remove(fieldInstanceName);
						}
					}
				}
				return isListFieldGet;
			}).collect(Collectors.toList());
			listGetMethods.forEach(m -> {
				String fieldNameInMethod = m.getName().substring(3);
				String fieldInstanceName = Common.makeFirstCharInLowercase(fieldNameInMethod);
				String typeName = m.getGenericReturnType().getTypeName();
				String genericType = null;
				int start = typeName.indexOf("<");
				int end = typeName.indexOf(">");
				genericType = typeName.substring(start + 1, end);
				Class listGenericType = null;
				try {
					listGenericType = CodeGenContext.getInstance().getReloadableDynamicClassLoaderOwner()
							.loadClass(genericType, true);
				} catch (Exception e1) {
					e1.printStackTrace();
				}
				if (!Common.isComplexType(listGenericType)) {
					sb.append(instanceName).append(".").append(m.getName()).append("().add(")
							.append(Common.getDefaultVal(listGenericType)).append(");\r\n");
				} else {
					String defaultVal = null;
					if (typeInstanceNames.containsKey(listGenericType)) {
						defaultVal = typeInstanceNames.get(listGenericType);
					} else {
						defaultVal = fieldInstanceName;
					}
					sb.append(instanceName).append(".").append(m.getName()).append("().add(").append(defaultVal)
							.append(");\r\n");
				}
			});
		}
		if (Common.isACollection(c) && genericTypes != null && genericTypes[0] != null) {
			Class gt = genericTypes[0];
			if (Common.isComplexType(gt)) {
				String gtInstanceName = Common.getInstanceName(gt);
				sb.append(instanceName).append(".").append("add").append("(").append(gtInstanceName).append(");\r\n");
			} else {
				sb.append(instanceName).append(".").append("add").append("(").append(Common.getDefaultVal(gt))
						.append(");\r\n");
			}
		}
		allSetSB.append(sb.toString());
		return sb.toString();
	}
	public static String generateCode(Class c, Class genericTypes[], CodeGenContext context) {
		if (null == c) {
			return "";
		}
		if (c.isInterface() || c.getEnclosingClass() != null) {
			return "";
		}
		if (c.isArray()) {
			c = c.getClass().getComponentType();
		}
		List<String> concernedPacks = Common.getDefaultConcernedPacks(c);
		if (genericTypes != null) {
			for (Class gt : genericTypes) {
				if (gt != null) {
					concernedPacks.addAll(Common.getDefaultConcernedPacks(gt));
				}
			}
		}
		return generateCode(c, genericTypes, concernedPacks, context);
	}
	public static String generateCode(Class c, CodeGenContext context) {
		return generateCode(c, (Class[]) null, context);
	}
	public static String generateCode(Class c, List<String> concernedPacks, CodeGenContext context) {
		return generateCode(c, (Class[]) null, concernedPacks, context);
	}
	public static String generateCode(Class c, Class genericTypes[], List<String> concernedPacks,
			CodeGenContext context) {
		return generateCodeWithoutRecursive(c, concernedPacks, context, true);
	}
	public static String generateCodeold(Class c, Class genericTypes[], List<String> concernedPacks,
			CodeGenContext context) {
		ObjWithDefaultValCreator obf = new ObjWithDefaultValCreator();
		List<Class<?>> allComplextTypes = new ArrayList<>();
		concernedPackageNames = concernedPacks;
		deepList.clear();
		String code = "";
		try {
			PojoSetterGenerator.context = context;
			Map<Class, String> typeInstanceNames = new HashMap<>();
			allComplextTypes.addAll(obf.getAllReferComplexType(c));
			if (genericTypes != null) {
				for (Class gt : genericTypes) {
					allComplextTypes.addAll(obf.getAllReferComplexType(gt));
				}
			}
			deepList=allComplextTypes.stream().map(e-> {
				ClzRefDeep cdf = new PojoSetterGenerator().new ClzRefDeep();
				cdf.setC(e);
				cdf.setI(0);
				cdf.setHasCollectionReturn(false);
				return cdf;
			}).collect(Collectors.toList());
			StringBuilder allNewClzCodeLines = new StringBuilder();
			allComplextTypes.stream().forEach(e-> {
				allNewClzCodeLines.append(PojoSetterGenerator.genNewClz(e)); 
			});
			deepList.forEach(cd -> {
				Class clzTmp = cd.getC();
				try {
					Common.importC(clzTmp, context);
					printAllSet(clzTmp, typeInstanceNames, cd.getGenericTypes(), context);
				} catch (Exception e) {
					e.printStackTrace();
				}
				;
			});
			allSetSB.insert(0, allNewClzCodeLines.toString());
			code = allSetSB.toString();
			allSetSB = new StringBuilder();
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			clear();
		}
		return code;
	}
	public static String generateCodeWithoutRecursive(Class c, CodeGenContext context, boolean clearAfterFinish) {
		List<String> concernedPacks = Common.getDefaultConcernedPacks(c);
		return generateCodeWithoutRecursive(c, concernedPacks, context, clearAfterFinish);
	}
	public static String generateCodeWithoutRecursive(Class c, CodeGenContext context) {
		List<String> concernedPacks = Common.getDefaultConcernedPacks(c);
		return generateCodeWithoutRecursive(c, concernedPacks, context);
	}
	public static String generateCodeWithoutRecursive(Class c, List<String> concernedPacks, CodeGenContext context) {
		return generateCodeWithoutRecursive(c, concernedPacks, context, true);
	}
	public static String generateCodeWithoutRecursive(Class c, List<String> concernedPacks, CodeGenContext context,
			boolean clearAfterFinish) {
		context.getVariableMap().put(Replacement.TMP_CLASS_NAME.name(), c.getSimpleName());
		context.getVariableMap().put(Replacement.TMP_INSTANCE_NAME.name(), Common.getInstanceName(c));
		String str;
		try {
			str = Common.replaceAllKeyWord(Syntax.PODAM_INIT_POJO, context.getVariableMap());
		} catch (Exception e) {
			e.printStackTrace();
			str="";
		}
		return str;
	}
	public static String generateCodeWithoutRecursiveOld(Class c, List<String> concernedPacks, CodeGenContext context,
			boolean clearAfterFinish) {
		concernedPackageNames = concernedPacks;
		PojoSetterGenerator.context = context;
		StringBuilder sb = new StringBuilder();
		try {
			sb.append(PojoSetterGenerator.genNewClz(c)); 
			String str = printAllSet(c, context);
			sb.append(str);
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (clearAfterFinish) {
				clear();
			}
		}
		return sb.toString();
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\codegen\Const.java---
package codegen;
public final class Const {
	public static String CLASS_SIMPLE_NAME_KEY = "ClassSimpleName";
	public static String CLASS_NAME_KEY = "ClassName";
	public static final int MIN_FONT_SIZE = 10;
	public static final int MAX_FONT_SIZE = 45;
	public static final int MIN_BACK_COLOR_UNMATCH = 3;
	public static final double MAX_BACKGROUND_COLOR_UNMATCH_PERCENTAGE = 0.02;
	public static final double MAX_FONT_COLOR_UNMATCH_PERCENTAGE = 0.02;
	public static final int MIN_FONT_COLOR_UNMATCH = 3;
	public static final String SPECIFY_CLASS = "specify a class";
	public static final String OUTPUT_SYS_PROPERTY_NAME = "output";
	public static final String MEMORY_FILE_PATH_NAME = "botbrain";
	public static final String BRAIN_LOCAL_REPO_PROPERTY_KEYWORD = "local_repository";
	public static final String BRAIN_LOCAL_REPO_KEYWORD = "local repository";
	public static final String BRAIN_MVN_HOME_KEYWORD = "maven home";
	public static final String CLIPBOARD_CLIENT_APP_PATH_KEYWORD = "clipboard app path";
	public static final String BRAIN_LAST_PROJECT_KEYWORD = "last project";
	public static final String BRAIN_CG_KEY_APP_KEYWORD = "cgkey_app";
	public static final String BRAIN_IDE_PROC_KEYWORD = "ide_proc_name_keyword";
	public static final int MAX_WAIT_TIME = 3;
	public static final String MEMORY_KEYWORD_MAPPING_KEY = "memoryKeywords";
	public static final String MEMORY_AREA_KEY = "table";
}
----strat of file D:\projects\cg\cg-min\src\main\java\codegen\DBNameEnum.java---
package codegen;
public enum DBNameEnum {
	CODING_LOGIC_TABLE("coding logic", "codearea");
	private String uiName = "";
	private String tableName = "";
	DBNameEnum(String uiName, String tableName) {
		this.uiName = uiName;
		this.tableName = tableName;
	}
	public String getUiName() {
		return uiName;
	}
	public String getTableName() {
		return tableName;
	}
	public static String getTableNameByUiName(String uiName) {
		String s = "";
		DBNameEnum[] des = DBNameEnum.values();
		for (int i = 0; i < des.length; i++) {
			if (des[i].getUiName().equalsIgnoreCase(uiName)) {
				s = des[i].getTableName();
			}
		}
		return s;
	}
	public static String getUiNameByTableName(String tableName) {
		String s = "";
		DBNameEnum[] des = DBNameEnum.values();
		for (int i = 0; i < des.length; i++) {
			if (des[i].getTableName().equalsIgnoreCase(tableName)) {
				s = des[i].getUiName();
			}
		}
		return s;
	}
	public static String[] getAllUiName() {
		String[] names = new String[DBNameEnum.values().length];
		DBNameEnum[] des = DBNameEnum.values();
		for (int i = 0; i < des.length; i++) {
			names[i] = des[i].getUiName();
		}
		return names;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\codegen\eclipseRobot\Const.java---
package codegen.eclipseRobot;
import java.io.File;
import java.util.Arrays;
import java.util.List;
public class Const {
	public static final int MAX_FONT_SIZE = 20;
	public static final int MIN_FONT_SIZE = 10;
	public static final double MAX_FONT_COLOR_UNMATCH_PERCENTAGE = 0.02;
	public static final int MIN_FONT_COLOR_UNMATCH = 3;
	public static final int MIN_BACK_COLOR_UNMATCH = 2;
	public static final double MAX_BACKGROUND_COLOR_UNMATCH_PERCENTAGE = 0.01;
	public static final String CHECKBOX_FOR_CREATE_CONSTRUCTOR_WHEN_NEW_CLASS_RS_NAME = null;
	public static final String BTN_ADD_INTERFACE_WHEN_NEW_CLASS_RS_NAME = null;
	public static final String TEXT_FIELD_SUPER_CLASS_WHEN_NEW_CLASS_RS_NAME = null;
	public static final String CLASS_NAME_WHEN_NEW_CLASS_RS_NAME = null;
	public static final String PACKNAME_WHEN_NEW_CLASS_RS_NAME = null;
	public static final String NEW_CLASS_IN_POP_MENU_RS_NAME = null;
	public static final List<Class<?>> primitiveClz = Arrays.asList(
			new Class[] { String.class, int.class, boolean.class, long.class, double.class, short.class,
					float.class, byte.class, char.class, Integer.class, Boolean.class, Long.class, Double.class,
					Short.class, Float.class, Byte.class, Character.class, java.sql.Date.class, java.util.Date.class,
					java.sql.Timestamp.class, java.math.BigInteger.class, java.math.BigDecimal.class,
					javax.xml.datatype.XMLGregorianCalendar.class, File.class, Object.class });
	public static final List<Class<?>> returnTypePrimitiveClz = Arrays.asList(
			new Class[] { String.class, int.class, boolean.class, long.class, double.class, short.class,
					float.class, byte.class, char.class, Integer.class, Boolean.class, Long.class, Double.class,
					Short.class, Float.class, Byte.class, Character.class, java.sql.Date.class, java.util.Date.class,
					java.sql.Timestamp.class, java.math.BigInteger.class, java.math.BigDecimal.class,
					javax.xml.datatype.XMLGregorianCalendar.class, File.class, Object.class, void.class });
	public static final String ECLIPSE_WINDOW_TITLE_KEYWORD = "eclipse";
	public static enum WinOperationEnum {
		RESIZE("resize"), SWITCH_ECLIPSE("switchProcess"), GET_ACTIVE_WINDOW("getActiveWindow");
		String value;
		private WinOperationEnum(String value) {
			this.value = value;
		}
		public void setValue(String value) {
			this.value = value;
		}
		public String getValue() {
			return value;
		}
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\codegen\eclipseRobot\Converter.java---
package codegen.eclipseRobot;
import codegen.complexobj.CodeGenContext;
import codegen.util.Common;
import javax.xml.datatype.DatatypeConfigurationException;
import javax.xml.datatype.DatatypeFactory;
import javax.xml.datatype.XMLGregorianCalendar;
import java.io.File;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.GregorianCalendar;
public class Converter {
	static SimpleDateFormat sdf = new SimpleDateFormat("yyyyMMdd");
	private static DatatypeFactory df = null;
	static {
		try {
			df = DatatypeFactory.newInstance();
		} catch (DatatypeConfigurationException dce) {
			throw new IllegalStateException("Exception", dce);
		}
	}
	public static XMLGregorianCalendar toXMLGregorianCalendar(Date date) {
		if (date == null) {
			return null;
		} else {
			return toXMLGregorianCalendar(date.getTime());
		}
	}
	public static XMLGregorianCalendar toXMLGregorianCalendar(long timeInMillis) {
		GregorianCalendar gc = new GregorianCalendar();
		gc.setTimeInMillis(timeInMillis);
		return df.newXMLGregorianCalendar(gc);
	}
	public static Object convert(Object source, Class targetType) throws Exception {
		return convert(source, targetType, ",");
	}
	public static Object convert(Object source, Class targetType, String delimiter) throws Exception {
		Object o = null;
		if (targetType == Class.class) {
			o = Common.getClzByName(source.toString());
		} else if (targetType == Boolean.class || targetType == boolean.class) {
			o = source;
		} else if (targetType == Long.class || targetType == long.class) {
			o = Long.parseLong(source.toString().trim());
		} else if (targetType == Double.class || targetType == double.class) {
			o = Double.parseDouble(source.toString().trim());
		} else if (targetType == int.class || targetType == Integer.class) {
			o = Integer.parseInt(source.toString().trim());
		} else if (targetType == Short.class || targetType == short.class) {
			o = Short.parseShort(source.toString().trim());
		} else if (targetType == Float.class || targetType == float.class) {
			o = Float.parseFloat(source.toString().trim());
		} else if (targetType == Byte.class || targetType == byte.class) {
			o = Byte.parseByte(source.toString().trim());
		} else if (targetType == Date.class) {
			o = sdf.parse(source.toString().trim());
		} else if (targetType == BigInteger.class) {
			o = new BigInteger(source.toString().trim());
		} else if (targetType == BigDecimal.class) {
			o = new BigDecimal(source.toString().trim());
		} else if (targetType == XMLGregorianCalendar.class) {
			Date d = sdf.parse(source.toString().trim());
			o = toXMLGregorianCalendar(d);
		} else if (targetType == File.class) {
			File file = new File(source.toString().trim());
			o = file;
		} else if (targetType.isArray()) {
			if (targetType.getComponentType() == Class.class) {
				String classNames[] = (source == null || source.toString().trim().equals("")) ? new String[] {}
						: source.toString().trim().split(delimiter, -1);
				Class c[] = new Class[classNames.length];
				for (int i = 0; i < classNames.length; i++) {
					String s = classNames[i];
					c[i] = Common.getClzByName(s.trim());
				}
				o = c;
			} else if (targetType.getComponentType() == File.class) {
				String names[] = (source == null || source.toString().trim().equals("")) ? new String[] {}
						: source.toString().trim().split(delimiter, -1);
				File fs[] = new File[names.length];
				for (int i = 0; i < names.length; i++) {
					String s = names[i];
					fs[i] = new File(s);
				}
				o = fs;
			} else {
				o = source.toString().equals("") ? null : source.toString().trim().split(delimiter, -1);
			}
		} else if (targetType == CodeGenContext.class) {
			try {
				Class contextC = CodeGenContext.getInstance().getReloadableDynamicClassLoaderOwner()
						.loadClass(source.toString(), true);
				o = contextC.newInstance();
			} catch (Exception e) {
			}
		} else {
			o = source.toString();
		}
		return o;
	}
	public static void main(String[] args) {
		try {
			convert("java.lang.Exception", Class[].class);
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\codegen\eclipseRobot\DataModel.java---
package codegen.eclipseRobot;
import codegen.complexobj.CodeGenContext;
import codegen.util.Common;
import com.dgs.annotation.ServiceMethodAnn;
import java.io.File;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
public class DataModel {
	private EventObject eventObject;
	Method methods[];
	private String selectedItem;
	Method selectedMethod;
	private Object params[];
	private Object paramPossibleVals[];
	CodeGenContext context;
	Class selectedClz;
	public static int DEFAULT_TEXTAREA_COLS = 8;
	public static int DEFAULT_TEXTAREA_ROWS = 5;
	public String getSelectedItem() {
		return selectedItem;
	}
	public void setSelectedItem(String selectedItem) {
		this.selectedItem = selectedItem;
	}
	public List<String> getItems() {
		List<String> list = new ArrayList<>();
		if (methods != null && methods.length > 0) {
			for (Method m : methods) {
				ServiceMethodAnn annotation = m.getAnnotation(ServiceMethodAnn.class);
				if (annotation != null && annotation.visible()) {
				}
				list.add(annotation.keyword()[0]);
			}
		}
		return list;
	}
	public void resetMs(Class... serviceClazz) {
		List<Method> allMethods = new ArrayList<>();
		Method[] ms = null;
		for(Class serviceClz : serviceClazz) {
			ms = Common.getAllPublicMethods(serviceClz);
			Collections.addAll(allMethods, ms);
		}
		if(null==ms) {
			ms = new Method[] {};
		}
		for (Class<?> c : context.getAttachedClzList()) {
			Method[] tmpms = Common.getAllPublicMethods(c);
			Collections.addAll(allMethods, tmpms);
		}
		List<Method> list = allMethods.stream().filter(m -> {
			ServiceMethodAnn annotation = m.getAnnotation(ServiceMethodAnn.class);
			if (annotation == null || !annotation.visible()) {
				return false;
			}
			if (!m.getName().equals("main") && m.getDeclaringClass() != Object.class) {
				if (m.getName().equals("genBatchCreateMethods")) {
					String NEW_FIELD_MATCH_WORD = "newfield";
				}
				Class pc[] = m.getParameterTypes();
				boolean allPrimitiveType = true;
				for (Class c : pc) {
					if (c.isArray()) {
						c = c.getComponentType();
					}
					if (c != CodeGenContext.class && c != Class.class && c != File.class && Common.isComplexType(c)) {
						return false;
					}
				}
				return allPrimitiveType;
			} else
				return false;
		}).distinct().collect(Collectors.toList());
		final String highestPriorityMethodNameRegex = "(?i)genCode";
		final String highPriorityMethodNameRegex = "(?i)gen.+";
		Pattern hp = Pattern.compile(highestPriorityMethodNameRegex);
		Pattern p1 = Pattern.compile(highPriorityMethodNameRegex);
		list.sort(new Comparator<Method>() {
			@Override
			public int compare(Method o1, Method o2) {
				Matcher m1 = hp.matcher(o1.getName());
				Matcher m2 = hp.matcher(o2.getName());
				Matcher m3 = p1.matcher(o1.getName());
				Matcher m4 = p1.matcher(o2.getName());
				boolean m1Find = m1.find();
				boolean m2Find = m2.find();
				boolean m3Find = m3.find();
				boolean m4Find = m4.find();
				if (m1Find || m2Find) {
					if (m1Find && m2Find) {
						return 0;
					} else if (m1Find && !m2Find) {
						return -1;
					} else {
						return 1;
					}
				} else if (m3Find || m4Find) {
					if (m3Find && m4Find) {
						return 0;
					} else if (m3Find && !m4Find) {
						return -1;
					} else {
						return 1;
					}
				} else {
					if (o1.getDeclaringClass() == o2.getDeclaringClass()) {
						return o1.getName().compareTo(o2.getName());
					} else {
						return o1.getDeclaringClass().getSimpleName().compareTo(o2.getDeclaringClass().getSimpleName());
					}
				}
			}
		});
		ms = list.toArray(new Method[] {});
		this.setMethods(ms);
	}
	public Method[] getMethods() {
		return methods;
	}
	public void setMethods(Method[] methods) {
		this.methods = methods;
	}
	public Method getSelectedMethod() {
		Method m = null;
		if (methods == null) {
			return m;
		}
		try {
			for (Method m1 : this.methods) {
				ServiceMethodAnn annotation = m1.getAnnotation(ServiceMethodAnn.class);
				if (annotation.keyword()[0].equals(this.selectedItem)) {
					m = m1;
					break;
				}
			}
		} catch (Exception e) {
		}
		return m;
	}
	public Object[] getParams() {
		return params;
	}
	public void setParams(Object... params) {
		this.params = params;
	}
	public CodeGenContext getContext() {
		return context;
	}
	public void setContext(CodeGenContext context) {
		this.context = context;
	}
	public Object[] getParamPossibleVals() {
		return paramPossibleVals;
	}
	public void setParamPossibleVals(Object... paramPossibleVals) {
		this.paramPossibleVals = paramPossibleVals;
	}
	public static void main(String[] args) {
		QualifierName qualifierName = DataModel.extractQualifierName("model.Profile");
	}
	public static QualifierName extractQualifierName(String string) {
		QualifierName qn = new QualifierName();
		if("".equals(string)) {
			return qn;
		}
		try {
			qn.setOrigContent(string);
			Pattern p1 = Pattern.compile("^(?:[\\w]+\\.)+");
			Matcher m1 = p1.matcher(string);
			if (m1.find()) {
				QualifierName.QualifierPart qp = qn.new QualifierPart();
				qp.setQualifierHead(m1.group());
				String lastPart = string.substring(qp.getQualifierHead().length());
				qp.setQualifierLastPart(lastPart);
				qn.setQp(qp);
				String packName = getByRegex(qn.getQp().getQualifierHead(), "^(?:[a-z0-9]+\\.)+");
				qn.setPackName(packName);
				String classQualifierNameRegex = "^(?:[a-z]+[\\w]*\\.)+(?:[A-Z]+[\\w]*\\.*)+";
				String classQualifierName = getByRegex(qn.getQp().getQualifierHead(), classQualifierNameRegex);
				if (classQualifierName == null || "".equals(classQualifierName)) {
					classQualifierName = getByRegex(qn.getOrigContent(), classQualifierNameRegex);
				}
				qn.setClassQualifierName(classQualifierName);
				if (classQualifierName != null && !"".equals(classQualifierName)) {
					qn.setClassQualifierName(classQualifierName);
					Class c = tryGetClass(qn.getClassQualifierName());
					if (c != null) {
						qn.setClz(c);
					}
					String nameSplit[] = classQualifierName.split("\\.");
					if (nameSplit.length > 0) {
						qn.setClzSimpleName(nameSplit[nameSplit.length - 1]);
					}
					if (qn.getQp().getQualifierLastPart() == null) {
						/*
						 * if(classQualifierName.toUpperCase().equals( classQualifierName) &&
						 * !classQualifierName.contains("_")){ }else{
						 * qn.setFieldName(classQualifierName); }
						 */
					} else {
						if (qn.getQp().getQualifierLastPart().contains("(")
								&& qn.getQp().getQualifierLastPart().contains(")")) {
							String methodName = getByRegex(qn.getQp().getQualifierLastPart(), "^([\\w\\d]+)\\(.+", 1);
							int firstBrace = string.indexOf("(");
							int closeBrace = string.indexOf(")");
							String params = string.substring(firstBrace + 1, closeBrace);
							String paramArray[] = splitParam(params);
							if (methodName.equals(qn.getClzSimpleName())) {
								qn.setConstructParam(paramArray);
								qn.setConstructor(true);
							} else {
								qn.setMethodName(methodName);
								qn.setMethodParam(paramArray);
							}
						} else {
							String fieldName = getByRegex(qn.getQp().getQualifierLastPart(), "^[a-z]+\\w*$");
							if (fieldName == null) {
								fieldName = getByRegex(qn.getQp().getQualifierLastPart(), "^(?:[A-Z]+_+)+[A-Z]*$");
							}
							qn.setFieldName(fieldName);
						}
					}
				}
			}
			if (string.endsWith(".class")) {
				String name = string.replaceAll(".class", "");
				qn.setClassQualifierName(name);
			} else if (string.contains("(")) {
			} else {
				Class c = qn.getClz();
				if (c != null) {
					Field f = tryGetField(c, qn.getQp().getQualifierLastPart());
					if (f != null) {
						qn.setField(f);
					}
				}
			}
		} catch (Exception e) {
		}
		return qn;
	}
	public static String getByRegex(String string, String regex, int groupIndex) {
		String matchedQualifierPart = "";
		Pattern p = Pattern.compile(regex);
		Matcher m = p.matcher(string);
		if (m.find()) {
			matchedQualifierPart = m.group(groupIndex);
			if (matchedQualifierPart.endsWith(".")) {
				matchedQualifierPart = matchedQualifierPart.substring(0, matchedQualifierPart.length() - 1);
			}
		}
		return matchedQualifierPart;
	}
	public static String getByRegex(String string, String regex) {
		return getByRegex(string, regex, 0);
	}
	public void setIfClassQualifier(String string, QualifierName qn) {
	}
	public void setIfMethodQualifier(String string, QualifierName qn) {
	}
	public void setIfFieldQualifier(String string, QualifierName qn) {
	}
	public static String[] splitParam(String paramStr) {
		int commaValidPos[] = DataModel.getCommaPositionInParamStr(paramStr);
		if (commaValidPos.length > 0) {
			String[] params = new String[commaValidPos.length + 1];
			int lastCommaP = 0;
			for (int i = 0; i < commaValidPos.length; i++) {
				int commaP = commaValidPos[i];
				String p = paramStr.substring(lastCommaP == 0 ? 0 : lastCommaP + 1, commaP);
				params[i] = p.trim();
				lastCommaP = commaP;
			}
			String lastP = paramStr.substring(commaValidPos[commaValidPos.length - 1] + 1);
			params[params.length - 1] = lastP.trim();
			return params;
		} else if (paramStr != null && !"".equals(paramStr.trim())) {
			return new String[] { paramStr.trim() };
		} else {
			return new String[] {};
		}
	}
	public static int[] getCommaPositionInParamStr(String paramStr) {
		int leftBraketCount = 0;
		int rightBraketCount = 0;
		List<Integer> list = new ArrayList<>();
		char[] chs = paramStr.toCharArray();
		for (int i = 0; i < chs.length; i++) {
			char ch = chs[i];
			if (ch == ',') {
				if (leftBraketCount == 0 && rightBraketCount == 0) {
					list.add(i);
				}
			} else if (ch == '<') {
				leftBraketCount++;
			} else if (ch == '>') {
				rightBraketCount++;
				if (rightBraketCount == leftBraketCount) {
					leftBraketCount = 0;
					rightBraketCount = 0;
				}
			}
		}
		int[] ps = list.stream().mapToInt(e -> e).toArray();
		return ps;
	}
	public static Class getOuterClass(String string) {
		Class c = null;
		try {
			c = CodeGenContext.getInstance().getReloadableDynamicClassLoaderOwner().loadClass(string, true);
		} catch (Exception e1) {
			e1.printStackTrace();
		}
		return c;
	}
	public static Class getOuterClass1(String string) {
		Class c = null;
		if (string.endsWith(">") && string.contains("<")) {
			string = string.replaceAll("<.+>", "");
		}
		try {
			c = CodeGenContext.getInstance().getReloadableDynamicClassLoaderOwner().loadClass(string, true);
			return c;
		} catch (ClassNotFoundException e) {
			try {
				c = CodeGenContext.getInstance().getReloadableDynamicClassLoaderOwner().loadClass(string, true);
			} catch (Exception e1) {
				e.printStackTrace();
			}
			int lastDot = string.lastIndexOf(".");
			String className = lastDot != -1 ? string.substring(0, lastDot) : string;
			if (lastDot != -1) {
				className = string.substring(0, lastDot);
			} else {
				return c;
			}
			return getOuterClass(className);
		}
	}
	public static Class tryGetInnerClz(Class outerClz, String string) {
		Class c = null;
		String outCName = outerClz.getName();
		if (string.endsWith(">") && string.contains("<")) {
			string = string.replaceAll("<.+>", "");
		}
		String remainingPart = string.replaceFirst(outCName, "");
		if (!"".equals(remainingPart.trim())) {
			try {
				String restPart = remainingPart.replaceAll("\\.", "\\$");
				c = CodeGenContext.getInstance().getReloadableDynamicClassLoaderOwner().loadClass(outCName + restPart,
						true);
				return c;
			} catch (ClassNotFoundException e) {
				int lastDot = remainingPart.lastIndexOf(".");
				String classPart = remainingPart.substring(0, lastDot);
				classPart = classPart.replaceAll("\\.", "\\$");
				if (classPart.length() > 0) {
					try {
						c = CodeGenContext.getInstance().getReloadableDynamicClassLoaderOwner()
								.loadClass(outCName + classPart, true);
						return c;
					} catch (ClassNotFoundException e1) {
					}
				}
			}
		}
		return c;
	}
	public static Class tryGetClass(String string) {
		Class outerClz = getOuterClass(string);
		return outerClz;
	}
	public static Class tryGetClass1(String string) {
		Class outerClz = getOuterClass(string);
		Class innerClz = null;
		if (outerClz != null)
			innerClz = tryGetInnerClz(outerClz, string);
		return innerClz != null ? innerClz : outerClz;
	}
	public static Field tryGetField(Class c, String fieldPart) {
		if (c != null) {
			if (fieldPart.length() > 0) {
				try {
					Field field = c.getDeclaredField(fieldPart);
					return field;
				} catch (NoSuchFieldException | SecurityException e) {
				}
			}
		}
		return null;
	}
	public Class getSelectedClz() {
		return selectedClz;
	}
	public void setSelectedClz(Class selectedClz) {
		this.selectedClz = selectedClz;
	}
	public void setSelectedMethod(Method selectedMethod) {
		this.selectedMethod = selectedMethod;
	}
	public EventObject getEventObject() {
		return eventObject;
	}
	public void setEventObject(EventObject eventObject) {
		this.eventObject = eventObject;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\codegen\eclipseRobot\EclipseCodeGenContext.java---
package codegen.eclipseRobot;
import codegen.complexobj.CodeGenContext;
public class EclipseCodeGenContext extends CodeGenContext {
	private EclipseService eclipseService;
	private H2JDBCService databaseService;
	private static EclipseCodeGenContext eclipseCodeGenContext;
	public EclipseCodeGenContext() {
		init();
	}
	public static EclipseCodeGenContext getInstance() {
		if (eclipseCodeGenContext == null) {
			return newInstance();
		} else {
			return eclipseCodeGenContext;
		}
	}
	public static EclipseCodeGenContext newInstance() {
		EclipseCodeGenContext context = new EclipseCodeGenContext();
		context.init();
		eclipseCodeGenContext = context;
		return context;
	}
	public EclipseService getEclipseService() {
		return eclipseService;
	}
	public void setEclipseService(EclipseService eclipseService) {
		this.eclipseService = eclipseService;
	}
	public H2JDBCService getDatabaseService() {
		return databaseService;
	}
	public void setDatabaseService(H2JDBCService databaseService) {
		this.databaseService = databaseService;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\codegen\eclipseRobot\EclipseService.java---
package codegen.eclipseRobot;
import codegen.MethodCallParamVariableCode;
import codegen.Replacement;
import codegen.Syntax;
import codegen.complexobj.CodeGenContext;
import codegen.complexobj.PojoSetterGenerator;
import codegen.eclipseRobot.Const.WinOperationEnum;
import codegen.robot.PixelMatchResult;
import codegen.util.ClipBoard;
import codegen.util.Common;
import codegen.util.PomUtil;
import codegen.winsys.WinSysService;
import com.dgs.annotation.FileChooserAnnotation;
import com.dgs.annotation.ParamAnno;
import com.dgs.annotation.ServiceMethodAnn;
import com.dgs.annotation.UIAnno;
import com.dgs.jnaforwin32.WindowService;
import com.github.gemba.artifactresolver.DependencyResolver;
import com.github.gemba.artifactresolver.RepositorySystemHelper;
import org.apache.maven.model.Model;
import org.eclipse.aether.artifact.DefaultArtifact;
import ui.validation.ValidationAnn;
import javax.sql.DataSource;
import javax.xml.datatype.XMLGregorianCalendar;
import java.awt.*;
import java.awt.event.KeyEvent;
import java.awt.image.BufferedImage;
import java.io.*;
import java.lang.annotation.Annotation;
import java.lang.reflect.*;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.net.MalformedURLException;
import java.net.URI;
import java.net.URL;
import java.security.MessageDigest;
import java.sql.Connection;
import java.sql.Driver;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.util.List;
import java.util.*;
import java.util.jar.JarEntry;
import java.util.jar.JarFile;
import java.util.jar.JarInputStream;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import java.util.stream.Stream;
/**
 * note the method parameter names is useful when showing in UI, thus need
 * change java compiler preference, by doing below
 * Window->preference->Compiler->check "Store information about method
 * parameters(usable via reflection)"
 *
 */
public class EclipseService extends WinSysService {
	public static final String SPRING_BOOT_TEMPLATE_JAR_NAME = "springbootsimpletemplate-1.0.jar";
	public static String ECLIPSE_TITLE_KEYWORD = "Eclipse";
	public static String SPECIAL_DIALOG_FONT_NAME = "Segoe UI";
	public static String DIALOG_FONT_NAME = "Khmer UI";
	public static Color ECLIPSE_TITLE_DISABLE_FONT = new Color(151, 151, 151);
	public static Color DISABLE_MENU_ITEM_COLOR = new Color(109, 109, 109);
	public static int MENU_ITEM_SIZE = 12;
	public static String COPY_QUALIFIER_NAME_MENU_LABEL = "Copy Qualified Name";
	public static String COPY_QUALIFIER_NAME_HOTKEY = "Ctrl+`";
	private WindowService windowService;
	private H2JDBCService h2JDBCService;	
	@ServiceMethodAnn(keyword = "checksum return byte")
	public static byte[] createChecksum(@ParamAnno(description = "file for check sum") @ValidationAnn(validations = {
			"codegen.eclipseRobot.MandatoryCheck" }) File file) throws Exception {
		InputStream fis = new FileInputStream(file);
		byte[] buffer = new byte[1024];
		MessageDigest complete = MessageDigest.getInstance("MD5");
		int numRead;
		do {
			numRead = fis.read(buffer);
			if (numRead > 0) {
				complete.update(buffer, 0, numRead);
			}
		} while (numRead != -1);
		fis.close();
		return complete.digest();
	}
	@ServiceMethodAnn(keyword = "checksum return string")
	public static String getMD5Checksum(
			@ParamAnno(description = "file") @ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) File file)
			throws Exception {
		byte[] b = createChecksum(file);
		String result = "";
		for (int i = 0; i < b.length; i++) {
			result += Integer.toString((b[i] & 0xff) + 0x100, 16).substring(1);
		}
		return result;
	}
	/**
	 * 
	 * @param targetDirectory consider add a file or directory annotation to make a
	 *                        difference
	 * @param folderName
	 */
	@ServiceMethodAnn(keyword = "create project folder")
	public void createNewProjFolder(@FileChooserAnnotation(chooseDirOnly = true) @ValidationAnn(validations = {
			"codegen.eclipseRobot.MandatoryCheck" }) File targetDirectory, String folderName) {
		String projDir = targetDirectory.getAbsolutePath();
		boolean b = Common.isBlank(folderName);
		if (!b) {
			projDir = projDir + File.separator + folderName;
		}
		File codingLogicFolder = new File(projDir + File.separator + "coding logic");
		File businessLogicFolder = new File(projDir + File.separator + "business logic");
		File functionLogicFolder = new File(projDir + File.separator + "function logic");
		File testingFolder = new File(projDir + File.separator + "testing");
		File projectMgtFolder = new File(projDir + File.separator + "project management");
		File deploymentFolder = new File(projDir + File.separator + "deployment");
		File productionFolder = new File(projDir + File.separator + "production");
		if (!codingLogicFolder.exists()) {
			codingLogicFolder.mkdirs();
		}
		if (!businessLogicFolder.exists()) {
			businessLogicFolder.mkdirs();
		}
		if (!functionLogicFolder.exists()) {
			functionLogicFolder.mkdirs();
		}
		if (!testingFolder.exists()) {
			testingFolder.mkdirs();
		}
		if (!projectMgtFolder.exists()) {
			projectMgtFolder.mkdirs();
		}
		if (!deploymentFolder.exists()) {
			deploymentFolder.mkdirs();
		}
		if (!productionFolder.exists()) {
			productionFolder.mkdirs();
		}
		return;
	}
	public void setCopyQualifierKey() throws Exception {
		this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_E);
		boolean hotKeyStrFound = false;
		try {
			blockUntilFound(COPY_QUALIFIER_NAME_HOTKEY, DIALOG_FONT_NAME, MENU_ITEM_SIZE, Font.PLAIN, Color.BLACK,
					false, true);
			hotKeyStrFound = true;
		} catch (Exception e) {
			try {
				blockUntilFound(COPY_QUALIFIER_NAME_HOTKEY, DIALOG_FONT_NAME, MENU_ITEM_SIZE, Font.PLAIN,
						DISABLE_MENU_ITEM_COLOR, false, true);
				hotKeyStrFound = true;
			} catch (Exception e1) {
				e1.printStackTrace();
			}
		}
		if (!hotKeyStrFound) {
			this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_W, KeyEvent.VK_P);
			this.blockUntilFound("Preferences", DIALOG_FONT_NAME, Color.BLACK);
			this.getkRobot().typeStr("Keys");
			this.blockUntilFound("Keys", DIALOG_FONT_NAME, Color.BLACK);
			blockUntilFound("Keys", DIALOG_FONT_NAME, Font.BOLD, Color.BLACK, false, true);
			this.getmRobot().mouseClick();
			this.blockUntilFound("type filter text", DIALOG_FONT_NAME, Font.PLAIN, new Color(87, 87, 87), false, true);
			this.getmRobot().mouseClick();
			this.getkRobot().typeStr("Copy Qualified Na");
			this.blockUntilFound("Copy Qualified Name", DIALOG_FONT_NAME, Color.BLACK);
			PixelMatchResult pmr = this.tryFindText("Ctrl+`", DIALOG_FONT_NAME, Font.PLAIN, Color.BLACK, false);
			if (pmr != null) {
				this.getkRobot().clickKey(KeyEvent.VK_ESCAPE);
				return;
			} else {
				this.getkRobot().arrowDown();
				this.getkRobot().end();
				this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_B);
				this.getkRobot().clickCompositeKey(KeyEvent.VK_CONTROL, KeyEvent.VK_BACK_QUOTE);
				this.getkRobot().tab();
				this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_A);
				this.getkRobot().clickKey(KeyEvent.VK_ESCAPE);
			}
		}
		return;
	}
	public void clickProjByName(String name, boolean matchExactly) throws Exception {
		this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_SHIFT, KeyEvent.VK_Q);
		Thread.sleep(1000);
		this.getkRobot().clickKey(KeyEvent.VK_P);
		Thread.sleep(500);
		this.collapseAll();
		Thread.sleep(500);
		this.getkRobot().home();
		String lastProjName = null;
		String nameInQualifiedFormat = "/" + name;
		boolean reachLastProj = false;
		while (!reachLastProj) {
			this.copyQualifiedName();
			Thread.sleep(500);
			try {
				String data = ClipBoard.getString();
				if (data != null) {
					System.out.println(String.format("nameInQualifiedFormat=%s,data=%s", nameInQualifiedFormat, data));
					if (data.equals(lastProjName)) {
						reachLastProj = true;
					}
					if (matchExactly) {
						if (nameInQualifiedFormat.equalsIgnoreCase(data)) {
							return;
						}
					} else {
						String nameRegex = "(?i)" + name;
						Pattern hp = Pattern.compile(nameRegex);
						Matcher m = hp.matcher(data);
						if (m.find()) {
							System.out.println("match data " + data);
							return;
						}
					}
					lastProjName = data;
				} else {
					return;
				}
				System.out.println("arrow down ");
				this.getkRobot().arrowDown();
			} catch (Exception e) {
				throw e;
			}
		}
	}
	public void clickProjLikeName(String name) throws Exception {
		clickProjByName(name, false);
	}
	@ServiceMethodAnn(keyword = "new class")
	public void createNewClass(
			@ParamAnno(description = "Class Name")  String className, 
			int modifier,
			@ParamAnno(description = "Package Name") String packName, 
			@ParamAnno(description = "Super Class") Class superC, 
			@ParamAnno(description = "Interface Class") Class interfaceC) throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		Common.setModifier(modifier, context);
		createNewClass(className, modifier, packName, superC != null ? superC.getName() : null,
				interfaceC != null ? interfaceC.getName() : null);
	}
	@ServiceMethodAnn(keyword = "new classes")
	public void createManyClasses(@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) String classNames[],
			int modifier, 
			@ParamAnno(description = "Package Name") String packName, 
			@ParamAnno(description = "Super Class Name") String superClassName, String interfaceName) {
		for (String className : classNames) {
			try {
				this.createNewClass(className, modifier, packName, superClassName, interfaceName);
			} catch (Exception e) {
				e.printStackTrace();
			}
		}
		return;
	}
	public void createNewClass(@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) String className, int modifier,
			String packName, String superClassName, String interfaceName) throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		Common.setModifier(modifier, context);
		if(!this.isActiveEclipseWindow())
			return;
		if(!this.openWizard())
			return;
		Thread.sleep(1500);
		this.getkRobot().typeStr("class");
		Thread.sleep(500);
		this.getkRobot().enter();
		Thread.sleep(500);
		this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_M);
		Thread.sleep(500);
		this.getkRobot().typeStr(className);
		Thread.sleep(500);
		if (superClassName != null && !"".equals(superClassName.trim())) {
			this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_S);
			this.getkRobot().end();
			this.getkRobot().selectAll();
			this.getkRobot().backSace();
			Thread.sleep(500);
			this.getkRobot().typeStr(superClassName);
		}
		if (interfaceName != null && !"".equals(interfaceName.trim())) {
			this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_A);
			Thread.sleep(500);
			this.getkRobot().typeStr(interfaceName);
			Thread.sleep(1000);
			this.getkRobot().enter();
			Thread.sleep(500);
		}
		boolean specifyPack = packName != null && !"".equals(packName.trim()) ? true : false;
		if (specifyPack) {
			this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_K);
			this.getkRobot().end();
			this.getkRobot().selectAll();
			this.getkRobot().backSace();
			Thread.sleep(500);
			this.getkRobot().typeStr(packName);
		}
		this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_U);
		this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_F);
	}
	@ServiceMethodAnn(keyword = { "new interface", "create interface with super interface name" })
	public void createNewInterface(@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) String interfaceName,
			int modifier, String packName, String... superInterfaceNames) throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		if(!this.isActiveEclipseWindow())
			return;
		Common.setModifier(modifier, context);
		if(!this.openWizard())
			return;
		Thread.sleep(1500);
		this.getkRobot().typeStr("interface");
		Thread.sleep(500);
		this.getkRobot().enter();
		Thread.sleep(500);
		this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_M);
		this.getkRobot().typeStr(interfaceName);
		if (superInterfaceNames != null && superInterfaceNames.length>0) {
			for(String superInterfaceName : superInterfaceNames) {
				this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_A);
				this.getkRobot().end();
				Thread.sleep(500);
				this.getkRobot().selectAll();
				this.getkRobot().backSace();
				this.getkRobot().typeStr(superInterfaceName);
				Thread.sleep(500);
				this.getkRobot().enter();
			}
		}
		boolean specifyPack = packName != null && !"".equals(packName.trim()) ? true : false;
		if (specifyPack) {
			this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_K);
			this.getkRobot().end();
			this.getkRobot().selectAll();
			this.getkRobot().backSace();
			Thread.sleep(500);
			this.getkRobot().typeStr(packName);
		}
		this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_F);
	}
	@ServiceMethodAnn(keyword = { "new interface with super interface", "create interface with super interface" })
	public void createNewInterfaceWithSuperC(
			@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) String interfaceName, int modifier, String packName,
			Class superInterface) throws Exception {
		createNewInterface(interfaceName, modifier, packName, superInterface != null ? superInterface.getName() : null);
	}
	@ServiceMethodAnn(keyword = "new enum")
	public void createNewEnum(@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) String name, String packName)
			throws Exception {
		if(!this.isActiveEclipseWindow())
			return;
		if(!this.openWizard())
			return;
		Thread.sleep(1500);
		this.getkRobot().typeStr("enum");
		Thread.sleep(500);
		this.getkRobot().enter();
		Thread.sleep(500);
		this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_M);
		this.getkRobot().typeStr(name);
		boolean specifyPack = packName != null && !"".equals(packName.trim()) ? true : false;
		if (specifyPack) {
			this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_K);
			this.getkRobot().end();
			this.getkRobot().selectAll();
			this.getkRobot().backSace();
			Thread.sleep(500);
			this.getkRobot().typeStr(packName);
		}
		this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_F);
	}
	public void createNewAnnotation(@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) String name, String packName)
			throws Exception {
		if(!this.openWizard())
			return;
		Thread.sleep(500);
		this.getkRobot().typeStr("annotation");
		Thread.sleep(500);
		this.getkRobot().enter();
		Thread.sleep(500);
		this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_M);
		this.getkRobot().typeStr(name);
		boolean specifyPack = packName != null && !"".equals(packName.trim()) ? true : false;
		if (specifyPack) {
			this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_K);
			this.getkRobot().end();
			this.getkRobot().selectAll();
			Thread.sleep(500);
			this.getkRobot().backSace();
			Thread.sleep(500);
			this.getkRobot().typeStr(packName);
		}
		this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_R);
		this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_U);
		this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_F);
	}
	@ServiceMethodAnn(keyword = "new package")
	public void createNewPackage(String packName) throws Exception {
		if(!this.openWizard())
			return;
		Thread.sleep(500);
		this.getkRobot().typeStr("package");
		Thread.sleep(500);
		this.getkRobot().enter();
		Thread.sleep(500);
		this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_M);
		this.getkRobot().typeStr(packName);
		boolean specifyPack = packName != null && !"".equals(packName.trim()) ? true : false;
		if (specifyPack) {
			this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_K);
			this.getkRobot().end();
			this.getkRobot().selectAll();
			this.getkRobot().backSace();
			Thread.sleep(500);
			this.getkRobot().typeStr(packName);
		}
		this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_F);
	}
	@ServiceMethodAnn(keyword = "new annotation")
	public void createAnnotation(@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) String name, String packName)
			throws Exception {
		if(!this.openWizard())
			return;
		Thread.sleep(500);
		this.getkRobot().typeStr("Annotation");
		Thread.sleep(500);
		this.getkRobot().enter();
		Thread.sleep(500);
		this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_M);
		this.getkRobot().typeStr(name);
		boolean specifyPack = packName != null && !"".equals(packName.trim()) ? true : false;
		if (specifyPack) {
			this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_K);
			this.getkRobot().end();
			this.getkRobot().selectAll();
			this.getkRobot().backSace();
			Thread.sleep(500);
			this.getkRobot().typeStr(packName);
		}
		this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_F);
	}
	public void updateMavenDependency() throws Exception {
		this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_F5);
		this.getmRobot().delay(500);
		this.getkRobot().clickKey(KeyEvent.VK_TAB);
		this.getkRobot().clickKey(KeyEvent.VK_SPACE);
		this.getkRobot().clickKey(KeyEvent.VK_TAB);
		this.getkRobot().clickKey(KeyEvent.VK_TAB);
		this.getkRobot().clickKey(KeyEvent.VK_TAB);
		this.getkRobot().clickKey(KeyEvent.VK_TAB);
		this.getkRobot().clickKey(KeyEvent.VK_TAB);
		this.getkRobot().clickKey(KeyEvent.VK_TAB);
		this.getkRobot().clickKey(KeyEvent.VK_SPACE);
		this.getkRobot().enter();
	}
	@ServiceMethodAnn(keyword = { "gen service interface", "create service interface" })
	public void createServiceInterface(@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) String interfaceName, int modifier, String packName,
			Class superInterface) throws Exception {
	    this.createNewInterfaceWithSuperC(interfaceName, modifier, packName, superInterface);
	}
	@ServiceMethodAnn(keyword = { "gen service class", "create service class" })
	public void createServiceClz(@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) String className, int modifier, @ParamAnno(description = "as Component")boolean asComponent,@ParamAnno(description = "as Service")boolean asService,
			String packName, Class superC, Class interfaceC) throws Exception {
	    this.createNewClass(className, modifier, packName, superC, interfaceC);
	}
	@ServiceMethodAnn(keyword = { "gen jpa repository class", "create jpa repository class" })
	public void createRepository(@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) String interfaceName, int modifier, String packName,
			boolean extendsJpaSpecificationExecutor) throws Exception {
		if(extendsJpaSpecificationExecutor) {
			this.createNewInterface(interfaceName, modifier, packName, "org.springframework.data.jpa.repository.JpaRepository","org.springframework.data.jpa.repository.JpaSpecificationExecutor");
		}else {
			this.createNewInterface(interfaceName, modifier, packName, "org.springframework.data.jpa.repository.JpaRepository");
		}
	}
	@ServiceMethodAnn(keyword = { "gen JPA Specification class", "create JPA Specification class" })
	public void createJPASpecification(@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) String className, int modifier,
			String packName, Class superC, Class interfaceC) throws Exception {
	    this.createNewClass(className, modifier, packName, superC, interfaceC);
	}
	@ServiceMethodAnn(keyword = { "gen data class", "create data class" })
	public void createDataClass(@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) String className, int modifier,
			String packName, Class superC, Class interfaceC, boolean dataAnnotation
			, boolean getterAnnotation, boolean setterAnnotation, boolean toStringAnnotation, boolean withEqualsAndHashCode) throws Exception {
	    this.createNewClass(className, modifier, packName, superC, interfaceC);
	    if(dataAnnotation) {
	    }
	}
	@ServiceMethodAnn(keyword = { "gen entity class", "create entity class" })
	public void createEntityClass(@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) String className, int modifier,
			String packName, Class superC, Class interfaceC) throws Exception {
	    this.createNewClass(className, modifier, packName, superC, interfaceC);
	}
	@ServiceMethodAnn(keyword = { "gen config bean class", "create config bean class" })
	public void createConfigClass(@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) String className, int modifier,
			String packName, Class superC, Class interfaceC) throws Exception {
	    this.createNewClass(className, modifier, packName, superC, interfaceC);
	}
	public void quickFix() throws Exception {
		this.getkRobot().clickCompositeKey(KeyEvent.VK_CONTROL, KeyEvent.VK_1);
		Thread.sleep(500);
		this.getkRobot().enter();
		Thread.sleep(1000);
	}
	public void gotoLine(@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) int line) throws Exception {
		this.getkRobot().clickCompositeKey(KeyEvent.VK_CONTROL, KeyEvent.VK_L);
		Thread.sleep(1000);
		this.getkRobot().typeStr(Integer.toString(line));
		Thread.sleep(1000);
		this.getkRobot().enter();
	}
	public void popOpenTypeDialog() {
		this.getkRobot().clickCompositeKey(KeyEvent.VK_CONTROL, KeyEvent.VK_SHIFT, KeyEvent.VK_T);
	}
	public void outline(Class c) throws Exception {
		this.editClass(c);
		Thread.sleep(500);
		this.getmRobot().mouseClick();
		this.getkRobot().clickCompositeKey(KeyEvent.VK_CONTROL, KeyEvent.VK_O);
	}
	public void hightLightMethod(Class c, String methodNameStr) throws Exception {
		this.outline(c);
		Thread.sleep(1000);
		this.getkRobot().typeStr(methodNameStr);
		Thread.sleep(1000);
		this.getkRobot().enter();
		Thread.sleep(1000);
		this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_SHIFT, KeyEvent.VK_RIGHT);
		Thread.sleep(1000);
	}
	public String copyMethod(Class c, String methodNameStr) throws Exception {
		hightLightMethod(c, methodNameStr);
		this.getkRobot().copy();
		this.getkRobot().arrowleft();
		return ClipBoard.getString();
	}
	public void findStr(@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) String find) throws Exception {
		findStr(find, false);
	}
	public void findStr(@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) String find, boolean isBack)
			throws Exception {
		this.getkRobot().clickCompositeKey(KeyEvent.VK_CONTROL, KeyEvent.VK_F);
		this.blockUntilFound("Find/Replace", SPECIAL_DIALOG_FONT_NAME, MENU_ITEM_SIZE, Color.BLACK);
		this.getkRobot().typeStr(find);
		this.blockUntilFound(find, DIALOG_FONT_NAME, Color.BLACK);
		if (isBack) {
			this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_B);
		}
		this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_X);
		this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_N);
		try {
			Thread.sleep(500L);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		this.getkRobot().copy();
		String copiedData = ClipBoard.getString();
		if (copiedData != null && !"".equals(copiedData)) {
			Pattern pattern = Pattern.compile(find);
			Matcher matcher = pattern.matcher(copiedData);
			if (matcher.find()) {
				this.getkRobot().clickKey(KeyEvent.VK_ESCAPE);
				return;
			}
		}
		this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_X);
		this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_N);
		this.getkRobot().clickKey(KeyEvent.VK_ESCAPE);
		this.blockUntilNotFound("Find/Replace", SPECIAL_DIALOG_FONT_NAME, MENU_ITEM_SIZE, Color.BLACK);
		return;
	}
	public void replaceStrInAllTabs(@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) String find,
			@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) String replacement) throws Exception {
		replaceStr(find, replacement, false);
		boolean back = true;
		switchFile(back);
	}
	public void replaceStr(@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) String find,
			@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) String replacement) throws Exception {
		replaceStr(find, replacement, false);
	}
	public void replaceStr(@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) String find,
			@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) String replacement, boolean isBack)
			throws Exception {
		this.getkRobot().clickCompositeKey(KeyEvent.VK_CONTROL, KeyEvent.VK_F);
		this.blockUntilFound("Find/Replace", SPECIAL_DIALOG_FONT_NAME, MENU_ITEM_SIZE, Color.BLACK);
		this.getkRobot().clickCompositeKey(KeyEvent.VK_CONTROL, KeyEvent.VK_F);
		this.getkRobot().typeStr(find);
		if (isBack) {
			this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_B);
		}
		this.blockUntilFound(find, DIALOG_FONT_NAME, Color.BLACK);
		this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_E);
		this.getkRobot().typeStr(replacement);
		this.blockUntilFound(replacement, DIALOG_FONT_NAME, Color.BLACK);
		this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_X);
		this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_N);
		this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_R);
		try {
			Thread.sleep(500L);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_X);
		this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_N);
		this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_R);
		this.getkRobot().clickKey(KeyEvent.VK_ESCAPE);
		this.blockUntilNotFound("Find/Replace", SPECIAL_DIALOG_FONT_NAME, MENU_ITEM_SIZE, Color.BLACK);
		return;
	}
	public void replaceMethodText(@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) Class c, String methodNameStr,
			String newMethodText) throws Exception {
		hightLightMethod(c, methodNameStr);
		this.getkRobot().del();
		this.getkRobot().paste();
		Thread.sleep(1000);
		this.saveFile();
	}
	public void editMethod(Class c, String methodNameStr) throws Exception {
		this.outline(c);
		Thread.sleep(500);
		this.getkRobot().typeStr(methodNameStr);
		Thread.sleep(1000);
		this.getkRobot().enter();
		Thread.sleep(1000);
		this.getkRobot().end();
		this.getkRobot().arrowDown();
	}
	public void editClass(Class c) throws Exception {
		this.editClass(c.getName(), -1);
	}
	@Deprecated
	public void blockUntilFound(String expectedStrOnScreen, String fontName, boolean b) {
		blockUntilFound(expectedStrOnScreen, fontName, Font.PLAIN, Color.WHITE, b);
	}
	public void blockUntilFound(String expectedStrOnScreen, String fontName, Color fontColor) {
		blockUntilFound(expectedStrOnScreen, fontName, Font.PLAIN, fontColor, false);
	}
	public void blockUntilNotFound(String expectedStrOnScreen, String fontName, Color fontColor) {
		blockUntilFound(expectedStrOnScreen, fontName, Font.PLAIN, fontColor, true);
	}
	public void blockUntilFoundBold(String expectedStrOnScreen, String fontName, Color fontColor) {
		blockUntilFound(expectedStrOnScreen, fontName, Font.BOLD, fontColor, false);
	}
	public void blockUntilNotFoundBold(String expectedStrOnScreen, String fontName, Color fontColor) {
		blockUntilFound(expectedStrOnScreen, fontName, Font.BOLD, fontColor, true);
	}
	public void blockUntilFound(String expectedStrOnScreen, String fontName, int fontStyle, Color fontColor,
			boolean untilNotFound) {
		blockUntilFound(expectedStrOnScreen, fontName, fontStyle, fontColor, untilNotFound, false);
	}
	public void blockUntilFound(String expectedStrOnScreen, String fontName, int size, Color fontColor)
			throws Exception {
		blockUntilFound(expectedStrOnScreen, fontName, size, Font.PLAIN, fontColor, false);
	}
	public void blockUntilNotFound(String expectedStrOnScreen, String fontName, int size, Color fontColor)
			throws Exception {
		blockUntilFound(expectedStrOnScreen, fontName, size, Font.PLAIN, fontColor, true);
	}
	public void blockUntilFoundBold(String expectedStrOnScreen, String fontName, int size, Color fontColor)
			throws Exception {
		blockUntilFound(expectedStrOnScreen, fontName, size, Font.BOLD, fontColor, false);
	}
	public void blockUntilNotFoundBold(String expectedStrOnScreen, String fontName, int size, Color fontColor)
			throws Exception {
		blockUntilFound(expectedStrOnScreen, fontName, size, Font.BOLD, fontColor, true);
	}
	public void blockUntilFound(String expectedStrOnScreen, String fontName, int size, int fontStyle, Color fontColor,
			boolean untilNotFound) throws Exception {
		blockUntilFound(expectedStrOnScreen, fontName, size, fontStyle, fontColor, untilNotFound, false);
	}
	static int TRY_MAX_TIMES = 3;
	public boolean blockUntilFound(String expectedStrOnScreen, String fontName, int fontStyle, Color fontColor,
			boolean untilNotFound, boolean moveMouse) {
		PixelMatchResult pixelMatchResult = null;
		int times = 0;
		boolean b = false;
		return b;
	}
	public void blockUntilFound(String expectedStrOnScreen, String fontName, int size, int fontStyle, Color fontColor,
			boolean untilNotFound, boolean moveMouse) throws Exception {
	}
	public PixelMatchResult tryFindText(String expectedStrOnScreen, String fontName, int fontStyle, Color fontColor,
			boolean moveMouse) throws Exception {
		PixelMatchResult pixelMatchResult = null;
		return pixelMatchResult;
	}
	public void editClass(@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) String name, int maxTimes)
			throws Exception {
		for (int i = 0; maxTimes == -1 || i < maxTimes; i++) {
			this.popOpenTypeDialog();
			this.blockUntilFound("Open Type", SPECIAL_DIALOG_FONT_NAME, MENU_ITEM_SIZE, Color.BLACK);
			this.getkRobot().typeStr(name);
			this.blockUntilFound(name, DIALOG_FONT_NAME, Color.BLACK);
			this.getkRobot().enter();
			this.blockUntilNotFound("Open Type", SPECIAL_DIALOG_FONT_NAME, MENU_ITEM_SIZE, Color.BLACK);
			String nameFragements[] = name.split("\\.");
			if (nameFragements.length > 0) {
				/*
				 * this.getkRobot().clickCompositeKey(KeyEvent.VK_CONTROL, KeyEvent.VK_F);
				 * this.blockUntilFound("Find/Replace", "Khmer UI", Color.BLACK);
				 * this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_F); String
				 * strToFind = "class\\s+" + nameFragements[nameFragements.length-1];
				 * this.getkRobot().typeStr(strToFind); this.blockUntilFound(strToFind,
				 * "Khmer UI", Color.BLACK); this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT,
				 * KeyEvent.VK_X); this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT,
				 * KeyEvent.VK_N); Thread.sleep(500L); //in case the regular expression checkbox
				 * chosen already this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT,
				 * KeyEvent.VK_X); this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT,
				 * KeyEvent.VK_N); Thread.sleep(500L);
				 * this.getkRobot().clickCompositeKey(KeyEvent.VK_ESCAPE);
				 * this.blockUntilNotFound("Find/Replace", "Khmer UI", Color.BLACK);
				 */
				this.copyQualifiedName();
				String actualQualifiedName = ClipBoard.getString();
				if (actualQualifiedName.equalsIgnoreCase(name)) {
					return;
				}
			}
		}
	}
	public void editClass(@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) String name) throws Exception {
		editClass(name, 3);
	}
	public void orginizeImports() throws Exception {
		this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_S);
		Thread.sleep(1000);
		this.getkRobot().arrowDown(10);
		Thread.sleep(1000);
		this.getkRobot().enter();
		Thread.sleep(1000);
		this.saveFile();
	}
	public void copyQualifiedName() {
		this.getkRobot().clickCompositeKey(KeyEvent.VK_CONTROL, KeyEvent.VK_BACK_QUOTE);
		this.getkRobot().clickKey(KeyEvent.VK_ESCAPE);// escape for case of no
		/*
		 * try { PixelMatchResult pmr = this.tryFindText( "No Element to qualify found",
		 * DIALOG_FONT_NAME, Font.PLAIN, Color.BLACK, false); if(pmr!=null){
		 * this.getkRobot().clickKey(KeyEvent.VK_ESCAPE); } } catch (Exception e) {
		 * e.printStackTrace(); }
		 */
	}
	public void copyClassQualifiedName(@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) String className)
			throws Exception {
		this.editClass(className);
		Thread.sleep(500);
		this.linkExplorer();
		this.copyQualifiedName();
	}
	public void selectAllClassCode(@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) String classname)
			throws Exception {
		this.editClass(classname);
		this.getkRobot().selectAll();
	}
	public String copyAllClassCode(@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) String classname)
			throws Exception {
		this.selectAllClassCode(classname);
		Thread.sleep(1000);
		this.getkRobot().copy();
		Thread.sleep(1000);
		return ClipBoard.getString();
	}
	@ServiceMethodAnn(keyword = "gen new ArrayList")
	public String genNewArrayList(@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) Class genericType)
			throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		Class c = List.class;
		Class cc = Common.getDefaultConcreteClass(c);
		Common.importC(cc, context);
		context.getVariableMap().put(Replacement.TMP_CLASS_NAME.name(), cc.getSimpleName());
		context.getVariableMap().put(Replacement.GENERIC_TYPE_NAME.name(), Common.getClassName(genericType, context));
		String instanceName = Common.getInstanceName(c);
		context.getVariableMap().put(Replacement.TMP_INSTANCE_NAME.name(), instanceName);
		String str = Common.replaceAllKeyWord(Syntax.INIT_LIST, context.getVariableMap());
		return str;
	}
	@ServiceMethodAnn(keyword = "gen new map")
	public String genNewMap(@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) Class genericTypeKey,
			@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) Class genericTypeValue) throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		Class c = Map.class;
		Class cc = Common.getConcreteClass(c, context);
		Common.importC(cc, context);
		context.getVariableMap().put(Replacement.TMP_CLASS_NAME.name(), cc.getSimpleName());
		context.getVariableMap().put(Replacement.GENERIC_TYPE_KEY.name(), genericTypeKey.getSimpleName());
		context.getVariableMap().put(Replacement.GENERIC_TYPE_VAL.name(), genericTypeValue.getSimpleName());
		String instanceName = Common.getInstanceName(c);
		context.getVariableMap().put(Replacement.TMP_INSTANCE_NAME.name(), instanceName);
		String str = Common.replaceAllKeyWord(Syntax.INIT_Map, context.getVariableMap());
		return str;
	}
	public void formatCode(Class c) throws Exception {
		this.editClass(c);
		Thread.sleep(1000);
		this.format();
	}
	public void format() throws Exception {
		this.getmRobot().mouseClick();
		getkRobot().clickCompositeKey(KeyEvent.VK_CONTROL, KeyEvent.VK_SHIFT, KeyEvent.VK_F);
		Thread.sleep(1000);
	}
	public String genCastViaTargetClass(Class targetC, String targetCName, String value, boolean hasTargetClassDeclare)
			throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		if (hasTargetClassDeclare) {
			context.getVariableMap().put(Replacement.TARGET_CLASS_NAME.name(), targetC.getSimpleName());
			context.getVariableMap().put(Replacement.SEPERATOR.name(), " ");
		} else {
			context.getVariableMap().put(Replacement.TARGET_CLASS_NAME.name(), "");
			context.getVariableMap().put(Replacement.SEPERATOR.name(), "");
		}
		context.getVariableMap().put(Replacement.TARGET_INSTANCE_NAME.name(), targetCName);
		context.getVariableMap().put(Replacement.TMP_CLASS_NAME.name(), targetC.getSimpleName());
		context.getVariableMap().put(Replacement.TMP_INSTANCE_VALUE.name(), value);
		String lineStr = Common.replaceAllKeyWord(Syntax.CAST_LINE, context.getVariableMap());
		return lineStr;
	}
	public String genCastExplicitly(String value, boolean hasTargetClassDeclare, Class targetC, String targetCName)
			throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		if (hasTargetClassDeclare) {
			context.getVariableMap().put(Replacement.TARGET_CLASS_NAME.name(), targetC.getSimpleName());
			context.getVariableMap().put(Replacement.SEPERATOR.name(), " ");
		} else {
			context.getVariableMap().put(Replacement.TARGET_CLASS_NAME.name(), "");
			context.getVariableMap().put(Replacement.SEPERATOR.name(), "");
		}
		context.getVariableMap().put(Replacement.TARGET_INSTANCE_NAME.name(), targetCName);
		context.getVariableMap().put(Replacement.TMP_CLASS_NAME.name(), targetC.getSimpleName());
		context.getVariableMap().put(Replacement.TMP_INSTANCE_VALUE.name(), value);
		String lineStr = Common.replaceAllKeyWord(Syntax.CAST_EXPLICIT_LINE, context.getVariableMap());
		return lineStr;
	}
	@UIAnno(uiClz="ui.GenAnnotationPane")
	@ServiceMethodAnn(keyword = { "declare annotation" })
	public void declareAnnotation() {
	}
	public String genAnnotation(Class<Annotation> c, String... params) {
		if (!c.isAnnotation()) {
			return "";
		}
		if ("org.springframework.beans.factory.annotation.Autowired".equals(c.getCanonicalName())) {
			return "@Autowired";
		}
		else if (params == null || params[0] == null || "".equals(params[0])) {
			return String.format("@%s", c.getSimpleName());
		} else {
			return String.format("@%s(\"%s\")", c.getSimpleName(), params[0]);
		}
	}
	public String genManyFieldsDeclare(@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) Class classes[],
			int modifier, boolean withAutowiredAnnotation, boolean withQualifierAnnotation, String qualifierName, String value) throws Exception {
		StringBuilder sb = new StringBuilder();
		for (Class c : classes) {
			String str = genFieldDeclare(c, Common.getInstanceName(c), modifier, withAutowiredAnnotation,  qualifierName, value);
			sb.append(str).append(Syntax.NEW_LINE);
		}
		return sb.toString();
	}
	@ServiceMethodAnn(keyword = { "gen field declaration" })
	public String genFieldDeclare(@ParamAnno(description = "Field type") @ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) Class c,
			@ParamAnno(description = "Field Name") @ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) String fieldName, int modifier,
			@ParamAnno(description = "Is Autowired") boolean withAutowiredAnnotation,
			@ParamAnno(description = "Qualifier Name") String qualifierName,
			@ParamAnno(description = "Value")String value) throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		Common.setModifier(modifier, context);
		context.getVariableMap().put(Replacement.FIELD_CLASS_NAME.name(), c.getSimpleName());
		context.getVariableMap().put(Replacement.FIELD_INSTANCE_NAME.name(),
				fieldName == null ? Common.getInstanceName(c) : fieldName);
		String str = Common.replaceAllKeyWord(Syntax.FIELD_DECLARE, context.getVariableMap());
		StringBuilder sb = new StringBuilder();
		if(withAutowiredAnnotation){
			sb.append("@Autowired").append(Syntax.NEW_LINE);
		}
		if(null!=qualifierName && !"".equals(qualifierName)){
			sb.append(String.format("@Qualifier(\"%s\")", qualifierName)).append(Syntax.NEW_LINE);
		}
		if(null!=value && !"".equals(value)){
			sb.append(String.format("@Value(\"${%s}\")", value)).append(Syntax.NEW_LINE);
		}
		sb.append(str);
		return sb.toString();
	}
	public String genShortDeclare(String defaultVal, boolean isPrimitiveWrapper) throws Exception {
		return genVariableDeclare(isPrimitiveWrapper ? Short.class : short.class, defaultVal);
	}
	public String genIntDeclare(String defaultVal, boolean isPrimitiveWrapper) throws Exception {
		return genVariableDeclare(isPrimitiveWrapper ? Integer.class : int.class, defaultVal);
	}
	public String genLongDeclare(String defaultVal, boolean isPrimitiveWrapper) throws Exception {
		return genVariableDeclare(isPrimitiveWrapper ? Long.class : long.class, defaultVal);
	}
	public String genByteDeclare(String defaultVal, boolean isPrimitiveWrapper) throws Exception {
		return genVariableDeclare(isPrimitiveWrapper ? Byte.class : byte.class, defaultVal);
	}
	public String genStrDeclare(String defaultVal) throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		return genVariableDeclare(String.class, defaultVal);
	}
	public String genBooleanDeclare(String defaultVal, boolean isPrimitiveWrapper) throws Exception {
		return genVariableDeclare(isPrimitiveWrapper ? Boolean.class : boolean.class, defaultVal);
	}
	public String genVariableDeclare(Class clz, String defaultVal) throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		boolean isComplexType = Common.isComplexType(clz);
		if (!isComplexType) {
			return genPrimitiveVariables(clz);
		} else {
			boolean hasDefaultVal = defaultVal == null ? false : true;
			context.getVariableMap().put(Replacement.TMP_CLASS_NAME.name(), clz.getSimpleName());
			context.getVariableMap().put(Replacement.TMP_INSTANCE_NAME.name(), Common.getInstanceName(clz));
			if (defaultVal != null) {
				context.getVariableMap().put(Replacement.TMP_INSTANCE_VALUE.name(), defaultVal);
			} else if (isComplexType) {
				context.getVariableMap().put(Replacement.TMP_INSTANCE_VALUE.name(), "null");
			}
			hasDefaultVal = context.getVariableMap().get(Replacement.TMP_INSTANCE_VALUE.name()) != null;
			String lineStr = Common.replaceAllKeyWord(hasDefaultVal ? Syntax.ASSIGN_LINE : Syntax.DECLARE_LINE,
					context.getVariableMap());
			return lineStr;
		}
	}
	@ServiceMethodAnn(keyword = { "gen return"})
	public String genReturn(String returnVal) throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		if (returnVal != null) {
			context.getVariableMap().put(Replacement.TMP_INSTANCE_VALUE.name(), returnVal);
		} else {
			context.getVariableMap().put(Replacement.TMP_INSTANCE_VALUE.name(), "");
		}
		String lineStr = Common.replaceAllKeyWord(Syntax.RETURN, context.getVariableMap());
		return lineStr;
	}
	@ServiceMethodAnn(keyword = { "gen string format"})
	public String genStringFormat(String format) throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		context.getVariableMap().put(Replacement.METHOD_PARAMS_VARIABLE.name(), "\"" + format + "\"");
		String lineStr = Common.replaceAllKeyWord(Syntax.STRING_FORMAT, context.getVariableMap());
		return lineStr;
	}
	@ServiceMethodAnn(keyword = { "gen sys out", "system.out" })
	public String genSysOut(String format, boolean withoutStringFormat, boolean printNotInNewLine) throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		String formatStr = null;
		if (!withoutStringFormat) {
			context.getVariableMap().put(Replacement.METHOD_PARAMS_VARIABLE.name(), "\"" + format + "\"");
			formatStr = Common.replaceAllKeyWord(Syntax.STRING_FORMAT, context.getVariableMap()).trim();
			boolean b = formatStr.endsWith(";");
			if (b) {
				formatStr = formatStr.substring(0, formatStr.length() - 1);
			}
		} else {
			formatStr = "";
		}
		if (printNotInNewLine) {
			context.getVariableMap().put(Replacement.METHOD_NAME.name(), "print");
		} else {
			context.getVariableMap().put(Replacement.METHOD_NAME.name(), "println");
		}
		context.getVariableMap().put(Replacement.METHOD_PARAMS_VARIABLE.name(), formatStr);
		String lineStr = Common.replaceAllKeyWord(Syntax.SYS_OUT, context.getVariableMap());
		return lineStr;
	}
	@ServiceMethodAnn(keyword = { "gen sys out", "system.out" })
	public String genSysOut(String format) throws Exception {
		return genSysOut(format, false, false);
	}
	public MethodCallParamVariableCode getConstructorParamVariablesWithDefaultVal(Constructor ct, Map<Class, String> types) throws Exception {
		MethodCallParamVariableCode mcp;
		Class ps[] = ct.getParameterTypes();
		Parameter pts[] = ct.getParameters();
		StringBuilder sb = new StringBuilder();
		List<String> params = new ArrayList<>();
		for (int i = 0; i < ps.length; i++) {
			Class p = ps[i];
			if (types.containsKey(p)) {
				params.add(types.get(p));
			} else {
				boolean b = Common.isComplexType(p);
				if (b) {
					String s = this.genVariableDeclare(p, null);
					sb.append(s);
					String instanceName = Common.getInstanceName(p);
					types.put(p, instanceName);
					params.add(instanceName);
				} else {
					/*
					 * Parameter pt = pts[i]; params.add(pt.getName());
					 */
					Parameter pt = pts[i];
					types.put(p, pt.getName());
					params.add(pt.getName());
					String s = this.genPrimitiveVariable(p, pt.getName());
					sb.append(s);
				}
			}
		}
		String paramArray[] = params.toArray(new String[params.size()]);
		mcp = new MethodCallParamVariableCode(sb.toString(), paramArray);
		return mcp;
	}
	public String genConstructorStr(@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) Class c, Constructor ct,  Map<Class, String> types) throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		StringBuilder codeLine = new StringBuilder();
		MethodCallParamVariableCode mcp = getConstructorParamVariablesWithDefaultVal(ct, types);
		String[] params = mcp.getParamvariables();
		codeLine.append(mcp.getParamVariableDeclareWithDefaultVal());
		String simpleName = c.getSimpleName();
		context.getVariableMap().put(Replacement.ABSTRACT_CLASS_NAME.name(), simpleName);
		context.getVariableMap().put(Replacement.ABSTRACT_INSTANCE_NAME.name(), Common.getInstanceName(c));
		context.getVariableMap().put(Replacement.TMP_CLASS_NAME.name(),simpleName);
		context.getVariableMap().put(Replacement.SEPERATOR.name()," ");
		String paramVariables = Common.genMethodParamsVariable(params);
		context.getVariableMap().put(Replacement.METHOD_PARAMS_VARIABLE.name(), paramVariables);
		String initLine = Common.replaceAllKeyWord(Syntax.ABSTRACT_NEW_INSTANCE_LINE_WITH_DECLARE_OR_NOT,
				context.getVariableMap());
		codeLine.append(initLine);
		return codeLine.toString();
	}
	public MethodCallParamVariableCode getMethodParamVariablesWithDefaultVal(Method method, Map<Class, String> types) throws Exception {
		MethodCallParamVariableCode mcp;
		Class ps[] = method.getParameterTypes();
		Parameter pts[] = method.getParameters();
		StringBuilder sb = new StringBuilder();
		List<String> params = new ArrayList<>();
		for (int i = 0; i < ps.length; i++) {
			Class p = ps[i];
			if (types.containsKey(p)) {
				params.add(types.get(p));
			} else {
				boolean b = Common.isComplexType(p);
				if (b) {
					String s = this.genVariableDeclare(p, null);
					sb.append(s);
					String instanceName = Common.getInstanceName(p);
					types.put(p, instanceName);
					params.add(instanceName);
				} else {
					/*
					 * Parameter pt = pts[i]; params.add(pt.getName());
					 */
					Parameter pt = pts[i];
					types.put(p, pt.getName());
					params.add(pt.getName());
					String s = this.genPrimitiveVariable(p, pt.getName());
					sb.append(s);
				}
			}
		}
		String paramArray[] = params.toArray(new String[params.size()]);
		mcp = new MethodCallParamVariableCode(sb.toString(), paramArray);
		return mcp;
	}
	public String genCallInstanceMethodStr(@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) Class c,
			String objName, String methodName, boolean omitReturn, String... params) throws Exception {
		Method[] ms = Common.getAllMethods(c);
		Method m = null;
		for (Method m1 : ms) {
			if (m1.getName().equals(methodName) && m1.getParameterCount() == (params != null ? params.length : 0)) {
				m = m1;
				break;
			}
		}
		return genCallInstanceMethodStr(c, objName, m, omitReturn, params);
	}
	public String genCallInstanceMethodStr(@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) Class c, Method m,
			boolean omitReturn, String... params) throws Exception {
		return genCallInstanceMethodStr(c, null, m, omitReturn, params);
	}
	public String genCallInstanceMethodStr1(@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) Class c,
			String objName, Method m, boolean omitReturn, Map<Class, String> types) throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		StringBuilder codeLine = new StringBuilder();
		MethodCallParamVariableCode mcp = getMethodParamVariablesWithDefaultVal(m, types);
		String[] params = mcp.getParamvariables();
		codeLine.append(mcp.getParamVariableDeclareWithDefaultVal());
		String instanceName = Common.getInstanceName(c);
		boolean isVoidMethod = omitReturn || Common.isVoid(m);
		context.getVariableMap().put(Replacement.METHOD_RETURN_VALUE.name(), instanceName);
		if (m.getParameterCount() > 0) {
			String paramVariables = null;
			Class t[] = m.getParameterTypes();
			if (t.length == 1 && Common.isFunctionInterface(t[0])) {
				paramVariables = Common.genFunctionImplementation(t[0], params);
			} else {
				paramVariables = Common.genMethodParamsVariable(params);
			}
			context.getVariableMap().put(Replacement.METHOD_PARAMS_VARIABLE.name(), paramVariables);
		} else {
			context.getVariableMap().put(Replacement.METHOD_PARAMS_VARIABLE.name(), "");
		}
		if (!isVoidMethod) {
			Class returnType = m.getReturnType();
			if (returnType.isArray()) {
				Class eType = returnType.getComponentType();
				String clzName = Common.getClassName(eType, context);
				context.getVariableMap().put(Replacement.RETURN_TYPE.name(), clzName);
				String returnInstanceName = Common.getInstanceName(eType) + "Array[]";
				context.getVariableMap().put(Replacement.RETURN_TYPE_INSTANCE.name(), returnInstanceName);
			} else {
				String clzName = Common.getClassName(returnType, context);
				context.getVariableMap().put(Replacement.RETURN_TYPE.name(), clzName);
				String returnInstanceName = Common.getInstanceName(returnType);
				context.getVariableMap().put(Replacement.RETURN_TYPE_INSTANCE.name(), returnInstanceName);
			}
		}
		if (Common.isStatic(m)) {
			context.getVariableMap().put(Replacement.TMP_INSTANCE_NAME.name(), c.getSimpleName());
		} else {
			context.getVariableMap().put(Replacement.TMP_INSTANCE_NAME.name(),
					objName == null ? Common.getInstanceName(c) : objName);
		}
		context.getVariableMap().put(Replacement.METHOD_NAME.name(), m.getName());
		String methodCallingStr = Common.replaceAllKeyWord(
				isVoidMethod ? Syntax.VOID_METHOD_CALLING : Syntax.METHOD_WITH_RETURN_CALLING,
				context.getVariableMap());
		codeLine.append(methodCallingStr);
		if (!omitReturn && Common.isMethodReturnBoolean(m)) {
			codeLine.append(this.genIfElseBlock(false, "b")).append(Syntax.NEW_LINE);
		}
		return codeLine.toString();
	}
	@ServiceMethodAnn(keyword = "gen call method string")
	public String genCallInstanceMethodStr(@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) Class c,
			String objName, Method m, boolean omitReturn, String... params) throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		String instanceName = Common.getInstanceName(c);
		boolean isVoidMethod = omitReturn || Common.isVoid(m);
		context.getVariableMap().put(Replacement.METHOD_RETURN_VALUE.name(), instanceName);
		if (m.getParameterCount() > 0) {
			String paramVariables = null;
			Class t[] = m.getParameterTypes();
			if (t.length == 1 && Common.isFunctionInterface(t[0])) {
				paramVariables = Common.genFunctionImplementation(t[0], params);
			} else {
				paramVariables = Common.genMethodParamsVariable(params);
			}
			context.getVariableMap().put(Replacement.METHOD_PARAMS_VARIABLE.name(), paramVariables);
		} else {
			context.getVariableMap().put(Replacement.METHOD_PARAMS_VARIABLE.name(), "");
		}
		if (!isVoidMethod) {
			Class returnType = m.getReturnType();
			if (returnType.isArray()) {
				Class eType = returnType.getComponentType();
				String clzName = Common.getClassName(eType, context);
				context.getVariableMap().put(Replacement.RETURN_TYPE.name(), clzName);
				String returnInstanceName = Common.getInstanceName(eType) + "Array[]";
				context.getVariableMap().put(Replacement.RETURN_TYPE_INSTANCE.name(), returnInstanceName);
			} else {
				String clzName = Common.getClassName(returnType, context);
				context.getVariableMap().put(Replacement.RETURN_TYPE.name(), clzName);
				String returnInstanceName = Common.getInstanceName(returnType);
				context.getVariableMap().put(Replacement.RETURN_TYPE_INSTANCE.name(), returnInstanceName);
			}
		}
		if (Common.isStatic(m)) {
			context.getVariableMap().put(Replacement.TMP_INSTANCE_NAME.name(), c.getSimpleName());
		} else {
			context.getVariableMap().put(Replacement.TMP_INSTANCE_NAME.name(),
					objName == null ? Common.getInstanceName(c) : objName);
		}
		context.getVariableMap().put(Replacement.METHOD_NAME.name(), m.getName());
		String methodCallingStr = Common.replaceAllKeyWord(
				isVoidMethod ? Syntax.VOID_METHOD_CALLING : Syntax.METHOD_WITH_RETURN_CALLING,
				context.getVariableMap());
		return methodCallingStr;
	}
	public String genInitAClass(Class c) throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		return Common.initAClass(c, Common.getInstanceName(c), false, context);
	}
	public String genInitAClass(Class c, String instanceName) throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		return Common.initAClass(c, instanceName, false, context);
	}
	public String genInitAClassWithNameDeclare(Class c, boolean hasClassNameDeclare) throws Exception {
		return genInitAClassWithNameDeclare(c, Common.getInstanceName(c), hasClassNameDeclare);
	}
	public String genInitAClassWithNameDeclare(Class c, String instanceName, boolean hasClassNameDeclare)
			throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		return Common.initAClass(c, instanceName, hasClassNameDeclare, context);
	}
	@ServiceMethodAnn(keyword = "gen if else")
	public String genIfElseBlock(boolean withoutElse,
			@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) String... expressions) throws Exception {
		StringBuilder sb = new StringBuilder();
		CodeGenContext context = CodeGenContext.getInstance();
		for (int i = 0; i < expressions.length; i++) {
			if (i > 0 && i <= expressions.length - 1) {
				context.getVariableMap().put(Replacement.PREFIX_STR.name(), "else ");
			} else {
				context.getVariableMap().put(Replacement.PREFIX_STR.name(), "");
			}
			context.getVariableMap().put(Replacement.IF_EXPRESSION.name(), expressions[i]);
			String str = Common.replaceAllKeyWord(Syntax.IF_ELSE_BLOCK, context.getVariableMap());
			sb.append(str);
		}
		if (sb.length() > 0 && !withoutElse) {
			String elseStr = Common.replaceAllKeyWord(Syntax.ELSE_BLOCK, context.getVariableMap());
			sb.append(elseStr);
		}
		return sb.toString();
	}
	@ServiceMethodAnn(keyword = "gen try catch")
	public String genTryCatchBlock(Class... exceptions) throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		context.getVariableMap().put(Replacement.TRY_BODY.name(), "");
		StringBuilder sb = new StringBuilder();
		for (Class c : exceptions) {
			sb.append(c.getSimpleName()).append(" | ");
		}
		if (sb.length() > 0) {
			sb.delete(sb.length() - 2, sb.length());
		}
		context.getVariableMap().put(Replacement.EXCEPTIONS_DECLARE.name(), sb.append(" e").toString());
		context.getVariableMap().put(Replacement.CATCH_BODY.name(), "");
		context.getVariableMap().put(Replacement.FINALLY_BODY.name(), "");
		String str = Common.replaceAllKeyWord(Syntax.TRY_CATCH_BLOCK, context.getVariableMap());
		return str;
	}
	@ServiceMethodAnn(keyword = "gen switch block")
	public String genSwitchBlock(@ParamAnno(description = "variable name for switch") @ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) String switchVariable,
			@ParamAnno(description = "case values(seperate by comma)") @ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) String... caseValues) throws Exception {
		StringBuilder sb = new StringBuilder();
		StringBuilder caseSb = new StringBuilder();
		CodeGenContext context = CodeGenContext.getInstance();
		for (int i = 0; i < caseValues.length; i++) {
			context.getVariableMap().put(Replacement.TMP_INSTANCE_NAME.name(), caseValues[i]);
			String casePart = Common.replaceAllKeyWord(Syntax.SWITCH_CASE_BLOCK, context.getVariableMap());
			caseSb.append(casePart).append(Syntax.NEW_LINE);
		}
		String defaultPart = Common.replaceAllKeyWord(Syntax.SWITCH_DEFAULT_BLOCK, context.getVariableMap());
		caseSb.append(defaultPart).append(Syntax.NEW_LINE);
		context.getVariableMap().put(Replacement.TMP_INSTANCE_NAME.name(), switchVariable);
		context.getVariableMap().put(Replacement.BLOCK_BODY.name(), caseSb.toString());
		String str = Common.replaceAllKeyWord(Syntax.SWITCH_BLOCK, context.getVariableMap());
		sb.append(str);
		return sb.toString();
	}
	public String genField(int modifier, @ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) Class pt,
			boolean withDefaultVal) throws Exception {
		StringBuilder stringBuilder = new StringBuilder();
		CodeGenContext context = CodeGenContext.getInstance();
		if (!Common.isComplexType(pt)) {
			Common.setModifier(modifier, context);
			context.getVariableMap().put(Replacement.FIELD_CLASS_NAME.name(), pt.getSimpleName());
			context.getVariableMap().put(Replacement.FIELD_INSTANCE_NAME.name(), Common.getInstanceName(pt));
			context.getVariableMap().put(Replacement.TMP_INSTANCE_VALUE.name(), Common.getDefaultVal(pt));
			String str = Common.replaceAllKeyWord(Syntax.FIELD_DECLARE_WITH_ASSIGN, context.getVariableMap());
			stringBuilder.append(str);
		}
		return stringBuilder.toString();
	}
	public String genPrimitiveFields(boolean intVariable, boolean booleanVariable, boolean stringVariable,
			boolean longVariable, boolean doubleVariable, boolean floatVariable, boolean charVariable,
			boolean shortVariable, boolean byteVariable, boolean bigIntegerVariable, boolean bigDecimalVariable,
			boolean xmlGregorianCalendarVariable, int modifier) throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		List<Class<?>> list = new ArrayList<>();
		if (intVariable) {
			list.add(int.class);
		}
		if (booleanVariable) {
			list.add(boolean.class);
		}
		if (stringVariable) {
			list.add(String.class);
		}
		if (longVariable) {
			list.add(long.class);
		}
		if (doubleVariable) {
			list.add(double.class);
		}
		if (floatVariable) {
			list.add(float.class);
		}
		if (charVariable) {
			list.add(char.class);
		}
		if (shortVariable) {
			list.add(short.class);
		}
		if (byteVariable) {
			list.add(byte.class);
		}
		if (bigIntegerVariable) {
			list.add(BigInteger.class);
		}
		if (bigDecimalVariable) {
			list.add(BigDecimal.class);
		}
		if (xmlGregorianCalendarVariable) {
			list.add(XMLGregorianCalendar.class);
		}
		StringBuilder stringBuilder = new StringBuilder();
		for (Class pt : list) {
			if (!Common.isComplexType(pt)) {
				Common.setModifier(modifier, context);
				context.getVariableMap().put(Replacement.FIELD_CLASS_NAME.name(), pt.getSimpleName());
				context.getVariableMap().put(Replacement.FIELD_INSTANCE_NAME.name(), Common.getInstanceName(pt));
				context.getVariableMap().put(Replacement.TMP_INSTANCE_VALUE.name(), Common.getDefaultVal(pt));
				String str = Common.replaceAllKeyWord(Syntax.FIELD_DECLARE_WITH_ASSIGN, context.getVariableMap());
				stringBuilder.append(str);
			}
		}
		return stringBuilder.toString();
	}
	@ServiceMethodAnn(keyword = "gen primitive wrapper fields")
	public String genPrimitiveWrapperFields(boolean IntegerVariable, boolean BooleanVariable, boolean StringVariable,
			boolean LongVariable, boolean DoubleVariable, boolean FloatVariable, boolean CharacterVariable,
			boolean ShortVariable, boolean ByteVariable, boolean BigIntegerVariable, boolean BigDecimalVariable,
			boolean xmlGregorianCalendarVariable) throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		List<Class> list = new ArrayList<>();
		if (IntegerVariable) {
			list.add(Integer.class);
		}
		if (BooleanVariable) {
			list.add(Boolean.class);
		}
		if (StringVariable) {
			list.add(String.class);
		}
		if (LongVariable) {
			list.add(Long.class);
		}
		if (DoubleVariable) {
			list.add(Double.class);
		}
		if (FloatVariable) {
			list.add(Float.class);
		}
		if (CharacterVariable) {
			list.add(Character.class);
		}
		if (ShortVariable) {
			list.add(Short.class);
		}
		if (ByteVariable) {
			list.add(Byte.class);
		}
		if (BigIntegerVariable) {
			list.add(BigInteger.class);
		}
		if (BigDecimalVariable) {
			list.add(BigDecimal.class);
		}
		if (xmlGregorianCalendarVariable) {
			list.add(XMLGregorianCalendar.class);
		}
		StringBuilder stringBuilder = new StringBuilder();
		for (Class pt : list) {
			context.getVariableMap().put(Replacement.PRIVILEDGE_MODIFIER.name(), "private");
			context.getVariableMap().put(Replacement.STATIC_MODIFIER.name(), "");
			context.getVariableMap().put(Replacement.FIELD_CLASS_NAME.name(), pt.getSimpleName());
			context.getVariableMap().put(Replacement.FIELD_INSTANCE_NAME.name(), Common.getInstanceName(pt));
			context.getVariableMap().put(Replacement.TMP_INSTANCE_VALUE.name(), Common.getDefaultVal(pt));
			String str = Common.replaceAllKeyWord(Syntax.FIELD_DECLARE_WITH_ASSIGN, context.getVariableMap());
			stringBuilder.append(str);
		}
		return stringBuilder.toString();
	}
	public String genPrimitiveVariables(@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) Class... primitiveClz)
			throws Exception {
		StringBuilder stringBuilder = new StringBuilder();
		for (Class pt : primitiveClz) {
			if (!Common.isComplexType(pt)) {
				CodeGenContext context = CodeGenContext.getInstance();
				context.getVariableMap().put(Replacement.TMP_CLASS_NAME.name(), pt.getSimpleName());
				context.getVariableMap().put(Replacement.TMP_INSTANCE_NAME.name(), Common.getInstanceName(pt));
				context.getVariableMap().put(Replacement.TMP_INSTANCE_VALUE.name(), Common.getDefaultVal(pt));
				String str = Common.replaceAllKeyWord(Syntax.ASSIGN_LINE, context.getVariableMap());
				stringBuilder.append(str);
			}
		}
		return stringBuilder.toString();
	}
	@Deprecated
	public String genPrimitiveVariable(@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) Class primitiveClz,
			String instanceName) throws Exception {
		StringBuilder stringBuilder = new StringBuilder();
		if (!Common.isComplexType(primitiveClz)) {
			CodeGenContext context = CodeGenContext.getInstance();
			context.getVariableMap().put(Replacement.TMP_CLASS_NAME.name(), primitiveClz.getSimpleName());
			context.getVariableMap().put(Replacement.TMP_INSTANCE_NAME.name(),
					!Common.isBlank(instanceName) ? instanceName : Common.getInstanceName(primitiveClz));
			context.getVariableMap().put(Replacement.TMP_INSTANCE_VALUE.name(), Common.getDefaultVal(primitiveClz));
			String str = Common.replaceAllKeyWord(Syntax.ASSIGN_LINE, context.getVariableMap());
			stringBuilder.append(str);
		}
		return stringBuilder.toString();
	}
	@ServiceMethodAnn(keyword = "new prmitive variables")
	public String genPrimitiveVariables(boolean intVariable, boolean booleanVariable, boolean stringVariable,
			boolean longVariable, boolean doubleVariable, boolean floatVariable, boolean charVariable,
			boolean shortVariable, boolean byteVariable, boolean bigIntegerVariable, boolean bigDecimalVariable,
			boolean xmlGregorianCalendarVariable) throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		List<Class> list = new ArrayList<>();
		if (intVariable) {
			list.add(int.class);
		}
		if (booleanVariable) {
			list.add(boolean.class);
		}
		if (stringVariable) {
			list.add(String.class);
		}
		if (longVariable) {
			list.add(long.class);
		}
		if (doubleVariable) {
			list.add(double.class);
		}
		if (floatVariable) {
			list.add(float.class);
		}
		if (charVariable) {
			list.add(char.class);
		}
		if (shortVariable) {
			list.add(short.class);
		}
		if (byteVariable) {
			list.add(byte.class);
		}
		if (bigIntegerVariable) {
			list.add(BigInteger.class);
		}
		if (bigDecimalVariable) {
			list.add(BigDecimal.class);
		}
		if (xmlGregorianCalendarVariable) {
			list.add(XMLGregorianCalendar.class);
		}
		Class clz[] = list.toArray(new Class[] {});
		return genPrimitiveVariables(clz);
	}
	@ServiceMethodAnn(keyword = "new prmitive wrapper variables")
	public String genPrimitiveWrapperVariables(boolean IntegerVariable, boolean BooleanVariable, boolean StringVariable,
			boolean LongVariable, boolean DoubleVariable, boolean FloatVariable, boolean CharacterVariable,
			boolean ShortVariable, boolean ByteVariable, boolean BigIntegerVariable, boolean BigDecimalVariable,
			boolean xmlGregorianCalendarVariable) throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		List<Class> list = new ArrayList<>();
		if (IntegerVariable) {
			list.add(Integer.class);
		}
		if (BooleanVariable) {
			list.add(Boolean.class);
		}
		if (StringVariable) {
			list.add(String.class);
		}
		if (LongVariable) {
			list.add(Long.class);
		}
		if (DoubleVariable) {
			list.add(Double.class);
		}
		if (FloatVariable) {
			list.add(Float.class);
		}
		if (CharacterVariable) {
			list.add(Character.class);
		}
		if (ShortVariable) {
			list.add(Short.class);
		}
		if (ByteVariable) {
			list.add(Byte.class);
		}
		if (BigIntegerVariable) {
			list.add(BigInteger.class);
		}
		if (BigDecimalVariable) {
			list.add(BigDecimal.class);
		}
		if (xmlGregorianCalendarVariable) {
			list.add(XMLGregorianCalendar.class);
		}
		Class clz[] = list.toArray(new Class[] {});
		return genPrimitiveVariables(clz);
	}
	@ServiceMethodAnn(keyword = "gen loop with int variable")
	public String genForLoopWithIntBlock() throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		Class c = int.class;
		context.getVariableMap().put(Replacement.TMP_CLASS_NAME.name(), c.getSimpleName());
		context.getVariableMap().put(Replacement.TMP_INSTANCE_NAME.name(), Common.getInstanceName(c));
		String str = Common.replaceAllKeyWord(Syntax.FOR_LOOP_INCREMENT_BLOCK, context.getVariableMap());
		return str;
	}
	@ServiceMethodAnn(keyword = "gen loop with double variable")
	public String genForLoopWithDoubleBlock() throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		Class c = double.class;
		context.getVariableMap().put(Replacement.TMP_CLASS_NAME.name(), c.getSimpleName());
		context.getVariableMap().put(Replacement.TMP_INSTANCE_NAME.name(), Common.getInstanceName(c));
		String str = Common.replaceAllKeyWord(Syntax.FOR_LOOP_INCREMENT_BLOCK, context.getVariableMap());
		return str;
	}
	@ServiceMethodAnn(keyword = "gen loop with int variable in desc order")
	public String genForLoopWithIntDecrementBlock() throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		Class c = int.class;
		context.getVariableMap().put(Replacement.TMP_CLASS_NAME.name(), c.getSimpleName());
		context.getVariableMap().put(Replacement.TMP_INSTANCE_NAME.name(), Common.getInstanceName(c));
		String str = Common.replaceAllKeyWord(Syntax.FOR_LOOP_DECREMENT_BLOCK, context.getVariableMap());
		return str;
	}
	@ServiceMethodAnn(keyword = "gen loop with double variable in desc order")
	public String genForLoopWithDoubleDecrementBlock() throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		Class c = double.class;
		context.getVariableMap().put(Replacement.TMP_CLASS_NAME.name(), c.getSimpleName());
		context.getVariableMap().put(Replacement.TMP_INSTANCE_NAME.name(), Common.getInstanceName(c));
		String str = Common.replaceAllKeyWord(Syntax.FOR_LOOP_DECREMENT_BLOCK, context.getVariableMap());
		return str;
	}
	@ServiceMethodAnn(keyword = "gen while")
	public String genWhileBlock(String expression) throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		context.getVariableMap().put(Replacement.TMP_INSTANCE_NAME.name(), expression);
		context.getVariableMap().put(Replacement.BLOCK_BODY.name(), "");
		String str = Common.replaceAllKeyWord(Syntax.WHILE_BLOCK, context.getVariableMap());
		return str;
	}
	@ServiceMethodAnn(keyword = "gen do while")
	public String genDoWhileBlock(String expression) throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		context.getVariableMap().put(Replacement.TMP_INSTANCE_NAME.name(), expression);
		context.getVariableMap().put(Replacement.BLOCK_BODY.name(), "");
		String str = Common.replaceAllKeyWord(Syntax.DO_WHILE_BLOCK, context.getVariableMap());
		return str;
	}
	@ServiceMethodAnn(keyword = "gen synchronized block")
	public String genSynchronizedBlock(String objMonitor) throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		context.getVariableMap().put(Replacement.TMP_INSTANCE_NAME.name(), objMonitor);
		context.getVariableMap().put(Replacement.BLOCK_BODY.name(), "");
		String str = Common.replaceAllKeyWord(Syntax.SYNCHRONIZED_BLOCK, context.getVariableMap());
		return str;
	}
	public void importC(Class c) throws Exception {
		this.getkRobot().clickCompositeKey(KeyEvent.VK_CONTROL, KeyEvent.VK_SHIFT, KeyEvent.VK_T);
		Thread.sleep(500);
		this.getkRobot().typeStr(c.getName());
		Thread.sleep(500);
		this.getkRobot().enter();
		Thread.sleep(500);
	}
	public void moveCusorToBeforeLastMethod() throws Exception {
		this.getkRobot().clickCompositeKey(KeyEvent.VK_CONTROL, KeyEvent.VK_O);
		Thread.sleep(500);
		this.getkRobot().arrowDown();
		this.getkRobot().end();
		this.getkRobot().enter();
		this.getkRobot().arrowUp();
		this.getkRobot().end();
		this.getkRobot().enter();
	}
	public void moveCusorToFieldArea() throws Exception {
		this.getkRobot().clickCompositeKey(KeyEvent.VK_CONTROL, KeyEvent.VK_O);
		Thread.sleep(500);
		this.getkRobot().arrowDown();
		this.getkRobot().home();
		this.getkRobot().arrowDown();
		this.getkRobot().enter();
		this.getkRobot().arrowDown();
		this.getkRobot().end();
		this.getkRobot().enter();
	}
	@SuppressWarnings("rawtypes")
	public String genNewMethod(String methodName, Class<?> returnType, int modifier, Class[] exceptions,
			Map.Entry<Class, String>... params) throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		Common.setModifier(modifier, context);
		context.getVariableMap().put(Replacement.METHOD_RETURN_TYPE.name(),
				returnType == Void.class ? "void" : returnType.getSimpleName());
		context.getVariableMap().put(Replacement.METHOD_NAME.name(), methodName);
		context.getVariableMap().put(Replacement.METHOD_RETURN_VALUE.name(), "");
		context.getVariableMap().put(Replacement.METHOD_BODY.name(), "");
		context.getVariableMap().put(Replacement.METHOD_PARAMS_DECLARE.name(),
				Common.genMethodParamDeclareVariable(params));
		context.getVariableMap().put(Replacement.THROWS_EXCEPTION.name(), Common.genExceptionThrows(exceptions));
		String str = Common.replaceAllKeyWord(Syntax.NORMAL_METHOD, context.getVariableMap());
		return str;
	}
	@ServiceMethodAnn(keyword = "new method")
	public String genNewMethod(@ParamAnno(description = "Method Name") @ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) String methodName, int modifier,
			@ParamAnno(description = "Return Type") Class rt,
			@ParamAnno(description = "Method Parameter Types") Class[] params,
			@ParamAnno(description = "Method Exception Types") Class... exceptions) throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		Common.setModifier(modifier, context);
		if(null!=rt) {
			context.getVariableMap().put(Replacement.METHOD_RETURN_TYPE.name(),
					rt == void.class ? "void" : rt.getSimpleName());
		}
		context.getVariableMap().put(Replacement.METHOD_NAME.name(), methodName);
		context.getVariableMap().put(Replacement.METHOD_RETURN_VALUE.name(),
				rt == void.class ? "" : Common.getInstanceName(rt));
		context.getVariableMap().put(Replacement.METHOD_BODY.name(), "");
		String paramDeclare = Common.genMethodParamsDeclaration(params);
		context.getVariableMap().put(Replacement.METHOD_PARAMS_DECLARE.name(), paramDeclare);
		context.getVariableMap().put(Replacement.THROWS_EXCEPTION.name(), Common.genExceptionThrows(exceptions));
		String str = Common.replaceAllKeyWord(Syntax.NORMAL_METHOD, context.getVariableMap());
		return str;
	}
	@ServiceMethodAnn(keyword = "new controller method,spring mvc endpoint")
	public String genControllerMethod(
			@ParamAnno(description = "Method Name") @ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) String methodName, boolean post,
			@ParamAnno(description = "Request Path") String path,
			@ParamAnno(description = "Path variable name") String pathVariableName,
			@ParamAnno(description = "Request parameter name") String requestParamName,
			@ParamAnno(description = "Is Application Form Media Type") boolean consumeUrlEncodeEntireFormData, @ParamAnno(description = "RequestBody Generic Class") Class<?> reqBodyClz,
			@ParamAnno(description = "Contain Response Body Annotation") boolean withResponseBodyAnnotation, int modifier) throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		Common.setModifier(modifier, context);
		context.getVariableMap().put(Replacement.PATH.name(), path);
		context.getVariableMap().put(Replacement.METHOD_STR.name(),
				String.format(",method=RequestMethod.%s", post ? "POST" : "GET"));
		context.getVariableMap().put(Replacement.HEADERS.name(), "");
		context.getVariableMap().put(Replacement.CONSUMERS.name(), consumeUrlEncodeEntireFormData ? ", consumes=MediaType.APPLICATION_FORM_URLENCODED_VALUE" : "");
		StringBuilder produceSb = new StringBuilder();
		context.getVariableMap().put(Replacement.PRODUCES.name(), produceSb.toString());
		context.getVariableMap().put(Replacement.RESPONSE_BODY.name(),
				withResponseBodyAnnotation ? "@ResponseBody ResponseEntity<?>" : "");
		context.getVariableMap().put(Replacement.METHOD_RETURN_TYPE.name(), withResponseBodyAnnotation ? "@ResponseBody ResponseEntity<?>" : "String");
		context.getVariableMap().put(Replacement.METHOD_NAME.name(), methodName);
		context.getVariableMap().put(Replacement.METHOD_RETURN_VALUE.name(), withResponseBodyAnnotation ? "new ResponseEntity(HttpStatus.OK)" : "\"\"");
		context.getVariableMap().put(Replacement.METHOD_BODY.name(), "");
		String paramDeclareJoinStr = "";
		if(!"".equals(pathVariableName.trim())) {
			context.getVariableMap().put(Replacement.TMP_INSTANCE_VALUE.name(), pathVariableName);
			String pathVariable = Common.replaceAllKeyWord("@PathVariable(value=\"$TMP_INSTANCE_VALUE$\") String $TMP_INSTANCE_VALUE$", context.getVariableMap());
			paramDeclareJoinStr += pathVariable;
		}
		if(paramDeclareJoinStr.length()>0) {
			paramDeclareJoinStr +=",";
		}
		if(!"".equals(requestParamName.trim())) {
			context.getVariableMap().put(Replacement.TMP_INSTANCE_VALUE.name(), requestParamName);
			String pathVariable = Common.replaceAllKeyWord("@RequestParam(value=\"$TMP_INSTANCE_VALUE$\", required=true) String $TMP_INSTANCE_VALUE$", context.getVariableMap());
			paramDeclareJoinStr += pathVariable;
		}
		if(paramDeclareJoinStr.length()>0) {
			paramDeclareJoinStr +=",";
		}
		paramDeclareJoinStr = paramDeclareJoinStr + "HttpServletRequest request,HttpServletResponse response";
		if(consumeUrlEncodeEntireFormData) {
			if(paramDeclareJoinStr.length()>0) {
				paramDeclareJoinStr +=",";
			}
			paramDeclareJoinStr =paramDeclareJoinStr+ "@RequestBody MultiValueMap<String, String> formData";
		} else if(null!=reqBodyClz) {
			if(paramDeclareJoinStr.length()>0) {
				paramDeclareJoinStr +=",";
			}
			paramDeclareJoinStr =paramDeclareJoinStr+ "@RequestBody "+reqBodyClz.getSimpleName();
		}
		context.getVariableMap().put(Replacement.METHOD_PARAMS_DECLARE.name(), paramDeclareJoinStr);
		context.getVariableMap().put(Replacement.THROWS_EXCEPTION.name(), "");
		String str = Common.replaceAllKeyWord(Syntax.CONTROLLER_METHOD, context.getVariableMap());
		context.getVariableMap().remove(Replacement.TMP_INSTANCE_VALUE.name());
		return str;
	}
	public String genControllerMethod(@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) String methodName,
			String path, boolean isPostMethod, Class returnType,
			boolean withPathVariableAnnotation, Class[] methodParams, boolean withResponseBodyAnnotation,
			boolean produceXml, boolean produceJson, boolean produceTextHtml, String headers, int modifier,
			Class[] exceptions) throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		Common.setModifier(modifier, context);
		context.getVariableMap().put(Replacement.PATH.name(), path);
		context.getVariableMap().put(Replacement.METHOD_STR.name(),
				String.format(",method=RequestMethod.%s", isPostMethod ? "POST" : "GET"));
		String sArray[] = !"".equals(headers.trim()) ? headers.split(",") : new String[] {};
		String headersJoinStr = sArray.length > 0 ? Stream.of(sArray).collect(Collectors.joining("\",\"", "\"", "\""))
				: "";
		if (headersJoinStr.length() > 0) {
			headersJoinStr = ", headers={" + headersJoinStr + "}";
		}
		context.getVariableMap().put(Replacement.HEADERS.name(), headersJoinStr);
		context.getVariableMap().put(Replacement.CONSUMERS.name(), "");
		StringBuilder produceSb = new StringBuilder();
		boolean b = false;
		if (produceJson) {
			produceSb.append("\"MediaType.APPLICATION_JSON_VALUE\"");
			b = true;
		}
		if (produceXml) {
			if (b) {
				produceSb.append(",");
			}
			produceSb.append("\"MediaType.APPLICATION_XML_VALUE\"");
			b = true;
		}
		if (produceTextHtml) {
			if (b) {
				produceSb.append(",");
			}
			produceSb.append("\"MediaType.TEXT_HTML_VALUE\"");
		}
		if (produceSb.length() > 0) {
			produceSb.insert(0, ", produces={");
			produceSb.append("}");
		}
		context.getVariableMap().put(Replacement.PRODUCES.name(), produceSb.toString());
		context.getVariableMap().put(Replacement.RESPONSE_BODY.name(),
				withResponseBodyAnnotation ? "@ResponseBody" : "");
		context.getVariableMap().put(Replacement.METHOD_RETURN_TYPE.name(),
				returnType == Void.class ? "void" : returnType.getSimpleName());
		context.getVariableMap().put(Replacement.METHOD_NAME.name(), methodName);
		context.getVariableMap().put(Replacement.METHOD_RETURN_VALUE.name(), Common.getInstanceName(returnType));
		context.getVariableMap().put(Replacement.METHOD_BODY.name(), "");
		String paramDeclare = Common.genMethodParamsDeclaration(methodParams);
		String sArray1[] = !"".equals(paramDeclare.trim()) ? paramDeclare.split(",") : new String[] {};
		String paramDeclareJoinStr = sArray1.length > 0
				? Stream.of(sArray1).collect(Collectors.joining(",", "@PathVariable(\"\")", ""))
				: "";
		context.getVariableMap().put(Replacement.METHOD_PARAMS_DECLARE.name(), paramDeclareJoinStr);
		context.getVariableMap().put(Replacement.THROWS_EXCEPTION.name(), Common.genExceptionThrows(exceptions));
		String str = Common.replaceAllKeyWord(Syntax.CONTROLLER_METHOD, context.getVariableMap());
		return str;
	}
	private String genNewMethod(String methodName, String methodBody, Class returnType, int modifier, Class[] params,
			Class... exceptions) throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		Common.setModifier(modifier, context);
		context.getVariableMap().put(Replacement.METHOD_RETURN_TYPE.name(),
				returnType == Void.class ? "void" : returnType.getSimpleName());
		context.getVariableMap().put(Replacement.METHOD_NAME.name(), methodName);
		context.getVariableMap().put(Replacement.METHOD_RETURN_VALUE.name(), Common.getInstanceName(returnType));
		context.getVariableMap().put(Replacement.METHOD_BODY.name(), methodBody);
		String paramDeclare = Common.genMethodParamsDeclaration(params);
		context.getVariableMap().put(Replacement.METHOD_PARAMS_DECLARE.name(), paramDeclare);
		context.getVariableMap().put(Replacement.THROWS_EXCEPTION.name(), Common.genExceptionThrows(exceptions));
		String str = Common.replaceAllKeyWord(Syntax.NORMAL_METHOD, context.getVariableMap());
		return str;
	}
	public String genNewMethodReturnVoid(String methodName, int modifier, Class[] params, Class... exceptions)
			throws Exception {
		return genNewMethod(methodName, modifier, Void.class, params, exceptions);
	}
	public String genNewMethodReturnVoid(String methodName, int modifier, Class[] exceptions,
			Map.Entry<Class, String>... params) throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		Common.setModifier(modifier, context);
		context.getVariableMap().put(Replacement.METHOD_PARAMS_DECLARE.name(),
				Common.genMethodParamDeclareVariable(params));
		context.getVariableMap().put(Replacement.METHOD_RETURN_TYPE.name(), "");
		context.getVariableMap().put(Replacement.METHOD_NAME.name(), methodName);
		context.getVariableMap().put(Replacement.METHOD_RETURN_VALUE.name(), "");
		context.getVariableMap().put(Replacement.METHOD_BODY.name(), "");
		context.getVariableMap().put(Replacement.THROWS_EXCEPTION.name(), Common.genExceptionThrows(exceptions));
		String str = Common.replaceAllKeyWord(Syntax.NORMAL_METHOD, context.getVariableMap());
		return str;
	}
	public String genNewExceptionThrow(Class<? extends Exception> c, String... strings) throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		strings = strings == null ? new String[] { "" } : strings;
		context.getVariableMap().put(Replacement.METHOD_PARAMS_VARIABLE.name(),
				Common.genMethodParamsVariable(strings));
		context.getVariableMap().put(Replacement.TMP_CLASS_NAME.name(), c.getSimpleName());
		String str = Common.replaceAllKeyWord(Syntax.NEW_EXCEPTION_THROW, context.getVariableMap());
		return str;
	}
	@ServiceMethodAnn(keyword = "switch Process")
	public boolean switchProcess() throws Exception {
		return sendKeys(CodeGenContext.getIDEProcNameKeyword(), "");
	}
	@ServiceMethodAnn(keyword = "paste")
	public boolean paste() throws IOException {
		return sendKeys(CodeGenContext.getIDEProcNameKeyword(),"^(v)");
	}
	public boolean sendKeys(String processNameContain, String keys)
			throws IOException {
		boolean b = false;
		keys = "\""+ keys +"\"";
		String path = CodeGenContext.getCGKeyAppPath();
		Process proc = Runtime.getRuntime().exec(String.format("%s %s %s",path, processNameContain, keys));
		BufferedReader stdInput = new BufferedReader(new
				InputStreamReader(proc.getInputStream()));
		BufferedReader stdError = new BufferedReader(new
				InputStreamReader(proc.getErrorStream()));
		String s = null;
		while ((s = stdInput.readLine()) != null) {
			if("0".equalsIgnoreCase(s)){
				return true;
			}else{
				return false;
			}
		}
		System.out.println("Here is the standard error of the command (if any):\n");
		while ((s = stdError.readLine()) != null) {
			if("0".equalsIgnoreCase(s)){
				return true;
			}else{
				return false;
			}
		}
		return b;
	}
	public static void tryActiveEclipseWindow(boolean blockUtilActive) throws Exception {
		return;
	}
	public boolean isActiveEclipseWindow() {
		boolean b = false;
		String activeWindow = null;
		int maxTime = 3;
		do {
			try {
				activeWindow = getActiveWindow();
			} catch (Exception e) {
			}
			maxTime--;
			b=activeWindow.toLowerCase().contains(Const.ECLIPSE_WINDOW_TITLE_KEYWORD);
			if(!b) {
				try {
					Thread.sleep(300L);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
			}
		} while (activeWindow != null && !b
				&& maxTime > 0);
		return b;
	}
	@ServiceMethodAnn(keyword = "get active window")
	public String getActiveWindow() throws Exception {
		return windowService.getActiveWindowText();
	}
	public boolean isActiveWindowTitleContainIgnoreCase(String title) throws Exception {
		String currentActiveWindow = this.windowService.getActiveWindowText();
		currentActiveWindow = currentActiveWindow.toLowerCase();
		return currentActiveWindow.contains(title);
	}
	public static boolean isActiveWindowTitleEqualsIgnoreCase(String title) throws Exception {
		return false;
	}
	public void deleteLine() {
		this.getkRobot().clickCompositeKey(KeyEvent.VK_CONTROL, KeyEvent.VK_D);
	}
	@ServiceMethodAnn(keyword = "gen main method")
	public String genMain() {
		return Syntax.MAIN_BLOCK;
	}
	public void newSthHotKey() {
		this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_SHIFT, KeyEvent.VK_N);
	}
	public void saveFile() {
		this.getkRobot().clickCompositeKey(KeyEvent.VK_CONTROL, KeyEvent.VK_S);
	}
	public void fixProb() {
		this.getkRobot().clickCompositeKey(KeyEvent.VK_CONTROL, KeyEvent.VK_1);
	}
	public void closeTab() {
		this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_MINUS);
		this.getkRobot().clickKey(KeyEvent.VK_C);
	}
	public void closeAllTab() {
		this.getkRobot().clickCompositeKey(KeyEvent.VK_CONTROL, KeyEvent.VK_SHIFT, KeyEvent.VK_W);
	}
	public void linkExplorer() {
		this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_SHIFT, KeyEvent.VK_W);
		this.getkRobot().arrowDown();
		this.getkRobot().enter();
	}
	@ServiceMethodAnn(keyword = "new file wizard")
	public void createFileByOtherWizard(String jspFileName, String fileType) throws Exception {
		if(!this.openWizard())
			return;
		Thread.sleep(500);
		this.getkRobot().typeStr("jsp file");
		this.getkRobot().enter();
		Thread.sleep(500);
		this.getkRobot().typeStr(fileType);
		this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_N);
		Thread.sleep(500);
		this.getkRobot().typeStr(jspFileName);
		this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_N);
		Thread.sleep(500);
		this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_F);
	}
	@ServiceMethodAnn(keyword = "new jsp file")
	public void createJspFileByOtherWizard(String fileName, String fileType) throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		createFileByOtherWizard(fileName, "jsp file");
	}
	@ServiceMethodAnn(keyword = "new css file")
	public void createCssFileByOtherWizard(String fileName, String fileType) throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		createFileByOtherWizard(fileName, "css file");
	}
	@ServiceMethodAnn(keyword = "new html file")
	public void createHtmlFileByOtherWizard(String fileName, String fileType) throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		createFileByOtherWizard(fileName, "html file");
	}
	@ServiceMethodAnn(keyword = "create maven project by template")
	public void createNewMavenProjByTemplate(String groupId, String artifactroyId, String version, String pack,
			@ParamAnno(description = "Target Directory")
			@FileChooserAnnotation(chooseDirOnly = true) @ValidationAnn(validations = {
					"codegen.eclipseRobot.MandatoryCheck" }) File baseDirectory)
			throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		String baseDir = baseDirectory.getAbsolutePath();
		InputStream is = this.getClass().getClassLoader().getResourceAsStream("pom.xml.template2");
		String pomTemplate = Common.readAsStr(is);
		context.getVariableMap().put(MoreReplacement.GROUP_ID.name(), groupId);
		context.getVariableMap().put(MoreReplacement.ARTIFACT_ID.name(), artifactroyId);
		context.getVariableMap().put(MoreReplacement.ARTIFACT_VERSION.name(),
				version != null && !"".equals(version.trim()) ? version : "1.0-SNAPSHOT");
		context.getVariableMap().put(MoreReplacement.ARTIFACT_PACK.name(),
				pack != null && !"".equals(pack.trim()) ? pack : "jar");
		String pomStr = Common.replaceAllKeyWord(pomTemplate, context.getVariableMap());
		File file = new File(baseDir + "/src/test/java");
		file.mkdirs();
		File mainDir = new File(baseDir + "/src/main/java");
		mainDir.mkdirs();
		File rsDir = new File(baseDir + "/src/main/resources");
		rsDir.mkdirs();
		File pomFile = new File(baseDir + File.separatorChar + "pom.xml");
		Common.write(pomFile, pomStr);
		if(!this.isActiveEclipseWindow())
			return;
		this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_F);
		this.getkRobot().clickKey(KeyEvent.VK_I);
		Thread.sleep(100);
		this.getkRobot().typeStr("existing maven project");
		Thread.sleep(500);
		this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_N);
		Thread.sleep(500);
		this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_R);
		Thread.sleep(500);
		this.getkRobot().typeStr(baseDir);
		this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_A);
		Thread.sleep(500);
		this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_F);
	}
	@ServiceMethodAnn(keyword = { "run cp monitor" })
	public void runClipboardMonitor(File targetFile) {
		runExternalApp(targetFile, " host localhost port 8888");
	}
	@ServiceMethodAnn(keyword = { "run app" })
	public void runExternalApp(File targetFile,
			String args) {
		Runtime runtime = Runtime.getRuntime();
		String path = targetFile.getAbsolutePath() + " " + args;
		Process process = null;
		try {
			process = runtime.exec(path);
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
	@ServiceMethodAnn(keyword = { "gen maven dependency"})
	public static String genMavenDependency(String groupId, String arttifactorId, String version, String scope) throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		context.getVariableMap().put(Replacement.GROUP_ID.name(), groupId);
		context.getVariableMap().put(Replacement.ARTIFACTOR_ID.name(), arttifactorId);
		context.getVariableMap().put(Replacement.VERSION.name(), version);
		context.getVariableMap().put(Replacement.SCOPE.name(), scope);
		String str = Common.replaceAllKeyWord(Syntax.MAVEN_DEPENDENCY, context.getVariableMap());
		str = str.replaceAll("\\s*<version></version>\\s*","");
		str = str.replaceAll("\\s*<scope>\\s*</scope>","");
		return str;
	}
	@ServiceMethodAnn(keyword = { "string append", "string builder", "string buffer" })
	public static String genStringAppend(boolean stringBuilder, boolean stringBuffer) {
		StringBuilder sb = new StringBuilder();
		String str = stringBuilder ? "StringBuilder" : "StringBuffer";
		sb.append(String.format("%s sb = new %s();", str, str)).append(Syntax.NEW_LINE);
		sb.append(String.format("sb.append();"));
		return sb.toString();
	}
	@ServiceMethodAnn(keyword = { "string split", "string join" })
	public static String genStringSplitThenJoin(String delimiterWhenSplit, String delimiter, String prefix,
			String suffix) {
		StringBuilder sb = new StringBuilder();
		sb.append(String.format("String sArray[] = str.split(\"%s\");", delimiterWhenSplit)).append(Syntax.NEW_LINE);
		sb.append(
				String.format("String joinStr = Stream.of(sArray).collect(Collectors.joining(\"%s\", \"%s\", \"%s\"));",
						delimiter, prefix, suffix));
		return sb.toString();
	}
	public void collapseAll() {
		this.getkRobot().clickCompositeKey(KeyEvent.VK_CONTROL, KeyEvent.VK_SHIFT, KeyEvent.VK_DIVIDE);
	}
	public void runApp() throws Exception {
		this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_SHIFT, KeyEvent.VK_X);
		this.getkRobot().clickKey(KeyEvent.VK_J);
	}
	public void debugApp() throws Exception {
		this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_SHIFT, KeyEvent.VK_D);
		this.getkRobot().clickKey(KeyEvent.VK_J);
	}
	@ServiceMethodAnn(keyword = { "Lambda filter for Collection", "lambda tolist", "lambda tomap" })
	public String genCollStream(@ParamAnno(description = "Collection Name") String collectionName,
			@ParamAnno(description = "With for each") boolean needForEach,
			@ParamAnno(description = "With Filter") boolean needFilter,
			@ParamAnno(description = "With Distinct") boolean needDistinct,
			@ParamAnno(description = "With Sort") boolean needSort,
			@ParamAnno(description = "With Map") boolean needMap,
			@ParamAnno(description = "Collect As List") boolean collectAsList,
			@ParamAnno(description = "Collect As Set") boolean collectAsSet,
			@ParamAnno(description = "Collect As Map") boolean collectAsMap) throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		context.getVariableMap().put(Replacement.TMP_INSTANCE_VALUE.name(), collectionName);
		if (collectAsList) {
			context.getVariableMap().put(Replacement.TMP_CLASS_NAME.name(), "List");
			context.getVariableMap().put(Replacement.TMP_INSTANCE_NAME.name(), "list");
		} else if (collectAsMap) {
			context.getVariableMap().put(Replacement.TMP_CLASS_NAME.name(), "Map");
			context.getVariableMap().put(Replacement.TMP_INSTANCE_NAME.name(), "map");
		} else {
			context.getVariableMap().put(Replacement.TMP_CLASS_NAME.name(), "");
			context.getVariableMap().put(Replacement.TMP_INSTANCE_NAME.name(), "");
			context.getVariableMap().put(Replacement.ASSIGN_SYMBOL.name(), "");
		}
		StringBuilder sb = new StringBuilder(
				Common.replaceAllKeyWord(Syntax.COLLECTION_STREAM, context.getVariableMap()));
		if (needForEach) {
			sb.append(Common.replaceAllKeyWord(Syntax.STREAM_FOREACH, context.getVariableMap()));
		}
		if (needFilter) {
			sb.append(Common.replaceAllKeyWord(Syntax.STREAM_FILTER, context.getVariableMap()));
		}
		if (needDistinct) {
			sb.append(Common.replaceAllKeyWord(Syntax.STREAM_DISTINCT, context.getVariableMap()));
		}
		if (needSort) {
			sb.append(Common.replaceAllKeyWord(Syntax.STREAM_SORT, context.getVariableMap()));
		}
		if (needMap) {
			sb.append(Common.replaceAllKeyWord(Syntax.STREAM_MAP, context.getVariableMap()));
		}
		if (collectAsList) {
			sb.append(Common.replaceAllKeyWord(Syntax.STREAM_COLLECT_AS_LIST, context.getVariableMap()));
		} else if (collectAsSet) {
			sb.append(Common.replaceAllKeyWord(Syntax.STREAM_COLLECT_AS_SET, context.getVariableMap()));
		} else if (collectAsMap) {
			context.getVariableMap().put(Replacement.GENERIC_TYPE_KEY.name(), "");
			context.getVariableMap().put(Replacement.GENERIC_TYPE_VAL.name(), "");
			sb.append(Common.replaceAllKeyWord(Syntax.STREAM_COLLECT_AS_CONCURRENTMAP, context.getVariableMap()));
		} else {
			context.getVariableMap().put(Replacement.TMP_CLASS_NAME.name(), "");
			context.getVariableMap().put(Replacement.TMP_INSTANCE_NAME.name(), "");
		}
		sb.append(Syntax.END_OF_LINE);
		context.getVariableMap().put(Replacement.ASSIGN_SYMBOL.name(), Syntax.ASSIGN_SYMBOL);
		return sb.toString();
	}
	@ServiceMethodAnn(keyword = "Lambda filter for Map")
	public String genMapStream(String mapName, boolean keySetStream, boolean entryStream, boolean valueStream,
			boolean needForEach, boolean needFilter, boolean needDistinct, boolean needSort, boolean needMap, boolean collectAsList,boolean collectAsSet, boolean collectAsMap)
			throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		StringBuilder sb = new StringBuilder();
		context.getVariableMap().put(Replacement.TMP_INSTANCE_NAME.name(), mapName);
		String syntax = null;
		if (keySetStream) {
			syntax = Syntax.MAP_KEY_SET;
		} else if (entryStream) {
			syntax = Syntax.MAP_ENTRY_SET;
		} else if (valueStream) {
			syntax = Syntax.MAP_VALUES;
		}
		sb.append(Common.replaceAllKeyWord(syntax, context.getVariableMap()));
		String collStr = genCollStream("", needForEach, needFilter,needDistinct, needSort, needMap, collectAsList, collectAsSet, collectAsMap);
		sb.append(collStr);
		return sb.toString();
	}
	@ServiceMethodAnn(keyword = "print pixel color")
	public void printPixelColor() {
		java.awt.PointerInfo pointerInfo = MouseInfo.getPointerInfo();
		java.awt.Point point = pointerInfo.getLocation();
		Rectangle rect = new Rectangle((int) point.getX(), (int) point.getY(), 2, 2);
		BufferedImage img = this.getkRobot().getRobot().createScreenCapture(rect);
		int i = img.getRGB(0, 0);
		this.getmRobot().breakAlphaAndRGB(i);
		return;
	}
	public void switchFile(boolean back) {
		if (back)
			this.getkRobot().clickCompositeKey(KeyEvent.VK_CONTROL, KeyEvent.VK_F6);
		else
			this.getkRobot().clickCompositeKey(KeyEvent.VK_CONTROL, KeyEvent.VK_SHIFT, KeyEvent.VK_F6);
		return;
	}
	@ServiceMethodAnn(keyword = {"regex","regular expression match"})
	public String genRegexRelated(String regex, boolean notWithFind) throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		StringBuilder sb = new StringBuilder();
		String patternInstanceName = Common.getInstanceName(Pattern.class);
		String matcherInstanceName = Common.getInstanceName(Matcher.class);
		context.getVariableMap().put(Replacement.TMP_INSTANCE_VALUE.name(), patternInstanceName);
		context.getVariableMap().put(Replacement.TMP_INSTANCE_NAME.name(), "\"" + regex + "\"");
		String patternCompile = Common.replaceAllKeyWord(Syntax.PATTERN_COMPILE, context.getVariableMap());
		context.getVariableMap().put(Replacement.TMP_INSTANCE_VALUE.name(), matcherInstanceName);
		context.getVariableMap().put(Replacement.TMP_INSTANCE_NAME.name(), patternInstanceName);
		context.getVariableMap().put(Replacement.METHOD_PARAMS_VARIABLE.name(), "\"\"");
		String createMatchor = Common.replaceAllKeyWord(Syntax.PATTERN_CREATE_MATCHER, context.getVariableMap());
		sb.append(patternCompile).append(Syntax.NEW_LINE);
		sb.append(createMatchor).append(Syntax.NEW_LINE);
		String booleanName = Common.getInstanceName(boolean.class);
		if (!notWithFind) {
			context.getVariableMap().put(Replacement.TMP_INSTANCE_VALUE.name(), booleanName);
			context.getVariableMap().put(Replacement.TMP_INSTANCE_NAME.name(), matcherInstanceName);
			String findStr = Common.replaceAllKeyWord(Syntax.MATCHER_FIND, context.getVariableMap());
			sb.append(findStr).append(Syntax.NEW_LINE);
		} else {
			context.getVariableMap().put(Replacement.TMP_INSTANCE_VALUE.name(), booleanName);
			context.getVariableMap().put(Replacement.TMP_INSTANCE_NAME.name(), matcherInstanceName);
			String etireMatches = Common.replaceAllKeyWord(Syntax.MATCHER_MATCHES, context.getVariableMap());
			sb.append(etireMatches).append(Syntax.NEW_LINE);
		}
		return sb.toString();
	}
	@ServiceMethodAnn(keyword = { "gen code line", "generate code line" })
	public String genCallInstanceMethodStrByQualifierNames(
			@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) String[] qualifierNames, boolean genConstructor) {
		List<QualifierName> list = new ArrayList<>();
		for (String qn : qualifierNames) {
			QualifierName qualifierName = DataModel.extractQualifierName(qn);
			list.add(qualifierName);
		}
		String s = this.genCodeByQualifierNames(list, genConstructor);
		return s;
	}
	public String genCodeByMethods(Class<?>[] c, String[] ms) {
		StringBuilder sb = new StringBuilder();
		return sb.toString();
	}
	@ServiceMethodAnn(keyword = "gen one pojo class initlization code")
	public String genCode(@ParamAnno(description = "Class") Class c) {
		return "";
	}
	@ServiceMethodAnn(keyword = { "gen code"})
	@UIAnno(uiClz="ui.GenCodePane")
	public void genCode() {
	}
	/**
	 * copy qualifier name by a qualifier name and give parameter types followed
	 *
	 * @param list
	 *
	 * @return
	 */
	public String genCodeByQualifierNames(List<QualifierName> list, boolean genConstructor) {
		CodeGenContext context = CodeGenContext.getInstance();
		StringBuilder sb = new StringBuilder();
		Map<Class, String> types = new HashMap<>();
		list.forEach(qn -> {
			try {
				Method method = QualifierName.getMethodByQualifierName(qn);
				if (method != null) {
					boolean isClassCast = qn.isClassCastMethod(method);
					if (!isClassCast) {
						boolean isMethodVariable = qn.isMethodVariable();
						if (!isMethodVariable) {
							Class rt = method.getReturnType();
							if (!rt.equals(Void.TYPE) && !types.containsKey(rt)) {
								types.put(rt, Common.getInstanceName(rt));
							}
						} else {
						}
						Class ps[] = method.getParameterTypes();
						Parameter pts[] = method.getParameters();
						List<String> params = new ArrayList<>();
						for (int i = 0; i < ps.length; i++) {
							Class p = ps[i];
							boolean isComplex = Common.isComplexType(p);
							if (!isComplex && !types.containsKey(p)) {
							}
						}
					} else {
					}
				} else if (qn.getClassQualifierName() != null) {
					boolean isConstructor = qn.isConstructor();
					Class c = null;
					try {
						c = context.getReloadableDynamicClassLoaderOwner().loadClass(qn.getClassQualifierName(), true);
					} catch (Exception e) {
						e.printStackTrace();
					}
					if (c != null) {
						if (!isConstructor) {
							boolean isField = qn.isField();
							if (isField) {
								try {
									Field f = c.getField(qn.getFieldName());
									if (!types.containsKey(f.getDeclaringClass())) {
										types.put(f.getDeclaringClass(), qn.getFieldName());
									}
								} catch (Exception e) {
									e.printStackTrace();
								}
							} else {
								try {
									if (!types.containsKey(c)) {
										types.put(c, Common.getInstanceName(c));
									}
								} catch (Exception e) {
									e.printStackTrace();
								}
							}
						} else {
							if (!types.containsKey(c)) {
								types.put(c, Common.getInstanceName(c));
							}
						}
					}
				}
			} catch (Exception e) {
				e.printStackTrace();
			}
		});
		list.forEach(qn -> {
			try {
				if (qn.getClz() != null) {
					Method method = QualifierName.getMethodByQualifierName(qn);
					if (method != null) {
						boolean isClassCast = qn.isClassCastMethod(method);
						if (!isClassCast) {
							boolean isMethodVariable = qn.isMethodVariable();
							if (!isMethodVariable) {
								Class ps[] = method.getParameterTypes();
								Parameter pts[] = method.getParameters();
								List<String> params = new ArrayList<>();
								for (int i = 0; i < ps.length; i++) {
									Class p = ps[i];
									if (types.containsKey(p)) {
										params.add(types.get(p));
									} else {
										boolean b = Common.isComplexType(p);
										if (b) {
											String s = this.genVariableDeclare(p, null);
											sb.append(s);
											params.add(Common.getInstanceName(p));
										} else {
											/*
											 * Parameter pt = pts[i]; params.add(pt.getName());
											 */
											Parameter pt = pts[i];
											params.add(pt.getName());
											String s = this.genPrimitiveVariable(p, pt.getName());
											sb.append(s);
										}
									}
								}
								String paramArray[] = params.toArray(new String[params.size()]);
								String methodCallStr = this.genCallInstanceMethodStr(method.getDeclaringClass(), method,
										false, paramArray);
								sb.append(methodCallStr);
								if (Common.isMethodReturnBoolean(method)) {
									sb.append(this.genIfElseBlock(false, "b")).append(Syntax.NEW_LINE);
								}
							}
						} else {
						}
					} else if (qn.getClassQualifierName() != null) {
						boolean isConstructor = qn.isConstructor();
						Class c = null;
						try {
							c = context.getReloadableDynamicClassLoaderOwner().loadClass(qn.getClassQualifierName(),
									true);
						} catch (Exception e) {
							e.printStackTrace();
						}
						if (c != null) {
							if (isConstructor) {
								Constructor<?> ct = QualifierName.getConstructorByQualifierName(qn);
								String str = Common.initAClass(c, ct, Common.getInstanceName(c), true, context);
								sb.append(str);
							}
						}
					}
				} else {
					boolean isConstructor = qn.isConstructor();
					if (isConstructor) {
						String clzForPrint = !context.isGenFullQualifierName() ? qn.getClzSimpleName()
								: qn.getClassQualifierName();
						String params = (qn.getConstructParam() != null && !"".equals(qn.getConstructParam()))
								? String.join(",", qn.getConstructParam())
								: "";
						/*
						 * String instanceName = Common.makeFirstCharInLowercase(qn.getClzSimpleName()
						 * ); sb.append(clzForPrint).append(" " ).append(instanceName).append(" = new "
						 * ).append(qn.getClzSimpleName()).append("(").append( params).append(")");
						 */
						context.getVariableMap().put(Replacement.ABSTRACT_CLASS_NAME.name(), clzForPrint);
						context.getVariableMap().put(Replacement.SEPERATOR.name(), " ");
						String instanceName = Common.makeFirstCharInLowercase(qn.getClzSimpleName());
						context.getVariableMap().put(Replacement.ABSTRACT_INSTANCE_NAME.name(), instanceName);
						context.getVariableMap().put(Replacement.TMP_CLASS_NAME.name(), clzForPrint);
						context.getVariableMap().put(Replacement.METHOD_PARAMS_VARIABLE.name(), params);
						String initLine = Common.replaceAllKeyWord(
								Syntax.ABSTRACT_NEW_INSTANCE_LINE_WITH_DECLARE_OR_NOT, context.getVariableMap());
						sb.append(initLine);
					}
					boolean isMethodQualifier = qn.isMethodQualifier();
					if (isMethodQualifier) {
						String instanceName = Common.makeFirstCharInLowercase(qn.getClzSimpleName());
						String params = (qn.getMethodParam() != null && !"".equals(qn.getMethodParam()))
								? String.join(",", qn.getMethodParam())
								: "";
						context.getVariableMap().put(Replacement.METHOD_PARAMS_VARIABLE.name(), params);
						context.getVariableMap().put(Replacement.TMP_INSTANCE_NAME.name(), instanceName);
						context.getVariableMap().put(Replacement.METHOD_NAME.name(), qn.getMethodName());
						String methodCallingStr = Common.replaceAllKeyWord(Syntax.VOID_METHOD_CALLING,
								context.getVariableMap());
						sb.append(methodCallingStr);
					}
				}
			} catch (Exception e) {
				e.printStackTrace();
			}
		});
		return sb.toString();
	}
	@Deprecated
	public void gitPull1() throws Exception {
		this.popupContextMenu();
		int i = 14;
		this.getkRobot().arrowDown(i);
		this.getkRobot().arrowRight();
		String s = "Pull";
		this.blockUntilFound(s, DIALOG_FONT_NAME, Color.BLACK);
		this.getkRobot().enter();
		return;
	}
	public void gitPull(String basePath) throws Exception {
		this.openExplorer();
		this.popupContextMenu();
		int i = 14;
		this.getkRobot().arrowDown(i);
		this.getkRobot().arrowRight();
		String s = "Pull";
		this.blockUntilFound(s, DIALOG_FONT_NAME, Color.BLACK);
		this.getkRobot().enter();
		return;
	}
	@ServiceMethodAnn(keyword = { "gen log trace", "log trace" })
	public String genLoggerTrace() {
		return Syntax.LOGGER_TRACE;
	}
	@ServiceMethodAnn(keyword = { "log debug" })
	public String genLoggerDebug() {
		return Syntax.LOGGER_DEBUG;
	}
	@ServiceMethodAnn(keyword = { "log info" })
	public String genLoggerInfo() {
		return Syntax.LOGGER_INFO;
	}
	@ServiceMethodAnn(keyword = { "log error" })
	public String genLoggerError() {
		return Syntax.LOGGER_ERROR;
	}
	@ServiceMethodAnn(keyword = { "log fatal" })
	public String genLoggerFatal() {
		return Syntax.LOGGER_FATAL;
	}
	public String getBaseDir() {
		File file = new File(".");
		String s = file.getAbsolutePath();
		return s;
	}
	public void openPom() throws Exception {
		this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_F);
		this.getkRobot().clickKey(KeyEvent.VK_PERIOD);
		this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_N);
		String s = this.getBaseDir() + "\\pom.xml";
		this.getkRobot().typeStr(s);
		this.blockUntilFound(s, SPECIAL_DIALOG_FONT_NAME, MENU_ITEM_SIZE, Color.BLACK);
		this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_O);
		return;
	}
	@ServiceMethodAnn(keyword = "gen sys input")
	public String genSysInput() throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		String str = Common.replaceAllKeyWord(Syntax.SYS_IN, context.getVariableMap());
		return str;
	}
	@ServiceMethodAnn(keyword = "gen methods by qualifier names")
	public String genBatchCreateMethodsByQualifierNames(String[] qualifierNames, boolean genFullQualifierName,
			int modifier) throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		List<Class> clist = new ArrayList<>();
		for (String qn : qualifierNames) {
			QualifierName qualifierName = DataModel.extractQualifierName(qn);
			if (qualifierName.getClz() != null)
				clist.add(qualifierName.getClz());
		}
		String s = this.genBatchCreateMethods(clist, modifier, genFullQualifierName, new Class[] {});
		return s;
	}
	@ServiceMethodAnn(keyword = "gen methods")
	public String genBatchCreateMethods(List<Class> clzs, int modifier, boolean genFullQualifierName,
			Class... exceptions) throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		StringBuilder stringBuilder = new StringBuilder();
		context.setGenFullQualifierName(genFullQualifierName);
		for (Class c : clzs) {
			String defaultCreateMethodName = Common.getDefaultCreateMethodName(c);
			String s = genCode(c);
			Class rt = c;
			String entireMethodCode = genNewMethod(defaultCreateMethodName, s, rt, modifier, exceptions);
			stringBuilder.append(entireMethodCode).append(Syntax.NEW_LINE);
		}
		return stringBuilder.toString();
	}
	@ServiceMethodAnn(keyword = "gen foreach")
	public String genForEach(Class itemClz, String collName) throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		String itemName = Common.getInstanceName(itemClz);
		return genForEach(itemClz, itemName, collName);
	}
	@ServiceMethodAnn(keyword = "gen foreach 2")
	public String genForEach(Class itemClz, String itemName, String collName) throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		context.getVariableMap().put(Replacement.TMP_CLASS_NAME.name(), itemClz.getSimpleName());
		context.getVariableMap().put(Replacement.ITEM_NAME.name(), itemName);
		context.getVariableMap().put(Replacement.TMP_INSTANCE_NAME.name(), collName);
		String str = Common.replaceAllKeyWord(Syntax.FOR_EACH_BLOCK, context.getVariableMap());
		return str;
	}
	@ServiceMethodAnn(keyword = "set mvn home")
	public void setMvnHome(@FileChooserAnnotation(chooseDirOnly = true) @ValidationAnn(validations = {
			"codegen.eclipseRobot.MandatoryCheck" }) File mvnHome) throws Exception {
		String path = mvnHome.getAbsolutePath();
		CodeGenContext.setMavenHome(path);
		try {
		    EclipseCodeGenContext.getInstance().getDatabaseService().saveOrUpdate(H2JDBCService.CONFIG_TABLE, codegen.Const.BRAIN_MVN_HOME_KEYWORD, path);
		} catch (Exception e) {
			throw new Exception("memorize maven home failed");
		}
	}
	@ServiceMethodAnn(keyword = "set local repository")
	public void setLocalRepoDir(@FileChooserAnnotation(chooseDirOnly = true) @ValidationAnn(validations = {
			"codegen.eclipseRobot.MandatoryCheck" }) File localRepoDir) throws Exception {
		String path = localRepoDir.getAbsolutePath();
		CodeGenContext.setLocalRepoDir(path);
		try {
		    EclipseCodeGenContext.getInstance().getDatabaseService().saveOrUpdate(H2JDBCService.CONFIG_TABLE, codegen.Const.BRAIN_LOCAL_REPO_KEYWORD, path);
		} catch (Exception e) {
			throw new Exception("memorize local repository failed");
		}
	}
	@ServiceMethodAnn(keyword = "gen mvn cmd file")
	public static File genMvnCommandBuild(File pomFile, boolean clean, boolean compile, boolean install, boolean deploy, boolean pack,
			boolean skipTest, boolean debug, boolean isForUnix) throws IOException {
		Runtime runtime = Runtime.getRuntime();
		String path = pomFile.getAbsolutePath();
		String properties = "";
		if (skipTest) {
			properties = "-Dmaven.test.skip=true";
		}
		String debugParam = "";
		if (debug) {
			debugParam = " -X";
		}
		String cleanArg = clean ? "clean" : "";
		String installArg = clean ? "install" : "";
		String compileArg = clean ? "compile" : "";
		String deployArg = deploy ? "deploy" : "";
		if (pack) {
			installArg = "";
		}
		String packArg = pack ? "package" : "";
		if (compile) {
			installArg = "";
			packArg = "";
		}
		String cmd = "mvn %s%s -U %s %s %s %s %s";
		String command = String.format(cmd, properties, debugParam, cleanArg, compileArg, installArg, deployArg, packArg)
				+ ">fulllog.txt";
		if(isForUnix)
		    command = "#!/bin/bash" + System.lineSeparator() + command;
		String fileName = isForUnix ? "mvncmd.sh" : "mvncmd.bat";
		File file = new File(pomFile.getParent() + File.separator + fileName);
		try {
			Common.write(file, command);
		} catch (IOException e) {
			throw e;
		}
		return file;
	}
	private File findMavenHome() throws IOException {
		String mavenHome = CodeGenContext.getMavenHome();
		if (mavenHome == null) {
			throw new IllegalStateException("Cannot find Maven application "
					+ "directory. Either specify \'maven.home\' system property, or M2_HOME environment variable.");
		}
		return new File(mavenHome);
	}
	public void registerAbstractConcreteClassMappingSimple(Class<?> abstractClass, Class<?> concreteClass,
			String factoryMethodName) {
		CodeGenContext context = CodeGenContext.getInstance();
		context.registerAbstractConcreteClassMappingSimple(abstractClass, concreteClass, factoryMethodName);
	}
	public void registerAbstractConcreteClassMappingSimple(Class<?> abstractClass, Class<?> concreteClass,
			String factoryMethodName, String methodParamVariables[]) {
		CodeGenContext context = CodeGenContext.getInstance();
		context.registerAbstractConcreteClassMappingSimple(abstractClass, concreteClass, factoryMethodName,
				methodParamVariables);
	}
	public void registerAbstractConcreteClassMappingSimple(Class<?> abstractClass, Class<?> concreteClass) {
		CodeGenContext context = CodeGenContext.getInstance();
		context.registerAbstractConcreteClassMappingSimple(abstractClass, concreteClass, (Method) null, null);
		System.out.println(String.format("register abstract class, concrete class method pair [%s, %s]",
				abstractClass.getName(), concreteClass.getName()));
	}
	public void registerAbstractConcreteClassMappingSimple(Class<?> abstractClass, String qualifierName) {
		CodeGenContext context = CodeGenContext.getInstance();
		QualifierName qn = DataModel.extractQualifierName(qualifierName);
		Method method = QualifierName.getMethodByQualifierName(qn);
		if (method != null) {
			context.registerAbstractConcreteClassMappingSimple(abstractClass, method.getDeclaringClass(), method, null);
			System.out.println(String.format("register abstract class, concrete class method pair [%s, %s, %s]",
					abstractClass.getName(), method.getDeclaringClass().getName(), method.getName()));
		} else if (qn.getClz() != null) {
			context.registerAbstractConcreteClassMappingSimple(abstractClass, qn.getClz(), (Method) null, null);
			System.out.println(String.format("register abstract class, concrete class method pair [%s, %s]",
					abstractClass.getName(), qn.getClz().getName()));
		} else {
			System.out.println(String.format("cannot get class for qualifiername %s", qualifierName));
		}
	}
	@ServiceMethodAnn(keyword = "gen write file as text")
	public String genWriteFile() throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		StringBuilder sb = new StringBuilder(Common.replaceAllKeyWord(Syntax.WRITE_FILE, context.getVariableMap()));
		return sb.toString();
	}
	@ServiceMethodAnn(keyword = "read file as string")
	public String genReadFile() throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		StringBuilder sb = new StringBuilder(Common.replaceAllKeyWord(Syntax.READ_FILE, context.getVariableMap()));
		return sb.toString();
	}
	@ServiceMethodAnn(keyword = "thread pool")
	public static String genThreadPoolRunTaskMethod(int modifier, int corePoolSize, int maximumPoolSize,
			boolean isCallable, boolean defineThreadFactory, Class returnType) throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		Common.setModifier(modifier, context);
		StringBuilder sb = new StringBuilder();
		context.getVariableMap().put(Replacement.CORE_POOL_SIZE.name(), Integer.toString(corePoolSize));
		context.getVariableMap().put(Replacement.MAX_POOL_SIZE.name(), Integer.toString(maximumPoolSize));
		String newThreadFactory = null;
		if (defineThreadFactory) {
			newThreadFactory = ", " + Common.replaceAllKeyWord(Syntax.NEW_THREAD_FACTORY, context.getVariableMap());
		} else {
			newThreadFactory = "";
		}
		context.getVariableMap().put(Replacement.NEW_THREAD_FACTORY.name(), newThreadFactory);
		String str = Common.replaceAllKeyWord(Syntax.THREAD_POOL_EXECUTOR, context.getVariableMap());
		String submitTaskStr = null;
		if (isCallable) {
			context.getVariableMap().put(Replacement.RETURN_TYPE.name(), returnType.getSimpleName());
			submitTaskStr = Common.replaceAllKeyWord(Syntax.SUBMIT_CALLABLE_TASK, context.getVariableMap());
		} else {
			submitTaskStr = Common.replaceAllKeyWord(Syntax.SUBMIT_RUNNABLE_TASK, context.getVariableMap());
		}
		sb.append(str).append(Syntax.NEW_LINE);
		sb.append(submitTaskStr);
		return sb.toString();
	}
	@ServiceMethodAnn(keyword = "running jar")
	public String getRunningJar() {
		return Common.getRunningJar();
	}
	@ServiceMethodAnn(keyword = "working dir")
	public String getWorkingDir() {
		return Common.getWorkingDir();
	}
	private void createSpringBootProj(String baseDir, JarFile jarFile, String groupId,
			String artifactroyId, String pack, String webContext, int port) throws IOException, Exception {
		File testJavaDir = new File(baseDir + "/src/test/java");
		testJavaDir.mkdirs();
		File javaDir = new File(baseDir + "/src/main/java");
		javaDir.mkdirs();
		File resourceDir = new File(baseDir + "/src/main/resources");
		resourceDir.mkdirs();
		CodeGenContext context = CodeGenContext.getInstance();
		context.getVariableMap().put(MoreReplacement.WEB_CONTEXT.name(), webContext);
		context.getVariableMap().put(MoreReplacement.WEB_PORT.name(), Integer.toString(port));
		Enumeration<JarEntry> enumJar = jarFile.entries();
		while (enumJar.hasMoreElements()) {
			JarEntry e = enumJar.nextElement();
			String name = e.getName();
			System.out.println("get JarEntry which name is " + name);
			if (name.contains("webapps/css") || name.contains("webapps/js") || name.contains("webapps/img")
					|| name.contains("webapps/image")
					|| (name.contains("META-INF") && name.endsWith("spring.factories"))) {
				if (!name.endsWith("/")) {
					InputStream is = jarFile.getInputStream(e);
					String templateStr = Common.readAsStr(is);
					String fileStr = Common.replaceAllKeyWord(templateStr, context.getVariableMap());
					File file = new File(baseDir + File.separatorChar + name);
					Common.write(file, fileStr);
				} else {
					File file = new File(baseDir + File.separatorChar + name);
					file.mkdirs();
				}
			}
			if (name.endsWith(".template")) {
				InputStream is = jarFile.getInputStream(e);
				String newFileName = name.replace(".template", "");
				String templateStr = Common.readAsStr(is);
				if ("pom.xml.template".equals(name.toLowerCase())) {
					context.getVariableMap().put(MoreReplacement.GROUP_ID.name(), groupId);
					context.getVariableMap().put(MoreReplacement.ARTIFACT_ID.name(), artifactroyId);
					context.getVariableMap().put(MoreReplacement.ARTIFACT_VERSION.name(), "1.0-SNAPSHOT");
					context.getVariableMap().put(MoreReplacement.ARTIFACT_PACK.name(),
							pack != null && !"".equals(pack.trim()) ? pack : "jar");
					String pomStr = Common.replaceAllKeyWord(templateStr, context.getVariableMap());
					File pomFile = new File(baseDir + File.separatorChar + newFileName);
					Common.write(pomFile, pomStr);
				} else {
					String fileStr = Common.replaceAllKeyWord(templateStr, context.getVariableMap());
					File file = new File(baseDir + File.separatorChar + newFileName);
					Common.write(file, fileStr);
				}
			}
		}
		this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_F);
		this.getkRobot().clickKey(KeyEvent.VK_I);
		Thread.sleep(600);
		try {
			blockUntilFound("Import E", DIALOG_FONT_NAME, MENU_ITEM_SIZE, Font.PLAIN, Color.BLACK, false, true);
		} catch (Exception e) {
			e.printStackTrace();
		}
		this.getkRobot().typeStr("maven");
		Thread.sleep(500);
		try {
			blockUntilFound("maven", DIALOG_FONT_NAME, MENU_ITEM_SIZE, Font.PLAIN, Color.BLACK, false, false);
		} catch (Exception e) {
			e.printStackTrace();
		}
		this.getkRobot().arrowDown();
		Thread.sleep(500);
		this.getkRobot().home();
		Thread.sleep(500);
		this.getkRobot().arrowDown(2);
		this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_N);
		this.blockUntilFound("Select Maven", DIALOG_FONT_NAME, Color.BLACK);
		this.getkRobot().typeStr(baseDir);
		this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_A);
		Thread.sleep(500);
		this.getkRobot().clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_F);
	}
	public void createSpringBootProj(String groupId, String artifactroyId, String pack,
			@ParamAnno(description = "base directory") @FileChooserAnnotation(chooseDirOnly = true) @ValidationAnn(validations = {
					"codegen.eclipseRobot.MandatoryCheck" }) File baseDirectory,
			String webContext, int port) throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		String baseDir = baseDirectory.getAbsolutePath();
		String runningJarPath = Common.getRunningJar();
		JarFile jarFile = null;
		JarEntry jarEntry = null;
		JarInputStream jarInputStream = null;
		try {
			jarFile = new JarFile(runningJarPath);
			System.out.println("get jar file" + runningJarPath);
			jarEntry = jarFile.getJarEntry(SPRING_BOOT_TEMPLATE_JAR_NAME);
			InputStream inputStream = jarFile.getInputStream(jarEntry);
			System.out.println("get jar inputStream" + inputStream);
			jarInputStream = new JarInputStream(inputStream);
			jarFile = new JarFile(
					String.format("%s/codegen/springbootsimpletemplate/1.0/springbootsimpletemplate-1.0.jar",
							context.getLocalRepoDir()));
			createSpringBootProj(baseDirectory.getAbsolutePath(), jarFile, groupId, artifactroyId, pack,
					webContext, port);
		} catch (IOException e2) {
			e2.printStackTrace();
			throw e2;
		}
		try {
			jarInputStream.close();
			jarFile.close();
		} catch (IOException e1) {
			e1.printStackTrace();
		}
		return;
	}
	public static void registerDataSource(Class<?> driverClass, String jdbcurl, String user, String password) {
		return;
	}
	public static String talk() {
		return "";
	}
	/**
	 * for testing seek text on screen 1 setting window
	 * desktop->personalality->window color->dialog->font change as "Segeo UI" 2
	 * disable font smooth
	 * set font size as 100%,otherwise may mouse move will not work properly
	 * 
	 * @param text
	 * @throws Exception
	 */
	@ServiceMethodAnn(keyword = "seek text on screen")
	public boolean seekText(@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) String text) throws Exception {
		long arg0 = 3000L;
		Thread.sleep(arg0);
		boolean b =blockUntilFound(text, SPECIAL_DIALOG_FONT_NAME, Font.PLAIN, Color.BLACK, false, true);
		if(!b) {
			b = blockUntilFound(text, SPECIAL_DIALOG_FONT_NAME, Font.PLAIN, this.ECLIPSE_TITLE_DISABLE_FONT, false, true);
		}
		return b;
	}
	public String genGetClipBoardMonitorServerPort() {
		CodeGenContext context = CodeGenContext.getInstance();
		return Integer.toString(context.getClipBoardMonitorServerPort());
	}
	public String genGenJarPlugin() {
		CodeGenContext context = CodeGenContext.getInstance();
		return "            <plugin>" + "                <groupId>org.apache.maven.plugins</groupId>"
				+ "                <artifactId>maven-jar-plugin</artifactId>" + "                <executions>"
				+ "                    <execution>" + "                        <id>make-a-jar</id>"
				+ "                        <phase>compile</phase>" + "                        <goals>"
				+ "                            <goal>jar</goal>" + "                        </goals>"
				+ "                    </execution>" + "                </executions>" + "            </plugin>";
	}
	private boolean openWizard() {
		CodeGenContext context = CodeGenContext.getInstance();
		int i=0;
		String currentWintitle;
		boolean b = false;
		do {
			i++;
			try {
				this.getkRobot().clickCompositeKey(KeyEvent.VK_CONTROL, KeyEvent.VK_N);
				currentWintitle=this.getActiveWindow();
			} catch (Exception e) {
				currentWintitle="";
			}
			b = "new".equalsIgnoreCase(currentWintitle);
			b=true;
			if(!b) {
				try {
					Thread.sleep(200L);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
			}
		}while(!b && i<codegen.Const.MAX_WAIT_TIME);
		return b;
	}
	public void attacheServiceClz(Class<?> c) {
		CodeGenContext context = CodeGenContext.getInstance();
		context.getAttachedClzList().add(c);
		return;
	}
	public DataSource createDataSource(Class driverClz, String jdbcUrl, String userName, String password) {
		String s = "";
		try {
			Connection connection = DriverManager.getConnection(s, s, s);
		} catch (SQLException e) {
			e.printStackTrace();
		}
		DataSource dataSource = null;
		return dataSource;
	}
	public String genSingleMethodUnitTestCase() {
		return null;
	}
	@ServiceMethodAnn(keyword = "gen test SpringJunitRunner")
	public String genTestWithSpringJunitRunnerPart() {
		StringBuilder sb = new StringBuilder();
		sb.append("@RunWith(SpringJUnit4ClassRunner.class)").append(Syntax.NEW_LINE);
		sb.append("@TestPropertySource(\"classpath:app.properties\")").append(Syntax.NEW_LINE);
		sb.append("@ContextConfiguration(value={\"classpath:config.xml\"}, classes={Config.class})")
				.append(Syntax.NEW_LINE);
		sb.append("@WebAppConfiguration");
		return sb.toString();
	}
	@ServiceMethodAnn(keyword = "gen Object Json app")
	public String genJsonWriteApp(Class c) {
		StringBuilder sb = new StringBuilder();
		String code = this.genCode(c);
		sb.append(code).append(Syntax.NEW_LINE).append("ObjectMapper om=new ObjectMapper();").append(Syntax.NEW_LINE)
				.append("String jsonStr = om.writeValueAsString(obj);\r\nSystem.out.println(jsonStr);");
		return sb.toString();
	}
	List<String> list = new ArrayList<>();
	@ServiceMethodAnn(keyword = "connect database")
	public Connection connectDb(Class driverClz, String jdbcUrl, String userName, String password) throws InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException, NoSuchMethodException, SecurityException, SQLException {
		Connection conn = null;
		if(null!=driverClz) {
			Driver driver = (Driver) driverClz.getDeclaredConstructor().newInstance();
			DriverManager.registerDriver(driver);
			conn = DriverManager.getConnection(jdbcUrl, userName, password);
		}
	    return conn;
	}
	@ServiceMethodAnn(keyword = "gen html table")
	public String genHtmlTable(int howManyColumns, int howManyRows, boolean hasHeader, boolean withInDiv) throws Exception {
		StringBuilder sb = new StringBuilder();
		if(withInDiv){
			sb.append("<div>").append(Syntax.NEW_LINE);
		}
		sb.append("<table>").append(Syntax.NEW_LINE);
		if(hasHeader){
			sb.append("<tr>").append(Syntax.NEW_LINE);
			for(int c=0;c<howManyColumns;c++){
				sb.append("<th></th>");
			}
			sb.append(Syntax.NEW_LINE).append("</tr>").append(Syntax.NEW_LINE);
		}
		for(int r=0;r<howManyRows;r++){
			sb.append("<tr>").append(Syntax.NEW_LINE);
			for(int c=0;c<howManyColumns;c++){
				sb.append("<td></td>");
			}
			sb.append(Syntax.NEW_LINE).append("</tr>").append(Syntax.NEW_LINE);
		}
		sb.append("</table>").append(Syntax.NEW_LINE);
		if(withInDiv){
			sb.append("</div>").append(Syntax.NEW_LINE);
		}
		return sb.toString();
	}
	@ServiceMethodAnn(keyword = "gen html href, tag a")
	public String genHtmlTagHref(String id, String link) throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		String trimId = id.trim();
		context.getVariableMap().put(Replacement.ID.name(),  !"".equals(trimId) ? " id="+trimId : "");
		context.getVariableMap().put(Replacement.LINK.name(), "\""+link+"\"");
		String str = Common.replaceAllKeyWord(Syntax.HTML_TAG_A, context.getVariableMap());
		return str;
	}
	@ServiceMethodAnn(keyword = "gen html input text, tag input")
	public String genHtmlTagInputText(String id, String name) throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		String trimId = id.trim();
		context.getVariableMap().put(Replacement.ID.name(), !"".equals(trimId) ? " id="+trimId : "");
		context.getVariableMap().put(Replacement.TAG_NAME.name(), name);
		String str = Common.replaceAllKeyWord(Syntax.HTML_TAG_TEXT, context.getVariableMap());
		return str;
	}
	@ServiceMethodAnn(keyword = "gen html input hidden, tag input hidden")
	public String genHtmlTagInputHidden(String id, String name) throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		String trimId = id.trim();
		context.getVariableMap().put(Replacement.ID.name(),  !"".equals(trimId) ? " id="+trimId : "");
		context.getVariableMap().put(Replacement.TAG_NAME.name(), name);
		String str = Common.replaceAllKeyWord(Syntax.HTML_TAG_TEXT, context.getVariableMap());
		return str;
	}
	@ServiceMethodAnn(keyword = "gen html input button, tag input button")
	public String genHtmlTagInputBtn(String id, String name) throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		String trimId = id.trim();
		context.getVariableMap().put(Replacement.ID.name(),  !"".equals(trimId) ? " id="+trimId : "");
		context.getVariableMap().put(Replacement.TAG_NAME.name(), name);
		String str = Common.replaceAllKeyWord(Syntax.HTML_TAG_BTN, context.getVariableMap());
		return str;
	}
	@ServiceMethodAnn(keyword = "gen html input file, tag input file")
	public String genHtmlTagInputFile(String id, String name) throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		String trimId = id.trim();
		context.getVariableMap().put(Replacement.ID.name(),  !"".equals(trimId) ? " id="+trimId : "");
		context.getVariableMap().put(Replacement.TAG_NAME.name(), name);
		String str = Common.replaceAllKeyWord(Syntax.HTML_TAG_FILE, context.getVariableMap());
		return str;
	}
	@ServiceMethodAnn(keyword = "gen html input select, tag input select")
	public String genHtmlTagInputSelect(String id, String name) throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		String trimId = id.trim();
		context.getVariableMap().put(Replacement.ID.name(),  !"".equals(trimId) ? " id="+trimId : "");
		context.getVariableMap().put(Replacement.TAG_NAME.name(), name);
		String str = Common.replaceAllKeyWord(Syntax.HTML_TAG_SELECT, context.getVariableMap());
		return str;
	}
	@ServiceMethodAnn(keyword = "gen html form, tag html form")
	public String genHtmlTagForm(String id, String name, boolean get, String action, boolean newWindow) throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		String trimId = id.trim();
		context.getVariableMap().put(Replacement.ID.name(),  !"".equals(trimId) ? " id="+trimId : "");
		context.getVariableMap().put(Replacement.TAG_NAME.name(), name);
		context.getVariableMap().put(Replacement.LINK.name(), action);
		context.getVariableMap().put(Replacement.REQUEST_METHOD.name(), get ? "get": "post");
		context.getVariableMap().put(Replacement.TARGET.name(), newWindow ? "_blank": "");
		String str = Common.replaceAllKeyWord(Syntax.HTML_TAG_FORM, context.getVariableMap());
		return str;
	}
	public H2JDBCService getH2JDBCService() {
        return h2JDBCService;
    }
    public void setH2JDBCService(H2JDBCService h2jdbcService) {
        h2JDBCService = h2jdbcService;
    }
    public WindowService getWindowService() {
		return windowService;
	}
	public void setWindowService(WindowService windowService) {
		this.windowService = windowService;
	}
	@ServiceMethodAnn(keyword = "load project dependency")
	public List<String> loadProjDepependcies(@ParamAnno(description = "Pom File") File pomFile) throws Exception {
		Model model = PomUtil.parsePom(pomFile);
		String parentGroupId = null;
		String parentversion = null;
		if (model.getParent() != null) {
			parentGroupId = model.getParent().getGroupId();
			parentversion = model.getParent().getVersion();
		}
		String artifactId = model.getArtifactId();
		String groupId = model.getGroupId() == null ? parentGroupId : model.getGroupId();
		String version = model.getVersion() == null ? parentversion : model.getVersion();
		String pack = model.getPackaging();
		File file = new File(pomFile.getParent() + File.separator + "target" + File.separator + "classes");
		URL targetClassDir = null;
		if (file.exists()) {
			URI uRI = file.toURI();
			targetClassDir = uRI.toURL();
		}
		URL targetTestClassDir = null;
		file = new File(pomFile.getParent() + File.separator + "target" + File.separator + "test-classes");
		if (file.exists()) {
			URI uRI = file.toURI();
			targetTestClassDir = uRI.toURL();
		}
		CodeGenContext.getInstance().setPomFile(pomFile);
		List<String> dependencies = this.loadProjDepependcies(groupId, artifactId, version, pack, targetClassDir, targetTestClassDir);
		this.h2JDBCService.saveOrUpdateLastProject( pomFile.getAbsolutePath());
		return dependencies;
	}
	@ServiceMethodAnn(keyword = "load project dependency 2")
	public List<String> loadProjDepependcies(String groupId, String artifactId, String version, String pack,
			URL... targetDirURLs) throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		System.out.println("loading artifact under " + CodeGenContext.getLocalRepoDir());
		DefaultArtifact artifact = new DefaultArtifact(groupId, artifactId, pack, version);
		boolean isWarPack = false;
		if ("war".equalsIgnoreCase(pack)) {
			isWarPack = true;
		} else if ("pom".equalsIgnoreCase(pack)) {
		}
		if (targetDirURLs != null) {
			for (URL url : targetDirURLs) {
				if (null != url) {
					context.getReloadableDynamicClassLoaderOwner().addDirUrl(url);
				}
			}
		}
		RepositorySystemHelper repoSystemHelper = new RepositorySystemHelper(CodeGenContext.getLocalRepoDir(),
				new HashMap());
		DependencyResolver dependencyResolver = new DependencyResolver(repoSystemHelper);
		List<String> list = null;
		try {
			list = dependencyResolver.getProjDepArtifactFilePath(artifact);
		} catch (Exception e1) {
		}
		if (list.size() == 0) {
			throw new Exception("failed when load project dependencies");
		}
		for (String str : list) {
			File file = new File(str);
			URI uRI = file.toURI();
			URL uRL = uRI.toURL();
			if (Common.isJarFile(file)) {
				context.getReloadableDynamicClassLoaderOwner().addJarUrl(uRL);
			}
		}
		context.getReloadableDynamicClassLoaderOwner().loadAllJar(this.getClass().getClassLoader());
		context.getReloadableDynamicClassLoaderOwner()
				.loadAllClzInDirectory(context.getReloadableDynamicClassLoaderOwner().getJarDynamicClassLoader());
		return list;
	}
	@ServiceMethodAnn(keyword = "reload all dependencies")
	public void reloadAll() {
		File pomFile = CodeGenContext.getInstance().getPomFile();
		if(null!=pomFile) {
			try {
				this.loadProjDepependcies(pomFile);
			} catch (Exception e) {
				e.printStackTrace();
			}
		}
	}
	@ServiceMethodAnn(keyword = "reload target directory dependencies")
	public void reloadAllTargetDirDependencies() throws Exception {
		CodeGenContext.getInstance().getReloadableDynamicClassLoaderOwner().reloadAllClzInDirectory();
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\codegen\eclipseRobot\FilterCombBox.java---
package codegen.eclipseRobot;
import javax.swing.*;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.ArrayList;
import java.util.List;
public class FilterCombBox extends JComboBox {
	private List<Object> array;
	private static final int maxShowingItems = 50;
	public FilterCombBox(List<Object> array) {
		super(array.subList(0, array.size()>maxShowingItems? maxShowingItems: array.size()).toArray());
		this.array = array;
		this.setEditable(true);
		addEditorListener();
	}
	public void addEditorListener(){
		final JTextField tf = (JTextField) this.getEditor().getEditorComponent();
		tf.addKeyListener(new KeyAdapter() {
			public void keyReleased(KeyEvent e) {
				if (e.getKeyCode() == 38 || e.getKeyCode() == 40 || e.getKeyCode() == 9 || e.getKeyCode() == 18
						|| e.getKeyCode() == KeyEvent.VK_ENTER) {
					return;
				}
				SwingUtilities.invokeLater(new Runnable() {
					@Override
					public void run() {
						if(!"".equals(tf.getText())) {
							comboFilter(tf.getText());
						}
					}
				});
			}
		});
		tf.addMouseListener(new MouseAdapter() {
			public void mouseClicked(MouseEvent e) {
				SwingUtilities.invokeLater(new Runnable() {
					@Override
					public void run() {
						comboFilter("");
					}
				});
			}
		});
	}
	public void comboFilter(String enteredText) {
		List<Object> filterArray = new ArrayList<>();
		for (int i = 0; i < array.size(); i++) {
			if (array.get(i).toString().toLowerCase().contains(enteredText.toLowerCase())) {
				filterArray.add(array.get(i));
			}
		}
		if (filterArray.size() > 0) {
			if (filterArray.size() < 4 && array.size() > 2) {
				filterArray.add(array.get(0));
				filterArray.add(array.get(1));
			}
			this.setModel(new DefaultComboBoxModel(filterArray.subList(0, filterArray.size()> maxShowingItems ? maxShowingItems : filterArray.size()).toArray()));
			this.showPopup();
			this.setSelectedItem(enteredText);
		} else {
			this.hidePopup();
		}
	}
	public boolean isValidSelectedItem(Object obj) {
		return array.contains(obj);
	}
	public synchronized void addCustomItem(Object... items) {
		for (Object i : items) {
			addItem(i);
			array.add(i);
		}
	}
	public synchronized void resetArray(List<Object> array) {
		this.array = array;
	}
	public List<Object> getArray() {
		return array;
	}
	public void cleanModelData() {
		this.removeAllItems();
		this.removeAll();
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\codegen\eclipseRobot\H2JDBCService.java---
package codegen.eclipseRobot;
import codegen.Syntax;
import codegen.eclipseRobot.model.MemoryArea;
import codegen.eclipseRobot.model.MemoryItem;
import codegen.eclipseRobot.model.MemoryItemKey;
import codegen.robot.Service;
import com.dgs.annotation.ParamAnno;
import com.dgs.annotation.ServiceMethodAnn;
import com.dgs.annotation.UIAnno;
import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import org.apache.commons.lang3.StringUtils;
import ui.validation.NotVisibleInUI;
import ui.validation.ValidationAnn;
import java.io.File;
import java.lang.reflect.Type;
import java.sql.*;
import java.util.Date;
import java.util.*;
import java.util.stream.Collectors;
public class H2JDBCService extends Service {
	private File file;
	private String userName="sa";
	private String pwd;
	public static final String CREATE_TABLE = "CREATE TABLE %s(ID VARCHAR(255) PRIMARY KEY, keywords VARCHAR_IGNORECASE(255), content LONGVARCHAR, comment VARCHAR(255), createTime TIMESTAMP, updateTime TIMESTAMP);";
	public static final String MEMORY_AREAS_KEY_WORDS = "MEMORY_AREAS_KEY_WORDS";
	private List<String> memoryAreas;
	private Map<String, List<MemoryItemKey>> tableKeywordsMapping = new HashMap<>();
	public static final String CONFIG_TABLE = "config";
	public static final String COLUMN_ID = "ID";
	public static final String COLUMN_KEYWORDS = "keywords";
	public static final String COLUMN_CONTENT = "content";
	public static final String COLUMN_COMMENT = "comment";
	public static final String JRE8_RTJAR_JAVA_JAVAX_ORG_KEYWORD = "jre8_rtjar_java_javax_org";
	public H2JDBCService() {
	}
	public String testConnection(@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) File dbfile, String user, String password)throws Exception {
		Connection conn = getConnection(dbfile, user, password);
		if(null!=conn) {
			conn.close();
		}else {
			return "failed";
		}
		return "ok";
	}
	public Connection getConnection(@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) File dbfile, String user, String password) throws Exception {
		this.file = dbfile;
		String driverClzName = "org.h2.Driver";
		String dbFilepath = dbfile.getAbsolutePath();
		dbFilepath = dbFilepath.replaceFirst(".mv.db", "");
		String url = "jdbc:h2:file:"+dbFilepath;
		Connection connection = null;
		try {
			Class.forName(driverClzName);
			connection = DriverManager.getConnection(url, user, password);
		} catch (SQLException | ClassNotFoundException e) {
			e.printStackTrace();
			throw e;
		} finally {
		}
		return connection;
	}
	@ServiceMethodAnn(keyword = "memorize config")
	public void memorizeConfig(@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) String keywords,
			@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) String content) throws Exception {
		memorizeInTable(CONFIG_TABLE, keywords,content);
	}
	@ServiceMethodAnn(keyword = "memorize in area")
	public void memorizeInTable(
	        @UIAnno(uiClz = "ui.ClassCombBoxpane")
	        @ParamAnno(description = "memory area") 
	        String areaName, @ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) String keywords,
			@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) String content) throws Exception {
		insert(areaName, keywords, content);
	}
	@ServiceMethodAnn(keyword = "create memory area")
	public void createTable(
	        @ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) String areaName, boolean disable)
			throws Exception {
		String sql = String.format(CREATE_TABLE, areaName);
		executeUpdate(sql, new String[]{});
		String areaJson = this.showConfigMemory(MEMORY_AREAS_KEY_WORDS);
		Gson gson = new Gson();
		Type type = new TypeToken<List<MemoryArea>>(){}.getType();
		List<MemoryArea> list1 = gson.fromJson(areaJson, type);
		MemoryArea ma = new MemoryArea(areaName, disable);
		list1.add(ma);
		areaJson = gson.toJson(list1);
		this.saveOrUpdate(CONFIG_TABLE, MEMORY_AREAS_KEY_WORDS, areaJson);
		return;
	}
	public String showMemoryById(String tableName, @ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) String id)
			throws Exception {
		MemoryItem item = this.findById(tableName, id);
		StringBuilder sb = new StringBuilder();
		if(null != item) {
			sb.append(item.getContent()).append(Syntax.NEW_LINE).append(Syntax.NEW_LINE);
		}
		return sb.toString();
	}
	@ServiceMethodAnn(keyword = "show all memory")
	public String showAllMemory(String tableName) throws Exception {
		List<MemoryItem> list = this.findAll(tableName);
		StringBuilder sb = new StringBuilder();
		for(MemoryItem item : list) {
			sb.append(item.getKey().getId()).append("-").append(item.getKey().getKeywords()).append(Syntax.NEW_LINE)
					.append(item.getContent()).append(Syntax.NEW_LINE).append(Syntax.NEW_LINE);
			sb.append("---------------------------------");
		}
		return sb.toString();
	}
	public List<MemoryItemKey> getAllItemKeys(String tableName) throws Exception {
	    List<MemoryItemKey> keyList = new ArrayList<>();
	    Connection connection = null;
        Statement statement=null;
        ResultSet resultSet=null;
        try {
            connection = getConnection(file, this.userName, this.pwd);
            connection.setAutoCommit(false);
            String sql = String.format("select %s, %s from %s", COLUMN_ID, COLUMN_KEYWORDS, tableName);
            statement = connection.createStatement();
            resultSet = statement.executeQuery(sql);
            ResultSetMetaData resultSetMetaData = resultSet.getMetaData();
            int cc = resultSetMetaData.getColumnCount();
            while(resultSet.next()){
                MemoryItemKey memoryItemKey =  new MemoryItemKey();
                memoryItemKey.setTable(tableName);
                for(int i=1;i<=cc;i++){
                    String cl = null;
                    try {
                        cl = resultSetMetaData.getColumnLabel(i);
                    } catch (Exception e) {
                        cl = resultSetMetaData.getColumnName(i);
                    }
                    Object o = resultSet.getObject(i);
                    if(COLUMN_ID.equalsIgnoreCase(cl)) {
                        memoryItemKey.setId(o.toString());
                    }else if(COLUMN_KEYWORDS.equalsIgnoreCase(cl)) {
                        memoryItemKey.setKeywords(o.toString());
                    }
                }
                keyList.add(memoryItemKey);
            }
        } catch (Exception e) {
            e.printStackTrace();
            throw e;
        } finally {
            if(null!=statement){
                statement.close();
            }
            if(null!=connection){
                connection.close();
            }
        }
        return keyList;
	}
	private Map<MemoryItemKey, MemoryItem> getAllItems(String tableName) throws Exception {
		Map<MemoryItemKey, MemoryItem> map = new HashMap<>();
		Connection connection = null;
		Statement statement=null;
		ResultSet resultSet=null;
		try {
			connection = getConnection(file, this.userName, this.pwd);
			connection.setAutoCommit(false);
			String sql = String.format("select * from %s", tableName);
			statement = connection.createStatement();
			resultSet = statement.executeQuery(sql);
			ResultSetMetaData resultSetMetaData = resultSet.getMetaData();
			int cc = resultSetMetaData.getColumnCount();
			while(resultSet.next()){
				MemoryItemKey memoryItemKey =  new MemoryItemKey();
				memoryItemKey.setTable(tableName);
				MemoryItem memoryItem =  new MemoryItem();
				memoryItem.setKey(memoryItemKey);
				for(int i=1;i<=cc;i++){
					String cl = null;
					try {
						cl = resultSetMetaData.getColumnLabel(i);
					} catch (Exception e) {
						cl = resultSetMetaData.getColumnName(i);
					}
					Object o = resultSet.getObject(i);
					if(COLUMN_ID.equalsIgnoreCase(cl)) {
                        memoryItemKey.setId(o.toString());
                    }else if(COLUMN_KEYWORDS.equalsIgnoreCase(cl)) {
                        memoryItemKey.setKeywords(o.toString());
                    }else if(COLUMN_CONTENT.equalsIgnoreCase(cl)) {
                        memoryItem.setContent(o.toString());
                    }else if(COLUMN_COMMENT.equalsIgnoreCase(cl)) {
                        memoryItem.setComment("");
                    }
				}
				map.put(memoryItemKey, memoryItem);
			}
		} catch (Exception e) {
			e.printStackTrace();
			throw e;
		} finally {
			if(null!=statement){
				statement.close();
			}
			if(null!=connection){
				connection.close();
			}
		}
		return map;
	}
	public void loadAllKeywordsMappings() throws Exception {
		for(String table : memoryAreas) {
		    List<MemoryItemKey> keyList = this.getAllItemKeys(table);
		    tableKeywordsMapping.putIfAbsent(table, keyList);
		}
	    return ;
	}
	public Map<String, List<MemoryItemKey>> getTableKeywordsMapping() {
        return tableKeywordsMapping;
    }
    public List<String> loadAllEnabledMemoryAreas() throws Exception {
		List<MemoryArea> list = getAllMemoryAreas();
		List<String> list1=list.stream().filter(e -> !e.isDisable()).map(e->e.getTable()).collect(Collectors.toList());
		memoryAreas = list1;
		return list1;
	}
	public List<MemoryArea> getAllMemoryAreas() throws Exception {
		String areaJson = this.showConfigMemory(MEMORY_AREAS_KEY_WORDS);
		if(Objects.isNull(areaJson)) {
			System.out.print(String.format("cannot find memory area row"));
			return new ArrayList<MemoryArea>();
		}else{
			Gson gson = new Gson();
			Type type = new TypeToken<List<MemoryArea>>(){}.getType();
			List<MemoryArea> list1 = gson.fromJson(areaJson, type);
			return list1;
		}
	}
	@UIAnno(uiClz="ui.MemoryPane")
	@ServiceMethodAnn(keyword = "show memory")
	public String showMemory(String table, String keyword) throws Exception {
		MemoryItem item = findOneByKeyword(table, keyword);
		if(null!=item) {
			return item.getContent();
		}
		System.out.print(String.format("cannot find row by table %s and keyword %s", table, keyword));
		return "";
	}
	public String showConfigMemory(String keyword) throws Exception {
		return showMemory(this.CONFIG_TABLE, keyword);
	}
	public List<String> getJREClzNames() throws Exception {
		String name = showMemory(this.CONFIG_TABLE, JRE8_RTJAR_JAVA_JAVAX_ORG_KEYWORD);
		List<String> list = new ArrayList<>();
		Scanner scanner = new Scanner(name);
		try {
			while (scanner.hasNextLine()) {
				String line = scanner.nextLine();
				if (line != null && !"".equals(line.trim())) {
					list.add(line);
				}
			}
		} catch (Exception e) {
		} finally {
			scanner.close();
		}
		return list;
	}
	@NotVisibleInUI
	public int insert(String tableName, String keywords, String content) throws Exception {
		UUID uuid = UUID.randomUUID();
		String id = uuid.toString();
		return insert(tableName, id, keywords, content); 
	}
	@NotVisibleInUI
    public int insert(String tableName,String id, String keywords, String content) throws Exception {
        String sql = String.format("insert into %s (keywords, content, id, createTime, updateTime) values (?, ?, ?, ?, ?)", tableName);
        long now = new Date().getTime();
        Timestamp nowTimestamp = new Timestamp(now);
        int i = executeUpdate(sql,new Object[] {  keywords, content, id, nowTimestamp, nowTimestamp});
        if(i>0){
            MemoryItemKey key = new MemoryItemKey();
            key.setId(id);
            key.setKeywords(keywords);
            key.setTable(tableName);
            MemoryItem mi = new MemoryItem();
            mi.setKey(key);
            mi.setContent(content);
            List<MemoryItemKey> keys;
            if(tableKeywordsMapping.containsKey(tableName)) {
                keys = tableKeywordsMapping.get(tableName);
            }else {
                keys = new ArrayList<>();
                tableKeywordsMapping.put(tableName, keys);
            }
            keys.add(key);
        }
        return i; 
    }
	public void reloadMapping(String tableName) throws Exception{
	}
	public void updateMapping(MemoryItemKey oldkey, MemoryItemKey key, MemoryItem mi) throws Exception{
	    List<MemoryItemKey> keys;
        if(tableKeywordsMapping.containsKey(key.getTable())) {
            keys = tableKeywordsMapping.get(key.getTable());
        }else {
            keys = new ArrayList<>();
        }
        MemoryItemKey existingKey = null;
        for(MemoryItemKey tempKey : keys) {
            if(tempKey.equals(oldkey)) {
                existingKey = tempKey;
            }
        }
        if(null!=existingKey) {
            existingKey.setId(oldkey.getId());
            existingKey.setTable(oldkey.getTable());
            existingKey.setKeywords(oldkey.getKeywords());
        }
	}
	public void removeMapping(MemoryItemKey key) throws Exception{
	    List<MemoryItemKey> keys;
        if(tableKeywordsMapping.containsKey(key.getTable())) {
            keys = tableKeywordsMapping.get(key.getTable());
        }else {
            keys = new ArrayList<>();
        }
        for(int i=0;i<keys.size();i++) {
            MemoryItemKey tempKey = keys.get(i);
            if(tempKey.equals(key)) {
                keys.set(i, null);
            }
        }
        List<MemoryItemKey> newKeys= new ArrayList<>();
        for(MemoryItemKey tempKey : keys) {
            if(tempKey != null) {
                newKeys.add(tempKey);
            }
        }
        tableKeywordsMapping.remove(key.getTable());
        tableKeywordsMapping.putIfAbsent(key.getTable(), newKeys);
	}
	public MemoryItemKey getOldMemoryItemFromKeywordsMapping(String table, String id) throws Exception{
		List<MemoryItemKey> keys;
        if(tableKeywordsMapping.containsKey(table)) {
            keys = tableKeywordsMapping.get(table);
        }else {
            keys = new ArrayList<>();
        }
        MemoryItemKey existingKey = null;
        for(MemoryItemKey tempKey : keys) {
            if(tempKey.getId().equals(id)) {
                existingKey = tempKey;
            }
        }
		return existingKey;
	}
	public void saveOrUpdateLastProject(String content) throws Exception{
		saveOrUpdate(CONFIG_TABLE, codegen.Const.BRAIN_LAST_PROJECT_KEYWORD, content);
	}
	public void saveOrUpdate(String tableName, String keywords, String content) throws Exception{
		List<MemoryItem> itemList;
		String id;
		try {
			itemList = this.findByKeyword(tableName, keywords);
		} catch (Exception e) {
			itemList=null;
		}
		if(!Objects.isNull(itemList) && !itemList.isEmpty()){
			id =itemList.get(0).getKey().getId();
			String oldContent = itemList.get(0).getContent();
			if(!StringUtils.equalsIgnoreCase(oldContent, content)){
				int i= this.updateById(tableName, id, keywords, content);
				if(i>0){
				}else{
				}
			}
		}else{
			this.memorizeInTable(tableName, keywords, content);
		}
		return ;
	}
	@NotVisibleInUI
	public int updateById(String tableName,@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) String id, String keywords,
			String content) throws Exception {
		String sql = String.format("update %s set keywords=?,content=?,updateTime=? where id=?", tableName);
		long now = new Date().getTime();
        Timestamp nowTimestamp = new Timestamp(now);
		int i = 0;
		try {
			i = executeUpdate(sql,new Object[] { keywords, content,nowTimestamp, id});
		} catch (Exception e) {
			System.out.println(e.getMessage());
		}
		if(i>0){
			MemoryItemKey key = new MemoryItemKey();
			key.setId(id);
			key.setKeywords(keywords);
			key.setTable(tableName);
			MemoryItem mi = new MemoryItem();
			mi.setKey(key);
			mi.setContent(content);
			MemoryItemKey oldKey = getOldMemoryItemFromKeywordsMapping(tableName, id);
			if(null!=oldKey)
				updateMapping(oldKey, key, mi );
		}
		return i; 
	}
	@NotVisibleInUI
	public int removeById(String tableName,@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) String id) throws Exception {
		String sql = String.format("delete from %s where id=?", tableName);
		int i=0;
		try {
			i = executeUpdate(sql,new Object[] { id});
		} catch (Exception e) {
		    System.out.println(e.getMessage());
		} 
		if(i>0){
		    MemoryItemKey oldKey = getOldMemoryItemFromKeywordsMapping(tableName, id);
			if(null!=oldKey)
				removeMapping(oldKey);
		}
		return i; 
	}
	public MemoryItem findOneByKeyword(String tableName,String keywords) throws Exception {
		Connection connection = null;
		Statement statement=null;
		ResultSet resultSet=null;
		MemoryItem memoryItem =  new MemoryItem();
		try {
			connection = getConnection(file, this.userName, this.pwd);
			connection.setAutoCommit(false);
			String sql = String.format("select top 1 * from %s where keywords like '%%%s%%'", tableName, keywords);
			statement = connection.createStatement();
			resultSet = statement.executeQuery(sql);
			ResultSetMetaData resultSetMetaData = resultSet.getMetaData();
			int cc = resultSetMetaData.getColumnCount();
			while(resultSet.next()){
				MemoryItemKey memoryItemKey =  new MemoryItemKey();
				memoryItem.setKey(memoryItemKey);
				for(int i=1;i<=cc;i++){
					String cl = resultSetMetaData.getColumnLabel(i);
					Object o = resultSet.getObject(i);
					if(cl.equalsIgnoreCase("id")) {
						memoryItemKey.setId(o.toString());
					}else if(cl.equalsIgnoreCase("keywords")) {
						memoryItemKey.setKeywords(o.toString());
					}else if(cl.equalsIgnoreCase("content")) {
						memoryItem.setContent(o.toString());
					}else if(cl.equalsIgnoreCase("comment")) {
						memoryItem.setComment("");
					}
				}
			}
		} catch (Exception e) {
			e.printStackTrace();
			throw e;
		} finally {
			if(null!=statement){
				statement.close();
			}
			if(null!=connection){
				connection.close();
			}
		}
		if(memoryItem.getKey()==null) {
			throw new Exception("cannot find item by "+keywords);
		}
		return memoryItem;
	}
	public List<MemoryItem> findByKeyword(String tableName,String keywords) throws Exception {
		List<MemoryItem> list = new ArrayList<>();
		Connection connection = null;
		Statement statement=null;
		ResultSet resultSet=null;
		try {
			connection = getConnection(file, this.userName, this.pwd);
			connection.setAutoCommit(false);
			String sql = String.format("select * from %s where keywords like '%%%s%%'", tableName, keywords);
			statement = connection.createStatement();
			resultSet = statement.executeQuery(sql);
			ResultSetMetaData resultSetMetaData = resultSet.getMetaData();
			int cc = resultSetMetaData.getColumnCount();
			while(resultSet.next()){
				MemoryItemKey memoryItemKey =  new MemoryItemKey();
				MemoryItem memoryItem =  new MemoryItem();
				memoryItem.setKey(memoryItemKey);
				for(int i=1;i<=cc;i++){
					String cl = resultSetMetaData.getColumnLabel(i);
					Object o = resultSet.getObject(i);
					if(cl.equalsIgnoreCase("id")) {
						memoryItemKey.setId(o.toString());
					}else if(cl.equalsIgnoreCase("keywords")) {
						memoryItemKey.setKeywords(o.toString());
					}else if(cl.equalsIgnoreCase("content")) {
						memoryItem.setContent(o.toString());
					}else if(cl.equalsIgnoreCase("comment")) {
						memoryItem.setComment("");
					}
				}
				list.add(memoryItem);
			}
		} catch (Exception e) {
			e.printStackTrace();
			throw e;
		} finally {
			if(null!=statement){
				statement.close();
			}
			if(null!=connection){
				connection.close();
			}
		}
		return list;
	}
	public int executeUpdate(String sql, Object... args) throws Exception {
		int i;
		Connection connection = null;
		PreparedStatement statement=null;
		try {
			connection = getConnection(file, this.userName, this.pwd);
			connection.setAutoCommit(false);
			statement = connection.prepareStatement(sql);
			for(int j=1;j<=args.length;j++){
				statement.setString(j, args[j-1].toString());
			}
			i = statement.executeUpdate();
			connection.commit();
		} catch (Exception e) {
			e.printStackTrace();
			throw e;
		} finally {
			if(null!=statement){
				statement.close();
			}
			if(null!=connection){
				connection.close();
			}
		}
		return i;
	}
	public MemoryItem findById(String tableName,String id) throws Exception {
		Connection connection = null;
		Statement statement=null;
		ResultSet resultSet=null;
		MemoryItem memoryItem =  new MemoryItem();
		try {
			connection = getConnection(file, this.userName, this.pwd);
			connection.setAutoCommit(false);
			String sql = String.format("select * from %s where id='%s'", tableName, id);
			statement = connection.createStatement();
			resultSet = statement.executeQuery(sql);
			ResultSetMetaData resultSetMetaData = resultSet.getMetaData();
			int cc = resultSetMetaData.getColumnCount();
			while(resultSet.next()){
				MemoryItemKey memoryItemKey =  new MemoryItemKey();
				memoryItem.setKey(memoryItemKey);
				for(int i=1;i<=cc;i++){
					String cl = resultSetMetaData.getColumnLabel(i);
					Object o = resultSet.getObject(i);
					if(cl.equalsIgnoreCase("id")) {
						memoryItemKey.setId(o.toString());
					}else if(cl.equalsIgnoreCase("keywords")) {
						memoryItemKey.setKeywords(o.toString());
					}else if(cl.equalsIgnoreCase("content")) {
						memoryItem.setContent(o.toString());
					}else if(cl.equalsIgnoreCase("comment")) {
						memoryItem.setComment("");
					}
				}
			}
		} catch (Exception e) {
			e.printStackTrace();
			throw e;
		} finally {
			if(null!=statement){
				statement.close();
			}
			if(null!=connection){
				connection.close();
			}
		}
		if(memoryItem.getKey()==null) {
			throw new Exception("cannot find item by id "+id);
		}
		return memoryItem;
	}
	public List<MemoryItem> findAll(String tableName) throws Exception {
		List<MemoryItem> list = new ArrayList<>();
		Connection connection = null;
		Statement statement=null;
		ResultSet resultSet=null;
		try {
			connection = getConnection(file, this.userName, this.pwd);
			connection.setAutoCommit(false);
			String sql = String.format("select * from %s", tableName);
			statement = connection.createStatement();
			resultSet = statement.executeQuery(sql);
			ResultSetMetaData resultSetMetaData = resultSet.getMetaData();
			int cc = resultSetMetaData.getColumnCount();
			while(resultSet.next()){
				MemoryItemKey memoryItemKey =  new MemoryItemKey();
				MemoryItem memoryItem =  new MemoryItem();
				memoryItem.setKey(memoryItemKey);
				for(int i=1;i<=cc;i++){
					String cl = resultSetMetaData.getColumnLabel(i);
					Object o = resultSet.getObject(i);
					if(cl.equalsIgnoreCase("id")) {
						memoryItemKey.setId(o.toString());
					}else if(cl.equalsIgnoreCase("keywords")) {
						memoryItemKey.setKeywords(o.toString());
					}else if(cl.equalsIgnoreCase("content")) {
						memoryItem.setContent(o.toString());
					}else if(cl.equalsIgnoreCase("comment")) {
						memoryItem.setComment("");
					}
				}
				list.add(memoryItem);
			}
		} catch (Exception e) {
			e.printStackTrace();
			throw e;
		} finally {
			if(null!=statement){
				statement.close();
			}
			if(null!=connection){
				connection.close();
			}
		}
		return list;
	}
	public File getFile() {
		return file;
	}
	public void setFile(File file) {
		this.file = file;
	}
	public String getUserName() {
		return userName;
	}
	public void setUserName(String userName) {
		this.userName = userName;
	}
	public String getPwd() {
		return pwd;
	}
	public void setPwd(String pwd) {
		this.pwd = pwd;
	}
	public List<String> getMemoryAreas() {
		return memoryAreas;
	}
	public static void main(String[] args){
		Connection connection = null;
		Statement statement=null;
		ResultSet resultSet=null;
		try {
			H2JDBCService ds = new H2JDBCService();
			File f = new File("D:\\projects\\cg\\cg-5.6\\bb");
			ds.testConnection(f, "sa", "");
			ds.loadAllEnabledMemoryAreas();
			ds.loadAllKeywordsMappings();
			List<MemoryItem> list = ds.findByKeyword(ds.CONFIG_TABLE, codegen.Const.BRAIN_LOCAL_REPO_KEYWORD);
			MemoryItem mi = ds.findOneByKeyword(ds.CONFIG_TABLE, codegen.Const.BRAIN_LOCAL_REPO_KEYWORD);
			int r = ds.executeUpdate("update config set keywords=?,content=? where id=?",  mi.getKey().getKeywords(), "test", mi.getKey().getId());
			r = ds.executeUpdate("delete from config where keywords=?",  mi.getKey().getKeywords());
			mi = ds.findOneByKeyword(ds.CONFIG_TABLE, codegen.Const.BRAIN_LOCAL_REPO_KEYWORD);
			ds.removeById(ds.CONFIG_TABLE, mi.getKey().getId());
			statement = connection.createStatement();
			String sql = "select * from commandsyntax";
			resultSet = statement.executeQuery(sql);
			ResultSetMetaData resultSetMetaData = resultSet.getMetaData();
			int cc = resultSetMetaData.getColumnCount();
			while(resultSet.next()){
				for(int i=1;i<=cc;i++){
					Object o = resultSet.getObject(i);
					System.out.println(String.format("column is = %s", o));
				}
			}
			connection.close();
		} catch ( Exception e) {
			e.printStackTrace();
		} finally {
			if(null!=resultSet){
				try {
					resultSet.close();
				} catch (SQLException e) {
					e.printStackTrace();
				}
			}
			if(null!=statement){
				try {
					statement.close();
				} catch (SQLException e) {
					e.printStackTrace();
				}
			}
			if(null!=connection){
				try {
					connection.close();
				} catch (SQLException e) {
					e.printStackTrace();
				}
			}
		}
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\codegen\eclipseRobot\H2JDBCService2.java---
package codegen.eclipseRobot;
import codegen.Syntax;
import codegen.eclipseRobot.model.MemoryArea;
import codegen.eclipseRobot.model.MemoryItem;
import codegen.eclipseRobot.model.MemoryItemKey;
import codegen.robot.Service;
import com.dgs.annotation.ParamAnno;
import com.dgs.annotation.ServiceMethodAnn;
import com.dgs.annotation.UIAnno;
import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import org.apache.commons.lang3.StringUtils;
import ui.validation.NotVisibleInUI;
import ui.validation.ValidationAnn;
import java.io.File;
import java.lang.reflect.Type;
import java.sql.*;
import java.util.Date;
import java.util.*;
import java.util.stream.Collectors;
public class H2JDBCService2 extends Service {
	private File file;
	private String userName="sa";
	private String pwd;
	public static final String CREATE_TABLE = "CREATE TABLE %s(ID VARCHAR(255) PRIMARY KEY, keywords VARCHAR_IGNORECASE(255), content LONGVARCHAR, comment VARCHAR(255), createTime TIMESTAMP, updateTime TIMESTAMP);";
	public static final String MEMORY_AREAS_KEY_WORDS = "MEMORY_AREAS_KEY_WORDS";
	private List<String> memoryAreas;
	List<MemoryItem> configItems;
	List<MemoryItem> commandItems;
	List<MemoryItem> miscAreaItems;
	List<MemoryItem> codeSyntaxItems;
	private Map<MemoryItemKey, MemoryItem> codeSyntaxKeywordsMapping = new HashMap<>();
	private Map<MemoryItemKey, MemoryItem> commandKeywordsMapping = new HashMap<>();
	private Map<MemoryItemKey, MemoryItem> miscKeywordsMapping = new HashMap<>();
	private Map<MemoryItemKey, MemoryItem> configKeywordsMapping = new HashMap<>();
	public static final String CONFIG_TABLE = "config";
	public static final String COMMAND_SYNTAX_TABLE = "commandsyntax";
	public static final String MISC_AREA_TABLE = "miscarea";
	public static final String CODE_SYNTAX_TABLE = "codesyntax";
	public static final String COLUMN_ID = "ID";
	public static final String COLUMN_KEYWORDS = "keywords";
	public static final String COLUMN_CONTENT = "content";
	public static final String COLUMN_COMMENT = "comment";
	public static final String JRE8_RTJAR_JAVA_JAVAX_ORG_KEYWORD = "jre8_rtjar_java_javax_org";
	public H2JDBCService2() {
	}
	public String testConnection(@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) File dbfile, String user, String password)throws Exception {
		Connection conn = getConnection(dbfile, user, password);
		if(null!=conn) {
			conn.close();
		}else {
			return "failed";
		}
		return "ok";
	}
	public Connection getConnection(@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) File dbfile, String user, String password) throws Exception {
		this.file = dbfile;
		String driverClzName = "org.h2.Driver";
		String dbFilepath = dbfile.getAbsolutePath();
		dbFilepath = dbFilepath.replaceFirst(".mv.db", "");
		String url = "jdbc:h2:file:"+dbFilepath;
		Connection connection = null;
		try {
			Class.forName(driverClzName);
			connection = DriverManager.getConnection(url, user, password);
		} catch (SQLException | ClassNotFoundException e) {
			e.printStackTrace();
			throw e;
		} finally {
		}
		return connection;
	}
	@ServiceMethodAnn(keyword = "memorize code syntax")
	public void memorizeCodeSyntax(@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) String keywords,
			@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) String content) throws Exception {
		memorizeInTable(CODE_SYNTAX_TABLE, keywords,content);
	}
	@ServiceMethodAnn(keyword = "memorize config")
	public void memorizeConfig(@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) String keywords,
			@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) String content) throws Exception {
		memorizeInTable(CONFIG_TABLE, keywords,content);
	}
	@ServiceMethodAnn(keyword = "memorize misc")
	public void memorizeMisc(@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) String keywords,
			@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) String content) throws Exception {
		memorizeInTable(MISC_AREA_TABLE, keywords,content);
	}
	@ServiceMethodAnn(keyword = "memorize command syntax")
	public void memorizeCommandSyntax(@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) String keywords,
			@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) String content) throws Exception {
		memorizeInTable(COMMAND_SYNTAX_TABLE, keywords,content);
	}
	@ServiceMethodAnn(keyword = "memorize in area")
	public void memorizeInTable(
	        @UIAnno(uiClz = "ui.ClassCombBoxpane")
	        @ParamAnno(description = "memory area") 
	        String areaName, @ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) String keywords,
			@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) String content) throws Exception {
		insert(areaName, keywords, content);
	}
	@ServiceMethodAnn(keyword = "create memory area")
	public void createTable(
	        @ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) String areaName, boolean disable)
			throws Exception {
		String sql = String.format(CREATE_TABLE, areaName);
		executeUpdate(sql, new String[]{});
		String areaJson = this.showConfigMemory(MEMORY_AREAS_KEY_WORDS);
		Gson gson = new Gson();
		Type type = new TypeToken<List<MemoryArea>>(){}.getType();
		List<MemoryArea> list1 = gson.fromJson(areaJson, type);
		MemoryArea ma = new MemoryArea(areaName, disable);
		list1.add(ma);
		areaJson = gson.toJson(list1);
		this.saveOrUpdate(CONFIG_TABLE, MEMORY_AREAS_KEY_WORDS, areaJson);
		return;
	}
	public String showMemoryById(String tableName, @ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) String id)
			throws Exception {
		MemoryItem item = this.findById(tableName, id);
		StringBuilder sb = new StringBuilder();
		if(null != item) {
			sb.append(item.getContent()).append(Syntax.NEW_LINE).append(Syntax.NEW_LINE);
		}
		return sb.toString();
	}
	@ServiceMethodAnn(keyword = "show all memory")
	public String showAllMemory(String tableName) throws Exception {
		List<MemoryItem> list = this.findAll(tableName);
		StringBuilder sb = new StringBuilder();
		for(MemoryItem item : list) {
			sb.append(item.getKey().getId()).append("-").append(item.getKey().getKeywords()).append(Syntax.NEW_LINE)
					.append(item.getContent()).append(Syntax.NEW_LINE).append(Syntax.NEW_LINE);
			sb.append("---------------------------------");
		}
		return sb.toString();
	}
	public Map<MemoryItemKey, MemoryItem> getAllItems(String tableName) throws Exception {
		Map<MemoryItemKey, MemoryItem> map = new HashMap<>();
		Connection connection = null;
		Statement statement=null;
		ResultSet resultSet=null;
		try {
			connection = getConnection(file, this.userName, this.pwd);
			connection.setAutoCommit(false);
			String sql = String.format("select * from %s", tableName);
			statement = connection.createStatement();
			resultSet = statement.executeQuery(sql);
			ResultSetMetaData resultSetMetaData = resultSet.getMetaData();
			int cc = resultSetMetaData.getColumnCount();
			while(resultSet.next()){
				MemoryItemKey memoryItemKey =  new MemoryItemKey();
				memoryItemKey.setTable(tableName);
				MemoryItem memoryItem =  new MemoryItem();
				memoryItem.setKey(memoryItemKey);
				for(int i=1;i<=cc;i++){
					String cl = null;
					try {
						cl = resultSetMetaData.getColumnLabel(i);
					} catch (Exception e) {
						cl = resultSetMetaData.getColumnName(i);
					}
					Object o = resultSet.getObject(i);
					if("id".equalsIgnoreCase(cl)) {
						memoryItemKey.setId(o.toString());
					}else if("keywords".equalsIgnoreCase(cl)) {
						memoryItemKey.setKeywords(o.toString());
					}else if("content".equalsIgnoreCase(cl)) {
						memoryItem.setContent(o.toString());
					}else if("comment".equalsIgnoreCase(cl)) {
						memoryItem.setComment("");
					}
				}
				map.put(memoryItemKey, memoryItem);
			}
		} catch (Exception e) {
			e.printStackTrace();
			throw e;
		} finally {
			if(null!=statement){
				statement.close();
			}
			if(null!=connection){
				connection.close();
			}
		}
		return map;
	}
	public void loadAllKeywordsMappings() throws Exception {
		getAllConfigItems();
		getAllMiscAreaItems();
		getAllCodeSyntaxItems();
		getAllCommandItems();
	    return ;
	}
	private Map<MemoryItemKey, MemoryItem> getAllConfigItems() throws Exception {
		this.configKeywordsMapping = getAllItems(CONFIG_TABLE);
	    return this.configKeywordsMapping;
	}
	private Map<MemoryItemKey, MemoryItem> getAllMiscAreaItems() throws Exception {
		this.miscKeywordsMapping = getAllItems(MISC_AREA_TABLE);
		return miscKeywordsMapping;
	}
	private Map<MemoryItemKey, MemoryItem> getAllCodeSyntaxItems() throws Exception {
		this.codeSyntaxKeywordsMapping = getAllItems(CODE_SYNTAX_TABLE);
		return this.codeSyntaxKeywordsMapping;
	}
	private Map<MemoryItemKey, MemoryItem> getAllCommandItems() throws Exception {
		this.commandKeywordsMapping = getAllItems(COMMAND_SYNTAX_TABLE);
		return this.commandKeywordsMapping;
	}
	public List<MemoryItemKey> getCodeSyntaxKeys()
			throws Exception {
		Set<MemoryItemKey> keys = codeSyntaxKeywordsMapping.keySet();
		List<MemoryItemKey> list = new ArrayList<>();
		list.addAll(keys);
	    return list;
	}
	public List<MemoryItemKey> getMiscAreaKeys()
			throws Exception {
		Set<MemoryItemKey> keys = miscKeywordsMapping.keySet();
		List<MemoryItemKey> list = new ArrayList<>();
		list.addAll(keys);
	    return list;
	}
	public List<MemoryItemKey> getCommandSyntaxKeys()
			throws Exception {
		Set<MemoryItemKey> keys = commandKeywordsMapping.keySet();
		List<MemoryItemKey> list = new ArrayList<>();
		list.addAll(keys);
	    return list;
	}
	public List<MemoryItemKey> getConfigKeys()
			throws Exception {
		Set<MemoryItemKey> keys = configKeywordsMapping.keySet();
		List<MemoryItemKey> list = new ArrayList<>();
		list.addAll(keys);
	    return list;
	}
	public List<String> loadAllEnabledMemoryAreas() throws Exception {
		List<MemoryArea> list = getAllMemoryAreas();
		List<String> list1=list.stream().filter(e -> !e.isDisable()).map(e->e.getTable()).collect(Collectors.toList());
		memoryAreas = list1;
		return list1;
	}
	public List<MemoryArea> getAllMemoryAreas() throws Exception {
		String areaJson = this.showConfigMemory(MEMORY_AREAS_KEY_WORDS);
		if(Objects.isNull(areaJson)) {
			System.out.print(String.format("cannot find memory area row"));
			return new ArrayList<MemoryArea>();
		}else{
			Gson gson = new Gson();
			Type type = new TypeToken<List<MemoryArea>>(){}.getType();
			List<MemoryArea> list1 = gson.fromJson(areaJson, type);
			return list1;
		}
	}
	@UIAnno(uiClz="ui.MemoryPane")
	@ServiceMethodAnn(keyword = "show memory")
	public String showMemory(String table, String keyword) throws Exception {
		MemoryItem item = findOneByKeyword(table, keyword);
		if(null!=item) {
			return item.getContent();
		}
		System.out.print(String.format("cannot find row by table %s and keyword %s", table, keyword));
		return "";
	}
	public String showCodeSyntaxMemory( String keyword) throws Exception {
		return showMemory(this.CODE_SYNTAX_TABLE, keyword);
	}
	public String showMiscAreaMemory( String keyword) throws Exception {
		return showMemory(this.MISC_AREA_TABLE, keyword);
	}
	public String showCommandMemory(String keyword) throws Exception {
		return showMemory(this.COMMAND_SYNTAX_TABLE, keyword);
	}
	public String showConfigMemory(String keyword) throws Exception {
		return showMemory(this.CONFIG_TABLE, keyword);
	}
	public List<String> getJREClzNames() throws Exception {
		String name = showMemory(this.CONFIG_TABLE, JRE8_RTJAR_JAVA_JAVAX_ORG_KEYWORD);
		List<String> list = new ArrayList<>();
		Scanner scanner = new Scanner(name);
		try {
			while (scanner.hasNextLine()) {
				String line = scanner.nextLine();
				if (line != null && !"".equals(line.trim())) {
					list.add(line);
				}
			}
		} catch (Exception e) {
		} finally {
			scanner.close();
		}
		return list;
	}
	@NotVisibleInUI
	public int insert(String tableName, String keywords, String content) throws Exception {
		UUID uuid = UUID.randomUUID();
		String id = uuid.toString();
		return insert(tableName, id, keywords, content); 
	}
	@NotVisibleInUI
    public int insert(String tableName,String id, String keywords, String content) throws Exception {
        String sql = String.format("insert into %s (keywords, content, id, createTime, updateTime) values (?, ?, ?, ?, ?)", tableName);
        long now = new Date().getTime();
        Timestamp nowTimestamp = new Timestamp(now);
        int i = executeUpdate(sql,new Object[] {  keywords, content, id, nowTimestamp, nowTimestamp});
        if(i>0){
            MemoryItemKey key = new MemoryItemKey();
            key.setId(id);
            key.setKeywords(keywords);
            key.setTable(tableName);
            MemoryItem mi = new MemoryItem();
            mi.setKey(key);
            mi.setContent(content);
            switch(tableName){ 
                case CONFIG_TABLE:
                    configKeywordsMapping.put(key, mi);
                break;
                case COMMAND_SYNTAX_TABLE:
                    this.commandKeywordsMapping.put(key, mi);
                break;
                case MISC_AREA_TABLE:
                    this.miscKeywordsMapping.put(key, mi);
                break;
                case CODE_SYNTAX_TABLE:
                    this.codeSyntaxKeywordsMapping.put(key, mi);
                break;
                default :
                break;
            }
        }
        return i; 
    }
	public void reloadMapping(String tableName) throws Exception{
		switch(tableName){ 
			case CONFIG_TABLE:
				getAllConfigItems();
			break;
			case COMMAND_SYNTAX_TABLE:
				getAllCommandItems();
			break;
			case MISC_AREA_TABLE:
				getAllMiscAreaItems();
			break;
			case CODE_SYNTAX_TABLE:
				getAllCodeSyntaxItems();
			break;
			default :
			break;
		}
	}
	public void updateMapping(MemoryItemKey oldkey, MemoryItemKey key, MemoryItem mi) throws Exception{
		switch(key.getTable() ){ 
			case CONFIG_TABLE:
				configKeywordsMapping.remove(oldkey);
				configKeywordsMapping.put(key, mi);
			break;
			case COMMAND_SYNTAX_TABLE:
				commandKeywordsMapping.remove(oldkey);
				commandKeywordsMapping.put(key, mi);
			break;
			case MISC_AREA_TABLE:
				miscKeywordsMapping.remove(oldkey);
				miscKeywordsMapping.put(key, mi);
			break;
			case CODE_SYNTAX_TABLE:
				codeSyntaxKeywordsMapping.remove(oldkey);
				codeSyntaxKeywordsMapping.put(key, mi);
			break;
			default :
			break;
		}
	}
	public void removeMapping(MemoryItemKey key) throws Exception{
		switch(key.getTable() ){ 
			case CONFIG_TABLE:
				configKeywordsMapping.remove(key);
			break;
			case COMMAND_SYNTAX_TABLE:
				commandKeywordsMapping.remove(key);
			break;
			case MISC_AREA_TABLE:
				miscKeywordsMapping.remove(key);
			break;
			case CODE_SYNTAX_TABLE:
				codeSyntaxKeywordsMapping.remove(key);
			break;
			default :
			break;
		}
	}
	public MemoryItem getOldMemoryItemFromKeywordsMapping(String table, String id) throws Exception{
		MemoryItemKey key = new MemoryItemKey();
		key.setId(id);
		key.setTable(table);
		MemoryItem item=null;
		switch(table){ 
			case CONFIG_TABLE:
				item= configKeywordsMapping.get(key);
			break;
			case COMMAND_SYNTAX_TABLE:
				item= commandKeywordsMapping.get(key);
			break;
			case MISC_AREA_TABLE:
				item= miscKeywordsMapping.get(key);
			break;
			case CODE_SYNTAX_TABLE:
				item= codeSyntaxKeywordsMapping.get(key);
			break;
			default :
			break;
		}
		return item;
	}
	public void saveOrUpdateLastProject(String content) throws Exception{
		saveOrUpdate(CONFIG_TABLE, codegen.Const.BRAIN_LAST_PROJECT_KEYWORD, content);
	}
	public void saveOrUpdate(String tableName, String keywords, String content) throws Exception{
		List<MemoryItem> itemList;
		String id;
		try {
			itemList = this.findByKeyword(tableName, keywords);
		} catch (Exception e) {
			itemList=null;
		}
		if(!Objects.isNull(itemList) && !itemList.isEmpty()){
			id =itemList.get(0).getKey().getId();
			String oldContent = itemList.get(0).getContent();
			if(!StringUtils.equalsIgnoreCase(oldContent, content)){
				int i= this.updateById(tableName, id, keywords, content);
				if(i>0){
				}else{
				}
			}
		}else{
			this.memorizeInTable(tableName, keywords, content);
		}
		return ;
	}
	@NotVisibleInUI
	public int updateById(String tableName,@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) String id, String keywords,
			String content) throws Exception {
		String sql = String.format("update %s set keywords=?,content=?,updateTime=? where id=?", tableName);
		long now = new Date().getTime();
        Timestamp nowTimestamp = new Timestamp(now);
		int i = 0;
		try {
			i = executeUpdate(sql,new Object[] { keywords, content,nowTimestamp, id});
		} catch (Exception e) {
			System.out.println(e.getMessage());
		}
		if(i>0){
			MemoryItemKey key = new MemoryItemKey();
			key.setId(id);
			key.setKeywords(keywords);
			key.setTable(tableName);
			MemoryItem mi = new MemoryItem();
			mi.setKey(key);
			mi.setContent(content);
			MemoryItem oldItem = getOldMemoryItemFromKeywordsMapping(tableName, id);
			if(null!=oldItem)
				updateMapping(oldItem.getKey(), key, mi );
		}
		return i; 
	}
	@NotVisibleInUI
	public int removeById(String tableName,@ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) String id) throws Exception {
		String sql = String.format("delete from %s where id=?", tableName);
		int i=0;
		try {
			i = executeUpdate(sql,new Object[] { id});
		} catch (Exception e) {
		    System.out.println(e.getMessage());
		} 
		if(i>0){
			MemoryItem oldItem = getOldMemoryItemFromKeywordsMapping(tableName, id);
			if(null!=oldItem)
				removeMapping(oldItem.getKey());
		}
		return i; 
	}
	public MemoryItem findOneByKeyword(String tableName,String keywords) throws Exception {
		Connection connection = null;
		Statement statement=null;
		ResultSet resultSet=null;
		MemoryItem memoryItem =  new MemoryItem();
		try {
			connection = getConnection(file, this.userName, this.pwd);
			connection.setAutoCommit(false);
			String sql = String.format("select top 1 * from %s where keywords like '%%%s%%'", tableName, keywords);
			statement = connection.createStatement();
			resultSet = statement.executeQuery(sql);
			ResultSetMetaData resultSetMetaData = resultSet.getMetaData();
			int cc = resultSetMetaData.getColumnCount();
			while(resultSet.next()){
				MemoryItemKey memoryItemKey =  new MemoryItemKey();
				memoryItem.setKey(memoryItemKey);
				for(int i=1;i<=cc;i++){
					String cl = resultSetMetaData.getColumnLabel(i);
					Object o = resultSet.getObject(i);
					if(cl.equalsIgnoreCase("id")) {
						memoryItemKey.setId(o.toString());
					}else if(cl.equalsIgnoreCase("keywords")) {
						memoryItemKey.setKeywords(o.toString());
					}else if(cl.equalsIgnoreCase("content")) {
						memoryItem.setContent(o.toString());
					}else if(cl.equalsIgnoreCase("comment")) {
						memoryItem.setComment("");
					}
				}
			}
		} catch (Exception e) {
			e.printStackTrace();
			throw e;
		} finally {
			if(null!=statement){
				statement.close();
			}
			if(null!=connection){
				connection.close();
			}
		}
		if(memoryItem.getKey()==null) {
			throw new Exception("cannot find item by "+keywords);
		}
		return memoryItem;
	}
	public List<MemoryItem> findByKeyword(String tableName,String keywords) throws Exception {
		List<MemoryItem> list = new ArrayList<>();
		Connection connection = null;
		Statement statement=null;
		ResultSet resultSet=null;
		try {
			connection = getConnection(file, this.userName, this.pwd);
			connection.setAutoCommit(false);
			String sql = String.format("select * from %s where keywords like '%%%s%%'", tableName, keywords);
			statement = connection.createStatement();
			resultSet = statement.executeQuery(sql);
			ResultSetMetaData resultSetMetaData = resultSet.getMetaData();
			int cc = resultSetMetaData.getColumnCount();
			while(resultSet.next()){
				MemoryItemKey memoryItemKey =  new MemoryItemKey();
				MemoryItem memoryItem =  new MemoryItem();
				memoryItem.setKey(memoryItemKey);
				for(int i=1;i<=cc;i++){
					String cl = resultSetMetaData.getColumnLabel(i);
					Object o = resultSet.getObject(i);
					if(cl.equalsIgnoreCase("id")) {
						memoryItemKey.setId(o.toString());
					}else if(cl.equalsIgnoreCase("keywords")) {
						memoryItemKey.setKeywords(o.toString());
					}else if(cl.equalsIgnoreCase("content")) {
						memoryItem.setContent(o.toString());
					}else if(cl.equalsIgnoreCase("comment")) {
						memoryItem.setComment("");
					}
				}
				list.add(memoryItem);
			}
		} catch (Exception e) {
			e.printStackTrace();
			throw e;
		} finally {
			if(null!=statement){
				statement.close();
			}
			if(null!=connection){
				connection.close();
			}
		}
		return list;
	}
	public int executeUpdate(String sql, Object... args) throws Exception {
		int i;
		Connection connection = null;
		PreparedStatement statement=null;
		try {
			connection = getConnection(file, this.userName, this.pwd);
			connection.setAutoCommit(false);
			statement = connection.prepareStatement(sql);
			for(int j=1;j<=args.length;j++){
				statement.setString(j, args[j-1].toString());
			}
			i = statement.executeUpdate();
			connection.commit();
		} catch (Exception e) {
			e.printStackTrace();
			throw e;
		} finally {
			if(null!=statement){
				statement.close();
			}
			if(null!=connection){
				connection.close();
			}
		}
		return i;
	}
	public MemoryItem findById(String tableName,String id) throws Exception {
		Connection connection = null;
		Statement statement=null;
		ResultSet resultSet=null;
		MemoryItem memoryItem =  new MemoryItem();
		try {
			connection = getConnection(file, this.userName, this.pwd);
			connection.setAutoCommit(false);
			String sql = String.format("select * from %s where id='%s'", tableName, id);
			statement = connection.createStatement();
			resultSet = statement.executeQuery(sql);
			ResultSetMetaData resultSetMetaData = resultSet.getMetaData();
			int cc = resultSetMetaData.getColumnCount();
			while(resultSet.next()){
				MemoryItemKey memoryItemKey =  new MemoryItemKey();
				memoryItem.setKey(memoryItemKey);
				for(int i=1;i<=cc;i++){
					String cl = resultSetMetaData.getColumnLabel(i);
					Object o = resultSet.getObject(i);
					if(cl.equalsIgnoreCase("id")) {
						memoryItemKey.setId(o.toString());
					}else if(cl.equalsIgnoreCase("keywords")) {
						memoryItemKey.setKeywords(o.toString());
					}else if(cl.equalsIgnoreCase("content")) {
						memoryItem.setContent(o.toString());
					}else if(cl.equalsIgnoreCase("comment")) {
						memoryItem.setComment("");
					}
				}
			}
		} catch (Exception e) {
			e.printStackTrace();
			throw e;
		} finally {
			if(null!=statement){
				statement.close();
			}
			if(null!=connection){
				connection.close();
			}
		}
		if(memoryItem.getKey()==null) {
			throw new Exception("cannot find item by id "+id);
		}
		return memoryItem;
	}
	public List<MemoryItem> findAll(String tableName) throws Exception {
		List<MemoryItem> list = new ArrayList<>();
		Connection connection = null;
		Statement statement=null;
		ResultSet resultSet=null;
		try {
			connection = getConnection(file, this.userName, this.pwd);
			connection.setAutoCommit(false);
			String sql = String.format("select * from %s", tableName);
			statement = connection.createStatement();
			resultSet = statement.executeQuery(sql);
			ResultSetMetaData resultSetMetaData = resultSet.getMetaData();
			int cc = resultSetMetaData.getColumnCount();
			while(resultSet.next()){
				MemoryItemKey memoryItemKey =  new MemoryItemKey();
				MemoryItem memoryItem =  new MemoryItem();
				memoryItem.setKey(memoryItemKey);
				for(int i=1;i<=cc;i++){
					String cl = resultSetMetaData.getColumnLabel(i);
					Object o = resultSet.getObject(i);
					if(cl.equalsIgnoreCase("id")) {
						memoryItemKey.setId(o.toString());
					}else if(cl.equalsIgnoreCase("keywords")) {
						memoryItemKey.setKeywords(o.toString());
					}else if(cl.equalsIgnoreCase("content")) {
						memoryItem.setContent(o.toString());
					}else if(cl.equalsIgnoreCase("comment")) {
						memoryItem.setComment("");
					}
				}
				list.add(memoryItem);
			}
		} catch (Exception e) {
			e.printStackTrace();
			throw e;
		} finally {
			if(null!=statement){
				statement.close();
			}
			if(null!=connection){
				connection.close();
			}
		}
		return list;
	}
	public File getFile() {
		return file;
	}
	public void setFile(File file) {
		this.file = file;
	}
	public String getUserName() {
		return userName;
	}
	public void setUserName(String userName) {
		this.userName = userName;
	}
	public String getPwd() {
		return pwd;
	}
	public void setPwd(String pwd) {
		this.pwd = pwd;
	}
	public List<String> getMemoryAreas() {
		return memoryAreas;
	}
	public static void main(String[] args){
		Connection connection = null;
		Statement statement=null;
		ResultSet resultSet=null;
		try {
			H2JDBCService2 ds = new H2JDBCService2();
			File f = new File("/dickson/h2db/bb");
			ds.testConnection(f, "sa", "");
			ds.loadAllEnabledMemoryAreas();
			ds.loadAllKeywordsMappings();
			List<MemoryItem> list = ds.findByKeyword(ds.CONFIG_TABLE, codegen.Const.BRAIN_LOCAL_REPO_KEYWORD);
			MemoryItem mi = ds.findOneByKeyword(ds.CONFIG_TABLE, codegen.Const.BRAIN_LOCAL_REPO_KEYWORD);
			int r = ds.executeUpdate("update config set keywords=?,content=? where id=?",  mi.getKey().getKeywords(), "test", mi.getKey().getId());
			r = ds.executeUpdate("delete from config where keywords=?",  mi.getKey().getKeywords());
			mi = ds.findOneByKeyword(ds.CONFIG_TABLE, codegen.Const.BRAIN_LOCAL_REPO_KEYWORD);
			ds.removeById(ds.CONFIG_TABLE, mi.getKey().getId());
			statement = connection.createStatement();
			String sql = "select * from commandsyntax";
			resultSet = statement.executeQuery(sql);
			ResultSetMetaData resultSetMetaData = resultSet.getMetaData();
			int cc = resultSetMetaData.getColumnCount();
			while(resultSet.next()){
				for(int i=1;i<=cc;i++){
					Object o = resultSet.getObject(i);
					System.out.println(String.format("column is = %s", o));
				}
			}
			connection.close();
		} catch ( Exception e) {
			e.printStackTrace();
		} finally {
			if(null!=resultSet){
				try {
					resultSet.close();
				} catch (SQLException e) {
					e.printStackTrace();
				}
			}
			if(null!=statement){
				try {
					statement.close();
				} catch (SQLException e) {
					e.printStackTrace();
				}
			}
			if(null!=connection){
				try {
					connection.close();
				} catch (SQLException e) {
					e.printStackTrace();
				}
			}
		}
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\codegen\eclipseRobot\HtmlService.java---
package codegen.eclipseRobot;
public class HtmlService extends EclipseService {
}
----strat of file D:\projects\cg\cg-min\src\main\java\codegen\eclipseRobot\HumanLanKeyword.java---
package codegen.eclipseRobot;
public @interface HumanLanKeyword {
	String[] keywords={};;
}
----strat of file D:\projects\cg\cg-min\src\main\java\codegen\eclipseRobot\MethodDescription.java---
package codegen.eclipseRobot;
public @interface MethodDescription {
	String humanLanWords="";
}
----strat of file D:\projects\cg\cg-min\src\main\java\codegen\eclipseRobot\model\MemoryArea.java---
package codegen.eclipseRobot.model;
import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.List;
public class MemoryArea {
	private String table;
	private boolean disable;
	public MemoryArea(String table, boolean disable) {
		super();
		this.table = table;
		this.disable = disable;
	}
	public String getTable() {
		return table;
	}
	public void setTable(String table) {
		this.table = table;
	}
	public boolean isDisable() {
		return disable;
	}
	public void setDisable(boolean disable) {
		this.disable = disable;
	}
	public static void main(String[] args){
		Gson gson = new Gson();
		List<MemoryArea> list = new ArrayList<>();
		list.add(new MemoryArea("config", false));
		list.add(new MemoryArea("commandsyntax", false));
		list.add(new MemoryArea("miscarea", false));
		list.add(new MemoryArea("codesyntax", false));
		String s = gson.toJson(list);
		Type type = new TypeToken<List<MemoryArea>>(){}.getType();
		List<MemoryArea> list1 = gson.fromJson(s, type);
		System.out.println(s);
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\codegen\eclipseRobot\model\MemoryItem.java---
package codegen.eclipseRobot.model;
public class MemoryItem {
	private MemoryItemKey key;
	private String content;
	private String comment;
	public MemoryItemKey getKey() {
		return key;
	}
	public void setKey(MemoryItemKey key) {
		this.key = key;
	}
	public String getContent() {
		return content;
	}
	public void setContent(String content) {
		this.content = content;
	}
	public String getComment() {
		return comment;
	}
	public void setComment(String comment) {
		this.comment = comment;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\codegen\eclipseRobot\model\MemoryItemKey.java---
package codegen.eclipseRobot.model;
public class MemoryItemKey{
	private String table;
	private String id;
	private String keywords;
	public String getId() {
		return id;
	}
	public void setId(String id) {
		this.id = id;
	}
	public String getKeywords() {
		return keywords;
	}
	public void setKeywords(String keywords) {
		this.keywords = keywords;
	}
	public String getTable() {
		return table;
	}
	public void setTable(String table) {
		this.table = table;
	}
	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + ((id == null) ? 0 : id.hashCode());
		result = prime * result + ((table == null) ? 0 : table.hashCode());
		return result;
	}
	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		MemoryItemKey other = (MemoryItemKey) obj;
		if (id == null) {
			if (other.id != null)
				return false;
		} else if (!id.equals(other.id))
			return false;
		if (table == null) {
			if (other.table != null)
				return false;
		} else if (!table.equals(other.table))
			return false;
		return true;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\codegen\eclipseRobot\MoreReplacement.java---
package codegen.eclipseRobot;
public enum MoreReplacement {
	GROUP_ID, ARTIFACT_ID, ARTIFACT_PACK, ARTIFACT_VERSION,
	WEB_CONTEXT,WEB_PORT
}
----strat of file D:\projects\cg\cg-min\src\main\java\codegen\eclipseRobot\NewClassParam.java---
package codegen.eclipseRobot;
public class NewClassParam {
	private String className;
	private String packName;
	private String superClassName;
	private String interfaceClassName[];
	private Class superClass;
	private Class interfaceClass[];
	public String getClassName() {
		return className;
	}
	public void setClassName(String className) {
		this.className = className;
	}
	public String getPackName() {
		return packName;
	}
	public void setPackName(String packName) {
		this.packName = packName;
	}
	public String getSuperClassName() {
		return superClassName;
	}
	public void setSuperClassName(String superClassName) {
		this.superClassName = superClassName;
	}
	public String[] getInterfaceClassName() {
		return interfaceClassName;
	}
	public void setInterfaceClassName(String... interfaceClassName) {
		this.interfaceClassName = interfaceClassName;
	}
	public Class getSuperClass() {
		return superClass;
	}
	public void setSuperClass(Class superClass) {
		this.superClass = superClass;
	}
	public Class[] getInterfaceClass() {
		return interfaceClass;
	}
	public void setInterfaceClass(Class... interfaceClass) {
		this.interfaceClass = interfaceClass;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\codegen\eclipseRobot\QualifierName.java---
package codegen.eclipseRobot;
import codegen.complexobj.CodeGenContext;
import codegen.util.Common;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;
public class QualifierName {
	public class QualifierPart {
		String qualifierHead;
		String qualifierLastPart;
		public String getQualifierHead() {
			return qualifierHead;
		}
		public void setQualifierHead(String qualifierHead) {
			this.qualifierHead = qualifierHead;
		}
		public String getQualifierLastPart() {
			return qualifierLastPart;
		}
		public void setQualifierLastPart(String qualifierLastPart) {
			this.qualifierLastPart = qualifierLastPart;
		}
	}
	private QualifierPart qp;
	String packName;
	String clzSimpleName;
	public class ClzRelationShip {
		String outSideClzQualifierName;
		InnerClzRelationShip innerClzRelationShip;
	}
	public class InnerClzRelationShip {
		String ClzQualifierName;
		InnerClzRelationShip innerClzRelationShip;
	}
	String origContent;
	String classQualifierName;
	String fieldName;
	String methodName;
	String methodParam[];
	boolean isConstructor;
	String constructParam[];
	Class clz;
	Field field;
	public boolean isInnerClzName(String classQualifierName) {
		boolean isInnerClzName = false;
		return isInnerClzName;
	}
	public boolean isMethodVariable() {
		boolean isMethodVariable = false;
		return isMethodVariable;
	}
	public boolean isField() {
		boolean isField = fieldName != null ? true : false;
		return isField;
	}
	public boolean isClassCastMethod(Method method) {
		boolean b = false;
		return b;
	}
	public static boolean isClassConstructor(QualifierName qn) {
		return isClassConstructor(qn.getClz(), qn.getOrigContent());
	}
	public static boolean isClassConstructor(Class c, String origQualifierName) {
		boolean isConstructor = false;
		if (c == null) {
			return isConstructor;
		}
		if (origQualifierName.trim().startsWith(c.getName() + "." + c.getSimpleName() + "(")
				&& origQualifierName.trim().endsWith(")")) {
			isConstructor = true;
		}
		return isConstructor;
	}
	public static Constructor<?> getConstructorByQualifierName(QualifierName qn) {
		Constructor<?> cc = null;
		if (isClassConstructor(qn)) {
			String origContent = qn.getOrigContent();
			int firstBrace = origContent.indexOf("(");
			int closeBrace = origContent.indexOf(")");
			String paramStr = origContent.substring(firstBrace + 1, closeBrace);
			String pnArray[] = paramStr.split(",", -1);
			Constructor<?> cts[] = qn.getClz().getConstructors();
			for (Constructor<?> ct : cts) {
				Class<?> pt[] = ct.getParameterTypes();
				if (pnArray.length == pt.length) {
					boolean nameMatch = true;
					for (int i = 0; i < pnArray.length; i++) {
						String ptSimpleName = pt[i].getSimpleName();
						String pn = pnArray[i].trim();
						pn = pn.replaceAll("<.+>", "");
						if (!ptSimpleName.equals(pn)) {
							nameMatch = false;
						}
					}
					if (nameMatch) {
						cc = ct;
						break;
					}
				}
			}
		}
		return cc;
	}
	private static boolean isMethodMatch(Method m1, QualifierName qn) {
		Class ps[] = m1.getParameterTypes();
		boolean allMatch = true;
		for (int i = 0; i < ps.length; i++) {
			Class p = ps[i];
			String mps = qn.getMethodParam()[i];
			mps = mps.replaceAll("<.+>", "");
			if (!p.getSimpleName().equals(mps)) {
				allMatch = false;
				break;
			}
		}
		return allMatch;
	}
	public static Method getMethodByQualifierName(QualifierName qn) {
		Method m = null;
		String origContent = qn.getOrigContent();
		if (origContent.contains(".") && origContent.contains("(") && origContent.contains(")")) {
			try {
				Class c = CodeGenContext.getInstance().getReloadableDynamicClassLoaderOwner()
						.loadClass(qn.getClassQualifierName(), true);
				Method ms[] = Common.getAllMethods(c);
				List<Method> list = Arrays.asList(ms);
				List<Method> fl = list.stream().filter(e -> {
					int eParamCount = e.getParameterCount();
					int methodParamCount = qn.getMethodParam() != null ? qn.getMethodParam().length : 0;
					if ("rangeCheck".equals(e.getName())) {
						System.out.print("***");
					}
					if (e.getName().equals(qn.getMethodName()) && eParamCount == methodParamCount) {
						return true;
					} else {
						return false;
					}
				}).collect(Collectors.toList());
				if (fl.size() == 1) {
					m = fl.get(0);
				} else if (fl.size() > 1) {
					List<Method> ml = fl.stream().filter(e -> {
						return isMethodMatch(e, qn);
					}).collect(Collectors.toList());
					if (ml.size() >= 1) {
						m = ml.get(0);
					} else {
						m = fl.get(0);
					}
				}
			} catch (ClassNotFoundException e) {
				e.printStackTrace();
			}
		}
		return m;
	}
	public boolean isFieldQualifier() {
		return classQualifierName != null && fieldName != null ? true : false;
	}
	public boolean isClassQualifier() {
		return classQualifierName != null && methodName == null && fieldName != null ? true : false;
	}
	public boolean isMethodQualifier() {
		return classQualifierName != null && methodName != null ? true : false;
	}
	public String getOrigContent() {
		return origContent;
	}
	public void setOrigContent(String origContent) {
		this.origContent = origContent;
	}
	public String getClassQualifierName() {
		return classQualifierName;
	}
	public void setClassQualifierName(String classQualifierName) {
		this.classQualifierName = classQualifierName;
	}
	public String getFieldName() {
		return fieldName;
	}
	public void setFieldName(String fieldName) {
		this.fieldName = fieldName;
	}
	public Field getField() {
		return field;
	}
	public void setField(Field field) {
		this.field = field;
	}
	public String getMethodName() {
		return methodName;
	}
	public void setMethodName(String methodName) {
		this.methodName = methodName;
	}
	public String[] getMethodParam() {
		return methodParam;
	}
	public void setMethodParam(String[] methodParam) {
		this.methodParam = methodParam;
	}
	public void setConstructor(boolean isConstructor) {
		this.isConstructor = isConstructor;
	}
	public boolean isConstructor() {
		return isConstructor;
	}
	public Class getClz() {
		return clz;
	}
	public void setClz(Class clz) {
		this.clz = clz;
	}
	public QualifierPart getQp() {
		return qp;
	}
	public void setQp(QualifierPart qp) {
		this.qp = qp;
	}
	public String getPackName() {
		return packName;
	}
	public void setPackName(String packName) {
		this.packName = packName;
	}
	public String getClzSimpleName() {
		return clzSimpleName;
	}
	public void setClzSimpleName(String clzSimpleName) {
		this.clzSimpleName = clzSimpleName;
	}
	public String[] getConstructParam() {
		return constructParam;
	}
	public void setConstructParam(String[] constructParam) {
		this.constructParam = constructParam;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\codegen\eclipseRobot\UIContext.java---
package codegen.eclipseRobot;
public class UIContext {
	public static int frameX;
	public static int frameY;
}
----strat of file D:\projects\cg\cg-min\src\main\java\codegen\eclipseRobot\UIController.java---
package codegen.eclipseRobot;
import java.awt.Component;
import java.awt.PointerInfo;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.io.File;
import java.io.IOException;
import java.lang.reflect.Constructor;
import java.lang.reflect.Method;
import java.net.URL;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import javax.swing.JButton;
import javax.swing.JComponent;
import javax.swing.JLabel;
import javax.swing.JTextField;
import javax.swing.SwingUtilities;
import javax.swing.SwingWorker;
import javax.swing.event.HyperlinkEvent;
import codegen.eclipseRobot.*;
import com.dgs.DatabaseService;
import com.dgs.annotation.ServiceMethodAnn;
import com.dgs.jnaforwin32.WindowService;
import clipboardclient.ConcreteClipboardMonitor;
import codegen.Const;
import codegen.complexobj.CodeGenContext;
import codegen.eclipseRobot.model.MemoryItem;
import codegen.eclipseRobot.model.MemoryItemKey;
import codegen.util.ClipBoard;
import codegen.util.Common;
import org.apache.commons.lang3.StringUtils;
import ui.ClassCombBox;
import ui.DefaultParamConverter;
import ui.FilterCombBoxPane;
import ui.GenAnnotationPane;
import ui.GenCodePane;
import ui.MemoryPane;
import ui.MethodTypePane;
import ui.SubmitBtnPane;
import ui.TablePane;
import ui.UI;
import ui.model.UIMemoryItemKey;
public class UIController {
	private EclipseService es;
	private H2JDBCService ds;
	private WindowService ws;
	private UI ui;
	private FilterCombBox filterCombBox;
	private DataModel model;
	static String NEW_METHOD_MATCH_WORD = "newmethod";
	static String NEW_FIELD_MATCH_WORD = "newfield";
	final String needMoveCursor = String.format("(?i)((?:%s)|(?:%s))", NEW_METHOD_MATCH_WORD, NEW_FIELD_MATCH_WORD);
	Pattern p = Pattern.compile(needMoveCursor);
	private ConcreteClipboardMonitor ccm;
	public UIController() {
		super();
		init();
	}
	public void init() {
		EclipseCodeGenContext context = EclipseCodeGenContext.newInstance();
		es = new EclipseService();
		ds = new H2JDBCService();
		ws = new WindowService();
		es.setWindowService(ws);
		es.setH2JDBCService(ds);
		context.setDatabaseService(ds);
		context.setEclipseService(es);
		model = new DataModel();
		CodeGenContext.getInstance().getUiModelMap().put(DataModel.class, model);
		model.setContext(context);
		model.resetMs(EclipseService.class, H2JDBCService.class);
		ui = new UI(model);
		ui.initView();
		filterCombBox = ui.getjComboBox();
		filterCombBox.addActionListener(e -> {
			String typeText = (String) filterCombBox.getSelectedItem();
			if (filterCombBox.isValidSelectedItem(typeText)) {
				onSelectionChanged(typeText);
			}
		});
		model.setSelectedItem(ui.getSeletedItem());
		ui.getEditorPane().addHyperlinkListener((HyperlinkEvent e) -> {
			model.setEventObject(e);
			HyperlinkEvent.EventType type = e.getEventType();
			final URL url = e.getURL();
			if (type == HyperlinkEvent.EventType.ENTERED) {
				System.out.println("URL: " + url);
			} else if (type == HyperlinkEvent.EventType.ACTIVATED) {
				if (url.toString().endsWith("action=clear")) {
					Runnable runner = new Runnable() {
						public void run() {
							ui.getEditorPane().loadWithSetPage();
						}
					};
					SwingUtilities.invokeLater(runner);
				}
				if (url.toString().endsWith("action=reload")) {
					try {
						reload();
					} catch (Exception e1) {
						e1.printStackTrace();
					}
				}
			}
		});
	}
	public void clickSubmitBtn() {
		convert(model);
		BtnClickSwingWorker sw = new BtnClickSwingWorker();
		sw.execute();
	}
	public void convert(DataModel model) {
		List<MethodTypePane> paneList = this.getChildComponent(ui.getTablePane(), MethodTypePane.class);
		if (paneList.size() > 0) {
			MethodTypePane mtp = paneList.get(0);
			DefaultParamConverter dpc = new DefaultParamConverter();
			dpc.convert(model, mtp.getPps(), mtp.getParamComps());
		} else {
		}
	}
	class BtnClickSwingWorker extends SwingWorker {
		@Override
		protected Object doInBackground() throws Exception {
			Object returnObj = callServiceMethod();
			afterServiceCall(model, returnObj);
			return null;
		}
	}
	public void afterServiceCall(DataModel model, Object returnObj) {
		Method m = model.getSelectedMethod();
		if (m == null) {
			return;
		}
		String methodDesc = getMethodDesc(m);
		if (!m.getName().startsWith("switchProcess")) {
			if (returnObj != null && returnObj instanceof String) {
				String str = (String) returnObj;
				boolean b = false;
				do {
					try {
						ClipBoard.setStringUtilSuccess(str);
						b = true;
					} catch (Exception e) {
					}
				} while (!b);
				try {
					b = es.paste();
				} catch (IOException e) {
				}
				if (!b) {
					ui.addRowInHtmlEditorPane("sorry, cannot activate the IDE window, pls do it manually");
				}
			} else if (returnObj != null && returnObj instanceof File) {
				File f = (File) returnObj;
				ui.addRowInHtmlEditorPane(String.format("file %s generated", f.getName()));
			}
		}
		ui.addRowInHtmlEditorPane(String.format("%s execution done", methodDesc));
	}
	public void startClipboardServer(String clientAppPath) {
		ccm = new ConcreteClipboardMonitor();
		ccm.start();
		while (ccm.getPort() == 0) {
			try {
				Thread.sleep(50);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}
		CodeGenContext.getInstance().setClipBoardMonitorServerPort(ccm.getPort());
		System.out.println(String.format("setClipBoardMonitorServerPort with port %s", ccm.getPort()));
	}
	public void start() {
		String dbPath = System.getProperty(codegen.Const.MEMORY_FILE_PATH_NAME);
		if (dbPath != null) {
			File f = new File(dbPath);
			if(!f.exists()) {
			    f = new File(dbPath+".mv.db");
			}
			if (f.isFile()) {
				try {
					System.out.println("going to load brain " + f.getAbsolutePath());
					ds.testConnection(f, "sa", "");
					ds.loadAllEnabledMemoryAreas();
					ds.loadAllKeywordsMappings();
					List<String> areas = ds.loadAllEnabledMemoryAreas();
					CodeGenContext.getMemoryAreas().clear();
					CodeGenContext.getMemoryAreas().addAll(areas);
					CodeGenContext.getInstance().setJreClasses(ds.getJREClzNames());
					this.callUIShow();
					MemoryItem row;
					String WpfAppFile = System.getProperty(codegen.Const.CLIPBOARD_CLIENT_APP_PATH_KEYWORD);
					File appFile = null;
					if (null != WpfAppFile) {
						appFile = new File(WpfAppFile);
					} else {
						if ((row = ds.findOneByKeyword(H2JDBCService.CONFIG_TABLE,
								codegen.Const.CLIPBOARD_CLIENT_APP_PATH_KEYWORD)) != null) {
							String content = row.getContent();
							appFile = new File(content);
						}
					}
					if (null != appFile && appFile.isFile()) {
					} else {
					}
					startClipboardServer(appFile.getAbsolutePath());
					{
						String localRepInSysProp = System.getProperty(codegen.Const.BRAIN_LOCAL_REPO_PROPERTY_KEYWORD);
						String content = null;
						if (null != localRepInSysProp) {
							content = localRepInSysProp;
						} else if ((row = ds.findOneByKeyword(H2JDBCService.CONFIG_TABLE,
								codegen.Const.BRAIN_LOCAL_REPO_KEYWORD)) != null) {
							content = row.getContent();
						}
						if (null != content) {
							File repoFile = new File(content);
							if (repoFile.isDirectory()) {
								System.out.println("setLocalRepoDir as " + repoFile.getAbsolutePath());
								CodeGenContext.setLocalRepoDir(repoFile.getAbsolutePath());
								ui.addRowInHtmlEditorPane(String.format("setLocalRepoDir with %s execution done",
										repoFile.getAbsolutePath()));
							}else{
								ui.addRowInHtmlEditorPane(
										String.format("given local repository path %s is not a directory", content));
							}
						}else{
							ui.addRowInHtmlEditorPane(
									String.format("cannot find %s in config", codegen.Const.BRAIN_LOCAL_REPO_KEYWORD));
						}
					}
					if ((row = ds.findOneByKeyword(H2JDBCService.CONFIG_TABLE,
							codegen.Const.BRAIN_MVN_HOME_KEYWORD)) != null) {
						String content = row.getContent();
						File mvnHome = new File(content);
						if (mvnHome.isDirectory()) {
							System.out.println("setMvnHome as " + mvnHome.getAbsolutePath());
							ui.addRowInHtmlEditorPane(
									String.format("setMvnHome with %s execution done", mvnHome.getAbsolutePath()));
						}
					}else{
						ui.addRowInHtmlEditorPane(
								String.format("cannot find %s in config", codegen.Const.BRAIN_MVN_HOME_KEYWORD));
					}
					if ((row = ds.findOneByKeyword(H2JDBCService.CONFIG_TABLE,
							codegen.Const.BRAIN_LAST_PROJECT_KEYWORD)) != null) {
						String content = row.getContent();
						File pomFile = new File(content);
						if (pomFile.isFile()) {
							System.out.println("last project is " + pomFile.getAbsolutePath());
							es.loadProjDepependcies(pomFile);
							ui.addRowInHtmlEditorPane(
									String.format("loaded last project  %s dependencies execution done", pomFile.getAbsolutePath()));
						}
					}else{
						ui.addRowInHtmlEditorPane(String.format("cannot find %s in config table", codegen.Const.BRAIN_LAST_PROJECT_KEYWORD));
					}
					if ((row = ds.findOneByKeyword(H2JDBCService.CONFIG_TABLE,
							codegen.Const.BRAIN_CG_KEY_APP_KEYWORD)) != null) {
						String content = row.getContent();
						File file = new File(content);
						if (file.isFile()) {
							CodeGenContext.getInstance().setCGKeyAppPath(file.getAbsolutePath());
							ui.addRowInHtmlEditorPane(
									String.format("find cg key app path is  %s, execution done", file.getAbsolutePath()));
						}
					}else{
						ui.addRowInHtmlEditorPane(String.format("cannot find %s in config table", codegen.Const.BRAIN_CG_KEY_APP_KEYWORD));
					}
					if ((row = ds.findOneByKeyword(H2JDBCService.CONFIG_TABLE,
							codegen.Const.BRAIN_IDE_PROC_KEYWORD)) != null) {
						String content = row.getContent();
						if (!StringUtils.isBlank(content)) {
							CodeGenContext.setIDEProcNameKeyword(content);
							ui.addRowInHtmlEditorPane(
									String.format("IDE proc keyword is  %s, execution done", CodeGenContext.getIDEProcNameKeyword()));
						}
					}else{
						ui.addRowInHtmlEditorPane(String.format("cannot find %s in config table", codegen.Const.BRAIN_IDE_PROC_KEYWORD));
					}
				} catch (Exception e) {
					e.printStackTrace();
				}
			}
		}
	}
	public void clearFilterKeyword() {
		model.resetMs(EclipseService.class, H2JDBCService.class);
	}
	public void onSelectionChanged(String selectedItem) {
		if ("".equals(selectedItem)) {
			return;
		}
		model.setSelectedItem(selectedItem);
		this.callUIShow();
	}
	public static List<UIMemoryItemKey> convertMemoryItemKey(List<MemoryItemKey> memoryItemKeyList) {
		List<UIMemoryItemKey> uiMemoryItemKeyList = memoryItemKeyList.stream().map(e -> {
			return new UIMemoryItemKey(e);
		}).collect(Collectors.toList());
		return uiMemoryItemKeyList;
	}
	public void beforeCallUIShow() {
		Method m = model.getSelectedMethod();
		if (m != null) {
			if ("memorizeInTable".equalsIgnoreCase(m.getName())) {
                try {
                    List<String> areas = CodeGenContext.getInstance().getMemoryAreas();
                    Object[] areasArray= areas.toArray(new Object[areas.size()]);
                    model.setParamPossibleVals(areasArray);
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }else if ("showMemory".equalsIgnoreCase(m.getName())) {
                try {
                    CodeGenContext.getInstance().getParamPossibleValsMap().putIfAbsent(Const.MEMORY_AREA_KEY, CodeGenContext.getInstance().getMemoryAreas());
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }else {
			}
		}
	}
	public void callUIShow() {
		beforeCallUIShow();
		ui.show(model);
		afterCallUIShow(model);
	}
	public void afterCallUIShow(DataModel model2) {
		Method m = model.getSelectedMethod();
		if (m == null) {
			return;
		}
		TablePane tablepane = ui.getTablePane();
		List<SubmitBtnPane> submitPanes = this.getSubmitPane(tablepane);
		for (SubmitBtnPane pane : submitPanes) {
			JButton jbt = pane.getSubmitBtn();
			jbt.addKeyListener(new KeyAdapter() {
				public void keyReleased(KeyEvent e) {
					if (e.getKeyChar() == KeyEvent.VK_ENTER) {
						clickSubmitBtn();
					}
				}
			});
			jbt.addMouseListener(new MouseAdapter() {
				@Override
				public void mouseReleased(MouseEvent e) {
					clickSubmitBtn();
				}
			});
		}
		if (null != m && "genFieldDeclare".equalsIgnoreCase(m.getName())) {
			List<ClassCombBox> ccs = this.getChildComponent(tablepane, ClassCombBox.class);
			List<JTextField> jcs = this.getChildComponent(tablepane, JTextField.class);
			ClassCombBox clzCombBox = null;
			JTextField fieldNameComp = null;
			for (JTextField jc : jcs) {
				if ("fieldName".equalsIgnoreCase(jc.getName())) {
					fieldNameComp = jc;
					break;
				}
			}
			for (ClassCombBox cc : ccs) {
				if ("c".equalsIgnoreCase(cc.getName())) {
					clzCombBox = cc;
					break;
				}
			}
			if (null != clzCombBox && null != fieldNameComp) {
				final ClassCombBox fclzCombBox = clzCombBox;
				final JTextField ffieldName = fieldNameComp;
				fclzCombBox.addActionListener(l -> {
					String clzSelected = fclzCombBox.getSelectedItem().toString();
					QualifierName qn = model.extractQualifierName(clzSelected);
					if (null != qn.getClz()) {
						ffieldName.setText(Common.getInstanceName(qn.getClz()));
					}
				});
			}
		}
		List<GenAnnotationPane> genAnnPaneList = this.getChildComponent(tablepane, GenAnnotationPane.class);
		List<GenCodePane> genCodePaneList = this.getChildComponent(tablepane, GenCodePane.class);
		List<FilterCombBoxPane> filterCombboxList = this.getChildComponent(tablepane, FilterCombBoxPane.class);
		List<MemoryPane> memoryPaneList = this.getChildComponent(tablepane, MemoryPane.class);
		boolean isGenAnnPane = genAnnPaneList.size() > 0;
		boolean isGenCodePane = genCodePaneList.size() > 0;
		boolean isMemoryPane = memoryPaneList.size() > 0;
		if (isMemoryPane) {
			for (MemoryPane mp : memoryPaneList) {
			    ClassCombBox tableCcb = (ClassCombBox) mp.getTableCombBoxPane().getInputComponent();
			    tableCcb.addItemListener(l -> {
                    try {
                        String table = (String) tableCcb.getSelectedItem();
                        ClassCombBox keywordCombbox = (ClassCombBox) mp.getKeywordsCombBoxPane().getInputComponent();
                        List<UIMemoryItemKey> keywordsList;
                        if(ds.getTableKeywordsMapping().containsKey(table)) {
                            keywordsList = convertMemoryItemKey(ds.getTableKeywordsMapping().get(table));
                        }else {
                            keywordsList = new ArrayList<>();
                        }
                        keywordCombbox.resetArray(new ArrayList<>());
                        keywordCombbox.removeAllItems();
                        keywordCombbox.addCustomItem(keywordsList.toArray());
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                });
			    ClassCombBox keywordsCombbox = (ClassCombBox) mp.getKeywordsCombBoxPane().getInputComponent();
                final UIMemoryItemKey keywordsCombKey = (UIMemoryItemKey) keywordsCombbox.getSelectedItem();
                if(keywordsCombKey!=null) {
					try {
						MemoryItem item = this.ds.findById(keywordsCombKey.getTable(), keywordsCombKey.getId());
						if (null != item) {
							mp.getContentArea().setText(item.getContent());
							mp.getNewKeyWords().setText(keywordsCombKey.getKeywords());
						}
					} catch (Exception e) {
						e.printStackTrace();
					}
				}
                keywordsCombbox.addItemListener(l -> {
                    try {
                    	Object obj = keywordsCombbox.getSelectedItem();
                    	if(obj!=null && UIMemoryItemKey.class.isAssignableFrom(obj.getClass())) {
							UIMemoryItemKey key = (UIMemoryItemKey) obj;
							if (null != key) {
								MemoryItem item = this.ds.findById(key.getTable(), key.getId());
								if (null != item) {
									mp.getContentArea().setText(item.getContent());
									mp.getNewKeyWords().setText(key.getKeywords());
								}
							}
						}
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                });
                mp.getUpdateJButton().addActionListener(l -> {
                    try {
                        UIMemoryItemKey key = (UIMemoryItemKey) keywordsCombbox.getSelectedItem();
						if (null != key) {
							int i = ds.updateById(key.getTable(), key.getId(), mp.getNewKeyWords().getText(),
									mp.getContentArea().getText());
							if (i > 0) {
								ui.addRowInHtmlEditorPane(String.format("update keywords %s done", mp.getNewKeyWords().getText()));
							}else{
								ui.addRowInHtmlEditorPane(String.format("update keywords %s failed", mp.getNewKeyWords().getText()));
							}
						}
                    } catch (Exception e) {
                        e.printStackTrace();
                        ui.addRowInHtmlEditorPane(String.format("update keywords %s failed due to %s", mp.getNewKeyWords().getText(), e.getMessage()));
                    }
                });
                mp.getDeleteJButton().addActionListener(l -> {
                    UIMemoryItemKey key = (UIMemoryItemKey) keywordsCombbox.getSelectedItem();
					if (null != key) {
						try {
							int i = ds.removeById(key.getTable(), key.getId());
							if (i > 0) {
								ui.addRowInHtmlEditorPane(String.format("keywords %s deletion done", key.getKeywords()));
							} else {
								ui.addRowInHtmlEditorPane(String.format("keywords %s deletion failed", key.getKeywords()));
							}
						} catch (Exception e) {
							e.printStackTrace();
							ui.addRowInHtmlEditorPane(String.format("delete keywords %s failed due to %s", key.getKeywords(), e.getMessage()));
						}
					}
                });
                mp.getDumpJButton().addActionListener(l -> {
                    switch2IDEAndPaste(mp.getContentArea().getText());
                });
			}
		}
		if (!isGenAnnPane && !isGenCodePane) {
			List<JTextField> JTextFieldList = this.getChildComponent(tablepane, JTextField.class);
			if (JTextFieldList.size() > 0) {
				for (JTextField jc : JTextFieldList) {
					jc.addKeyListener(new KeyAdapter() {
						public void keyReleased(KeyEvent e) {
							if (e.getKeyChar() == KeyEvent.VK_ENTER) {
								clickSubmitBtn();
							}
						}
					});
				}
			}
		}
		if (genAnnPaneList.size() > 0) {
			GenAnnotationPane annPane = genAnnPaneList.get(0);
			annPane.getClassCombBox().addActionListener(l -> {
				String clzSelected = annPane.getClassCombBox().getSelectedItem().toString();
				QualifierName qn = model.extractQualifierName(clzSelected);
				if (null != qn.getClz()) {
					model.setSelectedClz(qn.getClz());
					Class<?> c = qn.getClz();
					if (!c.isAnnotation()) {
						return;
					}
					annPane.getTablePane().cleanModelData();
					Method[] ms = c.getDeclaredMethods();
					annPane.getTablePane().newRow();
					for (Method method : ms) {
						JTextField jTextField = new JTextField(5);
						jTextField.setName(method.getName());
						JLabel jLabel = new JLabel(method.getName());
						annPane.getTablePane().addComponent(jLabel, jTextField);
						annPane.getTablePane().newRow();
					}
					annPane.getTablePane().showData();
					annPane.getTablePane().updateUI();
				}
			});
			annPane.getjButton().addActionListener(l -> {
				List<JTextField> allInputs = this.getChildComponent(tablepane, JTextField.class);
				Map<String, String> map = allInputs.stream()
						.collect(Collectors.toMap(e -> e.getName(), e -> e.getText(), (e1, e2) -> {
							return e1;
						}));
				Class<?> c = model.getSelectedClz();
				Method[] ms = c.getDeclaredMethods();
				StringBuilder sb = new StringBuilder();
				sb.append("@").append(c.getSimpleName());
				StringBuilder valsb = new StringBuilder();
				for (Method method : ms) {
					boolean b = map.containsKey(method.getName());
					if (b) {
						Class rt = method.getReturnType();
						String str = getAnnotationMethodReturnTypeVal(rt, map.get(method.getName()));
						if(!Objects.isNull(str) && !str.isEmpty() && !"\"\"".equals(str)){
							valsb.append(method.getName()).append("=").append(str).append(", ");
						}
					}
				}
				if (valsb.length() > 0) {
					sb.append("(");
					valsb.delete(valsb.length() - 2, valsb.length());
					sb.append(valsb.toString());
					sb.append(")");
				}
				switch2IDEAndPaste(sb.toString());
			});
		} else if (genCodePaneList.size() > 0) {
			Map<java.lang.Class, String> types = new HashMap<>();
			for (GenCodePane gcp : genCodePaneList) {
				gcp.getClassCombBox().addActionListener(l -> {
					String clzSelected = gcp.getClassCombBox().getSelectedItem().toString();
					QualifierName qn = model.extractQualifierName(clzSelected);
					if (null != qn.getClz()) {
						model.setSelectedClz(qn.getClz());
						try {
							String[] mstrs = Common.getAllMethodsAndConstructorStr(qn.getClz());
							gcp.getMethodCombBox().resetArray(new ArrayList<>());
							gcp.getMethodCombBox().removeAllItems();
							gcp.getMethodCombBox().addCustomItem(mstrs);
						} catch (Exception e) {
							e.printStackTrace();
						}
					}
				});
				gcp.getGen().addActionListener(l -> {
					String methodSelected = gcp.getMethodCombBox().getSelectedItem().toString().trim();
					if (!"".equals(methodSelected)) {
						Class<?> clz = model.getSelectedClz();
						for (Constructor ct : clz.getConstructors()) {
							if (methodSelected.equalsIgnoreCase(ct.toGenericString())) {
								try {
									String codeLine = es.genConstructorStr(clz, ct, types);
									gcp.getCodeLine().requestFocus();
									boolean b = false;
									do {
										try {
											ClipBoard.setStringUtilSuccess(codeLine);
											b = true;
										} catch (Exception e) {
										}
									} while (!b);
									es.getkRobot().paste();
								} catch (Exception e) {
									e.printStackTrace();
								}
							}
						}
						;
						Optional<Method> smP = Common.getAllMethodList(clz).stream()
								.filter(e -> e.toGenericString().equalsIgnoreCase(methodSelected)).findFirst();
						if (smP.isPresent()) {
							Method sm = smP.get();
							boolean omitReturn = gcp.getOmitReturn().isSelected();
							try {
								String codeLine = es.genCallInstanceMethodStr1(clz, null, sm, omitReturn, types);
								gcp.getCodeLine().requestFocus();
								boolean b = false;
								do {
									try {
										ClipBoard.setStringUtilSuccess(codeLine);
										b = true;
									} catch (Exception e) {
									}
								} while (!b);
								es.getkRobot().paste();
							} catch (Exception e) {
								e.printStackTrace();
							}
						}
					}
				});
				gcp.getDump().addActionListener(l -> {
					if ("".equals(gcp.getCodeLine().getText())) {
						return;
					}
					if (switch2IDEAndPaste(gcp.getCodeLine().getText())) {
						gcp.getCodeLine().setText("");
						types.clear();
					}
				});
			}
		} else {
		}
	}
	private boolean switch2IDEAndPaste(String content) {
		boolean b = false;
		try {
			es.switchProcess();
		} catch (Exception e) {
			e.printStackTrace();
		}
		do {
			try {
				ClipBoard.setStringUtilSuccess(content);
				b = true;
			} catch (Exception e) {
			}
		} while (!b);
		try {
			b =es.paste();
		} catch (IOException e) {
			e.printStackTrace();
		}
		return b;
	}
	private String getAnnotationMethodReturnTypeVal(Class rt, String val) {
		if (rt.equals(String.class)) {
			return "\"" + val + "\"";
		} else {
			return val;
		}
	}
	public void switchProcess() throws Exception {
		es.switchProcess();
	}
	public void reload() throws Exception {
		es.reloadAll();
		ui.addRowInHtmlEditorPane("reload execution done");
	}
	public Object callServiceMethod() throws Exception {
		Method m = this.model.getSelectedMethod();
		Class rt = m.getReturnType();
		boolean isReturnStr = false;
		if (rt.isAssignableFrom(String.class)) {
			isReturnStr = true;
		}
		Class c = m.getDeclaringClass();
		Exception expThrown = null;
		Object object = null;
		if (c.isAssignableFrom(EclipseService.class)) {
			object = es;
		} else if (c.isAssignableFrom(H2JDBCService.class)) {
			object = ds;
		} else {
			try {
				object = c.newInstance();
			} catch (InstantiationException e) {
				e.printStackTrace();
				expThrown = e;
			} catch (IllegalAccessException e) {
				e.printStackTrace();
				expThrown = e;
			}
		}
		Object serviceMethodReturnObj = null;
		if (object != null) {
			String name = m.getName();
			String methodDesc = getMethodDesc(m);
			try {
				if (name.startsWith("gen")) {
					serviceMethodReturnObj = m.invoke(object, this.model.getParams());
					if (!Common.isVoid(m)) {
						es.switchProcess();
						Matcher matcher = p.matcher(name);
						if (matcher.find()) {
							String matchStr = matcher.group();
							if (NEW_METHOD_MATCH_WORD.equalsIgnoreCase(matchStr)) {
							} else if (NEW_FIELD_MATCH_WORD.equalsIgnoreCase(matchStr)) {
							}
						}
					}
				} else {
					System.out.println("switch eclipse begin at " + System.currentTimeMillis());
					es.switchProcess();
					System.out.println("switch eclipse done at " + System.currentTimeMillis());
					serviceMethodReturnObj = m.invoke(object, this.model.getParams());
					System.out.println("invoke method done at " + System.currentTimeMillis());
				}
				if (m.getName().equalsIgnoreCase("attacheServiceClz")) {
					this.model.resetMs(EclipseService.class, DatabaseService.class);
					ui.refeedFilterCombBox();
				}
			} catch (Exception e) {
				e.printStackTrace();
				expThrown = e;
				String msg = null;
				if (e.getCause() != null && e.getCause().getMessage() != null
						&& !"null".equals(e.getCause().getMessage())) {
					msg = e.getCause().getMessage();
					ui.addRowInHtmlEditorPane(String.format("error when %s due to %s", methodDesc, msg));
				} else {
					ui.addRowInHtmlEditorPane(String.format("error when %s", methodDesc));
				}
			}
		} else {
			System.out.println(String.format("cannot get obj for Class %s", c.getCanonicalName()));
		}
		if (null != expThrown) {
			throw expThrown;
		}
		return serviceMethodReturnObj;
	}
	private String getMethodDesc(Method m) {
		String methodDesc = null;
		ServiceMethodAnn annotation = m.getAnnotation(ServiceMethodAnn.class);
		if (annotation == null || !annotation.visible()) {
			methodDesc = m.getName();
		} else {
			methodDesc = annotation.keyword()[0];
		}
		return methodDesc;
	}
	public void getAllChildComponents(JComponent container, List<JComponent> list) {
		Component componentArray[] = container.getComponents();
		List<JComponent> childList = Stream.of(componentArray).filter(e -> {
			if (e instanceof JComponent) {
				return true;
			}
			return false;
		}).map(e -> (JComponent) e).collect(Collectors.toList());
		list.addAll(childList);
		for (JComponent jComponent : childList) {
			getAllChildComponents(jComponent, list);
		}
	}
	public <T extends JComponent> List<T> getChildComponent(JComponent container, Class<T> componentType) {
		List<JComponent> list = new ArrayList<>();
		getAllChildComponents(container, list);
		List<T> list2 = list.stream().filter(e -> {
			Class c = e.getClass();
			if (componentType.isAssignableFrom(c)) {
				return true;
			}
			return false;
		}).map(e -> (T) e).collect(Collectors.toList());
		return list2;
	}
	public List<SubmitBtnPane> getSubmitPane(JComponent container) {
		List<SubmitBtnPane> panes = new ArrayList<>();
		List<JComponent> allComponents = this.getChildComponent(container, JComponent.class);
		for (JComponent comp : allComponents) {
			Class c = comp.getClass();
			if (SubmitBtnPane.class.isAssignableFrom(c)) {
				panes.add((SubmitBtnPane) comp);
			}
		}
		return panes;
	}
	public DataModel getModel() {
		return model;
	}
	public void setModel(DataModel model) {
		this.model = model;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\codegen\JavaKeyword.java---
/**
 * 
 */
package codegen;
/**
 * @author Administrator
 *
 */
public enum JavaKeyword {
	FOR("for"),WHILE("while"),GOTO("goto"),DO("do"),PUBLIC("public"),PRIVATE("private"),PROTECTED("protected"),STATIC("static"),FINAL("final"),SYNCHRONIZED("synchronized"),CLASS("class"),INT("int"),LONG("long"),BOOLEAN("boolean"),DOUBLE("double"),FLOAT("float"),NULL("null"),INSTANCEOF("instanceof"),IF("if"),ELSE("else"),ENUM("enum"),INTERFACE("interface");
	String value;
	private JavaKeyword(String value){
		this.value = value;
	}
	public String getValue() {
		return value;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\codegen\MethodCallParamVariableCode.java---
package codegen;
public class MethodCallParamVariableCode {
	String paramVariableDeclareWithDefaultVal;
	String[] paramvariables;
	public String getParamVariableDeclareWithDefaultVal() {
		return paramVariableDeclareWithDefaultVal;
	}
	public void setParamVariableDeclareWithDefaultVal(String paramVariableDeclareWithDefaultVal) {
		this.paramVariableDeclareWithDefaultVal = paramVariableDeclareWithDefaultVal;
	}
	public String[] getParamvariables() {
		return paramvariables;
	}
	public void setParamvariables(String[] paramvariables) {
		this.paramvariables = paramvariables;
	}
	public MethodCallParamVariableCode(String paramVariableDeclareWithDefaultVal, String[] paramvariables) {
		super();
		this.paramVariableDeclareWithDefaultVal = paramVariableDeclareWithDefaultVal;
		this.paramvariables = paramvariables;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\codegen\MethodMatcher.java---
package codegen;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.List;
public class MethodMatcher {
	private Class c;
	private String methodName;
	private Class classParams[];
	private List<MethodMatcher> miList = new ArrayList<>();
	public MethodMatcher(Class c) {
		super();
		this.c = c;
	}
	public MethodMatcher add(String methodName, Class... cp) {
		MethodMatcher mi = new MethodMatcher(c);
		mi.setMethodName(methodName);
		mi.setClassParams(cp);
		miList.add(mi);
		return this;
	}
	public String getMethodName() {
		return methodName;
	}
	public void setMethodName(String methodName) {
		this.methodName = methodName;
	}
	public Class getC() {
		return c;
	}
	public Class[] getClassParams() {
		return classParams;
	}
	public void setClassParams(Class[] classParams) {
		this.classParams = classParams;
	}
	public List<MethodMatcher> getMiList() {
		return miList;
	}
	public void setMiList(List<MethodMatcher> miList) {
		this.miList = miList;
	}
	public boolean match(Method m) {
		Class mC = m.getDeclaringClass();
		boolean b = false;
		if (!mC.equals(this.c)) {
			return b;
		}
		Class mp[] = m.getParameterTypes();
		if (m.getName().equals(this.methodName)) {
			if (m.getParameterCount() == 0 && (this.classParams == null || this.classParams.length == 0)) {
				return true;
			}
			if (m.getParameterCount() > 0) {
				if (this.classParams != null && this.classParams.length == mp.length) {
					for (int i = 0; i < mp.length; i++) {
						if (!mp[i].equals(this.classParams[i])) {
							i = mp.length;
						} else if (i == mp.length - 1) {
							b = true;
						}
					}
				}
			}
		}
		return b;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\codegen\Replacement.java---
package codegen;
public enum Replacement {
	PACKAGE_NAME, CLASS_NAME, INSTANCE_NAME, SEPERATOR, GENERIC_TYPE_NAME, GENERIC_TYPE_KEY, GENERIC_TYPE_VAL,
	ABSTRACT_CLASS_NAME, ABSTRACT_INSTANCE_NAME, TMP_CLASS_NAME, TMP_INSTANCE_NAME, TMP_INSTANCE_VALUE, ITEM_NAME,
	TARGET_CLASS_NAME, TARGET_INSTANCE_NAME, INIT_CLASS_WITH_DEFAULT_VALUE, DEFAULT_VALUE,
	ASSIGN_SYMBOL, NEW_LINE, END_OF_LINE, CLASS_END_LINE, FIELD_CLASS_NAME, FIELD_INSTANCE_NAME, FIELD_VALUE, QUALIFIER,
	METHOD_NAME, METHOD_RETURN_TYPE, METHOD_PARAMS, METHOD_PARAMS_VARIABLE, MATCH_PARAMS_VARIABLE,
	PRIVILEDGE_MODIFIER, STATIC_MODIFIER, ABSTRACT_MODIFIER, FINAL_MODIFIER, VOLATILE_MODIFIER, SYNC_MODIFIER, METHOD_PARAMS_DECLARE,
	METHOD_BODY, METHOD_RETURN_VALUE,
	LAMBDA_PARAMS_VARIABLE,
	THROWS_EXCEPTION, TRY_BODY, EXCEPTIONS_DECLARE, EXCEPTION_NAME, EXCEPTION_INSTANCE_NAME, CATCH_BODY, FINALLY_BODY,
	ANY_MATCH, RETURN_TYPE, RETURN_TYPE_INSTANCE,
	ASSERT_NOT_NULL, EXPECT_VALUE, ACTUAL_VALUE,
	EXCEPTION_CLASS, PREFIX_STR, IF_EXPRESSION, ELSE_BLOCK, IF_BODY, ELSE_BODY,
	BLOCK_BODY,
	CORE_POOL_SIZE, MAX_POOL_SIZE, NEW_THREAD_FACTORY,
	PATH, METHOD_STR, HEADERS, CONSUMERS, PRODUCES, RESPONSE_BODY,
	TAG_NAME,ID,LINK,TARGET, REQUEST_METHOD, 
	GROUP_ID, ARTIFACTOR_ID, VERSION, SCOPE,
}
----strat of file D:\projects\cg\cg-min\src\main\java\codegen\robot\KeyboardRobot.java---
package codegen.robot;
import java.awt.*;
import java.awt.event.KeyEvent;
import java.io.IOException;
public class KeyboardRobot {
	public static short asciiKeyEventCodeMapping[][][] = new short[][][] { { { 0, 0, 0 }, { 1, 0, 0 }, { 2, 0, 0 },
			{ 3, 0, 0 }, { 4, 0, 0 }, { 5, 0, 0 }, { 6, 0, 0 }, { 7, 0, 0 }, { 8, KeyEvent.VK_BACK_SPACE, 0 },
			{ 9, 0, 0 }, { 10, KeyEvent.VK_ENTER, 0 }, { 11, 0, 0 }, { 12, 0, 0 }, { 13, KeyEvent.VK_ENTER, 0 },
			{ 14, 0, 0 }, { 15, 0, 0 }, { 16, 0, 0 }, { 17, 0, 0 }, { 18, 0, 0 }, { 19, 0, 0 }, { 20, 0, 0 },
			{ 21, 0, 0 }, { 22, 0, 0 }, { 23, 0, 0 }, { 24, 0, 0 }, { 25, 0, 0 }, { 26, 0, 0 }, { 27, 0, 0 },
			{ 28, 0, 0 }, { 29, 0, 0 }, { 30, 0, 0 }, { 31, 0, 0 }, { 32, KeyEvent.VK_SPACE, 0 },
			{ 33, KeyEvent.VK_1, 1 }, { 34, KeyEvent.VK_QUOTE, 1 }, { 35, KeyEvent.VK_3, 1 }, { 36, KeyEvent.VK_4, 1 },
			{ 37, KeyEvent.VK_5, 1 }, { 38, KeyEvent.VK_7, 1 }, { 39, KeyEvent.VK_QUOTE, 0 }, { 40, KeyEvent.VK_9, 1 },
			{ 41, KeyEvent.VK_0, 1 }, { 42, KeyEvent.VK_8, 1 }, { 43, KeyEvent.VK_EQUALS, 1 },
			{ 44, KeyEvent.VK_COMMA, 0 }, { 45, KeyEvent.VK_MINUS, 0 }, { 46, KeyEvent.VK_PERIOD, 0 },
			{ 47, KeyEvent.VK_SLASH, 0 }, { 48, KeyEvent.VK_0, 0 }, { 49, KeyEvent.VK_1, 0 }, { 50, KeyEvent.VK_2, 0 },
			{ 51, KeyEvent.VK_3, 0 }, { 52, KeyEvent.VK_4, 0 }, { 53, KeyEvent.VK_5, 0 }, { 54, KeyEvent.VK_6, 0 },
			{ 55, KeyEvent.VK_7, 0 }, { 56, KeyEvent.VK_8, 0 }, { 57, KeyEvent.VK_9, 0 },
			{ 58, KeyEvent.VK_SEMICOLON, 1 }, { 59, KeyEvent.VK_SEMICOLON, 0 }, { 60, KeyEvent.VK_COMMA, 1 },
			{ 61, KeyEvent.VK_EQUALS, 0 }, { 62, KeyEvent.VK_PERIOD, 1 }, { 63, KeyEvent.VK_SLASH, 1 },
			{ 64, KeyEvent.VK_2, 1 }, { 65, KeyEvent.VK_A, 1 }, { 66, KeyEvent.VK_B, 1 }, { 67, KeyEvent.VK_C, 1 },
			{ 68, KeyEvent.VK_D, 1 }, { 69, KeyEvent.VK_E, 1 }, { 70, KeyEvent.VK_F, 1 }, { 71, KeyEvent.VK_G, 1 },
			{ 72, KeyEvent.VK_H, 1 }, { 73, KeyEvent.VK_I, 1 }, { 74, KeyEvent.VK_J, 1 }, { 75, KeyEvent.VK_K, 1 },
			{ 76, KeyEvent.VK_L, 1 }, { 77, KeyEvent.VK_M, 1 }, { 78, KeyEvent.VK_N, 1 }, { 79, KeyEvent.VK_O, 1 },
			{ 80, KeyEvent.VK_P, 1 }, { 81, KeyEvent.VK_Q, 1 }, { 82, KeyEvent.VK_R, 1 }, { 83, KeyEvent.VK_S, 1 },
			{ 84, KeyEvent.VK_T, 1 }, { 85, KeyEvent.VK_U, 1 }, { 86, KeyEvent.VK_V, 1 }, { 87, KeyEvent.VK_W, 1 },
			{ 88, KeyEvent.VK_X, 1 }, { 89, KeyEvent.VK_Y, 1 }, { 90, KeyEvent.VK_Z, 1 },
			{ 91, KeyEvent.VK_OPEN_BRACKET, 0 }, { 92, KeyEvent.VK_BACK_SLASH, 0 },
			{ 93, KeyEvent.VK_CLOSE_BRACKET, 0 }, { 94, KeyEvent.VK_6, 1 }, { 95, KeyEvent.VK_MINUS, 1 },
			{ 96, KeyEvent.VK_BACK_QUOTE, 0 }, { 97, KeyEvent.VK_A, 0 }, { 98, KeyEvent.VK_B, 0 },
			{ 99, KeyEvent.VK_C, 0 }, { 100, KeyEvent.VK_D, 0 }, { 101, KeyEvent.VK_E, 0 }, { 102, KeyEvent.VK_F, 0 },
			{ 103, KeyEvent.VK_G, 0 }, { 104, KeyEvent.VK_H, 0 }, { 105, KeyEvent.VK_I, 0 }, { 106, KeyEvent.VK_J, 0 },
			{ 107, KeyEvent.VK_K, 0 }, { 108, KeyEvent.VK_L, 0 }, { 109, KeyEvent.VK_M, 0 }, { 110, KeyEvent.VK_N, 0 },
			{ 111, KeyEvent.VK_O, 0 }, { 112, KeyEvent.VK_P, 0 }, { 113, KeyEvent.VK_Q, 0 }, { 114, KeyEvent.VK_R, 0 },
			{ 115, KeyEvent.VK_S, 0 }, { 116, KeyEvent.VK_T, 0 }, { 117, KeyEvent.VK_U, 0 }, { 118, KeyEvent.VK_V, 0 },
			{ 119, KeyEvent.VK_W, 0 }, { 120, KeyEvent.VK_X, 0 }, { 121, KeyEvent.VK_Y, 0 }, { 122, KeyEvent.VK_Z, 0 },
			{ 123, KeyEvent.VK_OPEN_BRACKET, 1 }, { 124, KeyEvent.VK_BACK_SLASH, 1 },
			{ 125, KeyEvent.VK_CLOSE_BRACKET, 1 }, { 126, KeyEvent.VK_BACK_QUOTE, 1 },
			{ 127, KeyEvent.VK_DELETE, 0 }, } };
	Robot robot;
	public KeyboardRobot() {
		try {
			robot = new Robot();
		} catch (AWTException e) {
			e.printStackTrace();
		}
	}
	public KeyboardRobot(Robot robot) {
		this.robot = robot;
	}
	public Robot getRobot() {
		return robot;
	}
	public void openApp(String appName) {
		try {
			Runtime.getRuntime().exec(appName);
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
	public void typeLetter(char c) {
		if (Character.isLetter(c)) {
		}
	}
	public void typeStr(String str) {
		char ch[] = str.toCharArray();
		for (char c : ch) {
			typeLetterOrDigit(c);
		}
	}
	/**
	 * enter event may click on UI not in eclipse window
	 */
	public void enter() {
		robot.keyPress(KeyEvent.VK_ENTER);
		robot.keyRelease(KeyEvent.VK_ENTER);
	}
	public void copy() {
		robot.keyPress(KeyEvent.VK_CONTROL);
		robot.keyPress(KeyEvent.VK_C);
		robot.delay(500);
		robot.keyRelease(KeyEvent.VK_CONTROL);
		robot.keyRelease(KeyEvent.VK_C);
	}
	public void paste() {
		robot.keyPress(KeyEvent.VK_CONTROL);
		robot.keyPress(KeyEvent.VK_V);
		robot.delay(500);
		robot.keyRelease(KeyEvent.VK_CONTROL);
		robot.keyRelease(KeyEvent.VK_V);
	}
	public void del() {
		typeLetterOrDigit((char) 127);
	}
	public void typeLetterOrDigit(char c) {
		short keyEventcode = asciiKeyEventCodeMapping[0][c][1];
		short shiftFlag = asciiKeyEventCodeMapping[0][c][2];
		boolean shift = toBoolean(shiftFlag);
		if (shift) {
			robot.keyPress(KeyEvent.VK_SHIFT);
		}
		robot.keyPress(keyEventcode);
		robot.keyRelease(keyEventcode);
		if (shift) {
			robot.keyRelease(KeyEvent.VK_SHIFT);
		}
		if (c == 34 || c == 39 || c == 40) {
			del();
		}
	}
	public void clickKey(int key) {
		robot.keyPress(key);
		robot.keyRelease(key);
	}
	public void pageUp() {
		clickKey(KeyEvent.VK_PAGE_UP);
	}
	public void pageDown() {
		clickKey(KeyEvent.VK_PAGE_DOWN);
	}
	public void home() {
		clickKey(KeyEvent.VK_HOME);
	}
	public void end() {
		clickKey(KeyEvent.VK_END);
	}
	public void arrowUp() {
		this.clickKey(KeyEvent.VK_UP);
	}
	public void arrowUp(int times) {
		for (int i = 0; i < times; i++)
			this.clickKey(KeyEvent.VK_UP);
	}
	public void arrowleft() {
		clickKey(KeyEvent.VK_LEFT);
	}
	public void arrowDown() {
		clickKey(KeyEvent.VK_DOWN);
	}
	public void arrowDown(int times) {
		for (int i = 0; i < times; i++)
			clickKey(KeyEvent.VK_DOWN);
	}
	public void tab() {
		clickKey(KeyEvent.VK_TAB);
	}
	public void space() {
		clickKey(KeyEvent.VK_SPACE);
	}
	public void tab(int times) {
		for (int i = 0; i < times; i++)
			clickKey(KeyEvent.VK_TAB);
	}
	public void backSace() {
		clickKey(KeyEvent.VK_BACK_SPACE);
	}
	public void backSace(int times) {
		for (int i = 0; i < times; i++)
			clickKey(KeyEvent.VK_BACK_SPACE);
	}
	public void altTab() {
		this.clickCompositeKey(KeyEvent.VK_ALT, KeyEvent.VK_TAB);
	}
	public void arrowRight() {
		clickKey(KeyEvent.VK_RIGHT);
	}
	public static boolean toBoolean(int s) {
		boolean b = false;
		b = s <= 0 ? false : true;
		return b;
	}
	public void copyLine() {
		Toolkit.getDefaultToolkit().setLockingKeyState(144, false);
		this.home();
		robot.keyPress(KeyEvent.VK_SHIFT);
		robot.delay(1000);
		this.end();
		robot.delay(1000);
		robot.keyRelease(KeyEvent.VK_SHIFT);
		this.copy();
	}
	public void clickCompositeKey(int... keycodes) {
		for (int k : keycodes) {
			robot.keyPress(k);
		}
		robot.delay(500);
		for (int i = keycodes.length - 1; i >= 0; i--) {
			robot.keyRelease(keycodes[i]);
		}
	}
	public void selectAll() {
		this.clickCompositeKey(KeyEvent.VK_CONTROL, KeyEvent.VK_A);
	}
	public static void main(String[] args) throws AWTException {
		Robot robot = new Robot();
		/*
		 * Dimension d= Toolkit.getDefaultToolkit().getScreenSize(); double width =
		 * d.getWidth(); double height = d.getHeight();
		 * System.out.println(String.format("width = %s, height = %s", width, height));
		 * for(int y = 0; y<height;y++){ for(int x = 0; x<width;x++){ robot.mouseMove(x,
		 * y); System.out.println("x =" +
		 * MouseInfo.getPointerInfo().getLocation().getX() + " Y = " +
		 * MouseInfo.getPointerInfo().getLocation().getY()); } }
		 */
		try {
			Thread.sleep(1500L);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		KeyboardRobot kr = new KeyboardRobot();
		kr.typeStr("pool.setOddsType(\"\");\r\npool.setAllupLevelKey(1);");
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\codegen\robot\MouseRobot.java---
package codegen.robot;
import java.awt.*;
import java.awt.event.InputEvent;
import java.awt.image.BufferedImage;
public class MouseRobot {
	Robot robot;
	public MouseRobot() {
		try {
			robot = new Robot();
		} catch (AWTException e) {
			e.printStackTrace();
		}
	}
	public MouseRobot(Robot robot) {
		this.robot = robot;
	}
	public Robot getRobot() {
		return robot;
	}
	public void delay(int ms) {
		robot.delay(ms);
	}
	public void mouseMove(int x, int y) {
		robot.mouseMove(x, y);
	}
	public void mouseMoveDown(int y) {
		int x = (int) MouseInfo.getPointerInfo().getLocation().getX();
		this.mouseMove(x, y);
	}
	public void moveRight(int offsetX) {
		int x = (int) MouseInfo.getPointerInfo().getLocation().getX();
		int y = (int) MouseInfo.getPointerInfo().getLocation().getY();
		x = x + offsetX;
		this.mouseMove(x, y);
	}
	public void mouseClickThreeTimes(int x, int y) {
		mouseClick(x, y);
		mouseClick(x, y);
		mouseClick(x, y);
	}
	public void mouseDoubleClick(int x, int y) {
		mouseClick(x, y);
		mouseClick(x, y);
	}
	public void mouseDoubleClick() {
		mouseClick();
		mouseClick();
	}
	public void mousePress() {
		robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);
	}
	public void mouseRelease() {
		robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);
	}
	public void dragTo(int offsetX) {
		this.mousePress();
		int x = (int) MouseInfo.getPointerInfo().getLocation().getX();
		int y = (int) MouseInfo.getPointerInfo().getLocation().getY();
		x = x + offsetX;
		this.mouseMove(x, y);
		this.mouseRelease();
	}
	@Deprecated
	/**
	 * mouse click event may click on UI not in eclipse window
	 */
	public void mouseClick() {
		robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);
		robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);
	}
	public void mouseClick(int x, int y) {
		robot.mouseMove(x, y);
		robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);
		robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);
	}
	public void mouseRightClick(int x, int y) {
		robot.mouseMove(x, y);
		robot.mousePress(InputEvent.BUTTON3_DOWN_MASK);
		robot.mouseRelease(InputEvent.BUTTON3_DOWN_MASK);
	}
	public void clickBtnByRsName(String rsName) throws Exception {
		try {
			BufferedImage image = Resource.getBufferedImageByRsName(rsName);
			clickBtn(image);
		} catch (Exception e) {
			throw new Exception(String.format("failed click with the specified rs name %s", rsName), e);
		}
	}
	public void clickBtn(BufferedImage btnImg) throws Exception {
		Dimension d = Toolkit.getDefaultToolkit().getScreenSize();
		double width = d.getWidth();
		double height = d.getHeight();
		Rectangle rect = new Rectangle((int) width, (int) height);
		BufferedImage img = robot.createScreenCapture(rect);
		PixelMatchResult mr = seek(btnImg, img);
		if (mr != null) {
			this.mouseClick(mr.getCenterPixel().getX(), mr.getCenterPixel().getY());
		} else {
			throw new Exception("cannot find the specified image on screen");
		}
	}
	public int[][] getPixels(BufferedImage img) {
		int w = img.getWidth();
		int h = img.getHeight();
		int[][] ps = new int[w][h];
		for (int i = 0; i < w; i++) {
			for (int j = 0; j < h; j++) {
				int pixel = img.getRGB(i, j);
				ps[i][j] = pixel;
			}
		}
		return ps;
	}
	public PixelMatchResult trySeek(int[][] rsPixels, int offsetX, int offsetY, BufferedImage screenCapture) {
		PixelMatchResult mr = null;
		int w = screenCapture.getWidth();
		int h = screenCapture.getHeight();
		int rw = rsPixels.length;
		int rh = rsPixels[0].length;
		int totalPixelMatched = 0;
		for (int j = 0; j < rh; j++) {
			for (int i = 0; i < rw; i++) {
				int rsPixel = rsPixels[i][j];
				int x = i + offsetX;
				int y = j + offsetY;
				if (x >= w || y >= h) {
					return null;
				}
				int pixel = screenCapture.getRGB(x, y);
				if (pixel == rsPixel) {
					totalPixelMatched++;
				} else {
					return null;
				}
			}
		}
		if (totalPixelMatched == rw * rh) {
			mr = new PixelMatchResult();
			int centerPixelX = rw / 2 + offsetX;
			int centerPixelY = rh / 2 + offsetY;
			Pixel p = new Pixel(centerPixelX, centerPixelY);
			mr.setCenterPixel(p);
			Pixel startPixel = new Pixel(offsetX, offsetY);
			mr.setStartPixel(startPixel);
			mr.setMatch(true);
		}
		return mr;
	}
	public PixelMatchResult seek(BufferedImage rsImg, BufferedImage screenCapture) {
		PixelMatchResult mr = null;
		int offsetX = 0;
		int offsetY = 0;
		int w = screenCapture.getWidth();
		int h = screenCapture.getHeight();
		int rsPs[][] = getPixels(rsImg);
		for (int j = 0; j < h; j++) {
			for (int i = 0; i < w; i++) {
				int pixel = screenCapture.getRGB(i, j);
				/*
				 * if(totalPixelMatched >0){ int x = i - offsetX; int y = j - offsetY; if(pixel
				 * == rsPs[x][y]){ totalPixelMatched++; if(totalPixelMatched == totalRsPixels){
				 * //matched mr = new PixelMatchResult(); int centerPixelX = rsImg.getWidth()/2
				 * + offsetX; int centerPixelY = rsImg.getHeight()/2 + offsetY; Pixel p = new
				 * Pixel(centerPixelX, centerPixelY); mr.setCenterPixel(p); mr.setMatch(true);
				 * return mr; } }else{ totalPixelMatched = 0; offsetX = 0; offsetY = 0; } }
				 */
				if (pixel == rsPs[0][0]) {
					offsetX = i;
					offsetY = j;
					mr = trySeek(rsPs, offsetX, offsetY, screenCapture);
					if (mr != null) {
						return mr;
					}
				}
			}
		}
		return mr;
	}
	public void trimImg(BufferedImage img) {
	}
	public void breakAlphaAndRGB(int pixel) {
		long alpha = ((long) pixel & (255L << 24)) >> 24;
		int red = (pixel & (255 << 16)) >> 16;
		int green = (pixel & (255 << 8)) >> 8;
		int blue = pixel & (255);
		System.out.println(String.format("alpha is %s, red is %s, green is %s, blue is %s ", alpha, red, green, blue));
	}
	public static void main(String[] args) {
		MouseRobot mr = new MouseRobot();
		try {
			Thread.sleep(3000);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		for (int i = 0; i <= 999999; i++) {
			mr.mouseClick();
			try {
				Thread.sleep(100);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}
		/*
		 * try { // BufferedImage projImg = Resource.getResource(new //
		 * File("d:\\eclipse packexploer font.png")); BufferedImage javaImg =
		 * Resource.getResource(new File("d:\\servers.png")); int javaImgPx[][] =
		 * mr.getPixels(javaImg); // int projImgPx[][] = mr.getPixels(projImg); //
		 * int firstJavaPx = javaImgPx[0][0]; int[][] ps = mr.getPixels(javaImg); //
		 * int firstProjPx = projImgPx[0][0]; int rw = ps.length; int rh =
		 * ps[0].length; for (int i = 0; i < rw; i++) { for (int j = 0; j < rh; j++) {
		 * System.out.print(String.format("i=%s,j=%s,dec=%s ", i, j, ps[i][j]));
		 * mr.breakAlphaAndRGB(ps[i][j]); } } // mr.breakAlphaAndRGB(firstProjPx); //
		 * mr.seek(javaImg, projImg); } catch (IOException e) { // TODO Auto-generated
		 * catch block e.printStackTrace(); }
		 */
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\codegen\robot\Pixel.java---
package codegen.robot;
public class Pixel {
	private int x;
	private int y;
	private int value;
	public Pixel(int x, int y) {
		super();
		this.x = x;
		this.y = y;
	}
	public int getX() {
		return x;
	}
	public void setX(int x) {
		this.x = x;
	}
	public int getY() {
		return y;
	}
	public void setY(int y) {
		this.y = y;
	}
	public int getValue() {
		return value;
	}
	public void setValue(int value) {
		this.value = value;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\codegen\robot\PixelMatchResult.java---
package codegen.robot;
public class PixelMatchResult {
	Pixel centerPixel;
	Pixel startPixel;
	boolean match;
	double percentage;
	public Pixel getCenterPixel() {
		return centerPixel;
	}
	public void setCenterPixel(Pixel centerPixel) {
		this.centerPixel = centerPixel;
	}
	public Pixel getStartPixel() {
		return startPixel;
	}
	public void setStartPixel(Pixel startPixel) {
		this.startPixel = startPixel;
	}
	public boolean isMatch() {
		return match;
	}
	public void setMatch(boolean match) {
		this.match = match;
	}
	public double getPercentage() {
		return percentage;
	}
	public void setPercentage(double percentage) {
		this.percentage = percentage;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\codegen\robot\Resource.java---
package codegen.robot;
import javax.imageio.ImageIO;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.IOException;
import java.net.URL;
public class Resource {
	public static BufferedImage getResource(File file) throws IOException {
		BufferedImage image = ImageIO.read(file);
		return image;
	}
	public static BufferedImage getResource(URL url) throws IOException {
		BufferedImage image = ImageIO.read(url);
		return image;
	}
	public static BufferedImage getBufferedImageByRsName(String rsName) throws IOException{
		BufferedImage image = null;
	    try{
		URL url = Resource.class.getClassLoader().getResource(rsName);
	    image = getResource(url);
	    } catch(IOException e){
	    	e.printStackTrace();
	    	throw e;
	    }
		return image;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\codegen\robot\Service.java---
package codegen.robot;
import codegen.complexobj.CodeGenContext;
import codegen.unittest.*;
import codegen.util.Common;
import com.dgs.annotation.FileChooserAnnotation;
import com.dgs.annotation.ParamAnno;
import com.dgs.annotation.ServiceMethodAnn;
import java.awt.*;
import java.awt.datatransfer.Clipboard;
import java.awt.image.BufferedImage;
import java.io.*;
import java.net.URL;
import java.nio.charset.Charset;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;
import java.util.stream.Stream;
public class Service {
	UnitTestCodeGeneratorDependOnClass u;
	MockClzFactoryGenerator i;
	private MouseRobot mRobot;
	private KeyboardRobot kRobot;
	public Service() {
		try {
			Robot r = new Robot();
			mRobot = new MouseRobot(r);
			kRobot = new KeyboardRobot(r);
		} catch (AWTException e) {
			e.printStackTrace();
		}
	}
	@ServiceMethodAnn(keyword = "set system property")
	public void addSystemProperty(String propertyName, String propertyValue) {
		System.setProperty(propertyName, propertyValue);
		if (codegen.Const.OUTPUT_SYS_PROPERTY_NAME.equals(propertyName)) {
			File f = new File(propertyValue);
			if (propertyValue != null && f.isFile()) {
				FileOutputStream fileOutputStream;
				try {
					fileOutputStream = new FileOutputStream(f);
					BufferedOutputStream bufferedOutputStream = new BufferedOutputStream(fileOutputStream);
					PrintStream printStream = new PrintStream(bufferedOutputStream, true);
					System.setOut(printStream);
					System.setErr(printStream);
				} catch (FileNotFoundException e) {
					e.printStackTrace();
				}
			}
		}
	}
	@ServiceMethodAnn(keyword = "install maven jar in local repository")
	public String genMvnInstallForJar(@ParamAnno(description = "Jar File") File jarFile, String groupId, String artifactId, String version, String pack) {
		String cmd = String.format("mvn install:install-file -Dfile=%s -DgroupId=%s -DartifactId=%s -Dversion=%s -Dpackaging=%s >deploy.log", 
				jarFile.getAbsolutePath(), groupId, artifactId, version,  pack);
		return cmd;
	}
	@ServiceMethodAnn(keyword = "gen all test classes at same package")
	public void genAllTestClssesByPackage(@ParamAnno(description = "One of Class") Class oneOfClass, 
			@FileChooserAnnotation(chooseDirOnly = true)  @ParamAnno(description = "Target Directory") File targetDirectory) throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		u = new UnitTestCodeGeneratorDependOnClass();
		GenTestParam gtp = new GenTestParam();
		gtp.setTargetDir(targetDirectory.getAbsolutePath());
		u.genAllTestUnderPack(oneOfClass, gtp, context);
		u = null;
	}
	@ServiceMethodAnn(keyword = "gen one class unittest save at target dir")
	public void genOneTestClass(@ParamAnno(description = "Class To Test") Class clzToTest, 
			@FileChooserAnnotation(chooseDirOnly = true) @ParamAnno(description = "Target Directory") File targetDirectory) throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		u = new UnitTestCodeGeneratorDependOnClass();
		GenTestParam gtp = new GenTestParam();
		gtp.setTargetDir(targetDirectory.getAbsolutePath());
		u.genAllTestCasesAndSave(clzToTest, gtp, context);
		u = null;
	}
	@ServiceMethodAnn(keyword = "gen one class unittest source code")
	public String genTestClassSource(@ParamAnno(description = "Class to Test") Class clzToTest) throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		u = new UnitTestCodeGeneratorDependOnClass();
		GenTestParam gtp = new GenTestParam();
		OneTestClassCreateResult otccr = u.genAllTest(clzToTest, gtp, context);
		u = null;
		return otccr.getCode();
	}
	@ServiceMethodAnn(keyword = "gen one class mock class source code")
	public String genMockClassSource(@ParamAnno(description = "Class") Class c) throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		i = new MockClzFactoryGenerator();
		MockClzFactoryCreateResult mcr = i.genMockClassSource(c, context);
		i = null;
		return mcr.getCode();
	}
	@ServiceMethodAnn(keyword = "gen mock class ")
	public void genMock(Class clzToTest, String targetDirectory) throws Exception {
		CodeGenContext context = CodeGenContext.getInstance();
		i = new MockClzFactoryGenerator();
		i.genMock(clzToTest, targetDirectory, context);
		i = null;
	}
	@ServiceMethodAnn(keyword = "gen interface mock class source code at same package")
	public void genAllInterfaceMockUnderPack(Class oneOfClass, String targetDirectory) throws Exception {
		i = new MockClzFactoryGenerator();
		i.genAllInterfaceMockUnderPack(oneOfClass, targetDirectory);
		i = null;
	}
	/*
	 * public void genAllInterfaceMockUnderPack(Package sourcePack, String
	 * targetDirectory) throws Exception { CodeGenContext context =
	 * CodeGenContext.getInstance(); i = new InterfaceMockGenerator();
	 * i.genAllInterfaceMockUnderPack(sourcePack, targetDirectory, context); i =
	 * null; }
	 */
	public void typeStr(String str) {
		kRobot.typeStr(str);
	}
	public void cleanTextField() {
		mRobot.delay(1000);
		mRobot.mouseDoubleClick();
		mRobot.delay(1000);
		kRobot.del();
	}
	public void copy1Line(URL keyboardCursorURL) throws Exception {
		BufferedImage rsImg;
		try {
			rsImg = Resource.getResource(keyboardCursorURL);
			copy1Line(rsImg);
		} catch (IOException e) {
			e.printStackTrace();
			return;
		}
	}
	public void copy1Line(String keyboardCursorRSName) throws Exception {
		BufferedImage rsImg;
		try {
			rsImg = Resource.getBufferedImageByRsName(keyboardCursorRSName);
			copy1Line(rsImg);
		} catch (IOException e) {
			e.printStackTrace();
			return;
		}
	}
	public void copy1Line(BufferedImage rsImg) throws Exception {
		select1LineAndNewLineChar(rsImg);
		this.kRobot.copy();
		Toolkit tk = Toolkit.getDefaultToolkit();
		Clipboard c = tk.getSystemClipboard();
	}
	public void copy1Line() throws Exception {
		selectLine();
		this.kRobot.copy();
	}
	public void selectLine() {
		getkRobot().copyLine();
	}
	public void select1LineAndNewLineChar(BufferedImage rsImg) throws Exception {
		this.getkRobot().home();
		this.getkRobot().home();
		Dimension d = Toolkit.getDefaultToolkit().getScreenSize();
		double width = d.getWidth();
		double height = d.getHeight();
		Rectangle rect = new Rectangle((int) width, (int) height);
		BufferedImage img = this.getkRobot().getRobot().createScreenCapture(rect);
		PixelMatchResult mr = this.getmRobot().seek(rsImg, img);
		if (mr != null) {
			int rsHeight = rsImg.getHeight();
			int x = mr.getStartPixel().getX();
			int y = mr.getStartPixel().getY() + rsHeight / 2;
			this.getmRobot().mouseMove(x, y);
			this.getmRobot().mousePress();
			y = y + rsImg.getHeight();
			this.getmRobot().mouseMove(x, y);
			this.getmRobot().mouseRelease();
		} else {
			throw new Exception();
		}
	}
	public void select1LineAndNewLineChar(String keyboardCursorRSName) throws Exception {
		BufferedImage rsImg;
		try {
			rsImg = Resource.getBufferedImageByRsName(keyboardCursorRSName);
			select1LineAndNewLineChar(rsImg);
		} catch (IOException e) {
			e.printStackTrace();
			return;
		}
	}
	public void select1LineAndNewLineChar(URL keyboardCursorURL) throws Exception {
		BufferedImage rsImg;
		try {
			rsImg = Resource.getResource(keyboardCursorURL);
			select1LineAndNewLineChar(rsImg);
		} catch (IOException e) {
			e.printStackTrace();
			return;
		}
	}
	public MouseRobot getmRobot() {
		return mRobot;
	}
	public void setmRobot(MouseRobot mRobot) {
		this.mRobot = mRobot;
	}
	public KeyboardRobot getkRobot() {
		return kRobot;
	}
	public void setkRobot(KeyboardRobot kRobot) {
		this.kRobot = kRobot;
	}
	static class Helper{
		private int data=5;
		public void bump(int inc){
			inc++;
			data=data+inc;
		}
	}
	public static void main(String[] args) {
		Double d = 1.0;
		if(d instanceof Number)
			d=d++;
		double e1 = 1.0;
		if((Double)e1 instanceof Double | d++==e1++)
			d+=d;
		Stream.of("little","red","riding","hood").parallel()
		.map(s->{System.out.println("map:"+s+" "+Thread.currentThread().getName());return s+"_";})
		.filter(s->{System.out.println("filter: "+s+" "+Thread.currentThread().getName());return s.length()>3;})
		.reduce((s1,s2)-> {System.out.println("reducer: "+s1+" "+Thread.currentThread().getName());return s1.length()>s2.length()?s1:s2;});
		Path inputFile = Paths.get("");
		Path outputFile = Paths.get("");
		try {
			BufferedReader reader = Files.newBufferedReader(inputFile, Charset.defaultCharset());
			BufferedWriter writer = Files.newBufferedWriter(outputFile, Charset.defaultCharset());
			String line = "";
			while((line=reader.readLine())!=null)
				writer.append(line);
		} catch (IOException e) {
			e.printStackTrace();
		}
		Float f = new Float(23.33);
		StringBuilder sb = new StringBuilder();
		for(String arg: args){
			if(sb.indexOf(arg)<1){
				sb.append(arg+" ");
			}
		}
		List<String> list11=new ArrayList<>();
		list11.add("Jupiter");
		list11.add("Neptune");
		list11.add("Mars");
		list11.add("Barth");
		Map<Integer, List<String>> len = list11.stream().collect(Collectors.groupingBy(p->p.length()));
		len.forEach((l,s)->System.out.print(l+"="+s+" "));
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\codegen\robot\TopLeftValidPixel.java---
package codegen.robot;
public class TopLeftValidPixel {
	public TopLeftValidPixel() {
	}
	private int validPixelOffsetX;
	private int validPixelOffsetY;
	private int pixelVal;
	public int getValidPixelOffsetX() {
		return validPixelOffsetX;
	}
	public void setValidPixelOffsetX(int validPixelOffsetX) {
		this.validPixelOffsetX = validPixelOffsetX;
	}
	public int getValidPixelOffsetY() {
		return validPixelOffsetY;
	}
	public void setValidPixelOffsetY(int validPixelOffsetY) {
		this.validPixelOffsetY = validPixelOffsetY;
	}
	public int getPixelVal() {
		return pixelVal;
	}
	public void setPixelVal(int pixelVal) {
		this.pixelVal = pixelVal;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\codegen\Syntax.java---
package codegen;
public class Syntax {
	public static String REFERENCE_SYMBOL = "$";
	public static String ASSIGN_SYMBOL = "=";
	public static String NEW_LINE = "\r\n";
	public static String END_OF_LINE = ";\r\n";
	public static String PACKAGE_DECLARE = "package $PACKAGE_NAME$$END_OF_LINE$";
	public static String FIELD_DECLARE = "$PRIVILEDGE_MODIFIER$$STATIC_MODIFIER$$ABSTRACT_MODIFIER$$FINAL_MODIFIER$$VOLATILE_MODIFIER$$SYNC_MODIFIER$ $FIELD_CLASS_NAME$ $FIELD_INSTANCE_NAME$$END_OF_LINE$";
	public static String FIELD_DECLARE_WITH_ASSIGN = "$PRIVILEDGE_MODIFIER$$STATIC_MODIFIER$$ABSTRACT_MODIFIER$$FINAL_MODIFIER$$SYNC_MODIFIER$ $FIELD_CLASS_NAME$ $FIELD_INSTANCE_NAME$=$TMP_INSTANCE_VALUE$$END_OF_LINE$";
	public static String IMPORT_LINE = "import $QUALIFIER$$END_OF_LINE$";
	public static String CLASS_BEGIN_LINE = "$PRIVILEDGE_MODIFIER$$STATIC_MODIFIER$$ABSTRACT_MODIFIER$$FINAL_MODIFIER$$SYNC_MODIFIER$ class $TMP_CLASS_NAME$ {$NEW_LINE$";
	public static String CLASS_END_LINE = "}";
	public static String DECLARE_LINE = "$TMP_CLASS_NAME$ $TMP_INSTANCE_NAME$;$NEW_LINE$";
	public static String ASSIGN_LINE = "$TMP_CLASS_NAME$ $TMP_INSTANCE_NAME$ = $TMP_INSTANCE_VALUE$;$NEW_LINE$";
	public static String ARRAY_DECLARE_LINE = "$TMP_CLASS_NAME$ $TMP_INSTANCE_NAME$[];$NEW_LINE$";
	public static String ARRAY_ASSIGN_LINE = "$TMP_CLASS_NAME$ $TMP_INSTANCE_NAME[]$ = $TMP_INSTANCE_VALUE$;$NEW_LINE$";
	public static String CAST_LINE = "$TARGET_CLASS_NAME$$SEPERATOR$$TARGET_INSTANCE_NAME$ = $TMP_CLASS_NAME$.class.cast(TMP_INSTANCE_VALUE);$NEW_LINE$";
	public static String CAST_EXPLICIT_LINE = "$TARGET_CLASS_NAME$$SEPERATOR$$TARGET_INSTANCE_NAME$ = ($TMP_CLASS_NAME$)$TMP_INSTANCE_VALUE$;$NEW_LINE$";
	public static String ABSTRACT_NEW_INSTANCE_LINE_WITH_DECLARE_OR_NOT = "$ABSTRACT_CLASS_NAME$$SEPERATOR$$ABSTRACT_INSTANCE_NAME$ = new $TMP_CLASS_NAME$($METHOD_PARAMS_VARIABLE$);$NEW_LINE$";
	public static String NEW_INSTANCE_LINE = "$TMP_INSTANCE_NAME$ = new $TMP_CLASS_NAME$();$NEW_LINE$";
	public static String INIT_CLASS_WITH_CONCRETE_LINE = "$ABSTRACT_CLASS_NAME$ $ABSTRACT_INSTANCE_NAME$ = $TMP_CLASS_NAME$.$METHOD_NAME$($METHOD_PARAMS_VARIABLE$);$NEW_LINE$";
	public static String NEW_ABSTRACT_CLASS_INSTANCE_LINE_BEGIN_LINE = "$TMP_INSTANCE_NAME$ = new $TMP_CLASS_NAME$(){$CLASS_END_LINE$";
	public static String NEW_ABSTRACT_CLASS_METHOD_WITH_RETURN = "@Override$CLASS_END_LINE$"
			+ "public $METHOD_RETURN_TYPE$ $METHOD_NAME$($METHOD_PARAMS_DECLARE$) {" + "return null;" + "}";
	public static String CONTROLLER_METHOD = "@RequestMapping(value=\"$PATH$\"$METHOD_STR$$HEADERS$$CONSUMERS$$PRODUCES$)"
			+ "$NEW_LINE$$PRIVILEDGE_MODIFIER$$STATIC_MODIFIER$$ABSTRACT_MODIFIER$$FINAL_MODIFIER$$SYNC_MODIFIER$ $METHOD_RETURN_TYPE$ $METHOD_NAME$($METHOD_PARAMS_DECLARE$) $THROWS_EXCEPTION${$NEW_LINE$"
			+ "    $METHOD_BODY$$NEW_LINE$" + "    return $METHOD_RETURN_VALUE$$END_OF_LINE$" + "}";
	public static String NORMAL_METHOD = "$PRIVILEDGE_MODIFIER$$STATIC_MODIFIER$$ABSTRACT_MODIFIER$$FINAL_MODIFIER$$SYNC_MODIFIER$ $METHOD_RETURN_TYPE$ $METHOD_NAME$($METHOD_PARAMS_DECLARE$) $THROWS_EXCEPTION${$NEW_LINE$"
			+ "    $METHOD_BODY$$NEW_LINE$" + "    return $METHOD_RETURN_VALUE$$END_OF_LINE$" + "}";
	public static String METHOD_END_LINE = "}";
	/***/
	public static String INIT_CLASS_WITH_DEFAULT_VALUE = "$TMP_CLASS_NAME$$SEPERATOR$$TMP_INSTANCE_NAME$ = $DEFAULT_VALUE$;$NEW_LINE$";
	public static String INIT_LIST = "List<$GENERIC_TYPE_NAME$> $TMP_INSTANCE_NAME$ = new $TMP_CLASS_NAME$<>();";
	public static String INIT_Map = "Map<$GENERIC_TYPE_KEY$, $GENERIC_TYPE_VAL$> $TMP_INSTANCE_NAME$ = new $TMP_CLASS_NAME$<>();";
	public static String NEW_ABSTRACT_CLASS_METHOD_RETURN_VOID = "@Override$CLASS_END_LINE$"
			+ "public void $METHOD_NAME$($METHOD_PARAMS_DECLARE$) {" + "return ;" + "}";
	public static String NEW_EXCEPTION_THROW = "throw new $TMP_CLASS_NAME$($METHOD_PARAMS_VARIABLE$);";
	public static String RETURN = "return $TMP_INSTANCE_VALUE$;";
	public static String LOGGER_TRACE = "log.trace(String.format(\" %s\", s));";
	public static String LOGGER_DEBUG = "log.debug(String.format(\" %s\", s));";
	public static String LOGGER_INFO = "log.info(String.format(\" %s\", s));";
	public static String LOGGER_ERROR = "log.error(String.format(\" %s\", s));";
	public static String LOGGER_FATAL = "log.fatal(String.format(\" %s\", s));";
	public static String NORMAL_SETUP_BEGIN_LINE = "@Before$NEW_LINE$"
			+ "public void setUp() throws Exception {$NEW_LINE$";
	public static String NORMAL_TEST_CASE_BEGIN_LINE = "@Test$NEW_LINE$" + "public void test$METHOD_NAME$() {";
	public static String EXCEPTION_TEST_CASE_BEGIN_LINE = "@Test(expected=$EXCEPTION_CLASS$.class)$CLASS_END_LINE$"
			+ "public void test$METHOD_NAME$() {";
	public static String METHOD_WITH_RETURN_CALLING = "$RETURN_TYPE$ $RETURN_TYPE_INSTANCE$ = $TMP_INSTANCE_NAME$.$METHOD_NAME$($METHOD_PARAMS_VARIABLE$);$NEW_LINE$";
	public static String VOID_METHOD_CALLING = "$TMP_INSTANCE_NAME$.$METHOD_NAME$($METHOD_PARAMS_VARIABLE$);$NEW_LINE$";
	public static String METHOD_PARAMS_VARIABLE_LINE = "$METHOD_PARAM1$, $METHOD_PARAM2$";
	public static String IF_ELSE_BLOCK = "$PREFIX_STR$if($IF_EXPRESSION$){$NEW_LINE$$NEW_LINE$" + "}";
	public static String ELSE_BLOCK = "else{$NEW_LINE$$NEW_LINE$" + "}";
	public static String FOR_EACH_BLOCK = "for($TMP_CLASS_NAME$ $ITEM_NAME$ : $TMP_INSTANCE_NAME$){$NEW_LINE$}";
	public static String FOR_LOOP_INCREMENT_BLOCK = "for($TMP_CLASS_NAME$ $TMP_INSTANCE_NAME$=0;$TMP_INSTANCE_NAME$<.length();$TMP_INSTANCE_NAME$++){$NEW_LINE$}";
	public static String FOR_LOOP_DECREMENT_BLOCK = "for($TMP_CLASS_NAME$ $TMP_INSTANCE_NAME$=.length()-1;$TMP_INSTANCE_NAME$>=0;$TMP_INSTANCE_NAME$--){$NEW_LINE$}";
	public static String SWITCH_BLOCK = "switch($TMP_INSTANCE_NAME$){$NEW_LINE$$BLOCK_BODY$}";
	public static String SWITCH_CASE_BLOCK = "case $TMP_INSTANCE_NAME$:$NEW_LINE$$NEW_LINE$$NEW_LINE$break$END_OF_LINE$";
	public static String SWITCH_DEFAULT_BLOCK = "default :$NEW_LINE$$NEW_LINE$break$END_OF_LINE$";
	public static String WHILE_BLOCK = "while($TMP_INSTANCE_NAME$){$NEW_LINE$$BLOCK_BODY$}";
	public static String DO_WHILE_BLOCK = "do{$NEW_LINE$$BLOCK_BODY$}while($TMP_INSTANCE_NAME$)$END_OF_LINE$";
	public static String SYNCHRONIZED_BLOCK = "synchronized($TMP_INSTANCE_NAME$){$NEW_LINE$$BLOCK_BODY$}";
	public static String TRY_CATCH_BLOCK = "try{$NEW_LINE$" + "$TRY_BODY$$NEW_LINE$"
			+ "}catch($EXCEPTIONS_DECLARE$){$NEW_LINE$" + "$CATCH_BODY$$NEW_LINE$" + "}finally{" + "$FINALLY_BODY$"
			+ "}";
	public static String COLLECTION_STREAM = "$TMP_CLASS_NAME$ $TMP_INSTANCE_NAME$$ASSIGN_SYMBOL$$TMP_INSTANCE_VALUE$.stream()";
	public static String STREAM_DISTINCT = ".distinct()";
	public static String STREAM_SORT = ".sorted((Object o1, Object o2)-> {$NEW_LINE$ if(o1 > o2) {$NEW_LINE$return -1;$NEW_LINE$}else if(o1 == o2) {$NEW_LINE$return 0;$NEW_LINE$}else {$NEW_LINE$return 1;} $NEW_LINE$})";
	public static String STREAM_FOREACH = ".forEach(e-> {})";
	public static String STREAM_FILTER = ".filter(e -> {if (\"\".equals(e)) { return true; } return false; })";
	public static String STREAM_MAP = ".map(e-> {return e;})";
	public static String STREAM_COLLECT_AS_LIST = ".collect(Collectors.toList())";
	public static String STREAM_COLLECT_AS_SET = ".collect(Collectors.toSet())";
	public static String STREAM_COLLECT_AS_MAP = ".collect(Collectors.toMap(e-> e.getId().toString().toLowerCase(), e->e.getValue(), (e1,e2)->{return e1;}))";
	public static String STREAM_COLLECT_AS_TREE_MAP = ".collect(Collectors.toMap(e-> e.getId().toString().toLowerCase(), e->e.getValue(), (e1,e2)->{return e1;}, ()->new TreeMap(String.CASE_INSENSITIVE_ORDER))";
	public static String STREAM_COLLECT_AS_CONCURRENTMAP = ".collect(Collectors.toConcurrentMap($GENERIC_TYPE_KEY$, $GENERIC_TYPE_VAL$))";
	public static String MAP_ENTRY_SET = "$TMP_INSTANCE_NAME$.entrySet()";
	public static String MAP_VALUES = "$TMP_INSTANCE_NAME$.values()";
	public static String MAP_KEY_SET = "$TMP_INSTANCE_NAME$.keySet()";
	public static String MAIN_BLOCK = "public static void main(String[] args){\r\n}";
	public static String EXCEPTIONS_DECLARE_LINE = "$EXCEPTION_NAME$ $EXCEPTION_INSTANCE_NAME$";
	public static String COLLECTION_LAMBDA_FOR_EACH = "$TMP_INSTANCE_NAME$.$METHOD_NAME$().forEach(($LAMBDA_PARAMS_VARIABLE$) -> {$NEW_LINE$"
			+ "$METHOD_BODY$" + "$NEW_LINE$});$NEW_LINE$";
	public static String SYS_IN = "BufferedReader br = new BufferedReader(new InputStreamReader(System.in));$NEW_LINE$"
			+ "while (true) {$NEW_LINE$" + "    String input = br.readLine();$NEW_LINE$"
			+ "    if (input != null && !input.isEmpty()){$NEW_LINE$" + "        switch (input){$NEW_LINE$"
			+ "            case \"\":$NEW_LINE$" + "                break;$NEW_LINE$"
			+ "            case \"exit\":$NEW_LINE$" + "                System.exit(0);$NEW_LINE$"
			+ "            default :$NEW_LINE$" + "                $NEW_LINE$" + "         }$NEW_LINE$"
			+ "    }$NEW_LINE$" + "}$NEW_LINE$";
	public static String SYS_OUT = "System.out.$METHOD_NAME$($METHOD_PARAMS_VARIABLE$);";
	public static String STRING_FORMAT = "String.format($METHOD_PARAMS_VARIABLE$);";
	public static String PATTERN_COMPILE = "Pattern $TMP_INSTANCE_VALUE$ = Pattern.compile($TMP_INSTANCE_NAME$, Pattern.MULTILINE | Pattern.CASE_INSENSITIVE);";
	public static String PATTERN_CREATE_MATCHER = "Matcher $TMP_INSTANCE_VALUE$ = $TMP_INSTANCE_NAME$.matcher($METHOD_PARAMS_VARIABLE$);";
	public static String MATCHER_FIND = "boolean $TMP_INSTANCE_VALUE$ = $TMP_INSTANCE_NAME$.find();";
	public static String MATCHER_MATCHES = "boolean $TMP_INSTANCE_VALUE$ = $TMP_INSTANCE_NAME$.matches();";
	public static String UNIT_TEST_SET_TARGET_OBJ_FIELD_CALLING = "setTargetObjField(\"$FIELD_INSTANCE_NAME$\", $TMP_INSTANCE_NAME$, $FIELD_VALUE$)$END_OF_LINE$";
	public static String UNIT_TEST_SET_TARGET_OBJ_FIELD_METHOD = "private void setTargetObjField(String fieldName, Object target, Object fieldObj){$NEW_LINE$"
			+ "try {$NEW_LINE$" + "Field f = getField(fieldName, target.getClass());$NEW_LINE$"
			+ "if(f == null){$NEW_LINE$" + "return;$NEW_LINE$" + "}$NEW_LINE$" + "f.setAccessible(true);$NEW_LINE$"
			+ "f.set(target, fieldObj);$NEW_LINE$"
			+ "} catch (SecurityException | IllegalArgumentException | IllegalAccessException e) {$NEW_LINE$"
			+ "e.printStackTrace();$NEW_LINE$" + "}$NEW_LINE$" + "}";
	public static String UNIT_TEST_GET_FIELD_METHOD = "private Field getField(String fieldName, Class target){$NEW_LINE$"
			+ "Field f = null;$NEW_LINE$" + "try{$NEW_LINE$" + "f = target.getDeclaredField(fieldName);$NEW_LINE$"
			+ "}catch(NoSuchFieldException e){$NEW_LINE$" + "Class superC = target.getSuperclass();$NEW_LINE$"
			+ "if(superC != null){$NEW_LINE$" + "return getField(fieldName, superC);$NEW_LINE$" + "}$NEW_LINE$"
			+ "}$NEW_LINE$" + "return f;$NEW_LINE$" + "}$NEW_LINE$";
	public static String ASSERT_FAIL = "Assert.fail()$END_OF_LINE$";
	public static String ASSERT_NOT_NULL = "Assert.assertNotNull($TMP_INSTANCE_NAME$)$END_OF_LINE$";
	public static String ASSERT_EQUAL = "Assert.assertEquals($EXPECT_VALUE$, $ACTUAL_VALUE$)$END_OF_LINE$";
	public static String MOCKITO_VERIFY = "Mockito.verify($INSTANCE_NAME$, Mockito.times(1)).$METHOD_NAME$($MATCH_PARAMS_VARIABLE$)$END_OF_LINE$";
	public static String POWER_MOCK_STATIC_VERIFY = "";
	public static String ANY_MATCH = "Mockito.any()";
	public static String ANY_OF_CLASS_MATCH = "Mockito.any($TMP_CLASS_NAME$.class)";
	public static String INTERFACE_MOCK_CLASS_NAME = "$TMP_CLASS_NAME$MOCK";
	public static String MOCK_CLASS_LINE = "$TMP_CLASS_NAME$ $TMP_INSTANCE_NAME$ = Mockito.mock($TMP_CLASS_NAME$.class)$END_OF_LINE$";
	public static String MOCK_THROW = "Mockito.doThrow(Exception.class).when($TMP_INSTANCE_NAME$).$METHOD_NAME$($METHOD_PARAMS_VARIABLE$)$END_OF_LINE$";
	public static String MOCK_RETURN_VOID = "Mockito.doNothing().when($TMP_INSTANCE_NAME$).$METHOD_NAME$($METHOD_PARAMS_VARIABLE$)$END_OF_LINE$";
	public static String MOCK_RETURN = "Mockito.doReturn($METHOD_RETURN_VALUE$).when($TMP_INSTANCE_NAME$).$METHOD_NAME$($METHOD_PARAMS_VARIABLE$)$END_OF_LINE$";
	public static String WRITE_FILE = "public static void write(File f, String fileStr) throws IOException {"
			+ "$NEW_LINE$" + "FileOutputStream fos = new FileOutputStream(f);" + "$NEW_LINE$"
			+ "fos.write(fileStr.getBytes());" + "$NEW_LINE$" + "fos.flush();" + "$NEW_LINE$" + "fos.close();"
			+ "$NEW_LINE$" + "}";
	public static String READ_FILE = "public static String readAsStr(File f) throws IOException {" + "$NEW_LINE$"
			+ "FileInputStream is = new FileInputStream(f);" + "$NEW_LINE$" + "StringBuilder sb = new StringBuilder();"
			+ "$NEW_LINE$" + "BufferedReader in = null;" + "$NEW_LINE$" + "try {" + "$NEW_LINE$"
			+ "	in = new BufferedReader(new InputStreamReader(is));" + "$NEW_LINE$" + "	String line = null;"
			+ "$NEW_LINE$" + "	while ((line = in.readLine()) != null) {" + "$NEW_LINE$"
			+ "		sb.append(line).append(\"\r\n\");" + "$NEW_LINE$" + "	}" + "$NEW_LINE$"
			+ "} catch (IOException e) {" + "$NEW_LINE$" + "	e.printStackTrace();" + "$NEW_LINE$" + "	throw e;"
			+ "$NEW_LINE$" + "} finally {" + "$NEW_LINE$" + "	if (in != null)" + "$NEW_LINE$" + "		try {"
			+ "$NEW_LINE$" + "			in.close();" + "$NEW_LINE$" + "		} catch (IOException e) {" + "$NEW_LINE$"
			+ "			e.printStackTrace();" + "$NEW_LINE$" + "		}" + "$NEW_LINE$" + "}" + "$NEW_LINE$"
			+ "return sb.toString();" + "$NEW_LINE$" + "}";
	public static String THREAD_POOL_EXECUTOR = "$PRIVILEDGE_MODIFIER$$STATIC_MODIFIER$$ABSTRACT_MODIFIER$$FINAL_MODIFIER$ BlockingQueue<Runnable> arrayBlockingQueue = new ArrayBlockingQueue<>($MAX_POOL_SIZE$);"
			+ "$NEW_LINE$"
			+ "$PRIVILEDGE_MODIFIER$$STATIC_MODIFIER$$ABSTRACT_MODIFIER$$FINAL_MODIFIER$ ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor($CORE_POOL_SIZE$, $MAX_POOL_SIZE$, 1L, java.util.concurrent.TimeUnit.SECONDS, arrayBlockingQueue $NEW_THREAD_FACTORY$);"
			+ "$NEW_LINE$"
			+ "$PRIVILEDGE_MODIFIER$$STATIC_MODIFIER$$ABSTRACT_MODIFIER$$FINAL_MODIFIER$ void shutdownThreadPool() {"
			+ "$NEW_LINE$" + "    threadPoolExecutor.shutdown();" + "$NEW_LINE$" + "}";
	public static String NEW_THREAD_FACTORY = "new ThreadFactory(){" + "$NEW_LINE$" + "@Override" + "$NEW_LINE$"
			+ "public Thread newThread(Runnable r) {" + "$NEW_LINE$" + "    return new Thread(r);" + "$NEW_LINE$"
			+ "}}";
	public static String SUBMIT_CALLABLE_TASK = "$PRIVILEDGE_MODIFIER$$STATIC_MODIFIER$$ABSTRACT_MODIFIER$$FINAL_MODIFIER$ $RETURN_TYPE$ submitTask(Callable<$RETURN_TYPE$> task) throws Exception {"
			+ "$NEW_LINE$" + "    Future<$RETURN_TYPE$> f = threadPoolExecutor.submit(task);" + "$NEW_LINE$"
			+ "    return f.get();" + "$NEW_LINE$" + "}";
	public static String SUBMIT_RUNNABLE_TASK = "$PRIVILEDGE_MODIFIER$$STATIC_MODIFIER$$ABSTRACT_MODIFIER$$FINAL_MODIFIER$ void submitTask(Runnable task) {"
			+ "$NEW_LINE$" + "    threadPoolExecutor.submit(task);" + "$NEW_LINE$" + "}";
	public static String MAVEN_DEPENDENCY = "<dependency>$NEW_LINE$<groupId>$GROUP_ID$</groupId>$NEW_LINE$<artifactId>$ARTIFACTOR_ID$</artifactId>$NEW_LINE$"
			+ "<version>$VERSION$</version>$NEW_LINE$<scope>$SCOPE$</scope>$NEW_LINE$</dependency>";
	public static String HTML_TAG_A = "<a$ID$ href=$LINK$></a>";
	public static String HTML_TAG_TEXT = "<input type=\"text\"$ID$ name=\"$TAG_NAME$\" value=\"\"></input>";
	public static String HTML_TAG_HIDDEN = "<input type=\"hidden\"$ID$ name=\"$TAG_NAME$\"  value=\"\"></input>";
	public static String HTML_TAG_BTN = "<input type=\"button\"$ID$ name=\"$TAG_NAME$\"  value=\"\"></input>";
	public static String HTML_TAG_FILE = "<input type=\"file\"$ID$ name=\"$TAG_NAME$\"  value=\"\"></input>";
	public static String HTML_TAG_SELECT = "<input type=\"select\"$ID$ name=\"$TAG_NAME$\">$NEW_LINE$<option value=\"\"></option>$NEW_LINE$</input>";
	public static String HTML_TAG_FORM = "<form$ID$ method=$REQUEST_METHOD$$ID$ action=$LINK$$TARGET$$NEW_LINE$</form>";
	public static String PODAM_INIT_POJO = "$TMP_CLASS_NAME$ $TMP_INSTANCE_NAME$ = new PodamFactoryImpl().manufacturePojo($TMP_CLASS_NAME$.class)$END_OF_LINE$";
}
----strat of file D:\projects\cg\cg-min\src\main\java\codegen\unittest\ClzNeedMockDetermination.java---
package codegen.unittest;
import codegen.util.Common;
import java.lang.annotation.Annotation;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.Map;
public class ClzNeedMockDetermination {
	public boolean needMock(Class<?> c) throws ClassNotFoundException {
		boolean b = true;
		boolean isInterface = c.isInterface();
		boolean isAbstract = Common.isAbstract(c);
		if (isInterface || isAbstract) {
			return true;
		}
		boolean isAnySpecifiedAnn = isAnySpecifiedAnnPackMatch(c,
				new String[] { "javax.persistence", "javax.xml.bind", "com.fasterxml.jackson.databind" });
		if (isAnySpecifiedAnn) {
			return false;
		}
		boolean isSimpleType = isSimpleTypeOrCollectionOfSimple(c);
		boolean isSimpleTypeMap = isSimpleTypeOrCollectionOfSimple(c);
		boolean isAllFieldsSimpleType = isAllFieldsSimpleType(c);
		if (isSimpleType) {
			return false;
		}
		if (isSimpleTypeMap) {
			return false;
		}
		if (isAllFieldsSimpleType) {
			return false;
		}
		boolean isAllStaticMethods = isAllMethodStatic(c);
		if (isAllStaticMethods) {
			return false;
		}
		return b;
	}
	public boolean isAllMethodStatic(Class<?> c) {
		Method[] ms = Common.getAllMethods(c);
		for (Method m : ms) {
			if ((m.getModifiers() & Modifier.STATIC) != 1) {
				return false;
			}
		}
		return true;
	}
	/**
	 * enum and all primitive types not need mock Object and Exception child classes
	 * and has default constructor or simply type param constructor are data Object
	 * Collection, arrays of all above classes not need mock
	 */
	public boolean isSimpleTypeOrMapOfSimple(Class<?> c) {
		boolean b = false;
		if (c.isAssignableFrom(Map.class)) {
			return true;
		} else {
		}
		b = Common.isPrimitiveType(c);
		if (b) {
			return true;
		} else {
			if (c.isAssignableFrom(Map.class)) {
				return true;
			} else {
			}
		}
		return b;
	}
	/**
	 * enum and all primitive types not need mock Object and Exception child classes
	 * and has default constructor or simply type param constructor are data Object
	 * Collection, arrays of all above classes not need mock
	 */
	public boolean isSimpleType(Class<?> c) {
		boolean b = false;
		b = Common.isPrimitiveType(c);
		if (b) {
			return true;
		} else {
			if (c.isAssignableFrom(Exception.class)) {
				return true;
			} else {
			}
		}
		return b;
	}
	/**
	 * enum and all primitive types not need mock Object and Exception child classes
	 * and has default constructor or simply type param constructor are data Object
	 * Collection, arrays of all above classes not need mock
	 */
	public boolean isSimpleTypeOrCollectionOfSimple(Class<?> c) {
		boolean b = false;
		b = Common.isPrimitiveType(c);
		if (b) {
			return true;
		} else {
			if (c.isAssignableFrom(Exception.class)) {
				return true;
			} else if (c.isAssignableFrom(Collection.class) || c.isAssignableFrom(Map.class)) {
				return true;
			}
		}
		return b;
	}
	private boolean isAllFieldsSimpleType(Class<?> c) {
		List<Field> fList = Common.getAllFields(c);
		boolean isAllFieldsSimpleType = fList.stream().anyMatch(f -> {
			return isSimpleType(f.getDeclaringClass());
		});
		return isAllFieldsSimpleType;
	}
	/**
	 * Entity, JaxbElement, xmlType, Json related objects are data Object
	 */
	private boolean isAnySpecifiedAnnPackMatch(Class<?> clz, String[] annPackName) throws ClassNotFoundException {
		List<Annotation> list = new ArrayList<>();
		Common.getAllClzAnnotation(clz, list);
		boolean anySpecifiedAnnPackMatch = list.stream().anyMatch(ann -> {
			boolean am = false;
			for (String packName : annPackName) {
				if (ann.annotationType().getName().startsWith(packName)) {
					am = true;
					break;
				}
			}
			return am;
		});
		return anySpecifiedAnnPackMatch;
	}
	/**
	 * Entity, JaxbElement, xmlType, Json related objects are data Object
	 *//*
		 * private boolean isSpecifiedAnn(Class<?> clz, String annClzName) throws
		 * ClassNotFoundException { Class annClz =
		 * CodeGenContext.getInstance().getReloadableDynamicClassLoaderOwner().loadClass(annClzName, true); return isSpecifiedAnnoInclz(clz,
		 * annClz); }
		 * 
		 * private <A extends Annotation> boolean isSpecifiedAnnoInclz(Class<?> c,
		 * Class<A> ac) { Annotation anns[] = c.getAnnotationsByType(ac); return
		 * anns.length > 1; }
		 */
}
----strat of file D:\projects\cg\cg-min\src\main\java\codegen\unittest\FieldInitParams.java---
package codegen.unittest;
import java.lang.reflect.Field;
public class FieldInitParams {
	private Field field;
	private Class<?> fieldType;
	private int mod;
	private String fieldName;
	private String defaultVal;
	private boolean tooManyMethods;
	private boolean needMock;
	private boolean needMockFactroyClz;
	private boolean isComplexType;
	public boolean isNeedMockFactroyClz() {
		return needMockFactroyClz;
	}
	public void setNeedMockFactroyClz(boolean needMockFactroyClz) {
		this.needMockFactroyClz = needMockFactroyClz;
	}
	public Field getField() {
		return field;
	}
	public void setField(Field field) {
		this.field = field;
	}
	public Class<?> getFieldType() {
		return fieldType;
	}
	public void setFieldType(Class<?> fieldType) {
		this.fieldType = fieldType;
	}
	public int getMod() {
		return mod;
	}
	public void setMod(int mod) {
		this.mod = mod;
	}
	public String getFieldName() {
		return fieldName;
	}
	public void setFieldName(String fieldName) {
		this.fieldName = fieldName;
	}
	public String getDefaultVal() {
		return defaultVal;
	}
	public void setDefaultVal(String defaultVal) {
		this.defaultVal = defaultVal;
	}
	public boolean isNeedMock() {
		return needMock;
	}
	public void setNeedMock(boolean needMock) {
		this.needMock = needMock;
	}
	public boolean isTooManyMethods() {
		return tooManyMethods;
	}
	public void setTooManyMethods(boolean tooManyMethods) {
		this.tooManyMethods = tooManyMethods;
	}
	public boolean isComplexType() {
		return isComplexType;
	}
	public void setComplexType(boolean isComplexType) {
		this.isComplexType = isComplexType;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\codegen\unittest\GenTestParam.java---
package codegen.unittest;
import java.util.ArrayList;
import java.util.List;
public class GenTestParam {
	List<OneTestClassCreateParam> oneTestClassParamList=new ArrayList<>();
	List<MockClzFactoryCreateParam> mockClzFactoryCreateParamList=new ArrayList<>();
	List<MockClzFactoryCreateResult> mockClzFactoryCreateResult = new ArrayList<>();
	String targetDir;
	public String getTargetDir() {
		return targetDir;
	}
	public void setTargetDir(String targetDir) {
		this.targetDir = targetDir;
	}
	public OneTestClassCreateParam getOneTestClassParamByClzEvenNotPresent(Class<?> clzToTest){
		for(OneTestClassCreateParam otc : getOneTestClassParamList()){
			if(otc.getClzBeTest().equals(clzToTest)){
				return otc;
			}
		}
		OneTestClassCreateParam otcp = new OneTestClassCreateParam();
		otcp.setClzBeTest(clzToTest);
		oneTestClassParamList.add(otcp);
		return otcp;
	}
	public OneTestClassCreateParam getOneTestClassParamByClz(Class<?> clzToTest){
		for(OneTestClassCreateParam otc : getOneTestClassParamList()){
			if(otc.getClzBeTest().equals(clzToTest)){
				return otc;
			}
		}
		return null;
	}
	public MockClzFactoryCreateResult getMockClzFactoryCreateResult(Class<?> clzBeMock){
		for(MockClzFactoryCreateResult mccr : getMockClzFactoryCreateResult()){
			if(mccr.getClzBeMock().equals(clzBeMock)){
				return mccr;
			}
		}
		return null;
	}
	public List<OneTestClassCreateParam> getOneTestClassParamList() {
		return oneTestClassParamList;
	}
	public void setOneTestClassParamList(List<OneTestClassCreateParam> oneTestClassParamList) {
		this.oneTestClassParamList = oneTestClassParamList;
	}
	public List<MockClzFactoryCreateParam> getMockClzFactoryCreateParamList() {
		return mockClzFactoryCreateParamList;
	}
	public void setMockClzFactoryCreateParamList(List<MockClzFactoryCreateParam> mockClzFactoryCreateParamList) {
		this.mockClzFactoryCreateParamList = mockClzFactoryCreateParamList;
	}
	public List<MockClzFactoryCreateResult> getMockClzFactoryCreateResult() {
		return mockClzFactoryCreateResult;
	}
	public void setMockClzFactoryCreateResult(List<MockClzFactoryCreateResult> mockClzFactoryCreateResult) {
		this.mockClzFactoryCreateResult = mockClzFactoryCreateResult;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\codegen\unittest\MethodCallingVariable.java---
package codegen.unittest;
public class MethodCallingVariable {
	Class c;
	String methodBody;
	String methodBlock;
	String methodName;
	public MethodCallingVariable() {
	}
	public Class getC() {
		return c;
	}
	public void setC(Class c) {
		this.c = c;
	}
	public String getMethodBody() {
		return methodBody;
	}
	public void setMethodBody(String methodBody) {
		this.methodBody = methodBody;
	}
	public String getMethodBlock() {
		return methodBlock;
	}
	public void setMethodBlock(String methodBlock) {
		this.methodBlock = methodBlock;
	}
	public String getMethodName() {
		return methodName;
	}
	public void setMethodName(String methodName) {
		this.methodName = methodName;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\codegen\unittest\MethodCaseCreateParam.java---
package codegen.unittest;
import java.lang.reflect.Method;
public class MethodCaseCreateParam {
	private Method methodForTest;
	private String methodName;
	private int mod;
	private Class returnType;
	private Class expected;
	private Class throwExp;
	public Method getMethodForTest() {
		return methodForTest;
	}
	public void setMethodForTest(Method methodForTest) {
		this.methodForTest = methodForTest;
	}
	public String getMethodName() {
		return methodName;
	}
	public void setMethodName(String methodName) {
		this.methodName = methodName;
	}
	public int getMod() {
		return mod;
	}
	public void setMod(int mod) {
		this.mod = mod;
	}
	public Class getReturnType() {
		return returnType;
	}
	public void setReturnType(Class returnType) {
		this.returnType = returnType;
	}
	public Class getExpected() {
		return expected;
	}
	public void setExpected(Class expected) {
		this.expected = expected;
	}
	public Class getThrowExp() {
		return throwExp;
	}
	public void setThrowExp(Class throwExp) {
		this.throwExp = throwExp;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\codegen\unittest\MockClzCreateParams.java---
package codegen.unittest;
public class MockClzCreateParams {
	private Class<?> clzBeMock;
	public Class<?> getClzBeMock() {
		return clzBeMock;
	}
	public void setClzBeMock(Class<?> clzBeMock) {
		this.clzBeMock = clzBeMock;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\codegen\unittest\MockClzFactoryCreateParam.java---
package codegen.unittest;
public class MockClzFactoryCreateParam {
	String targetDir;
	private Class<?> clzBeMock;
	private String factoryMethodName;
	public String getFactoryMethodName() {
		return factoryMethodName;
	}
	public void setFactoryMethodName(String factoryMethodName) {
		this.factoryMethodName = factoryMethodName;
	}
	public String getTargetDir() {
		return targetDir;
	}
	public void setTargetDir(String targetDir) {
		this.targetDir = targetDir;
	}
	public Class<?> getClzBeMock() {
		return clzBeMock;
	}
	public void setClzBeMock(Class<?> clzBeMock) {
		this.clzBeMock = clzBeMock;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\codegen\unittest\MockClzFactoryCreateResult.java---
package codegen.unittest;
import java.io.File;
public class MockClzFactoryCreateResult {
	private String moclClzName;
	private String moclClzSimpleName;
	private Class<?> clzBeMock;
	private String factoryMethodName;
	private String code;
	private File file;
	public String getMoclClzName() {
		return moclClzName;
	}
	public void setMoclClzName(String moclClzName) {
		this.moclClzName = moclClzName;
	}
	public String getMoclClzSimpleName() {
		return moclClzSimpleName;
	}
	public void setMoclClzSimpleName(String moclClzSimpleName) {
		this.moclClzSimpleName = moclClzSimpleName;
	}
	public Class<?> getClzBeMock() {
		return clzBeMock;
	}
	public void setClzBeMock(Class<?> clzBeMock) {
		this.clzBeMock = clzBeMock;
	}
	public String getFactoryMethodName() {
		return factoryMethodName;
	}
	public void setFactoryMethodName(String factoryMethodName) {
		this.factoryMethodName = factoryMethodName;
	}
	public String getCode() {
		return code;
	}
	public void setCode(String code) {
		this.code = code;
	}
	public File getFile() {
		return file;
	}
	public void setFile(File file) {
		this.file = file;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\codegen\unittest\MockClzFactoryGenerator.java---
package codegen.unittest;
import codegen.Replacement;
import codegen.Syntax;
import codegen.complexobj.CodeGenContext;
import codegen.util.Common;
import java.io.File;
import java.io.FileOutputStream;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.nio.ByteBuffer;
import java.nio.CharBuffer;
import java.nio.channels.FileChannel;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
public class MockClzFactoryGenerator {
	private String genClassBegin(Class c, CodeGenContext context) throws Exception {
		Common.setModifier(Modifier.PUBLIC, context);
		return Common.genMockClassBegin(c, context);
	}
	public MockClzFactoryCreateResult genMock(Class clzToBeMock, String targetDirectory, CodeGenContext context)
			throws Exception {
		MockClzFactoryCreateResult mcr = genMockClassSource(clzToBeMock, context);
		if (mcr == null) {
			return mcr;
		}
		File file = new File(targetDirectory);
		if (!file.exists()) {
			file.mkdirs();
		}
		File mockFactoryFile = new File(targetDirectory + File.separator + clzToBeMock.getSimpleName() + "Mock.java");
		mcr.setFile(mockFactoryFile);
		FileOutputStream fos = new FileOutputStream(mockFactoryFile);
		FileChannel fc = fos.getChannel();
		ByteBuffer bb = Common.utf8CharsetEncoder.encode(CharBuffer.wrap(mcr.getCode()));
		fc.write(bb);
		fc.close();
		fos.close();
		return mcr;
	}
	public MockClzFactoryCreateResult genMockClassSource(Class c, CodeGenContext context) throws Exception {
		MockClzFactoryCreateResult mockClzCreateResult = new MockClzFactoryCreateResult();
		mockClzCreateResult.setMoclClzName(c.getName());
		mockClzCreateResult.setMoclClzSimpleName(c.getSimpleName());
		mockClzCreateResult.setClzBeMock(c);
		String methodName = Common.getDefaultCreateMethodName(c);
		mockClzCreateResult.setFactoryMethodName(methodName);
		StringBuilder sb = new StringBuilder();
		String classBegin = genClassBegin(c, context);
		context.getPackageSB().append(Common.genPackage(c, context.getVariableMap()));
		context.getImportSB()
				.append(Common.genimportStr(c, context.getAlreadyImportClasses(), context.getVariableMap()));
		String methodBody = genAllMethodMockLines(c, context);
		Common.setModifier(Modifier.PUBLIC | Modifier.STATIC, context);
		context.getVariableMap().put(Replacement.METHOD_RETURN_TYPE.name(), c.getSimpleName());
		context.getVariableMap().put(Replacement.METHOD_NAME.name(), methodName);
		context.getVariableMap().put(Replacement.METHOD_PARAMS_DECLARE.name(), "");
		String returnTypeInstanceName = Common.getInstanceName(c);
		context.getVariableMap().put(Replacement.METHOD_BODY.name(), methodBody);
		context.getVariableMap().put(Replacement.METHOD_RETURN_VALUE.name(), returnTypeInstanceName);
		context.getVariableMap().put(Replacement.THROWS_EXCEPTION.name(), "");
		String mockMethodCreateStr = Common.replaceAllKeyWord(Syntax.NORMAL_METHOD, context.getVariableMap());
		sb.append(context.getPackageSB()).append(Syntax.NEW_LINE).append(context.getImportSB()).append(classBegin);
		sb.append(Syntax.NEW_LINE).append(mockMethodCreateStr);
		sb.append(Syntax.NEW_LINE).append(context.getCreatedComplexTypeMethod());
		sb.append(Syntax.NEW_LINE).append(Syntax.CLASS_END_LINE);
		context.clearExceptGlobalParam();
		mockClzCreateResult.setCode(sb.toString());
		return mockClzCreateResult;
	}
	public boolean isConcern(CodeGenContext context, Method m) {
		boolean b = false;
		codegen.MethodMatcher mi = context.getMethodMatchers().get(m.getDeclaringClass());
		boolean notEmptyMM = mi != null && mi.getMiList() != null && mi.getMiList().size() > 0;
		if (notEmptyMM) {
			for (codegen.MethodMatcher mm : mi.getMiList()) {
				if (mm.match(m)) {
					return true;
				}
			}
		} else {
			b = true;
		}
		return b;
	}
	public String genAllMethodMockLines(Class c, CodeGenContext context) throws Exception {
		context.renewSameTypeCreatedTimesMap();
		StringBuilder sb = new StringBuilder();
		StringBuilder mockMethodsLine = new StringBuilder();
		Method ms[] = Common.getAllPublicMethods(c);
		context.getVariableMap().put(Replacement.TMP_CLASS_NAME.name(), c.getSimpleName());
		String instanceName = Common.getInstanceName(c);
		context.getVariableMap().put(Replacement.TMP_INSTANCE_NAME.name(), instanceName);
		String mockClassLine = Common.replaceAllKeyWord(Syntax.MOCK_CLASS_LINE, context.getVariableMap());
		sb.append(mockClassLine);
		Common.importPack("org.mockito.*", context.getVariableMap(), context.getImportSB());
		boolean hasExceptionThrow = false;
		for (Method m : ms) {
			if (!Common.isStatic(m) && isConcern(context, m)// &&
			) {
				if (m.getExceptionTypes() != null && m.getExceptionTypes().length > 0) {
					hasExceptionThrow = true;
				}
				Class<?>[] ccs = Common.getConcreteClass(m.getParameterTypes(), context);
				if (!Common.isVoid(m)) {
					context.getVariableMap().put(Replacement.TMP_INSTANCE_NAME.name(), instanceName);
					context.getVariableMap().put(Replacement.METHOD_NAME.name(), m.getName());
					context.getImportSB().append(
							Common.genimportStr(context.getAlreadyImportClasses(), context.getVariableMap(), ccs));
					String paramVariables = Common.genUnitTestMatchersMethodParamsVariable(context.getVariableMap(),
							Common.getConcreteClass(m.getParameterTypes(), context));
					context.getVariableMap().put(Replacement.METHOD_PARAMS_VARIABLE.name(), paramVariables);
					String mockThrow = Common.replaceAllKeyWord(Syntax.MOCK_THROW, context.getVariableMap());
					Class rt = m.getReturnType();
					String returnValue = null;
					if (Common.isComplexType(rt)) {
						String typeName = m.getGenericReturnType().getTypeName();
						Class collectionGenericType = null;
						if (Common.isACollection(rt)) {
							String genericType = null;
							int start = typeName.indexOf("<");
							int end = typeName.indexOf(">");
							genericType = typeName.substring(start + 1, end);
							try {
								collectionGenericType = CodeGenContext.getInstance().getReloadableDynamicClassLoaderOwner().loadClass(genericType, true);
								Common.importC(collectionGenericType, context);
							} catch (Exception e1) {
							}
						}
						Common.importC(rt, context);
						Common.setModifier(Modifier.PUBLIC | Modifier.STATIC, context);
						MethodCallingVariable mc = Common.genIfNotExistAndGetClassCreateMethod(rt,
								new Class[] { collectionGenericType }, false, context);
						if (mc != null) {
							returnValue = Common.getInstanceName(rt, context.getSameTypeCreatedTimesMap());
							context.getVariableMap().put(Replacement.RETURN_TYPE.name(), rt.getSimpleName());
							context.getVariableMap().put(Replacement.RETURN_TYPE_INSTANCE.name(), returnValue);
							context.getVariableMap().put(Replacement.TMP_INSTANCE_NAME.name(),
									c.getSimpleName() + "Mock");
							context.getVariableMap().put(Replacement.METHOD_NAME.name(), mc.getMethodName());
							context.getVariableMap().put(Replacement.METHOD_PARAMS_VARIABLE.name(), "");
							String methodCallingStr = Common.replaceAllKeyWord(Syntax.METHOD_WITH_RETURN_CALLING,
									context.getVariableMap());
							mockMethodsLine.append(methodCallingStr);
						}
					} else {
						returnValue = Common.getDefaultVal(rt);
						returnValue = returnValue == null ? "" : returnValue;
					}
					context.getVariableMap().put(Replacement.TMP_INSTANCE_NAME.name(), instanceName);
					context.getVariableMap().put(Replacement.METHOD_RETURN_VALUE.name(), returnValue);
					context.getVariableMap().put(Replacement.METHOD_NAME.name(), m.getName());
					context.getVariableMap().put(Replacement.METHOD_PARAMS_VARIABLE.name(), paramVariables);
					String mockWithReturn = Common.replaceAllKeyWord(Syntax.MOCK_RETURN, context.getVariableMap());
					mockMethodsLine.append(mockThrow).append(mockWithReturn);
				} else {
					context.getVariableMap().put(Replacement.TMP_INSTANCE_NAME.name(), instanceName);
					context.getVariableMap().put(Replacement.METHOD_NAME.name(), m.getName());
					Common.importC(ccs, context);
					String paramVariables = Common.genUnitTestMatchersMethodParamsVariable(context.getVariableMap(),
							ccs);
					context.getVariableMap().put(Replacement.METHOD_PARAMS_VARIABLE.name(), paramVariables);
					String mockThrow = Common.replaceAllKeyWord(Syntax.MOCK_THROW, context.getVariableMap());
					String mockReturnVoid = Common.replaceAllKeyWord(Syntax.MOCK_RETURN_VOID, context.getVariableMap());
					mockMethodsLine.append(mockThrow).append(mockReturnVoid);
				}
			} else {
			}
		}
		if (!hasExceptionThrow) {
			sb.append(mockMethodsLine).append(Syntax.NEW_LINE);
		} else {
			context.getVariableMap().put(Replacement.TRY_BODY.name(), mockMethodsLine.toString());
			context.getVariableMap().put(Replacement.EXCEPTION_NAME.name(), Exception.class.getSimpleName());
			context.getVariableMap().put(Replacement.EXCEPTION_INSTANCE_NAME.name(), "e");
			String exceptionsDeclare = Common.replaceAllKeyWord(Syntax.EXCEPTIONS_DECLARE_LINE,
					context.getVariableMap());
			context.getVariableMap().put(Replacement.EXCEPTIONS_DECLARE.name(), exceptionsDeclare);
			context.getVariableMap().put(Replacement.CATCH_BODY.name(), "e.printStackTrace();");
			context.getVariableMap().put(Replacement.FINALLY_BODY.name(), "");
			String tryCatch = Common.replaceAllKeyWord(Syntax.TRY_CATCH_BLOCK, context.getVariableMap());
			sb.append(tryCatch).append(Syntax.NEW_LINE);
		}
		return sb.toString();
	}
	/*
	 * @Deprecated public void genMock(Class clzToTest, String targetDirectory)
	 * throws Exception { String strForFile = genMockClassSource(clzToTest); if
	 * (strForFile == null) { return; } File file = new File(targetDirectory +
	 * File.separator + clzToTest.getSimpleName() + "Mock.java"); FileOutputStream
	 * fos = new FileOutputStream(file); FileChannel fc = fos.getChannel();
	 * ByteBuffer bb =
	 * Common.utf8CharsetEncoder.encode(CharBuffer.wrap(strForFile)); fc.write(bb);
	 * fc.close(); fos.close(); }
	 */
	public void genAllInterfaceMockUnderPack(Class oneOfClass, String targetDirectory) throws Exception {
		Package sourcePack = oneOfClass.getPackage();
		if (sourcePack == null) {
			System.out.println("sourcePack is null");
			return;
		}
		File file = new File(targetDirectory);
		if (file.listFiles() != null && file.listFiles().length > 0) {
			System.out.println(
					String.format("targetDirectory %s is not empty, will skip the generating", targetDirectory));
			return;
		}
		if (!file.exists()) {
			file.mkdirs();
		}
		List<Class> list = new ArrayList<>();
		Common.getAllTopLevelClasses(oneOfClass, true, list);
		CodeGenContext context = CodeGenContext.getInstance();
		list.forEach(c -> {
			try {
				if (c.isInterface()) {
					genMock(c, targetDirectory, context);
				}
			} catch (Exception e) {
				e.printStackTrace();
			}
		});
	}
	public static void main(String[] args) {
		MockClzFactoryGenerator gen = new MockClzFactoryGenerator();
		try {
			Class rt = Object.class;
			Map<Class, Short> map = new HashMap<>();
			System.out.println(Modifier.PRIVATE | Modifier.STATIC);
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\codegen\unittest\OneTestClassCreateParam.java---
package codegen.unittest;
import java.util.ArrayList;
import java.util.List;
public class OneTestClassCreateParam {
	Class<?> clzBeTest;
	List<FieldInitParams> fieldInitParamList=new ArrayList<>();
	List<MockClzCreateParams> mockClzCreateParamList=new ArrayList<>();
	List<MethodCaseCreateParam> MethodCaseCreateParamList =new ArrayList<>();
	private OneTestClassCreateResult oneTestClassCreateResult;
	public Class<?> getClzBeTest() {
		return clzBeTest;
	}
	public void setClzBeTest(Class<?> clzBeTest) {
		this.clzBeTest = clzBeTest;
	}
	public List<FieldInitParams> getFieldInitParamList() {
		return fieldInitParamList;
	}
	public void setFieldInitParamList(List<FieldInitParams> fieldInitParamList) {
		this.fieldInitParamList = fieldInitParamList;
	}
	public List<MockClzCreateParams> getMockClzCreateParamList() {
		return mockClzCreateParamList;
	}
	public void setMockClzCreateParamList(List<MockClzCreateParams> mockClzCreateParamList) {
		this.mockClzCreateParamList = mockClzCreateParamList;
	}
	public List<MethodCaseCreateParam> getMethodCaseCreateParamList() {
		return MethodCaseCreateParamList;
	}
	public void setMethodCaseCreateParamList(List<MethodCaseCreateParam> methodCaseCreateParamList) {
		MethodCaseCreateParamList = methodCaseCreateParamList;
	}
	public OneTestClassCreateResult getOneTestClassCreateResult() {
		return oneTestClassCreateResult;
	}
	public void setOneTestClassCreateResult(OneTestClassCreateResult oneTestClassCreateResult) {
		this.oneTestClassCreateResult = oneTestClassCreateResult;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\codegen\unittest\OneTestClassCreateResult.java---
package codegen.unittest;
import java.io.File;
public class OneTestClassCreateResult {
	private File file;
	private Class<?> clzForTest;
	private String code;
	public File getFile() {
		return file;
	}
	public void setFile(File file) {
		this.file = file;
	}
	public Class<?> getClzForTest() {
		return clzForTest;
	}
	public void setClzForTest(Class<?> clzForTest) {
		this.clzForTest = clzForTest;
	}
	public String getCode() {
		return code;
	}
	public void setCode(String code) {
		this.code = code;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\codegen\unittest\UnitTestCodeGeneratorDependOnClass.java---
package codegen.unittest;
import codegen.Const;
import codegen.Replacement;
import codegen.Syntax;
import codegen.complexobj.CodeGenContext;
import codegen.util.Common;
import java.io.File;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.lang.reflect.Parameter;
import java.util.ArrayList;
import java.util.List;
import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import java.util.stream.Stream;
public class UnitTestCodeGeneratorDependOnClass {
	MockClzFactoryGenerator im = new MockClzFactoryGenerator();
	int maxMethod = 10;
	ClzNeedMockDetermination cmd = new ClzNeedMockDetermination();
	public void init(Class<?> clzToTest, CodeGenContext context) {
		context.getVariableMap().put(Replacement.CLASS_NAME.name(), Common.getClassName(clzToTest, context));
		context.getVariableMap().put(Replacement.INSTANCE_NAME.name(), Common.getInstanceName(clzToTest));
	}
	public void genPackage(Class<?> clzToTest, CodeGenContext context) throws Exception {
		context.getVariableMap().put(Replacement.PACKAGE_NAME.name(), clzToTest.getPackage().getName());
		String packageStr = Common.replaceAllKeyWord(Syntax.PACKAGE_DECLARE, context.getVariableMap());
		context.getPackageSB().append(packageStr);
	}
	private void importSimple(String qualifier, CodeGenContext context) throws Exception {
		Class<?> c = null;
		try {
			c = CodeGenContext.getInstance().getReloadableDynamicClassLoaderOwner().loadClass(qualifier, true);
		} catch (Exception e) {
		}
		if (c != null)
			Common.importC(c, context);
	}
	public void genImport(Class<?> clzToTest, CodeGenContext context) throws Exception {
		Common.importC(clzToTest, context);
		Common.importPack("org.junit.*", context.getVariableMap(), context.getImportSB());
		Common.importPack("org.mockito.*", context.getVariableMap(), context.getImportSB());
	}
	public void determineGenTestParam(Class<?> clzToTest, GenTestParam gtp, CodeGenContext context) throws Exception {
		if (gtp == null) {
			gtp = new GenTestParam();
		}
		this.determineFields(clzToTest, gtp, context);
		this.determineMockClzFactoryCreateParams(clzToTest, gtp, context);
		this.determineMockClzCreateParams(clzToTest, gtp, context);
		this.determineMethodCaseCreateParams(clzToTest, gtp, context);
	}
	public void determineMockClzCreateParams(Class<?> clzToTest, GenTestParam gtp, CodeGenContext context)
			throws Exception {
		List<MockClzCreateParams> list = new ArrayList<>();
		List<FieldInitParams> fipList = gtp.getOneTestClassParamByClzEvenNotPresent(clzToTest).getFieldInitParamList();
		for (FieldInitParams fip : fipList) {
			Field f = fip.getField();
			Class<?> fType = f.getType();
			if (Common.isFinal(f) || f.getName().contains("$") || this.canIgnore(fType))
				continue;
			if (fip.isComplexType()) {
				Common.importC(fType, context);
				boolean isTooManyMethods = fip.isTooManyMethods();
				boolean needMockFactroy = fip.isNeedMockFactroyClz() || isTooManyMethods;
				boolean needMock = needMockFactroy ? cmd.needMock(fip.getFieldType()) : true;
				fip.setNeedMock(needMock);
				if (needMock) {
					MockClzCreateParams mcp = new MockClzCreateParams();
					mcp.setClzBeMock(clzToTest);
					list.add(mcp);
				}
			}
		}
	}
	public void determineMockClzFactoryCreateParams(Class<?> clzToTest, GenTestParam gtp, CodeGenContext context)
			throws Exception {
		List<MockClzFactoryCreateParam> list = gtp.getMockClzFactoryCreateParamList();
		List<FieldInitParams> fipList = gtp.getOneTestClassParamByClzEvenNotPresent(clzToTest).getFieldInitParamList();
		for (FieldInitParams fip : fipList) {
			Field f = fip.getField();
			Class<?> fType = f.getType();
			if (Common.isFinal(f) || f.getName().contains("$") || this.canIgnore(fType))
				continue;
			if (fip.isComplexType()) {
				fip.setNeedMock(cmd.needMock(fip.getFieldType()));
				boolean isTooManyMethods = fip.isTooManyMethods();
				boolean needMockFactroyClz = isTooManyMethods || fip.getFieldType().isInterface();
				fip.setNeedMockFactroyClz(needMockFactroyClz);
				if (needMockFactroyClz) {
					MockClzFactoryCreateParam mccp = new MockClzFactoryCreateParam();
					if (!list.stream().anyMatch(e -> {
						return e.getClzBeMock().equals(fType);
					})) {
						mccp.setClzBeMock(fType);
						mccp.setFactoryMethodName("create" + fType.getSimpleName());
						mccp.setTargetDir(gtp.getTargetDir() + File.separator + "mock");
						list.add(mccp);
					}
				}
			} else {
				fip.setNeedMock(false);
				fip.setNeedMockFactroyClz(false);
			}
		}
	}
	public void determineFields(Class<?> clzToTest, GenTestParam gtp, CodeGenContext context) throws Exception {
		List<FieldInitParams> list = new ArrayList<>();
		List<String> concernedPackageNames = Common.getDefaultConcernedPacks(clzToTest);
		Common.getAllFields(clzToTest, concernedPackageNames, context.getAllFieldList());
		Field fa[] = context.getAllFieldList().toArray(new Field[0]);
		for (Field f : fa) {
			Class<?> fType = f.getType();
			if (Common.isFinal(f) || f.getName().contains("$") || canIgnore(fType))
				continue;
			FieldInitParams fieldInitParams = new FieldInitParams();
			boolean isTooManyMethods = Common.getAllDeclaredPublicMethodsForTest(fType).length > maxMethod ? true
					: false;
			fieldInitParams.setTooManyMethods(isTooManyMethods);
			fieldInitParams.setField(f);
			fieldInitParams.setMod(Modifier.PRIVATE);
			fieldInitParams.setFieldType(fType);
			fieldInitParams.setFieldName(Common.getInstanceName(fType));
			fieldInitParams.setComplexType(Common.isComplexType(fType));
			list.add(fieldInitParams);
		}
		gtp.getOneTestClassParamByClzEvenNotPresent(clzToTest).getFieldInitParamList().addAll(list);
	}
	public void determineMethodCaseCreateParams(Class<?> clzToTest, GenTestParam gtp, CodeGenContext context)
			throws Exception {
		Method ms[] = Common.getAllDeclaredPublicMethodsForTest(clzToTest);
		for (Method m : ms) {
			determineOneMethod(clzToTest, gtp, m, context);
		}
	}
	public void determineOneMethod(Class<?> clzToTest, GenTestParam gtp, Method m, CodeGenContext context) {
		MethodCaseCreateParam methodCaseCreateParam = new MethodCaseCreateParam();
		methodCaseCreateParam.setMod(Modifier.PUBLIC);
		methodCaseCreateParam.setMethodForTest(m);
		methodCaseCreateParam.setReturnType(m.getReturnType());
		String testMethodName = Common.makeFirstCharInUpperCase(m.getName());
		methodCaseCreateParam.setMethodName(Common.getMethodName(testMethodName, context));
		gtp.getOneTestClassParamByClzEvenNotPresent(clzToTest).getMethodCaseCreateParamList()
				.add(methodCaseCreateParam);
		Class<?> expClasses[] = m.getExceptionTypes();
		String expCaseNameFormat = "test%sWhen%s";
		for (Class<?> exp : expClasses) {
			MethodCaseCreateParam methodCaseCreateParam1 = new MethodCaseCreateParam();
			methodCaseCreateParam1.setMod(Modifier.PUBLIC);
			methodCaseCreateParam1.setReturnType(m.getReturnType());
			methodCaseCreateParam1.setMethodName(
					Common.getMethodName(String.format(expCaseNameFormat, m.getName(), exp.getSimpleName()), context));
			methodCaseCreateParam1.setExpected(exp);
			methodCaseCreateParam1.setMethodForTest(m);
			methodCaseCreateParam1.setThrowExp(exp);
			gtp.getOneTestClassParamByClzEvenNotPresent(clzToTest).getMethodCaseCreateParamList()
					.add(methodCaseCreateParam1);
		}
	}
	public void genFields(Class<?> clzToTest, GenTestParam gtp, CodeGenContext context) throws Exception {
		List<FieldInitParams> fipList = gtp.getOneTestClassParamByClzEvenNotPresent(clzToTest).getFieldInitParamList();
		for (FieldInitParams fip : fipList) {
			Field f = fip.getField();
			Class<?> fType = fip.getFieldType();
			if (Common.isFinal(f) || f.getName().contains("$") || canIgnore(fType))
				continue;
			String fieldTypeName = fType.getName();
			importSimple(fieldTypeName, context);
			String fieldTypeSimpleName = fType.getSimpleName();
			context.getVariableMap().put(Replacement.FIELD_CLASS_NAME.name(), fieldTypeSimpleName);
			context.getVariableMap().put(Replacement.FIELD_INSTANCE_NAME.name(), f.getName());
			Common.setModifier(Modifier.PRIVATE, context);
			String fieldStr = Common.replaceAllKeyWord(Syntax.FIELD_DECLARE, context.getVariableMap());
			context.getFieldsSB().append(fieldStr);
		}
		String fieldTypeSimpleName = clzToTest.getSimpleName();
		context.getVariableMap().put(Replacement.FIELD_CLASS_NAME.name(), fieldTypeSimpleName);
		context.getVariableMap().put(Replacement.FIELD_INSTANCE_NAME.name(), Common.getInstanceName(clzToTest));
		Common.setModifier(Modifier.PRIVATE, context);
		String fieldStr = Common.replaceAllKeyWord(Syntax.FIELD_DECLARE, context.getVariableMap());
		context.getFieldsSB().append(fieldStr);
		if (fipList.size() > 0) {
			Common.importC(Field.class, context);
			String setTargetObjFieldMethodStr = Common.replaceAllKeyWord(Syntax.UNIT_TEST_SET_TARGET_OBJ_FIELD_METHOD,
					context.getVariableMap());
			String getFieldMethodStr = Common.replaceAllKeyWord(Syntax.UNIT_TEST_GET_FIELD_METHOD,
					context.getVariableMap());
			context.getAddtionalMethods().append(Syntax.NEW_LINE).append(setTargetObjFieldMethodStr);
			context.getAddtionalMethods().append(getFieldMethodStr);
		}
	}
	private boolean canIgnore(Class<?> fieldType) {
		boolean b = false;
		if (fieldType.isAssignableFrom(Logger.class)) {
			b = true;
		}
		if (fieldType.isAssignableFrom(org.slf4j.Logger.class)) {
			b = true;
		}
		if ("logger".equalsIgnoreCase(fieldType.getSimpleName())) {
			b = true;
		}
		return b;
	}
	public void genSetup(Class<?> clzToTest, GenTestParam gtp, CodeGenContext context) throws Exception {
		List<FieldInitParams> fipList = gtp.getOneTestClassParamByClzEvenNotPresent(clzToTest).getFieldInitParamList();
		String setupStr = Common.replaceAllKeyWord(Syntax.NORMAL_SETUP_BEGIN_LINE, context.getVariableMap());
		context.getSetupSB().append(setupStr);
		context.getSetupSB().append(Common.initAClass(clzToTest, context));
		String clzToTestInstanceName = Common.getInstanceName(clzToTest);
		for (FieldInitParams fip : fipList) {
			Field f = fip.getField();
			Class<?> fType = f.getType();
			if (Common.isFinal(f) || f.getName().contains("$") || this.canIgnore(fType))
				continue;
			if (fip.isNeedMockFactroyClz()) {
				MockClzFactoryCreateResult mccr = gtp.getMockClzFactoryCreateResult(fType);
				if (mccr != null) {
					context.getVariableMap().put(Replacement.RETURN_TYPE.name(), "");
					context.getVariableMap().put(Replacement.RETURN_TYPE_INSTANCE.name(), f.getName());
					context.getVariableMap().put(Replacement.TMP_INSTANCE_NAME.name(), Common.getDefaultVal(fType));
					context.getVariableMap().put(Replacement.METHOD_NAME.name(), mccr.getFactoryMethodName());
					context.getVariableMap().put(Replacement.METHOD_PARAMS_VARIABLE.name(), "");
					String mockClzFactoryCallLine = Common.replaceAllKeyWord(Syntax.METHOD_WITH_RETURN_CALLING,
							context.getVariableMap());
					context.getSetupSB().append(mockClzFactoryCallLine);
				} else {
					throw new Exception(String.format("cannot get MockClzFactoryCreateResult for mockClz %s", fType));
				}
			} else if (fip.isNeedMock()) {
				tryRegistryMockConcreteClass(fType, context);
				Common.importC(fType, context);
				context.getVariableMap().put(Replacement.TMP_CLASS_NAME.name(), fType.getSimpleName());
				String mockLine = Common.replaceAllKeyWord(Syntax.MOCK_CLASS_LINE, context.getVariableMap());
				context.getSetupSB().append(mockLine);
			}
			boolean isPrimitiveType = Common.isPrimitiveType(fType);
			if (isPrimitiveType) {
				context.getVariableMap().put(Replacement.TMP_CLASS_NAME.name(), "");
				context.getVariableMap().put(Replacement.DEFAULT_VALUE.name(), Common.getDefaultVal(fType));
				context.getVariableMap().put(Replacement.SEPERATOR.name(), "");
				String fieldAssign = Common.replaceAllKeyWord(Syntax.INIT_CLASS_WITH_DEFAULT_VALUE,
						context.getVariableMap());
				context.getSetupSB().append(fieldAssign);
			}
			context.getVariableMap().put(Replacement.TMP_INSTANCE_NAME.name(), clzToTestInstanceName);
			context.getVariableMap().put(Replacement.FIELD_INSTANCE_NAME.name(), f.getName());
			context.getVariableMap().put(Replacement.FIELD_VALUE.name(), f.getName());
			String setFieldMethodStr = Common.replaceAllKeyWord(Syntax.UNIT_TEST_SET_TARGET_OBJ_FIELD_CALLING,
					context.getVariableMap());
			context.getSetupSB().append(setFieldMethodStr);
		}
		context.getSetupSB().append(Syntax.METHOD_END_LINE);
	}
	public void tryRegistryMockConcreteClass(Class<?> c, CodeGenContext context) {
		String mockClassName = Common.getDefaultMockClassName(c, context);
		try {
			Class<?> mockC = CodeGenContext.getInstance().getReloadableDynamicClassLoaderOwner().loadClass(mockClassName, true);
			String defaultCreateMethodName = Common.getDefaultCreateMethodName(c);
			Method ms[] = Common.getAllDeclaredPublicMethodsForTest(mockC);
			for (Method m : ms) {
				if (m.getName().equals(defaultCreateMethodName) && m.getParameterCount() == 0) {
					context.registerAbstractConcreteClassMappingSimple(c, mockC, defaultCreateMethodName);
					break;
				}
			}
		} catch (ClassNotFoundException e) {
		}
	}
	public StringBuilder genOneParamObject(Class<?> paramClz) {
		return null;
	}
	@SuppressWarnings("unused")
	private static String getEnumCreateStr(Class<?> c) {
		StringBuilder sb = new StringBuilder();
		String classNameForPrint = c.getName().replaceAll("\\$", "\\.");
		Object obj[] = c.getEnumConstants();
		sb.append(classNameForPrint).append(".").append(obj[0].toString());
		return sb.toString();
	}
	public String getComplexTypeCreateMethodName(Class<?> target, CodeGenContext context) {
		String methodName = "create" + target.getSimpleName();
		int sameMethodNameCound = 0;
		for (String name : context.getCreatedMethodName()) {
			Pattern p = Pattern.compile(methodName + "(\\d*)");
			Matcher m = p.matcher(name);
			if (m.find()) {
				String methodNameIndex = m.group(1);
				if (methodNameIndex != null && !"".equals(methodNameIndex.trim())) {
					try {
						sameMethodNameCound = Integer.valueOf(methodNameIndex);
					} catch (Exception e) {
						throw e;
					}
				}
				sameMethodNameCound++;
			}
		}
		if (sameMethodNameCound > 0)
			methodName = methodName + sameMethodNameCound;
		return methodName;
	}
	public void genAllTestCase(GenTestParam gtp, Class<?> clzToTest, CodeGenContext context) throws Exception {
		List<MethodCaseCreateParam> mcpList = gtp.getOneTestClassParamByClzEvenNotPresent(clzToTest)
				.getMethodCaseCreateParamList();
		for (MethodCaseCreateParam mcp : mcpList) {
			context.getAllTestCaseSB().append(genOneTestCase(clzToTest, mcp, context));
		}
	}
	public String genOneTestCase(Class<?> clzToTest, MethodCaseCreateParam mcc, CodeGenContext context)
			throws Exception {
		boolean isStatic = Common.isStatic(mcc.getMethodForTest());
		String clzInstanceName = Common.getInstanceName(clzToTest);
		context.getVariableMap().put(Replacement.METHOD_NAME.name(), mcc.getMethodName());
		StringBuilder sb = new StringBuilder();
		StringBuilder caseBodyExceptTryCatch = new StringBuilder();
		sb.append(Syntax.NEW_LINE);
		String caseBeginStr = Common.replaceAllKeyWord(Syntax.NORMAL_TEST_CASE_BEGIN_LINE, context.getVariableMap());
		sb.append(caseBeginStr).append(Syntax.NEW_LINE);
		Class<?> returnType = mcc.getReturnType();
		/** begin of method calling replacement **/
		Parameter[] ps = mcc.getMethodForTest().getParameters();
		Class<?> paramClasses[] = mcc.getMethodForTest().getParameterTypes();
		StringBuilder methodParamVariables = new StringBuilder();
		for (Parameter p : ps) {
			Class<?> c = p.getType();
			if (c != null) {
				String name = p.getName();
				Common.importC(c, context);
				String value = "null";
				if (!Common.isComplexType(c)) {
					value = Common.getDefaultVal(c);
				} else {
					Class<?> collectionGenericType = null;
					if (Common.isACollection(c)) {
						String genericType = null;
						String typeName = null;
						typeName = p.getParameterizedType().getTypeName();
						int start = typeName.indexOf("<");
						int end = typeName.indexOf(">");
						genericType = typeName.substring(start + 1, end);
						try {
							collectionGenericType = CodeGenContext.getInstance().getReloadableDynamicClassLoaderOwner().loadClass(genericType, true);
							Common.importC(collectionGenericType, context);
						} catch (Exception e1) {
						}
					}
					MethodCallingVariable mc = Common.genIfNotExistAndGetClassCreateMethod(c,
							new Class[] { collectionGenericType }, false, context);
					if (mc != null)
						value = mc.getMethodName() + "()";
				}
				context.getVariableMap().put(Replacement.TMP_CLASS_NAME.name(), Common.getClassName(c, context));
				context.getVariableMap().put(Replacement.TMP_INSTANCE_NAME.name(), name);
				context.getVariableMap().put(Replacement.TMP_INSTANCE_VALUE.name(), value);
				String paramAssignment = Common.replaceAllKeyWord(Syntax.ASSIGN_LINE, context.getVariableMap());
				caseBodyExceptTryCatch.append(Syntax.NEW_LINE).append(paramAssignment);
				methodParamVariables.append(name).append(", ");
			} else {
				System.out.println(String.format("p type %s is null", p));
			}
		}
		if (methodParamVariables.length() > 0) {
			methodParamVariables.delete(methodParamVariables.length() - 2, methodParamVariables.length());
		}
		String returnTypeInstanceName = Common.getInstanceName(returnType);
		boolean isVoidMethod = Common.isVoid(mcc.getMethodForTest());
		if (!isVoidMethod) {
			context.getVariableMap().put(Replacement.RETURN_TYPE.name(), Common.getClassName(returnType, context));
			context.getVariableMap().put(Replacement.RETURN_TYPE_INSTANCE.name(), returnTypeInstanceName);
		}
		String tempInstanceName = !isStatic ? clzInstanceName : clzToTest.getSimpleName();
		context.getVariableMap().put(Replacement.TMP_INSTANCE_NAME.name(), tempInstanceName);
		context.getVariableMap().put(Replacement.METHOD_NAME.name(), mcc.getMethodForTest().getName());
		context.getVariableMap().put(Replacement.METHOD_PARAMS_VARIABLE.name(), methodParamVariables.toString());
		String methodCallingStr = Common.replaceAllKeyWord(
				isVoidMethod ? Syntax.VOID_METHOD_CALLING : Syntax.METHOD_WITH_RETURN_CALLING,
				context.getVariableMap());
		caseBodyExceptTryCatch.append(Syntax.NEW_LINE).append(methodCallingStr);
		/** end of method calling replacement **/
		if (!isVoidMethod) {
			if (!returnType.isPrimitive()) {
				context.getVariableMap().put(Replacement.TMP_INSTANCE_NAME.name(), returnTypeInstanceName);
				String assertNotNull = Common.replaceAllKeyWord(Syntax.ASSERT_NOT_NULL, context.getVariableMap());
				caseBodyExceptTryCatch.append(Syntax.NEW_LINE).append(assertNotNull);
			}
			String expectedReturnTypeInstanceName = Common.getInstanceName(returnType, "expected");
			String value = null;
			if (!Common.isComplexType(returnType)) {
				value = Common.getDefaultVal(returnType);
			} else {
				/*
				 * MethodCallingVariable mc =
				 * Common.genIfNotExistAndGetClassCreateMethod(returnType, true, context); value
				 * = mc.getMethodName() + "()";
				 */
			}
			context.getVariableMap().put(Replacement.TMP_CLASS_NAME.name(), Common.getClassName(returnType, context));
			context.getVariableMap().put(Replacement.TMP_INSTANCE_NAME.name(), expectedReturnTypeInstanceName);
			context.getVariableMap().put(Replacement.TMP_INSTANCE_VALUE.name(), value);
			String expectedReturnTypeAssign = Common.replaceAllKeyWord(Syntax.ASSIGN_LINE, context.getVariableMap());
			context.getVariableMap().put(Replacement.EXPECT_VALUE.name(), expectedReturnTypeInstanceName);
			context.getVariableMap().put(Replacement.ACTUAL_VALUE.name(), returnTypeInstanceName);
			String assertEqual = Common.replaceAllKeyWord(Syntax.ASSERT_EQUAL, context.getVariableMap());
			Common.importC(returnType, context);
		}
		context.getVariableMap().put(Replacement.INSTANCE_NAME.name(), clzInstanceName);
		context.getVariableMap().put(Replacement.METHOD_NAME.name(), mcc.getMethodName());
		StringBuilder methodMatchVariables = new StringBuilder();
		for (int i = 0; i < ps.length; i++) {
			String anyMatch = Common.replaceAllKeyWord(Syntax.ANY_MATCH, context.getVariableMap());
			methodMatchVariables.append(anyMatch).append(", ");
		}
		if (methodMatchVariables.length() > 0) {
			methodMatchVariables.delete(methodMatchVariables.length() - 2, methodMatchVariables.length());
		}
		context.getVariableMap().put(Replacement.MATCH_PARAMS_VARIABLE.name(), methodMatchVariables.toString());
		String mockitoVerify = Common.replaceAllKeyWord(Syntax.MOCKITO_VERIFY, context.getVariableMap());
		Class<?> expClasses[] = mcc.getMethodForTest().getExceptionTypes();
		if (expClasses == null || expClasses.length == 0) {
			sb.append(caseBodyExceptTryCatch);
		} else {
			String names = Stream.of(expClasses).map(e -> {
				return e.getSimpleName();
			}).collect(Collectors.joining(" | "));
			for (Class<?> e : expClasses) {
				Common.importC(e, context);
			}
			context.getVariableMap().put(Replacement.EXCEPTION_NAME.name(), names);
			context.getVariableMap().put(Replacement.EXCEPTION_INSTANCE_NAME.name(), "e");
			String exceptionsDeclare = Common.replaceAllKeyWord(Syntax.EXCEPTIONS_DECLARE_LINE,
					context.getVariableMap());
			context.getVariableMap().put(Replacement.TRY_BODY.name(), caseBodyExceptTryCatch.toString());
			String catchBody = Common.replaceAllKeyWord(Syntax.ASSERT_FAIL, context.getVariableMap());
			context.getVariableMap().put(Replacement.CATCH_BODY.name(), catchBody);
			context.getVariableMap().put(Replacement.FINALLY_BODY.name(), "");
			context.getVariableMap().put(Replacement.EXCEPTIONS_DECLARE.name(), exceptionsDeclare);
			String tryCatchBlock = Common.replaceAllKeyWord(Syntax.TRY_CATCH_BLOCK, context.getVariableMap());
			sb.append(tryCatchBlock);
		}
		sb.append(Syntax.NEW_LINE).append(Syntax.CLASS_END_LINE).append(Syntax.NEW_LINE);
		return sb.toString();
	}
	private String genClassBegin(Class<?> clzToTest, CodeGenContext context) throws Exception {
		String className = Common.getClassName(clzToTest, context) + "Test";
		Common.setModifier(Modifier.PUBLIC, context);
		context.getVariableMap().put(Replacement.TMP_CLASS_NAME.name(), className);
		String beginstr = Common.replaceAllKeyWord(Syntax.CLASS_BEGIN_LINE, context.getVariableMap());
		return beginstr;
	}
	public OneTestClassCreateResult genAllTest(Class<?> clzToTest, GenTestParam gtp, CodeGenContext context)
			throws Exception {
		if (clzToTest.isInterface() || clzToTest.getEnclosingClass() != null) {
			return null;
		}
		if (clzToTest.isEnum()) {
			return null;
		}
		OneTestClassCreateResult oneTestClassCreateResult = new OneTestClassCreateResult();
		oneTestClassCreateResult.setClzForTest(clzToTest);
		this.init(clzToTest, context);
		context.getVariableMap().put(Const.CLASS_SIMPLE_NAME_KEY, clzToTest.getSimpleName());
		context.getVariableMap().put(Const.CLASS_NAME_KEY, clzToTest.getName());
		StringBuilder sb = new StringBuilder();
		this.determineFields(clzToTest, gtp, context);
		this.determineMockClzFactoryCreateParams(clzToTest, gtp, context);
		this.determineMockClzCreateParams(clzToTest, gtp, context);
		List<MockClzFactoryCreateParam> mcfcpList = gtp.getMockClzFactoryCreateParamList();
		for (MockClzFactoryCreateParam mcfcp : mcfcpList) {
			MockClzFactoryCreateResult mcfcr = im.genMock(mcfcp.getClzBeMock(), mcfcp.getTargetDir(), context);
			if (mcfcr.getFile() == null) {
				throw new Exception(String.format("mock class %s file not created", mcfcp.getClzBeMock()));
			} else {
				gtp.getMockClzFactoryCreateResult().add(mcfcr);
			}
		}
		this.determineMethodCaseCreateParams(clzToTest, gtp, context);
		genPackage(clzToTest, context);
		genImport(clzToTest, context);
		List<MethodCaseCreateParam> list = gtp.getOneTestClassParamByClzEvenNotPresent(clzToTest)
				.getMethodCaseCreateParamList();
		gtp.getOneTestClassParamByClzEvenNotPresent(clzToTest).getFieldInitParamList();
		genFields(clzToTest, gtp, context);
		genSetup(clzToTest, gtp, context);
		for (MethodCaseCreateParam mcp : list) {
			String oneTestCase = genOneTestCase(clzToTest, mcp, context);
			context.getAllTestCaseSB().append(oneTestCase);
		}
		sb.append(context.getPackageSB());
		sb.append(context.getImportSB());
		sb.append(genClassBegin(clzToTest, context));
		sb.append(context.getFieldsSB());
		sb.append(context.getSetupSB());
		sb.append(context.getAddtionalMethods());
		sb.append(context.getAllTestCaseSB());
		sb.append(context.getCreatedComplexTypeMethod());
		sb.append(Syntax.CLASS_END_LINE);
		context.clearExceptGlobalParam();
		oneTestClassCreateResult.setCode(sb.toString());
		gtp.getOneTestClassParamByClz(clzToTest).setOneTestClassCreateResult(oneTestClassCreateResult);
		File dir = Common.getFileByPackage(gtp.getTargetDir(), clzToTest.getPackage().getName());
		if (!dir.isDirectory()) {
			dir.mkdirs();
		}
		File file = new File(dir.getAbsolutePath() + File.separator + clzToTest.getSimpleName() + "Test.java");
		Common.write(file, sb.toString());
		oneTestClassCreateResult.setFile(file);
		return oneTestClassCreateResult;
	}
	public void genAllTestCasesAndSave(Class<?> clzToTest, GenTestParam gtp, CodeGenContext context) throws Exception {
		File file = new File(gtp.getTargetDir());
		boolean isMockClzFactoryCreated = !gtp.getMockClzFactoryCreateResult().isEmpty();
		boolean isTestClzFileCreated = gtp.getOneTestClassParamByClz(clzToTest) != null
				&& gtp.getOneTestClassParamByClz(clzToTest).getOneTestClassCreateResult() != null ? true : false;
		if (!isMockClzFactoryCreated && !isTestClzFileCreated && !gtp.getMockClzFactoryCreateResult().isEmpty()
				&& file.listFiles() != null && file.listFiles().length > 0) {
			System.out.println(
					String.format("targetDirectory %s is not empty, will skip the generating", gtp.getTargetDir()));
			return;
		}
		if (!file.exists()) {
			file.mkdirs();
		}
		OneTestClassCreateResult oneTestClassCreateResult = genAllTest(clzToTest, gtp, context);
		if (oneTestClassCreateResult == null) {
			return;
		}
	}
	@SuppressWarnings("rawtypes")
	public void genAllTestUnderPack(Class<?> oneOfClass, GenTestParam gtp, CodeGenContext context) throws Exception {
		Package sourcePack = oneOfClass.getPackage();
		if (sourcePack == null) {
			System.out.println("sourcePack is null");
			return;
		}
		File file = new File(gtp.getTargetDir());
		if (file.listFiles() != null && file.listFiles().length > 0) {
			System.out.println(
					String.format("targetDirectory %s is not empty, will skip the generating", gtp.getTargetDir()));
			return;
		}
		if (!file.exists()) {
			file.mkdirs();
		}
		List<Class> list = new ArrayList<>();
		Common.getAllTopLevelClasses(oneOfClass, true, list);
		list.forEach(c -> {
			try {
				genAllTestCasesAndSave(c, gtp, context);
			} catch (Exception e) {
				e.printStackTrace();
			}
		});
	}
	public static void main(String[] args) {
		UnitTestCodeGeneratorDependOnClass app = new UnitTestCodeGeneratorDependOnClass();
		try {
			Class<?> c = ClassLoader.getSystemClassLoader().loadClass("classfortest.Test1");
			GenTestParam gtp = new GenTestParam();
			gtp.setTargetDir("d:\\test1\\test2");
			app.genAllTestUnderPack(c, gtp, CodeGenContext.newInstance());
		} catch (Exception e) {
			e.printStackTrace();
		}
		/*
		 * Class c = ClassToTest.class; try { app.genAllTest(c, "c:\\"); } catch
		 * (Exception e) { // TODO Auto-generated catch block e.printStackTrace(); }
		 */
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\codegen\util\ClipBoard.java---
package codegen.util;
import java.awt.*;
import java.awt.datatransfer.Clipboard;
import java.awt.datatransfer.DataFlavor;
import java.awt.datatransfer.FlavorListener;
import java.awt.datatransfer.StringSelection;
public class ClipBoard {
	public static Toolkit toolkit = Toolkit.getDefaultToolkit();
	public static Clipboard clipboard = toolkit.getSystemClipboard();
	public static void addFlavorListener(FlavorListener l) {
		clipboard.addFlavorListener(l);
	}
	public static void setStringUtilSuccess(String srcData) {
		boolean b = false;
		do {
			try {
				StringSelection contents = new StringSelection(srcData);
				clipboard.setContents(contents, null);
				b = true;
			} catch (Exception e) {
			}
		} while (!b);
	}
	public static String getString() {
		String str = null;
		try {
			str = (String) clipboard.getData(DataFlavor.stringFlavor);
		} catch (Exception e) {
			System.out.println("cannot get clipboard string");
		}
		return str;
	}
	public static Image getImage() {
		Image img = null;
		try {
			img = (Image) clipboard.getData(DataFlavor.imageFlavor);
		} catch (Exception e) {
			System.out.println("cannot get clipboard image");
		}
		return img;
	}
	public static Toolkit getToolkit() {
		return toolkit;
	}
	public static void setToolkit(Toolkit toolkit) {
		ClipBoard.toolkit = toolkit;
	}
	public static Clipboard getClipboard() {
		return clipboard;
	}
	public static void setClipboard(Clipboard clipboard) {
		ClipBoard.clipboard = clipboard;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\codegen\util\Common.java---
package codegen.util;
import codegen.AbstractConcreteClassMapping;
import codegen.Replacement;
import codegen.Syntax;
import codegen.complexobj.CodeGenContext;
import codegen.complexobj.PojoSetterGenerator;
import codegen.unittest.MethodCallingVariable;
import java.io.*;
import java.lang.annotation.Annotation;
import java.lang.reflect.*;
import java.net.MalformedURLException;
import java.net.URISyntaxException;
import java.net.URL;
import java.nio.charset.Charset;
import java.nio.charset.CharsetDecoder;
import java.nio.charset.CharsetEncoder;
import java.nio.file.FileSystem;
import java.nio.file.*;
import java.security.CodeSource;
import java.security.ProtectionDomain;
import java.sql.Date;
import java.util.*;
import java.util.Map.Entry;
import java.util.concurrent.ThreadLocalRandom;
import java.util.jar.JarEntry;
import java.util.jar.JarFile;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;
public class Common {
	public static Charset utf8Charset = Charset.forName("UTF-8");
	public static CharsetEncoder utf8CharsetEncoder = utf8Charset.newEncoder();
	public static CharsetDecoder utf8CharsetDecoder = utf8Charset.newDecoder();
	public static String getRunningJar() {
		ProtectionDomain protectionDomain = Common.class.getProtectionDomain();
		CodeSource codeSource = protectionDomain.getCodeSource();
		URL uRL = codeSource.getLocation();
		String path = uRL.getPath();
		File jarFile = new File(path);
		String jarFilePath = jarFile.getAbsolutePath();
		return jarFilePath;
	}
	public static String getWorkingDir() {
		ProtectionDomain protectionDomain = Common.class.getProtectionDomain();
		CodeSource codeSource = protectionDomain.getCodeSource();
		URL uRL = codeSource.getLocation();
		String path = uRL.getPath();
		File jarFile = new File(path);
		String jarFilePath = jarFile.getAbsolutePath();
		String s = jarFilePath.replace(jarFile.getName(), "");
		return s;
	}
	public static Class[] getClassByName(String... clzNames) {
		List<Class<?>> list = new ArrayList<>();
		for(String name : clzNames) {
			Class<?> c = null;
			try {
				if(null==c) {
					c = Class.forName(name, false, Common.class.getClassLoader());
				}
			} catch (Exception e) {
			}
			if(null!=c) {
				list.add(c);
			}
		}
		return list.toArray(new Class[list.size()] );
	}
	public static Class getClzByName(String clzName) {
		Class o = null;
		try {
			o = CodeGenContext.getInstance().getReloadableDynamicClassLoaderOwner().loadClass(clzName, true);
		} catch (Exception e) {
			boolean isArrayType = false;
			String name = null;
			if (clzName.trim().endsWith("[]")) {
				isArrayType = true;
				String componentType = clzName.replaceAll("\\[\\]", "");
				name = componentType;
			} else {
				name = clzName;
			}
			try {
				Class componentClz = CodeGenContext.getInstance().getReloadableDynamicClassLoaderOwner().loadClass(name,
						true);
			} catch (ClassNotFoundException e1) {
				if (void.class.getSimpleName().equals(name)) {
					o = void.class;
				} else if (name.equals("java.lang.Object")) {
					o = Object.class;
				} else if (name.equals("java.lang.String")) {
					o = String.class;
				} else if (name.equals("java.lang.Boolean")) {
					o = Boolean.class;
				} else if (name.equals("java.lang.Long")) {
					o = Long.class;
				} else if (name.equals("java.lang.Double")) {
					o = Double.class;
				} else if (name.equals("java.lang.Integer")) {
					o = Integer.class;
				} else if (name.equals("java.lang.Short")) {
					o = Short.class;
				} else if (name.equals("java.lang.Float")) {
					o = Float.class;
				} else if (name.equals("java.lang.Byte")) {
					o = Byte.class;
				} else if (name.equals("java.lang.Character")) {
					o = Character.class;
				} else if (name.equals("java.sql.Date")) {
					o = Date.class;
				} else if (name.equals("boolean")) {
					o = boolean.class;
				} else if (name.equals("long")) {
					o = long.class;
				} else if (name.equals("double")) {
					o = double.class;
				} else if (name.equals("int")) {
					o = int.class;
				} else if (name.equals("short")) {
					o = short.class;
				} else if (name.equals("float")) {
					o = float.class;
				} else if (name.equals("byte")) {
					o = byte.class;
				} else if (name.equals("char")) {
					o = char.class;
				} else if (name.equals("java.sql.Timestamp")) {
					o = java.sql.Timestamp.class;
				} else if (name.equals("java.util.Date")) {
					o = Date.class;
				} else if (name.startsWith("java.util.Map")) {
					o = HashMap.class;
				} else if (name.startsWith("java.util.Set")) {
					o = HashSet.class;
				} else if (name.equals("java.math.BigInteger")) {
					o = java.math.BigInteger.class;
				} else if (name.equals("java.math.BigDecimal")) {
					o = java.math.BigDecimal.class;
				}
			}
			if (isArrayType) {
				Object arrayObj = Array.newInstance(o, 1);
				o = arrayObj.getClass();
			}
		}
		return o;
	}
	public static <T extends Annotation> T getParameterAnnotationByType(Class<T> c, Parameter param) {
		Annotation panns1[] = param.getAnnotations();
		Annotation ann = null;
		for (Annotation an : panns1) {
			if (c.isAssignableFrom(an.annotationType())) {
				ann = an;
				break;
			}
		}
		return (T) ann;
	}
	public static List<String> getDefaultConcernedPacks(Class c) {
		List<String> concernedPacks = new ArrayList<String>();
		String packageName = c.getPackage() != null ? c.getPackage().getName() : "";
		String packDeep[] = packageName.split("\\.");
		StringBuilder sb = new StringBuilder();
		if (packDeep.length > 2) {
			for (int i = 0; i <= 2; i++) {
				sb.append(packDeep[i]).append(".");
			}
			sb.delete(sb.length() - 1, sb.length());
		} else {
			sb.append(packageName);
		}
		concernedPacks.add(sb.toString());
		return concernedPacks;
	}
	public static boolean isConcernPack(String packName, List<String> concernedPackageNames) {
		boolean isconcern = false;
		isconcern = concernedPackageNames.stream().anyMatch(cp -> {
			if (packName.startsWith(cp.trim())) {
				return true;
			} else {
				return false;
			}
		});
		return isconcern;
	}
	public static List<Field> getAllFields(Class c) {
		List<Field> allFieldList = new ArrayList<>();
		while (c != Object.class) {
			allFieldList.addAll(Arrays.asList(c.getDeclaredFields()));
			c = c.getSuperclass();
		}
		return allFieldList;
	}
	public static void getAllFields(Class c, List<String> concernedPackageNames, List<Field> allFieldList) {
		for (Field f : c.getDeclaredFields()) {
			allFieldList.add(f);
		}
		Class superClass = c.getSuperclass();
		if (superClass != null) {
			String packName = superClass.getPackage().getName();
			isConcernPack(packName, concernedPackageNames);
			getAllFields(superClass, concernedPackageNames, allFieldList);
		}
	}
	public static void getAllFieldNames(Class c, List<String> concernedPackageNames, List<String> allFieldList) {
		for (Field f : c.getDeclaredFields()) {
			allFieldList.add(f.getName());
		}
		Class superClass = c.getSuperclass();
		if (superClass != null) {
			String packName = superClass.getPackage().getName();
			isConcernPack(packName, concernedPackageNames);
			getAllFieldNames(superClass, concernedPackageNames, allFieldList);
		}
	}
	public static Boolean isMethodReturnBoolean(Method m) {
		boolean b = false;
		Class c = m.getReturnType();
		if (Boolean.class.equals(c) || boolean.class.equals(c)) {
			b = true;
		}
		return b;
	}
	public static boolean isMethodReturnCollectionType(Method m) {
		boolean b = false;
		Class c = m.getReturnType();
		if (isACollection(c)) {
			b = true;
		}
		return b;
	}
	public static boolean isACollection(Class s) {
		boolean b = false;
		if (Collection.class.isAssignableFrom(s)) {
			b = true;
		}
		return b;
	}
	@Deprecated
	public static Class getOneClassUnderDirectory(String packName, String directory) {
		Class c = null;
		File childDirectory = new File(directory);
		if (childDirectory.isDirectory()) {
			File files[] = childDirectory.listFiles();
			if (files != null) {
				for (File file : files) {
					if (file.getName().endsWith(".class")) {
						StringBuilder sb = new StringBuilder(file.getName());
						String className = sb.delete(sb.length() - 6, sb.length()).toString();
						try {
							c = CodeGenContext.getInstance().getReloadableDynamicClassLoaderOwner()
									.loadClass(packName + "." + className, true);
							return c;
						} catch (Exception e) {
						}
					}
				}
			}
		}
		return c;
	}
	public static void getClassesUnderPackage(Class oneOfClass, List<Class> classList) {
		String packName = oneOfClass.getPackage().getName();
		if ("".equals(packName)) {
			getAllTopLevelClassesInClassesDirectory(oneOfClass, classList);
		} else {
			List<String> loadedClzNames = CodeGenContext.getInstance().getLoadedClassesName();
			List<String> claNames = loadedClzNames.stream().filter(e -> e.startsWith(packName))
					.collect(Collectors.toList());
			for (String clzName : claNames) {
				try {
					Class<?> clz = CodeGenContext.getInstance().getReloadableDynamicClassLoaderOwner()
							.loadClass(clzName, true);
					classList.add(clz);
				} catch (ClassNotFoundException e1) {
					System.out.println(String.format("cannot find class by name %s", clzName));
				}
			}
		}
	}
	public static void getAllTopLevelClassesInClassesDirectory(Class oneOfClass, List<Class> classList) {
		Package sourcePack = oneOfClass.getPackage();
		List<String> classNameList = new ArrayList<String>();
		String sourceDirectory = sourcePack.getName().replaceAll("\\.", "/");
		URL url = oneOfClass.getClassLoader().getResource(sourceDirectory);
		try {
			if (null != url) {
				java.net.URI uri = url.toURI();
				Path path;
				if (uri.getScheme().equals("jar")) {
					Map<String, Object> map = new HashMap<>();
					FileSystem fs = null;
					try {
						try {
							fs = FileSystems.getFileSystem(uri);
						} catch (Exception e) {
						}
						if (fs == null)
							fs = FileSystems.newFileSystem(uri, map);
					} catch (Exception e) {
					}
					if (fs == null) {
						System.out.print("cannot get FileSystem");
						return;
					}
					path = fs.getPath(sourceDirectory);
				} else {
					path = Paths.get(uri);
				}
				java.util.stream.Stream<Path> stream = Files.walk(path, Integer.MAX_VALUE);
				stream.forEach(e -> {
					if (e.toString().endsWith(".class")) {
						try {
							File f = e.toFile();
							classNameList.add(sourcePack.getName() + "." + f.getName());
						} catch (UnsupportedOperationException e1) {
							String name = e.toString();
							if (name.startsWith("/")) {
								name = name.substring(1);
							}
							name = name.replaceAll("/", ".");
							classNameList.add(name);
						}
					}
				});
			}
		} catch (URISyntaxException e) {
			e.printStackTrace();
		} catch (IOException e) {
			e.printStackTrace();
		}
		/*
		 * File fileDirectory = new File(url.getPath()); File files[] =
		 * fileDirectory.listFiles(); if(files != null){ for(File file : files){
		 * if(file.isDirectory()){ String packName = sourcePack.getName() + "." +
		 * file.getName(); String childDirectoryStr =
		 * sourcePack.getName().replaceAll("\\.", "/") + "/"+ file.getName(); URL
		 * childUrl = ClassLoader.getSystemClassLoader().getResource(childDirectoryStr);
		 * if(childUrl != null){ Class c = getOneClassUnderDirectory(packName,
		 * childUrl.getPath()); if(c != null){ getAllTopLevelClasses(c.getPackage(),
		 * classList); } } }else{ if(file.getName().endsWith(".class")){
		 * classNameList.add(sourcePack.getName() + "." + file.getName()); } } } }
		 */
		classNameList.forEach(name -> {
			StringBuilder sb = new StringBuilder(name);
			String className = sb.delete(sb.length() - 6, sb.length()).toString();
			try {
				Class c = CodeGenContext.getInstance().getReloadableDynamicClassLoaderOwner().loadClass(className,
						true);
				classList.add(c);
			} catch (Exception e) {
				e.printStackTrace();
			}
		});
		/*
		 * classNameList.forEach(name -> { StringBuilder sb = new StringBuilder(name);
		 * String className = sb.delete(sb.length() -6 , sb.length()).toString(); try {
		 * Class c =
		 * CodeGenContext.getInstance().getReloadableDynamicClassLoaderOwner().loadClass
		 * (className); classList.add(c); } catch (Exception e) { e.printStackTrace(); }
		 * });
		 */
		return;
	}
	/*
	 * @Deprecated public static void getAllTopLevelClasses(Package sourcePack,
	 * List<Class> classList){ List<String> classNameList = new ArrayList<String>();
	 * String sourceDirectory = sourcePack.getName().replaceAll("\\.", "/"); URL url
	 * = Common.class.getClassLoader().getResource(sourceDirectory); File
	 * fileDirectory = new File(url.getPath()); File files[] =
	 * fileDirectory.listFiles(); if(files != null){ for(File file : files){
	 * if(file.isDirectory()){ String packName = sourcePack.getName() + "." +
	 * file.getName(); String childDirectoryStr =
	 * sourcePack.getName().replaceAll("\\.", "/") + "/"+ file.getName(); URL
	 * childUrl = ClassLoader.getSystemClassLoader().getResource(childDirectoryStr);
	 * if(childUrl != null){ Class c = getOneClassUnderDirectory(packName,
	 * childUrl.getPath()); if(c != null){ getAllTopLevelClasses(c.getPackage(),
	 * classList); } } }else{ if(file.getName().endsWith(".class")){
	 * classNameList.add(sourcePack.getName() + "." + file.getName()); } } } }
	 * classNameList.forEach(name -> { StringBuilder sb = new StringBuilder(name);
	 * String className = sb.delete(sb.length() -6 , sb.length()).toString(); try {
	 * Class c =
	 * CodeGenContext.getInstance().getReloadableDynamicClassLoaderOwner().loadClass
	 * (className); classList.add(c); } catch (Exception e) { e.printStackTrace(); }
	 * }); return ; }
	 */
	public static void getAllTopLevelClasses(Class oneOfClass, boolean startDirectory, List<Class> classList) {
		getClassesUnderPackage(oneOfClass, classList);
	}
	public static String makeFirstCharInLowercase(String name) {
		char firstCh = name.charAt(0);
		String lowerCaseCh = new String(new char[] { firstCh });
		lowerCaseCh = lowerCaseCh.toLowerCase();
		return name.replaceFirst("\\w{1}", lowerCaseCh);
	}
	public static String makeFirstCharInUpperCase(String name) {
		char firstCh = name.charAt(0);
		String upperCaseCh = new String(new char[] { firstCh });
		upperCaseCh = upperCaseCh.toUpperCase();
		return name.replaceFirst("\\w{1}", upperCaseCh);
	}
	public static String getInstanceName(Class c, String prefix, String suffix) {
		if(null==c) {
			return "";
		}
		if (prefix != null && !"".equals(prefix.trim())) {
			String name = prefix + c.getSimpleName();
			if (suffix != null)
				name = name + suffix;
			return name;
		} else {
			char firstCh = c.getSimpleName().charAt(0);
			String lowerCaseCh = new String(new char[] { firstCh });
			lowerCaseCh = lowerCaseCh.toLowerCase();
			if (!isComplexType(c)) {
				return lowerCaseCh;
			}
			if (c == Class.class) {
				return "clz";
			}
			return c.getSimpleName().replaceFirst("\\w{1}", lowerCaseCh);
		}
	}
	public static String getInstanceName(Class c, String prefix) {
		return getInstanceName(c, prefix, null);
	}
	public static String getInstanceName(Class c) {
		return getInstanceName(c, null, null);
	}
	public static String getDefaultVal(Parameter p) {
		String defaultVal = null;
		if (p != null) {
			String typeName = null;
			typeName = p.getParameterizedType().getTypeName();
			Class c = null;
			try {
				c = CodeGenContext.getInstance().getReloadableDynamicClassLoaderOwner().loadClass(typeName, true);
			} catch (ClassNotFoundException e) {
			}
			if (typeName.equals("java.lang.Object")) {
				defaultVal = "new Object()";
			}
			if (typeName.equals("java.lang.String")) {
				defaultVal = "\"\"";
			}
			if (typeName.equals("java.lang.Boolean") || typeName.equals("boolean")) {
				defaultVal = "false";
			}
			if (typeName.equals("java.lang.Long") || typeName.equals("long")) {
				defaultVal = "1L";
			}
			if (typeName.equals("java.lang.Double") || typeName.equals("double")) {
				defaultVal = "1d";
			}
			if (typeName.equals("java.lang.Integer") || typeName.equals("int")) {
				defaultVal = "1";
			}
			if (typeName.equals("java.lang.Short") || typeName.equals("short")) {
				defaultVal = "(short)1";
			}
			if (typeName.equals("java.lang.Float") || typeName.equals("float")) {
				defaultVal = "1f";
			}
			if (typeName.equals("java.lang.Byte") || typeName.equals("byte")) {
				defaultVal = "(byte)0";
			}
			if (typeName.equals("java.lang.Character") || typeName.equals("char")) {
				defaultVal = "'a'";
			}
			if (typeName.equals("java.util.Date")) {
				defaultVal = "new java.util.Date()";
			}
			if (typeName.equals("java.sql.Date") || typeName.equals("java.sql.Timestamp")) {
				defaultVal = "new " + c.getName() + "(new java.util.Date().getTime())";
			}
			if (typeName.startsWith("java.util.Map")) {
				defaultVal = "new java.util.HashMap()";
			}
			if (typeName.startsWith("java.util.Set")) {
				defaultVal = "new java.util.HashSet()";
			}
			if (typeName.equals("java.math.BigInteger")) {
				defaultVal = "java.math.BigInteger.valueOf(1)";
			}
			if (typeName.equals("java.math.BigDecimal")) {
				defaultVal = "java.math.BigDecimal.valueOf(0)";
			}
			if (typeName.equals("javax.xml.datatype.XMLGregorianCalendar")) {
				defaultVal = "javax.xml.datatype.DatatypeFactory.newInstance().newXMLGregorianCalendar(new java.util.GregorianCalendar())";
			}
			if (c != null && c.isEnum()) {
				defaultVal = Common.getEnumCreateStr(c);
			}
			if (defaultVal == null && c != null) {
				defaultVal = getInstanceName(c);
			}
		}
		return defaultVal;
	}
	public static int getArrayDemension(Class<?> ptype) throws Exception {
		boolean b = ptype.isArray();
		int m = -1;
		if (b) {
			m = 1;
			Class<?> componentType = ptype.getComponentType();
			while (componentType.isArray()) {
				componentType = componentType.getComponentType();
				m++;
			}
		} else {
			throw new Exception("Object is not an array instance");
		}
		return m;
	}
	public static String getArrayComponentTypeByrepstr(String str) {
		String type = null;
		if (str.trim().length() == 1) {
			char ch = str.charAt(0);
			switch (ch) {
			case 'D':
				type = "double";
				break;
			case 'F':
				type = "float";
				break;
			case 'S':
				type = "short";
				break;
			case 'B':
				type = "byte";
				break;
			case 'Z':
				type = "boolean";
				break;
			case 'I':
				type = "int";
				break;
			case 'C':
				type = "char";
				break;
			default:
				break;
			}
		} else {
			str = str.replaceFirst("L", "");
			str = str.replaceFirst(";", "");
			type = str;
		}
		return type;
	}
	public static String getArrayClzTypeJavaCode(Class c) {
		String realType = null;
		if (c.isArray()) {
			String s = c.toString();
			String sArray[] = s.split(" ");
			if (sArray.length > 0) {
				String strTmp = sArray[1];
				int d = 0;
				int i = 0;
				char[] ch = strTmp.toCharArray();
				for (; i < ch.length; i++) {
					if (ch[i] != '[') {
						break;
					}
				}
				d = i;
				StringBuilder sb = new StringBuilder();
				String repsentType = strTmp.substring(i);
				realType = getArrayComponentTypeByrepstr(repsentType);
				for (; d > 0; d--) {
					sb.append("[]");
				}
				realType = realType + sb.toString();
			} else {
			}
		}
		return realType;
	}
	private static String getArrayComponentTypeJavaName(Class arrayClz) throws Exception {
		boolean b = arrayClz.isArray();
		Class<?> componentType = null;
		if (b) {
			componentType = arrayClz.getComponentType();
			while (componentType.isArray()) {
				componentType = componentType.getComponentType();
			}
		} else {
			throw new Exception("Object is not an array instance");
		}
		String str = componentType.getName();
		return str;
	}
	private static String getIntArrayInitJavaCode(int length) {
		StringBuilder sb = new StringBuilder();
		for (int i = 0; i < length; i++) {
			sb.append(1).append(",");
		}
		if (length > 0) {
			sb.delete(sb.length() - 1, sb.length());
		}
		return sb.toString();
	}
	public static String getDefaultVal(Class c) {
		String defaultVal = null;
		if (c != null) {
			if (c.isArray()) {
				int dn;
				try {
					dn = getArrayDemension(c);
					String arrayDimensionJavaCode = getIntArrayInitJavaCode(dn);
					String arrayComponentTypeName = getArrayComponentTypeJavaName(c);
					defaultVal = "(" + getArrayClzTypeJavaCode(c) + ")Array.newInstance(" + arrayComponentTypeName
							+ ".class ," + arrayDimensionJavaCode + ")";
				} catch (Exception e) {
					defaultVal = "null";
				}
			}
			String typeName = c.getName();
			if (typeName.equals("java.lang.Object")) {
				defaultVal = "new Object()";
			}
			if (typeName.equals("java.lang.String")) {
				defaultVal = "\"\"";
			}
			if (typeName.equals("java.lang.Boolean") || typeName.equals("boolean")) {
				defaultVal = "false";
			}
			if (typeName.equals("java.lang.Long") || typeName.equals("long")) {
				defaultVal = "1L";
			}
			if (typeName.equals("java.lang.Double") || typeName.equals("double")) {
				defaultVal = "1d";
			}
			if (typeName.equals("java.lang.Integer") || typeName.equals("int")) {
				defaultVal = "1";
			}
			if (typeName.equals("java.lang.Short") || typeName.equals("short")) {
				defaultVal = "(short)1";
			}
			if (typeName.equals("java.lang.Float") || typeName.equals("float")) {
				defaultVal = "1f";
			}
			if (typeName.equals("java.lang.Byte") || typeName.equals("byte")) {
				defaultVal = "(byte)1";
			}
			if (typeName.equals("java.lang.Character") || typeName.equals("char")) {
				defaultVal = "'a'";
			}
			if (typeName.equals("java.util.Date")) {
				defaultVal = "new java.util.Date()";
			}
			if (typeName.equals("java.sql.Date") || typeName.equals("java.sql.Timestamp")) {
				defaultVal = "new " + c.getName() + "(new java.util.Date().getTime())";
			}
			if (typeName.startsWith("java.util.Map")) {
				defaultVal = "new java.util.HashMap()";
			}
			if (typeName.startsWith("java.util.Set")) {
				defaultVal = "new java.util.HashSet()";
			}
			if (typeName.equals("java.math.BigInteger")) {
				defaultVal = "java.math.BigInteger.valueOf(1)";
			}
			if (typeName.equals("java.math.BigDecimal")) {
				defaultVal = "java.math.BigDecimal.valueOf(0)";
			}
			if (typeName.equals("javax.xml.datatype.XMLGregorianCalendar")) {
				defaultVal = "javax.xml.datatype.DatatypeFactory.newInstance().newXMLGregorianCalendar(new java.util.GregorianCalendar())";
			}
			if (c != null && c.isEnum()) {
				defaultVal = getEnumCreateStr(c);
			}
			if (defaultVal == null && c != null) {
				defaultVal = getInstanceName(c);
			}
		}
		return defaultVal;
	}
	public static String getEnumCreateStr(Class c) {
		StringBuilder sb = new StringBuilder();
		String classNameForPrint = c.getName().replaceAll("\\$", "\\.");
		Object obj[] = c.getEnumConstants();
		sb.append(classNameForPrint).append(".").append(obj[0].toString());
		return sb.toString();
	}
	public static boolean isPrimitiveType(Class c) {
		return !isComplexType(c);
	}
	public static boolean isComplexType(Class c) {
		boolean b = false;
		if (c.isPrimitive() || c.isEnum()) {
			return b;
		}
		if (c.isArray()) {
			c = c.getComponentType();
		}
		String typeName = c.getName();
		if (typeName.equals("java.lang.Object")) {
			return b;
		}
		if (typeName.equals("java.lang.String") || typeName.equals("java.lang.StringBuilder")
				|| typeName.equals("java.lang.StringBuffer")) {
			return b;
		}
		if (typeName.equals("java.lang.Boolean") || typeName.equals("boolean")) {
			return b;
		}
		if (typeName.equals("java.lang.Character") || typeName.equals("char")) {
			return b;
		}
		if (typeName.equals("java.lang.Long") || typeName.equals("long")) {
			return b;
		}
		if (typeName.equals("java.lang.Double") || typeName.equals("double")) {
			return b;
		}
		if (typeName.equals("java.lang.Integer") || typeName.equals("int")) {
			return b;
		}
		if (typeName.equals("java.lang.Short") || typeName.equals("short")) {
			return b;
		}
		if (typeName.equals("java.lang.Float") || typeName.equals("float")) {
			return b;
		}
		if (typeName.equals("java.lang.Byte") || typeName.equals("byte")) {
			return b;
		}
		if (typeName.equals("java.util.Date") || typeName.equals("java.sql.Date")
				|| typeName.equals("java.sql.Timestamp")) {
			return b;
		}
		if (typeName.equals("java.math.BigInteger")) {
			return b;
		}
		if (typeName.equals("java.math.BigDecimal")) {
			return b;
		}
		if (typeName.equals("javax.xml.datatype.XMLGregorianCalendar")) {
			return b;
		}
		b = true;
		return b;
	}
	public static Method[] getAllDeclaredPublicMethodsForTest(Class clzToTest) {
		Method ms[] = clzToTest.getDeclaredMethods();
		List<Method> list = Arrays.asList(ms);
		list = list.stream().filter(m -> {
			if (Modifier.isPublic(m.getModifiers()) && !m.isBridge()) {
				return true;
			}
			return false;
		}).collect(Collectors.toList());
		int mc = list.size();
		Method publicMethods[] = new Method[mc];
		return list.toArray(publicMethods);
	}
	public static Method[] getAllPublicMethods(Class clzToTest) {
		Method ms[] = clzToTest.getMethods();
		List<Method> list = Arrays.asList(ms);
		list = list.stream().filter(m -> {
			if (Modifier.isPublic(m.getModifiers())) {
				return true;
			}
			return false;
		}).collect(Collectors.toList());
		int mc = list.size();
		Method publicMethods[] = new Method[mc];
		return list.toArray(publicMethods);
	}
	public static List<Method> getAllMethodList(Class c) {
		Method ms[] = c.getMethods();
		Method dms[] = c.getDeclaredMethods();
		Method allM[] = new Method[ms.length + dms.length];
		System.arraycopy(ms, 0, allM, 0, ms.length);
		System.arraycopy(dms, 0, allM, ms.length, dms.length);
		List<Method> list = Arrays.asList(allM);
		return list;
	}
	public static Method[] getAllMethods(Class c) {
		Method ms[] = c.getMethods();
		Method dms[] = c.getDeclaredMethods();
		Method allM[] = new Method[ms.length + dms.length];
		System.arraycopy(ms, 0, allM, 0, ms.length);
		System.arraycopy(dms, 0, allM, ms.length, dms.length);
		List<Method> list = Arrays.asList(allM);
		list = list.stream().distinct().collect(Collectors.toList());
		int mc = list.size();
		Method publicMethods[] = new Method[mc];
		return list.toArray(publicMethods);
	}
	public static String[] getAllMethodsAndConstructorStr(Class<?> c) {
		List<Method> mlist = new ArrayList<>();
		List<String> list = new ArrayList<>();
		Constructor[] cs = c.getConstructors();
		for(Constructor cn : cs) {
			list.add(cn.toGenericString());
		}
		mlist.addAll(Arrays.asList(getAllMethods(c)));
		for(Method m : mlist) {
			list.add(m.toGenericString());
		}
		String publicMethods[] = new String[list.size()];
		return list.toArray(publicMethods);
	}
	public static List<String> getAllMethodQualifiers(Class<?> c) {
		List<Method> mlist = Arrays.asList(getAllMethods(c));
		List<String> list = new ArrayList<>();
		for(Method m : mlist) {
			list.add(m.toString());
		}
		return list;
	}
	public static void getAllClzAnnotation(Class<?> c, List<Annotation> list) {
		list.addAll(Arrays.asList(c.getAnnotations()));
		Class<?> superC = c.getSuperclass();
		if (superC != null) {
			getAllClzAnnotation(superC, list);
		}
	}
	public static boolean isClassArray(Class c) {
		boolean b = false;
		if (c.isArray() && c.getComponentType() == Class.class) {
			b = true;
		}
		return b;
	}
	public static boolean isVoid(Method m) {
		boolean b = false;
		Class c = m.getReturnType();
		if (c.equals(Void.TYPE)) {
			b = true;
		}
		return b;
	}
	public static boolean isStatic(Method m) {
		boolean b = false;
		if ((m.getModifiers() & Modifier.STATIC) == Modifier.STATIC) {
			b = true;
		}
		return b;
	}
	public static boolean isAbstract(Method m) {
		boolean abs = false;
		if ((m.getModifiers() & Modifier.ABSTRACT) == Modifier.ABSTRACT) {
			abs = true;
		}
		return abs;
	}
	public static boolean isAbstractOrInterface(Class clzToTest) {
		boolean abs = false;
		if (clzToTest.isInterface() || isAbstract(clzToTest)) {
			abs = true;
		}
		return abs;
	}
	public static boolean isAbstract(Class clzToTest) {
		boolean abs = false;
		if ((clzToTest.getModifiers() & Modifier.ABSTRACT) == Modifier.ABSTRACT) {
			abs = true;
		}
		return abs;
	}
	public static boolean isFinal(Field f) {
		boolean abs = false;
		if ((f.getModifiers() & Modifier.FINAL) == Modifier.FINAL) {
			abs = true;
		}
		return abs;
	}
	public static Map<String, String> createVariableMap() {
		Map<String, String> variableMap = new HashMap<>();
		variableMap.put(Replacement.ASSIGN_SYMBOL.name(), Syntax.ASSIGN_SYMBOL);
		variableMap.put(Replacement.END_OF_LINE.name(), Syntax.END_OF_LINE);
		variableMap.put(Replacement.NEW_LINE.name(), Syntax.NEW_LINE);
		variableMap.put(Replacement.CLASS_END_LINE.name(), Syntax.CLASS_END_LINE);
		return variableMap;
	}
	public static String replaceAllKeyWord(String syntax, Map<String, String> variableMap) throws Exception {
		String str = syntax;
		Iterator<Entry<String, String>> it = variableMap.entrySet().iterator();
		Entry<String, String> entry;
		while (it.hasNext()) {
			entry = it.next();
			String key = "\\" + Syntax.REFERENCE_SYMBOL + entry.getKey() + "\\" + Syntax.REFERENCE_SYMBOL;
			boolean replaceAble = true;
			if (entry.getValue() == null) {
				System.out.println("stopping");
				replaceAble = false;
			}
			if (replaceAble) {
				String replacement = null;
				try {
					replacement = replacePlaceHolder(entry.getValue(), variableMap);
					if (replacement.indexOf("$") != -1) {
						replacement = Matcher.quoteReplacement(replacement);
					}
					/*
					 * if(key.indexOf("$")!=-1){ key = Pattern.quote(key); }
					 */
					str = str.replaceAll(key, replacement);
				} catch (Exception e) {
					System.out.println(String.format("key=%s,replacement=%s,keyQuote=%s,replacementQuote=%s", key,
							replacement, Pattern.quote(key), Matcher.quoteReplacement(replacement)));
					e.printStackTrace();
				}
			}
		}
		return str;
	}
	private static String replacePlaceHolder(String strContainPlaceHolder, Map<String, String> variableMap) {
		if (strContainPlaceHolder.indexOf("${") != -1) {
			Pattern p = Pattern.compile("\\$\\{[\\w\\.\\(\\)]+\\}");
			Matcher m = p.matcher(strContainPlaceHolder);
			if (m.find()) {
				String value = null;
				if (m.groupCount() >= 1) {
					value = m.group(1);
				} else {
					value = m.group();
				}
				try {
					String keyname = value.substring(2, value.length() - 1);
					if (variableMap.containsKey(keyname)) {
						String regex = "\\" + Syntax.REFERENCE_SYMBOL + "\\{" + keyname + "\\}";
						strContainPlaceHolder = strContainPlaceHolder.replaceFirst(regex, variableMap.get(keyname));
					} else {
						return strContainPlaceHolder;
					}
				} catch (IndexOutOfBoundsException e) {
					return strContainPlaceHolder;
				}
				if (strContainPlaceHolder.indexOf("${") != -1) {
					return replacePlaceHolder(strContainPlaceHolder, variableMap);
				} else {
					return strContainPlaceHolder;
				}
			}
		}
		return strContainPlaceHolder;
	}
	public static String genPackage(Class clzToTest, Map<String, String> variableMap) throws Exception {
		variableMap.put(Replacement.PACKAGE_NAME.name(), clzToTest.getPackage().getName());
		String packageStr = Common.replaceAllKeyWord(Syntax.PACKAGE_DECLARE, variableMap);
		return packageStr;
	}
	public static String genMockClassBegin(Class clzToTest, CodeGenContext context) throws Exception {
		String className = clzToTest.getSimpleName();
		context.getVariableMap().put(Replacement.TMP_CLASS_NAME.name(), className + "Mock");
		String beginstr = Common.replaceAllKeyWord(Syntax.CLASS_BEGIN_LINE, context.getVariableMap());
		return beginstr;
	}
	public static String genClassBegin(Class clzToTest, Map<String, String> variableMap) throws Exception {
		String className = clzToTest.getSimpleName();
		variableMap.put(Replacement.TMP_CLASS_NAME.name(), className);
		String beginstr = Common.replaceAllKeyWord(Syntax.CLASS_BEGIN_LINE, variableMap);
		return beginstr;
	}
	public static String genUnitTestMatchersMethodParamsVariable(Map<String, String> variableMap, Class... cs)
			throws Exception {
		List<String> strList = new ArrayList<>();
		for (Class c : cs) {
			String matchStr = null;
			if (isComplexType(c)) {
				variableMap.put(Replacement.TMP_CLASS_NAME.name(), c.getSimpleName());
				matchStr = Common.replaceAllKeyWord(Syntax.ANY_OF_CLASS_MATCH, variableMap);
			} else {
				matchStr = Common.replaceAllKeyWord(Syntax.ANY_MATCH, variableMap);
			}
			strList.add(matchStr);
		}
		String strArray[] = new String[strList.size()];
		strArray = strList.toArray(strArray);
		return genMethodParamsVariable(strArray);
	}
	public static String genMethodParamsVariable(String... strings) {
		StringBuilder sb = new StringBuilder();
		for (String p : strings) {
			sb.append(p).append(", ");
		}
		if (sb.length() > 0) {
			sb.delete(sb.length() - 2, sb.length());
		}
		return sb.toString();
	}
	public static String genMethodParamsDeclaration(Class... cs) {
		StringBuilder sb = new StringBuilder();
		for (Class p : cs == null ? new Class[] {} : cs) {
			sb.append(p.getSimpleName()).append(" ").append(Common.getInstanceName(p)).append(", ");
		}
		if (sb.length() > 0) {
			sb.delete(sb.length() - 2, sb.length());
		}
		return sb.toString();
	}
	public static String genExceptionThrows(Class<? extends Exception>... cs) {
		StringBuilder sb = new StringBuilder();
		for (Class p : cs == null ? new Class[] {} : cs) {
			sb.append(p.getSimpleName()).append(", ");
		}
		if (sb.length() > 0) {
			sb.insert(0, "throws ");
			sb.delete(sb.length() - 2, sb.length());
		}
		return sb.toString();
	}
	public static String genMethodParamDeclareVariable(Entry<Class, String>... params) {
		if (params == null || params.length == 0) {
			return "";
		}
		StringBuilder sb = new StringBuilder();
		for (Entry<Class, String> e : params) {
			sb.append(e.getKey().getSimpleName()).append("  ").append(e.getValue()).append(", ");
		}
		if (sb.length() > 0) {
			sb.delete(sb.length() - 2, sb.length());
		}
		return sb.toString();
	}
	public static String genimportStr(List<Class> alreadyImportClasses, Map<String, String> variableMap,
			Class... clzToImport) throws Exception {
		StringBuilder sb = new StringBuilder();
		for (Class c : clzToImport) {
			String str = genimportStr(c, alreadyImportClasses, variableMap);
			if (!"".equals(str)) {
				sb.append(str).append(Syntax.NEW_LINE);
			}
		}
		return sb.toString();
	}
	public static void importPack(String packageName, Map<String, String> variableMap, StringBuilder importBuilder)
			throws Exception {
		variableMap.put(Replacement.QUALIFIER.name(), packageName);
		String importStr = Common.replaceAllKeyWord(Syntax.IMPORT_LINE, variableMap);
		importBuilder.append(importStr);
	}
	@Deprecated
	public static void importC(Class clzToImport, List<Class> alreadyImportClasses, Map<String, String> variableMap,
			StringBuilder importBuilder) throws Exception {
		String str = genimportStr(clzToImport, alreadyImportClasses, variableMap);
		if (!"".equals(str)) {
			importBuilder.append(str).append(Syntax.NEW_LINE);
		}
	}
	public static void importC(Class[] classesToImport, CodeGenContext context) throws Exception {
		for (Class p : classesToImport) {
			String str = genimportStr(p, context.getAlreadyImportClasses(), context.getVariableMap());
			if (!"".equals(str)) {
				context.getImportSB().append(str).append(Syntax.NEW_LINE);
			}
		}
	}
	public static void importC(Class clzToImport, CodeGenContext context) throws Exception {
		String str = genimportStr(clzToImport, context.getAlreadyImportClasses(), context.getVariableMap());
		if (!"".equals(str)) {
			context.getImportSB().append(str).append(Syntax.NEW_LINE);
		}
	}
	public static String genimportStr(Class clzToImport, List<Class> alreadyImportClasses,
			Map<String, String> variableMap) throws Exception {
		if (clzToImport.isArray()) {
			clzToImport = clzToImport.getComponentType();
		}
		if (clzToImport.getName().startsWith("java.lang")) {
			String name = clzToImport.getName();
			String packageFragement[] = name.split("\\.");
			if (packageFragement.length == 3)
				return "";
		}
		if (clzToImport.isPrimitive()) {
			return "";
		}
		if (alreadyImportClasses.contains(clzToImport)) {
			return "";
		}
		boolean ambiguousClass = isSameSimpleNameClassImported(clzToImport, alreadyImportClasses);
		if (!ambiguousClass) {
			String className = clzToImport.getName();
			if (clzToImport.getEnclosingClass() != null) {
				className = className.replaceAll("\\$", "\\.");
			}
			variableMap.put(Replacement.QUALIFIER.name(), className);
			String importStr = Common.replaceAllKeyWord(Syntax.IMPORT_LINE, variableMap);
			alreadyImportClasses.add(clzToImport);
			return importStr;
		}
		return "";
	}
	private static boolean isSameSimpleNameClassImported(Class c, List<Class> alreadyImportClasses) {
		boolean b = alreadyImportClasses.stream().anyMatch(a -> {
			String simpleName = c.getSimpleName();
			String existingSimpleName = a.getSimpleName();
			if (existingSimpleName.equals(simpleName))
				return true;
			else
				return false;
		});
		return b;
	}
	@Deprecated
	public static String genImportByQualifier(String qualifier, List<Class> alreadyImportClasses,
			Map<String, String> variableMap) throws Exception {
		Class c = null;
		try {
			c = CodeGenContext.getInstance().getReloadableDynamicClassLoaderOwner().loadClass(qualifier, true);
		} catch (Exception e) {
		}
		if (c != null) {
			return genimportStr(c, alreadyImportClasses, variableMap);
		} else {
			return "";
		}
	}
	public static String genImportByQualifier(String qualifier, CodeGenContext context) throws Exception {
		Class c = null;
		try {
			c = CodeGenContext.getInstance().getReloadableDynamicClassLoaderOwner().loadClass(qualifier, true);
		} catch (Exception e) {
		}
		if (c != null) {
			return genimportStr(c, context.getAlreadyImportClasses(), context.getVariableMap());
		} else {
			return "";
		}
	}
	@Deprecated
	public static String initAClass1(Class c, Map<String, String> variableMap, Map<Class, String> classSimpleNameMap)
			throws Exception {
		return initAClass1(c, null, variableMap, classSimpleNameMap);
	}
	@Deprecated
	public static String initAClass1(Class c, String instanceName, Map<String, String> variableMap,
			Map<Class, String> classSimpleNameMap) throws Exception {
		StringBuilder sb = new StringBuilder();
		if (Common.hasDefaultConstruct(c)) {
			variableMap.put(Replacement.TMP_CLASS_NAME.name(), getClassName1(c, classSimpleNameMap));
			variableMap.put(Replacement.TMP_INSTANCE_NAME.name(),
					instanceName != null ? instanceName : Common.getInstanceName(c));
			String instanceLine = Common.replaceAllKeyWord(Syntax.NEW_INSTANCE_LINE, variableMap);
			sb.append(instanceLine);
		} else {
			String defaultValue = getDefaultVal(c);
			variableMap.put(Replacement.DEFAULT_VALUE.name(), defaultValue);
			variableMap.put(Replacement.TMP_INSTANCE_NAME.name(),
					instanceName != null ? instanceName : Common.getInstanceName(c));
			String initLine = Common.replaceAllKeyWord(Syntax.INIT_CLASS_WITH_DEFAULT_VALUE, variableMap);
			sb.append(initLine);
		}
		return sb.toString();
	}
	public static String initAClass(Class c, CodeGenContext context) throws Exception {
		return initAClass(c, null, context);
	}
	public static String initAClass(Class c, String instanceName, CodeGenContext context) throws Exception {
		return initAClass(c, instanceName, false, context);
	}
	public static String initAClass(Class c, Constructor ct, String instanceName, boolean hasClassNameDeclare,
			CodeGenContext context) throws Exception {
		StringBuilder sb = new StringBuilder();
		if (context.getAbstractConcreteClassMap().get(c) != null) {
			AbstractConcreteClassMapping acMap = context.getAbstractConcreteClassMap().get(c);
			if (hasClassNameDeclare) {
				context.getVariableMap().put(Replacement.SEPERATOR.name(), " ");
				context.getVariableMap().put(Replacement.ABSTRACT_CLASS_NAME.name(), getClassName(c, context));
			} else {
				context.getVariableMap().put(Replacement.ABSTRACT_CLASS_NAME.name(), "");
				context.getVariableMap().put(Replacement.SEPERATOR.name(), "");
			}
			if (instanceName == null) {
				instanceName = acMap.getAbstractClassInstanceName();
				if (instanceName == null) {
					instanceName = Common.getInstanceName(acMap.getAbstractClass());
				}
			}
			context.getVariableMap().put(Replacement.ABSTRACT_INSTANCE_NAME.name(), instanceName);
			context.getVariableMap().put(Replacement.TMP_CLASS_NAME.name(),
					getClassName(acMap.getConcreteClass(), context));
			String initLine = null;
			if (acMap.getConcreteCFactoryMethod() != null) {
				context.getVariableMap().put(Replacement.METHOD_NAME.name(),
						acMap.getConcreteCFactoryMethod().getName());
				if (acMap.getConcreteCFactoryMethod().getParameterCount() > 0) {
					context.getVariableMap().put(Replacement.METHOD_PARAMS_VARIABLE.name(),
							Common.genMethodParamsVariable(acMap.getMethodParamVariables()));
				} else {
					context.getVariableMap().put(Replacement.METHOD_PARAMS_VARIABLE.name(), "");
				}
				initLine = Common.replaceAllKeyWord(Syntax.INIT_CLASS_WITH_CONCRETE_LINE, context.getVariableMap());
			} else {
				if (c.isInterface()) {
					Class concreteClass = acMap.getConcreteClass();
					if (Common.hasConstruct(concreteClass)) {
						if (Common.hasDefaultConstruct(concreteClass)) {
							context.getVariableMap().put(Replacement.METHOD_PARAMS_VARIABLE.name(), "");
							initLine = Common.replaceAllKeyWord(Syntax.ABSTRACT_NEW_INSTANCE_LINE_WITH_DECLARE_OR_NOT,
									context.getVariableMap());
						} else {
							ct = ct == null ? Common.tryGetConstructorHasPrimitiveParam(concreteClass) : ct;
							List<String> params = new ArrayList<>();
							if (ct != null) {
								Class cts[] = ct.getParameterTypes();
								for (Class pt : cts) {
									String dv = Common.getDefaultVal(pt);
									params.add(dv);
								}
							} else {
								ct = concreteClass.getConstructors()[0];
								Parameter pts[] = ct.getParameters();
								for (Parameter p : pts) {
									params.add(p.getName());
								}
							}
							String paramArray[] = params.toArray(new String[params.size()]);
							context.getVariableMap().put(Replacement.METHOD_PARAMS_VARIABLE.name(),
									Common.genMethodParamsVariable(paramArray));
							initLine = Common.replaceAllKeyWord(Syntax.ABSTRACT_NEW_INSTANCE_LINE_WITH_DECLARE_OR_NOT,
									context.getVariableMap());
						}
					}
				}
			}
			sb.append(initLine);
			Common.importC(acMap.getConcreteClass(), context);
		} else {
			Class concreteClass = null;
			if (c.isInterface()) {
				concreteClass = getDefaultConcreteClass(c);
			}
			if (Common.hasConstruct(c) || (concreteClass != null && Common.hasConstruct(concreteClass))) {
				if (hasClassNameDeclare) {
					context.getVariableMap().put(Replacement.SEPERATOR.name(), " ");
					context.getVariableMap().put(Replacement.ABSTRACT_CLASS_NAME.name(), getClassName(c, context));
					context.getVariableMap().put(Replacement.TMP_CLASS_NAME.name(),
							getClassName(c.isInterface() ? concreteClass : c, context));
					context.getVariableMap().put(Replacement.ABSTRACT_INSTANCE_NAME.name(),
							instanceName != null ? instanceName : Common.getInstanceName(c));
					if (Common.hasDefaultConstruct(c)
							|| (concreteClass != null && Common.hasConstruct(concreteClass))) {
						context.getVariableMap().put(Replacement.METHOD_PARAMS_VARIABLE.name(), "");
						String instanceLine = Common.replaceAllKeyWord(
								Syntax.ABSTRACT_NEW_INSTANCE_LINE_WITH_DECLARE_OR_NOT, context.getVariableMap());
						sb.append(instanceLine);
					} else {
						ct = ct == null
								? Common.tryGetConstructorHasPrimitiveParam(!c.isInterface() ? c : concreteClass)
								: ct;
						List<String> params = new ArrayList<>();
						if (ct != null) {
							Class cts[] = ct.getParameterTypes();
							for (Class pt : cts) {
								String dv = Common.getDefaultVal(pt);
								params.add(dv);
							}
						} else {
							ct = !c.isInterface() ? c.getConstructors()[0] : concreteClass.getConstructors()[0];
							Parameter pts[] = ct.getParameters();
							for (Parameter p : pts) {
								params.add(p.getName());
							}
						}
						String paramArray[] = params.toArray(new String[params.size()]);
						context.getVariableMap().put(Replacement.METHOD_PARAMS_VARIABLE.name(),
								Common.genMethodParamsVariable(paramArray));
						String instanceLine = Common.replaceAllKeyWord(
								Syntax.ABSTRACT_NEW_INSTANCE_LINE_WITH_DECLARE_OR_NOT, context.getVariableMap());
						sb.append(instanceLine);
					}
				} else {
					context.getVariableMap().put(Replacement.TMP_CLASS_NAME.name(),
							getClassName(c.isInterface() ? concreteClass : c, context));
					context.getVariableMap().put(Replacement.TMP_INSTANCE_NAME.name(),
							instanceName != null ? instanceName : Common.getInstanceName(c));
					String instanceLine = Common.replaceAllKeyWord(Syntax.NEW_INSTANCE_LINE, context.getVariableMap());
					sb.append(instanceLine);
				}
			} else {
				String defaultValue = getDefaultVal(c);
				context.getVariableMap().put(Replacement.DEFAULT_VALUE.name(), defaultValue);
				context.getVariableMap().put(Replacement.TMP_INSTANCE_NAME.name(),
						instanceName != null ? instanceName : Common.getInstanceName(c));
				if (hasClassNameDeclare) {
					context.getVariableMap().put(Replacement.SEPERATOR.name(), " ");
					context.getVariableMap().put(Replacement.TMP_CLASS_NAME.name(), c.getSimpleName());
				} else {
					context.getVariableMap().put(Replacement.SEPERATOR.name(), "");
					context.getVariableMap().put(Replacement.TMP_CLASS_NAME.name(), "");
				}
				String initLine = Common.replaceAllKeyWord(Syntax.INIT_CLASS_WITH_DEFAULT_VALUE,
						context.getVariableMap());
				sb.append(initLine);
			}
		}
		return sb.toString();
	}
	public static String initAClass(Class c, String instanceName, boolean hasClassNameDeclare, CodeGenContext context)
			throws Exception {
		return initAClass(c, null, instanceName, hasClassNameDeclare, context);
	}
	public static Constructor tryGetConstructorHasPrimitiveParam(Class c) {
		Constructor ct = null;
		Constructor[] cc = c.getConstructors();
		for (Constructor cte : cc) {
			boolean allPrimitiveTypes = true;
			Class pts[] = cte.getParameterTypes();
			for (Class p : pts) {
				if (Common.isComplexType(p)) {
					allPrimitiveTypes = false;
				}
			}
			if (allPrimitiveTypes) {
				ct = cte;
			}
		}
		return ct;
	}
	public static boolean hasConstruct(Class c) {
		boolean b = false;
		Constructor[] cc = c.getConstructors();
		b = cc.length > 0 ? true : false;
		return b;
	}
	public static boolean hasDefaultConstruct(Class c) {
		boolean b = false;
		Constructor[] cc = c.getConstructors();
		for (Constructor cons : cc) {
			if (cons.getParameterCount() == 0) {
				b = true;
				break;
			}
		}
		return b;
	}
	public static String getDefaultCreateMethodName(Class c) {
		String defaultCreateMethodName = "create" + c.getSimpleName();
		return defaultCreateMethodName;
	}
	@Deprecated
	public static String getComplexTypeCreateMethodName(Class target, List<String> createdMethodName) {
		String methodName = "create" + target.getSimpleName();
		int sameMethodNameCound = 0;
		for (String name : createdMethodName) {
			Pattern p = Pattern.compile(methodName + "(\\d*)");
			Matcher m = p.matcher(name);
			if (m.find()) {
				String methodNameIndex = m.group(1);
				if (methodNameIndex != null && !"".equals(methodNameIndex.trim())) {
					try {
						sameMethodNameCound = Integer.valueOf(methodNameIndex);
					} catch (Exception e) {
						throw e;
					}
				}
				sameMethodNameCound++;
			}
		}
		if (sameMethodNameCound > 0)
			methodName = methodName + sameMethodNameCound;
		return methodName;
	}
	public static String getComplexTypeCreateMethodName(Class target, CodeGenContext context) {
		String methodName = "create" + target.getSimpleName();
		int sameMethodNameCound = 0;
		for (String name : context.getCreatedMethodName()) {
			Pattern p = Pattern.compile(methodName + "(\\d*)");
			Matcher m = p.matcher(name);
			if (m.find()) {
				String methodNameIndex = m.group(1);
				if (methodNameIndex != null && !"".equals(methodNameIndex.trim())) {
					try {
						sameMethodNameCound = Integer.valueOf(methodNameIndex);
					} catch (Exception e) {
						throw e;
					}
				}
				sameMethodNameCound++;
			}
		}
		if (sameMethodNameCound > 0)
			methodName = methodName + sameMethodNameCound;
		return methodName;
	}
	public static String getMethodName(String rootMethodName, CodeGenContext context) {
		String methodName = rootMethodName;
		int sameMethodNameCound = 0;
		for (String name : context.getCreatedMethodName()) {
			Pattern p = Pattern.compile(methodName + "(\\d*)");
			Matcher m = p.matcher(name);
			if (m.find()) {
				String methodNameIndex = m.group(1);
				if (methodNameIndex != null && !"".equals(methodNameIndex.trim())) {
					try {
						sameMethodNameCound = Integer.valueOf(methodNameIndex);
					} catch (Exception e) {
						throw e;
					}
				}
				sameMethodNameCound++;
			}
		}
		if (sameMethodNameCound > 0)
			methodName = methodName + sameMethodNameCound;
		return methodName;
	}
	public static String getDefaultMockClassName(Class c, CodeGenContext context) {
		return c.getName() + "Mock";
	}
	public static String getClassName(Class c, CodeGenContext context) {
		String name = null;
		Map<Class, String> classSimpleName = context.getClassSimpleNameMap();
		if (!classSimpleName.containsKey(c)) {
			boolean ambiguousClass = false;
			ambiguousClass = classSimpleName.entrySet().stream().anyMatch(e -> {
				if (c.getSimpleName().equals(e.getValue().trim())) {
					return true;
				}
				return false;
			});
			if ((context != null && context.isGenFullQualifierName()) || ambiguousClass) {
				classSimpleName.put(c, c.getName());
			} else {
				classSimpleName.put(c, c.getSimpleName());
			}
		}
		name = classSimpleName.get(c);
		return name;
	}
	@Deprecated
	/**
	 * use getClassName(Class c, CodeGenContext context) instead
	 *
	 * @param c
	 * @param classSimpleName
	 * @return
	 */
	public static String getClassName1(Class c, Map<Class, String> classSimpleName) {
		String name = null;
		if (!classSimpleName.containsKey(c)) {
			boolean ambiguousClass = false;
			ambiguousClass = classSimpleName.entrySet().stream().anyMatch(e -> {
				if (c.getSimpleName().equals(e.getValue().trim())) {
					return true;
				}
				return false;
			});
			if (ambiguousClass) {
				classSimpleName.put(c, c.getName());
			} else {
				classSimpleName.put(c, c.getSimpleName());
			}
		}
		name = classSimpleName.get(c);
		return name;
	}
	public static Class getConcreteClass(Class c, CodeGenContext context) {
		Class concreteClass = c;
		if (context.getAbstractConcreteClassMap().get(c) != null) {
			AbstractConcreteClassMapping acMap = context.getAbstractConcreteClassMap().get(c);
			concreteClass = acMap.getConcreteClass();
		} else if (c.isInterface() || Common.isAbstract(c)) {
			concreteClass = getDefaultConcreteClass(c);
		}
		return concreteClass;
	}
	public static Class[] getConcreteClass(Class cs[], CodeGenContext context) {
		Class ccs[] = null;
		List<Class> list = new ArrayList<>();
		for (Class c : cs) {
			Class cc = getConcreteClass(c, context);
			if (cc != null) {
				list.add(cc);
			} else {
				System.out.println(String.format("cannot get concrete class for %s, return class itself", c.getName()));
				list.add(c);
			}
		}
		ccs = new Class[list.size()];
		return list.toArray(ccs);
	}
	public static boolean isBlank(String s) {
		return s == null || "".equals(s.trim());
	}
	public static Class getDefaultConcreteClass(Class interfaceC) {
		Class concreteC = null;
		if (!interfaceC.isInterface() && !isAbstract(interfaceC) && !interfaceC.isArray()) {
			return interfaceC;
		}
		if (List.class.isAssignableFrom(interfaceC) || AbstractList.class.isAssignableFrom(interfaceC)
				|| Collection.class == interfaceC) {
			concreteC = ArrayList.class;
		} else if (Map.class.isAssignableFrom(interfaceC) || AbstractMap.class.isAssignableFrom(interfaceC)) {
			concreteC = HashMap.class;
		} else if (Set.class.isAssignableFrom(interfaceC) || AbstractSet.class.isAssignableFrom(interfaceC)) {
			concreteC = HashSet.class;
		}
		return concreteC;
	}
	/*
	 * public static MethodCallingVariable
	 * genIfNotExistAndGetClassCreateMethod(Class c, Class genericTypes[], boolean
	 * forceGenerate,Map<MethodCallingKey, MethodCallingVariable>
	 * complexTypeCreateMapping, List<String> createdMethodName, Map<Class, String>
	 * classSimpleName, Map<String, String> variableMap) throws Exception{ Class
	 * concreteC = getDefaultConcreteClass(c); if(concreteC == null){ throw new
	 * Exception(String.format( "cannot get the concrete class for %s",
	 * c.getName())); } MethodCallingVariable mc = null; String
	 * defaultCreateMethodName = getDefaultCreateMethodName(c); MethodCallingKey
	 * defaultMethodCallingKey = new MethodCallingKey(c, defaultCreateMethodName);
	 * MethodCallingKey newMethodCallingKey = defaultMethodCallingKey;
	 * if(forceGenerate ||
	 * !complexTypeCreateMapping.containsKey(defaultMethodCallingKey)){ String
	 * methodBody = ObjSetCodeGenAfterCreateMethod.generateCode(concreteC,
	 * genericTypes); mc = new MethodCallingVariable(); mc.setC(c);
	 * mc.setMethodBody(methodBody); String methodName =
	 * getComplexTypeCreateMethodName(c, createdMethodName);
	 * mc.setMethodName(methodName); //mc.setParams(new Object[]{});
	 * newMethodCallingKey = new MethodCallingKey(c, methodName);
	 * complexTypeCreateMapping.put(newMethodCallingKey, mc);
	 * variableMap.put(Replacement.PRIVILEDGE_MODIFIER.name(), "private");
	 * if(!variableMap.containsKey(Replacement.STATIC_MODIFIER.name())){
	 * variableMap.put(Replacement.STATIC_MODIFIER.name(), ""); }
	 * variableMap.put(Replacement.METHOD_RETURN_TYPE.name(), getClassName(c,
	 * classSimpleName)); variableMap.put(Replacement.METHOD_NAME.name(),
	 * mc.getMethodName());
	 * variableMap.put(Replacement.METHOD_PARAMS_DECLARE.name(), "");
	 * variableMap.put(Replacement.METHOD_BODY.name(), mc.getMethodBody()); String
	 * instanceName = Common.getInstanceName(concreteC);
	 * variableMap.put(Replacement.METHOD_RETURN_VALUE.name(), instanceName); String
	 * createComplexTypeMethod = Common.replaceAllKeyWord(Syntax.NORMAL_METHOD,
	 * variableMap); mc.setMethodBlock(createComplexTypeMethod);
	 * createdMethodName.add(methodName); } mc =
	 * complexTypeCreateMapping.get(newMethodCallingKey); return mc; }
	 */
	/*
	 * public static MethodCallingVariable
	 * genIfNotExistAndGetClassCreateMethod(Class c, boolean
	 * forceGenerate,Map<MethodCallingKey, MethodCallingVariable>
	 * complexTypeCreateMapping, List<String> createdMethodName, Map<Class, String>
	 * classSimpleName, Map<String, String> variableMap) throws Exception{ return
	 * Common.genIfNotExistAndGetClassCreateMethod(c, null, forceGenerate,
	 * complexTypeCreateMapping, createdMethodName, classSimpleName, variableMap); }
	 */
	public static Class getGenericTypeIfOnlyOne(String typeName) {
		Class g = null;
		String genericType = null;
		int start = typeName.indexOf("<");
		int end = typeName.indexOf(">");
		genericType = typeName.substring(start + 1, end);
		try {
			g = CodeGenContext.getInstance().getReloadableDynamicClassLoaderOwner().loadClass(genericType, true);
		} catch (ClassNotFoundException e) {
			e.printStackTrace();
		}
		return g;
	}
	public static MethodCallingVariable genIfNotExistAndGetClassCreateMethod(Class c, boolean forceGenerate,
			CodeGenContext context) throws Exception {
		return genIfNotExistAndGetClassCreateMethod(c, null, forceGenerate, context);
	}
	public static MethodCallingVariable genIfNotExistAndGetClassCreateMethod(Class c, Class genericTypes[],
			boolean forceGenerate, CodeGenContext context) throws Exception {
		MethodCallingVariable mc = null;
		String defaultCreateMethodName = getDefaultCreateMethodName(c);
		MethodCallingKey defaultMethodCallingKey = new MethodCallingKey(c, defaultCreateMethodName);
		MethodCallingKey newMethodCallingKey = defaultMethodCallingKey;
		if (forceGenerate || !context.getComplexTypeCreateMapping().containsKey(defaultMethodCallingKey)) {
			Class concreteClass = c;
			if (context.getAbstractConcreteClassMap().get(c) != null) {
				AbstractConcreteClassMapping acMap = context.getAbstractConcreteClassMap().get(c);
				concreteClass = acMap.getConcreteClass();
			} else if (c.isInterface() || Common.isAbstract(c)) {
				concreteClass = getDefaultConcreteClass(c);
			}
			if (concreteClass == null) {
				System.out.println(String.format("cannot get concrete class for class %s null", c));
				return mc;
			}
			String methodBody = PojoSetterGenerator
					.generateCode(concreteClass, genericTypes, context);
			mc = new MethodCallingVariable();
			mc.setMethodBody(methodBody);
			String methodName = getComplexTypeCreateMethodName(concreteClass, context);
			mc.setMethodName(methodName);
			newMethodCallingKey = new MethodCallingKey(concreteClass, methodName);
			context.getComplexTypeCreateMapping().put(newMethodCallingKey, mc);
			context.getVariableMap().put(Replacement.METHOD_RETURN_TYPE.name(), Common.getClassName(c, context));
			context.getVariableMap().put(Replacement.METHOD_NAME.name(), mc.getMethodName());
			context.getVariableMap().put(Replacement.METHOD_PARAMS_DECLARE.name(), "");
			context.getVariableMap().put(Replacement.METHOD_BODY.name(), mc.getMethodBody());
			String instanceName = Common.getInstanceName(concreteClass);
			context.getVariableMap().put(Replacement.METHOD_RETURN_VALUE.name(), instanceName);
			context.getVariableMap().put(Replacement.THROWS_EXCEPTION.name(), "");
			String createComplexTypeMethod = Common.replaceAllKeyWord(Syntax.NORMAL_METHOD, context.getVariableMap());
			context.getCreatedComplexTypeMethod().append(createComplexTypeMethod).append(Syntax.NEW_LINE);
			context.getCreatedMethodName().add(methodName);
		}
		mc = context.getComplexTypeCreateMapping().get(newMethodCallingKey);
		return mc;
	}
	public static String readAsStr(File f) throws IOException {
		FileInputStream fis = new FileInputStream(f);
		return readAsStr(fis);
	}
	public static byte[] readAllInputStream(InputStream is) throws IOException {
		int nRead;
		ByteArrayOutputStream bao = new ByteArrayOutputStream();
		byte[] data = new byte[16384];
		while ((nRead = is.read(data, 0, data.length)) != -1) {
			bao.write(data, 0, nRead);
		}
		byte bArray[] = bao.toByteArray();
		return bArray;
	}
	public static String readAsStr(InputStream is) throws IOException {
		StringBuilder sb = new StringBuilder();
		BufferedReader in = null;
		try {
			in = new BufferedReader(new InputStreamReader(is));
			String line = null;
			while ((line = in.readLine()) != null) {
				sb.append(line).append("\r\n");
			}
		} catch (IOException e) {
			e.printStackTrace();
			throw e;
		} finally {
			if (in != null)
				try {
					in.close();
				} catch (IOException e) {
					e.printStackTrace();
				}
		}
		return sb.toString();
	}
	public static void write(File f, String fileStr) throws IOException {
		f.getParentFile().mkdirs();
		FileOutputStream fos = new FileOutputStream(f);
		fos.write(fileStr.getBytes());
		fos.flush();
		fos.close();
	}
	public static void writeInputStreamAllByte(InputStream is, OutputStream os) throws IOException {
		byte[] buffer = new byte[2048];
		int read = 0;
		while ((read = is.read(buffer)) != -1) {
			os.write(buffer, 0, read);
		}
		is.close();
		os.flush();
		os.close();
		return;
	}
	public static boolean isFunctionInterface(Class functionInterface) {
		boolean b = false;
		Method ms[] = Common.getInterfaceAbstractMethods(functionInterface);
		if (ms != null && ms.length == 1) {
			b = true;
		}
		return b;
	}
	public static Method[] getInterfaceAbstractMethods(Class functionInterface) {
		Method ms[] = null;
		if (functionInterface.isInterface()) {
			List<Method> list = Arrays.asList(Common.getAllDeclaredPublicMethodsForTest(functionInterface)).stream()
					.filter(m -> {
						return Common.isAbstract(m);
					}).collect(Collectors.toList());
			ms = list.toArray(new Method[list.size()]);
		}
		return ms;
	}
	public static String genFunctionImplementation(Class functionInterface, String... params) {
		StringBuilder sb = new StringBuilder();
		Method ms[] = Common.getInterfaceAbstractMethods(functionInterface);
		if (ms != null && ms.length == 1) {
			Method m = ms[0];
			String paramStr = Common.genMethodParamsVariable(params);
			sb.append("(").append(paramStr).append(")").append("{").append(Syntax.NEW_LINE);
			if (!Common.isVoid(m)) {
				sb.append("return ").append(Syntax.END_OF_LINE);
			}
			sb.append("}");
		}
		return sb.toString();
	}
	public static String getInstanceName(Class<?> rt, Map<Class<?>, Short> map) {
		short num;
		if (map.containsKey(rt)) {
			num = map.get(rt);
			num++;
		} else {
			num = 0;
		}
		map.put(rt, num);
		String name = Common.getInstanceName(rt) + (num == 0 ? "" : Short.toString(num));
		return name;
	}
	public static Class getClass(Type type) {
		if (type instanceof Class) {
			return (Class) type;
		} else if (type instanceof ParameterizedType) {
			return getClass(((ParameterizedType) type).getRawType());
		} else if (type instanceof GenericArrayType) {
			Type componentType = ((GenericArrayType) type).getGenericComponentType();
			Class componentC = getClass(componentType);
			if (componentC != null) {
				Object object = Array.newInstance(componentC, 0);
				return object.getClass();
			} else {
				return null;
			}
		} else {
			return null;
		}
	}
	public static <T> List<Class<?>> getTypeArguments(Class<T> baseClass, Class<? extends T> childClass) {
		Map<Type, Type> resolvedTypes = new HashMap<>();
		Type type = childClass;
		while (type != null && !getClass(type).equals(baseClass)) {
			if (type instanceof Class) {
				Class tc = (Class) type;
				Type itype[] = tc.getGenericInterfaces();
				type = itype[0];
			} else {
				ParameterizedType pt = (ParameterizedType) type;
				Type rawType = pt.getRawType();
				Class rawT = (Class) rawType;
				Type actualTypeArgs[] = pt.getActualTypeArguments();
				TypeVariable typeParams[] = rawT.getTypeParameters();
				for (int i = 0; i < actualTypeArgs.length; i++) {
					resolvedTypes.put(typeParams[i], actualTypeArgs[i]);
				}
				if (!rawT.equals(baseClass)) {
					type = rawT.getGenericSuperclass();
				} else {
				}
			}
		}
		Type actualTypeArgs[];
		if (type instanceof Class) {
			actualTypeArgs = ((Class) type).getTypeParameters();
		} else {
			actualTypeArgs = ((ParameterizedType) type).getActualTypeArguments();
		}
		List<Class<?>> list = new ArrayList<>();
		for (Type baseType : actualTypeArgs) {
			while (resolvedTypes.containsKey(baseType)) {
				baseType = resolvedTypes.get(baseType);
			}
			list.add(getClass(baseType));
		}
		return list;
	}
	public static List<Class<?>> getInterfaceGenericTypes(Class c) {
		List<Class<?>> list = new ArrayList<>();
		Type type = getClass(c);
		if (type instanceof Class) {
			Class tc = (Class) type;
			Type itypes[] = tc.getGenericInterfaces();
			for (Type t : itypes) {
				System.out.print(t.getTypeName());
				if (t instanceof ParameterizedType) {
					ParameterizedType pt = (ParameterizedType) t;
					Type ts[] = pt.getActualTypeArguments();
					for (Type t1 : ts) {
						if (t instanceof TypeVariable) {
							TypeVariable tv = (TypeVariable) t;
							System.out.print(tv.getName());
						} else {
							list.add(getClass(t1));
						}
					}
				}
			}
		}
		return list;
	}
	public Class[] getRepositorySuperClassActualParam(Class c) {
		Type t = c.getGenericSuperclass();
		if (t instanceof ParameterizedType) {
			ParameterizedType pt = (ParameterizedType) t;
			Type ts[] = pt.getActualTypeArguments();
			if (ts != null) {
				Class cces[] = new Class[ts.length];
				cces = Arrays.copyOf(ts, ts.length, Class[].class);
				return cces;
			} else {
				return null;
			}
		}
		return null;
	}
	public static int createRandom(int min, int max) {
		ThreadLocalRandom threadLocalRandom = ThreadLocalRandom.current();
		int i = threadLocalRandom.nextInt(min, max + 1);
		return i;
	}
	public static void main(String args[]) throws MalformedURLException {
		Common.getRunningJar();
		Map<String, String> variableMap = new HashMap<>();
		variableMap.put("abc", "handlerClass");
		variableMap.put("abc.11shandlerClass", "sss");
		System.out.println(int.class.getSimpleName());
		try {
			List<String> names = Common.getClassesNameFromJar(CodeGenContext.getInstance(), new URL[] {new URL("file://D:\\Java\\jdk1.8.0_131\\jre\\lib\\rt.jar")});
			StringBuilder sb = new StringBuilder();
			names = names.stream().filter(e -> e.startsWith("java.") || e.startsWith("org.") || e.startsWith("javax.")).sorted((String str1, String str2)-> {
				if(str1.startsWith("java.") && str2.startsWith("java.")) {
					if(str1.startsWith("java.lang") && !str2.startsWith("java.lang")) {
						return -1;
					}else if(!str1.startsWith("java.lang") && str2.startsWith("java.lang")) {
						return 1;
					}else {
						if(str1.startsWith("java.util") && !str2.startsWith("java.util")) {
							return -1;
						}else if(!str1.startsWith("java.util") && str2.startsWith("java.util")) {
							return 1;
						}else {
							if(str1.startsWith("java.io") && !str2.startsWith("java.io")) {
								return -1;
							}else if(!str1.startsWith("java.io") && str2.startsWith("java.io")) {
								return 1;
							}else {
								return str1.compareTo(str2);
							}
						}
					}
				}else {
					return str1.compareTo(str2);
				}
			}).collect(Collectors.toList());
			names.forEach(e-> {
				sb.append(e).append("\r\n");
			 });
			File file = new File("d:\\jreclz.txt");
			Common.write(file,sb.toString());
		} catch (ClassNotFoundException | IOException e) {
			e.printStackTrace();
		}
		/*
		 * try { URL url =new
		 * URL("D:\\androidMavenRepository\\junit\\junit\\3.8.1\\junit-3.8.1.jar");
		 * getClassesFromJar(new URL[]{url}, CodeGenContext.newInstance()); } catch
		 * (ClassNotFoundException | IOException e) { // TODO Auto-generated catch block
		 * e.printStackTrace(); }
		 */
	}
	public List<Class> getMethodReturnGenericTypes(Method m) {
		List<Class> list = new ArrayList<>();
		Type returnType = m.getGenericReturnType();
		if (returnType instanceof ParameterizedType) {
			ParameterizedType pt = (ParameterizedType) returnType;
			Type ts[] = pt.getActualTypeArguments();
			for (Type t1 : ts) {
				if (t1 instanceof Class) {
					list.add((Class) t1);
				}
			}
		}
		return list;
	}
	public static void setModifier(int mod, CodeGenContext context) {
		context.getVariableMap().put(Replacement.PRIVILEDGE_MODIFIER.name(), "");
		context.getVariableMap().put(Replacement.STATIC_MODIFIER.name(), "");
		context.getVariableMap().put(Replacement.ABSTRACT_MODIFIER.name(), "");
		context.getVariableMap().put(Replacement.FINAL_MODIFIER.name(), "");
		context.getVariableMap().put(Replacement.SYNC_MODIFIER.name(), "");
		context.getVariableMap().put(Replacement.VOLATILE_MODIFIER.name(), "");
		if (Modifier.isPublic(mod)) {
			context.getVariableMap().put(Replacement.PRIVILEDGE_MODIFIER.name(), "public");
		}
		if (Modifier.isPrivate(mod)) {
			context.getVariableMap().put(Replacement.PRIVILEDGE_MODIFIER.name(), "private");
		}
		if (Modifier.isProtected(mod)) {
			context.getVariableMap().put(Replacement.PRIVILEDGE_MODIFIER.name(), "protected");
		}
		if (Modifier.isStatic(mod)) {
			context.getVariableMap().put(Replacement.STATIC_MODIFIER.name(), " static ");
		}
		if (Modifier.isAbstract(mod)) {
			context.getVariableMap().put(Replacement.ABSTRACT_MODIFIER.name(), " abstract ");
		}
		if (Modifier.isFinal(mod)) {
			context.getVariableMap().put(Replacement.FINAL_MODIFIER.name(), " final ");
		}
		if (Modifier.isVolatile(mod)) {
			context.getVariableMap().put(Replacement.VOLATILE_MODIFIER.name(), " volatile ");
		}
		if (Modifier.isSynchronized(mod)) {
			context.getVariableMap().put(Replacement.SYNC_MODIFIER.name(), " synchronized ");
		}
	}
	public static File getFileByPackage(String baseDir, String packName) {
		String regex = "\\.";
		String path = null;
		try {
			path = baseDir + File.separator + packName.replaceAll(regex, "\\" + File.separator);
		} catch (Exception e) {
			e.printStackTrace();
		}
		return new File(path);
	}
	public static void listAllFiles(File dir, String fileNameRegex, List<File> allFiles) {
		File fileArray[] = dir.listFiles();
		for (File file : fileArray) {
			if (file.isFile()) {
				String s = file.getName();
				boolean b = s.matches(fileNameRegex);
				if (b) {
					allFiles.add(file);
				}
			} else {
				listAllFiles(file, fileNameRegex, allFiles);
			}
		}
	}
	public static boolean isJarFile(File jarfile) {
		String fileName = jarfile.getName().toLowerCase();
		if (!fileName.endsWith("jar")) {
			return false;
		}
		try {
			ZipFile file = new ZipFile(jarfile);
			Enumeration<? extends ZipEntry> e = file.entries();
			if (e.hasMoreElements()) {
				ZipEntry entry = e.nextElement();
				return true;
			}
		} catch (Exception ex) {
			return false;
		}
		return true;
	}
	public static List<String> getClassesNameFromJar(CodeGenContext context, URL... uls)
			throws IOException, ClassNotFoundException {
		return getClassesNameFromJar(uls, null, context);
	}
	public static List<String> getClassesNameFromJar(URL uls[], String clzName, CodeGenContext context) {
		List<String> list = new ArrayList<>();
		for (int i = 0; i < uls.length; i++) {
			JarFile jarFile = null;
			try {
				jarFile = new JarFile(uls[i].getPath());
				list.addAll(getJarFileClassNames(jarFile, context));
			} catch (IOException e2) {
			}
		}
		return list;
	}
	public static List<String> getJarFileClassNames(JarFile jarFile, CodeGenContext context) {
		List<String> list = new ArrayList<>();
		if (jarFile != null) {
			Enumeration<JarEntry> e = jarFile.entries();
			while (e.hasMoreElements()) {
				JarEntry entry = e.nextElement();
				String name = entry.getName();
				if (name.endsWith(".class")) {
					CharSequence charSequence = null;
					name = name.replace(".class", "");
					name = name.replace("/", ".");
					if ("junit.framework.TestCase".equals(name)) {
						System.out.println("***");
					}
					list.add(name);
				}
			}
			try {
				jarFile.close();
			} catch (IOException e1) {
				e1.printStackTrace();
			}
		}
		return list;
	}
	public static Class[] getClassesFromJar(URL uls[], String clzName, CodeGenContext context) {
		List<Class> list = new ArrayList<>();
		for (int i = 0; i < uls.length; i++) {
			JarFile jarFile = null;
			try {
				jarFile = new JarFile(uls[i].getPath());
			} catch (IOException e2) {
			}
			if (jarFile != null) {
				Enumeration<JarEntry> e = jarFile.entries();
				while (e.hasMoreElements()) {
					JarEntry entry = e.nextElement();
					String name = entry.getName();
					if (name.endsWith(".class")) {
						CharSequence charSequence = null;
						name = name.replace(".class", "");
						name = name.replace("/", ".");
						if ("junit.framework.TestCase".equals(name)) {
							System.out.println("***");
						}
						Class c = null;
						try {
							c = CodeGenContext.getInstance().getReloadableDynamicClassLoaderOwner().loadClass(name,
									true);
							if (c != null) {
								String s = c.getCanonicalName();
								if (clzName != null && s != null && s.endsWith(clzName)) {
									list.add(c);
								} else if (clzName == null) {
									list.add(c);
								}
							}
						} catch (Exception e1) {
						}
					}
				}
				try {
					jarFile.close();
				} catch (IOException e1) {
					e1.printStackTrace();
				}
			}
		}
		return (Class[]) list.toArray(new Class[list.size()]);
	}
	public static URL getJarUrlByResource(String resourceName) throws Exception {
		URL url = Common.class.getClassLoader().getResource(resourceName);
		boolean b = false;
		while (!b) {
			String p = url.getProtocol();
			if ("jar".equalsIgnoreCase(p)) {
				return url;
			}
			File pf = new File(url.getPath()).getParentFile();
			url = new URL(pf.getAbsolutePath());
		}
		return null;
	}
	public static List<Constructor> getConstructorWithPrimitiveArgs(Class<?> clz) {
		List<Constructor> list = new ArrayList<>();
		Constructor constructorArray[] = clz.getConstructors();
		for(Constructor constructor : constructorArray){
			Class clzArray[] = constructor.getParameterTypes();
			boolean b = true;
			for(Class pt : clzArray){
				if(!Common.isPrimitiveType(pt)){
					b = false;
					break;
				}
			}
			if(b){
				list.add(constructor);
			}
		}
	    return list;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\codegen\util\MethodCallingKey.java---
package codegen.util;
public class MethodCallingKey {
	Class c;
	String methodName;
	public MethodCallingKey(Class c, String methodName) {
		super();
		this.c = c;
		this.methodName = methodName;
	}
	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + ((c == null) ? 0 : c.hashCode());
		result = prime * result + ((methodName == null) ? 0 : methodName.hashCode());
		return result;
	}
	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		MethodCallingKey other = (MethodCallingKey) obj;
		if (c == null) {
			if (other.c != null)
				return false;
		} else if (!c.equals(other.c))
			return false;
		if (methodName == null) {
			if (other.methodName != null)
				return false;
		} else if (!methodName.equals(other.methodName))
			return false;
		return true;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\codegen\util\PomUtil.java---
package codegen.util;
import org.apache.maven.model.Dependency;
import org.apache.maven.model.DependencyManagement;
import org.apache.maven.model.Model;
import org.apache.maven.model.Parent;
import org.apache.maven.model.io.xpp3.MavenXpp3Reader;
import org.codehaus.plexus.util.xml.pull.XmlPullParserException;
import java.io.*;
import java.util.List;
public class PomUtil {
	public PomUtil() {
	}
	public static Model parsePom(File file) throws FileNotFoundException, IOException, XmlPullParserException {
		MavenXpp3Reader reader = new MavenXpp3Reader();
		Model model = reader.read(new FileReader(file));
		Parent p = model.getParent();
		String path = null;
		if (p != null) {
			path = p.getRelativePath();
		}
		DependencyManagement dm = model.getDependencyManagement();
		List<Dependency> mgtdep = null;
		if (dm != null)
			mgtdep = dm.getDependencies();
		List<Dependency> eependencyLimod = model.getDependencies();
		return model;
	}
	public static Model parsePom(InputStream is) throws IOException, XmlPullParserException {
		MavenXpp3Reader reader = new MavenXpp3Reader();
		Model model = reader.read(is);
		return model;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\codegen\winsys\WinSysService.java---
package codegen.winsys;
import codegen.robot.Service;
import java.awt.event.KeyEvent;
public class WinSysService extends Service {
	public WinSysService() {
		super();
	}
	public void popupContextMenu() {
		this.getkRobot().clickCompositeKey(KeyEvent.VK_SHIFT, KeyEvent.VK_F10);
	}
	public void openExplorer() {
		this.getkRobot().clickCompositeKey(KeyEvent.VK_WINDOWS, KeyEvent.VK_E);
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\com\dgs\ActivatedHyperlinkListener.java---
package com.dgs;
import javax.swing.*;
import javax.swing.event.HyperlinkEvent;
import javax.swing.event.HyperlinkListener;
import javax.swing.text.Document;
import java.io.IOException;
import java.net.URL;
public class ActivatedHyperlinkListener implements HyperlinkListener{
	JEditorPane editorPane;
	public ActivatedHyperlinkListener(JEditorPane editorPane) {
		this.editorPane = editorPane;
	}
	public void hyperlinkUpdate(HyperlinkEvent hyperlinkEvent) {
		HyperlinkEvent.EventType type = hyperlinkEvent.getEventType();
		final URL url = hyperlinkEvent.getURL();
		if (type == HyperlinkEvent.EventType.ENTERED) {
			System.out.println("URL: " + url);
		} else if (type == HyperlinkEvent.EventType.ACTIVATED) {
			System.out.println("Activated");
			Runnable runner = new Runnable() {
				public void run() {
					Document doc = editorPane.getDocument();
					try {
						editorPane.setPage(url);
					} catch (IOException ioException) {
						editorPane.setDocument(doc);
					}
				}
			};
			SwingUtilities.invokeLater(runner);
		}
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\com\dgs\annotation\ComponentFieldAnno.java---
package com.dgs.annotation;
import java.lang.annotation.Documented;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface ComponentFieldAnno {
	String name();
	String value();
}
----strat of file D:\projects\cg\cg-min\src\main\java\com\dgs\annotation\DontActiveIDE.java---
package com.dgs.annotation;
import java.lang.annotation.Documented;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface DontActiveIDE {
}
----strat of file D:\projects\cg\cg-min\src\main\java\com\dgs\annotation\FileChooserAnnotation.java---
package com.dgs.annotation;
import java.lang.annotation.Documented;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface FileChooserAnnotation {
	boolean chooseDirOnly() default false;
}
----strat of file D:\projects\cg\cg-min\src\main\java\com\dgs\annotation\ParamAnno.java---
package com.dgs.annotation;
import java.lang.annotation.Documented;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface ParamAnno {
	String name() default "";
	String description();
}
----strat of file D:\projects\cg\cg-min\src\main\java\com\dgs\annotation\ServiceMethodAnn.java---
package com.dgs.annotation;
import java.lang.annotation.Documented;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface ServiceMethodAnn {
	String[] keyword();
	String description() default "";
	boolean visible() default true;
}
----strat of file D:\projects\cg\cg-min\src\main\java\com\dgs\annotation\UIAnno.java---
package com.dgs.annotation;
import java.lang.annotation.Documented;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
@Retention(RetentionPolicy.RUNTIME)
@Documented
/**
 * used for custom ui pane
 * for method level e.g. 
 * 
 * for param level e.g.
 * @UIAnno(uiClz = "ui.ClassCombBoxpane")
   @ParamAnno(description = "memory area") 
   @ValidationAnn(validations = { "codegen.eclipseRobot.MandatoryCheck" }) 
   String areaName
 * @author osboxes
 *
 */
public @interface UIAnno {
	String uiClz() ;
}
----strat of file D:\projects\cg\cg-min\src\main\java\com\dgs\DatabaseService.java---
package com.dgs;
import javax.sql.DataSource;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
public abstract class DatabaseService {
	public DatabaseService() {
	}
	public String url;
	public String user;
	public String pwd ;
	public Connection getConnection(String driverClzName, String url, String user, String pwd) {
		Connection connection = null;
		try {
			Class.forName(driverClzName);
			this.url = url;
			this.user = user;
			this.pwd = pwd;
			connection = DriverManager.getConnection(url, user, pwd);
		} catch (SQLException | ClassNotFoundException e) {
			e.printStackTrace();
		}
		return connection;
	}
	public abstract DataSource getDataSource( String url, String user, String pwd) ;
	public abstract List<Map<String, String>> getAllShemaAndTableNames() throws SQLException;
	public abstract List<String> getAllTableNames() throws SQLException;
	public abstract Map<String, String> getTableIDColumns(String tableName) throws SQLException;
	public abstract List<String> getTableColumns(String tableName) throws SQLException;
	public abstract Map<String, String> getTableColumnAndType(String s) throws SQLException;
	boolean connectSuccess;
	public void setConnectSuccess(boolean connectSuccess) {;
		this.connectSuccess = connectSuccess;
	}
	public boolean isConnectSuccess() {
		return connectSuccess;
	}
	/**
	 * 
	 * @param selectedCols, key is column name, value is column value
	 * @param tableName
	 * @return
	 */
	public String genInsert(Map<String, String> selectedCols, String tableName) {
		if(selectedCols.isEmpty() || null==tableName) {
			return "";
		}
		Set<String> keys = selectedCols.keySet();
		StringBuilder sb = new StringBuilder();
		sb.append("insert into "+tableName +"(");
		for(String s : keys){
			sb.append(String.format(" %s,", s));
		}
		sb.deleteCharAt(sb.length()-1);
		sb.append(") values (");
		for(String s : keys){
			sb.append(String.format("'%s',", selectedCols.get(s)));
		}
		sb.deleteCharAt(sb.length()-1);
		sb.append(")");
	    return sb.toString();
	}
	public String genUpdate(Map<String, String> selectedCols, Map<String, String> whereCols, String tableName) throws SQLException {
		if(selectedCols.isEmpty() || null==tableName) {
			return "";
		}
		Set<String> keys = selectedCols.keySet();
		StringBuilder sb = new StringBuilder();
		sb.append("update "+tableName + " set ");
		for(String k : keys){
			sb.append(String.format(" %s =%s,", k, selectedCols.get(k)));
		}
		sb.deleteCharAt(sb.length()-1);
		sb.append(" where ");
		Set<String> wk = whereCols.keySet();
		for(String k : wk){
			sb.append(String.format(" %s ='%s' and ", k, whereCols.get(k)));
		}
		if(!wk.isEmpty()) {
			sb.delete(sb.length()-4, sb.length());
		}
	    return sb.toString();
	}
	public String genUpdateById(Map<String, String> selectedCols, String tableName) throws SQLException {
		Map<String, String> whereCols = this.getTableIDColumns(tableName);
		whereCols.replaceAll((k,v) -> "?");
	    return this.genUpdate(selectedCols, whereCols, tableName);
	}
	/**
	 * 
	 * @param selectedCols
	 * @param tableName
	 * @param joinTableNames
	 * @param joinCols tableA.id, tableB.id2
	 * @param whereCols tableA.name, table.name value
	 * @return
	 * @throws SQLException
	 */
	public String genSelect(Map<String, String> selectedCols,String tableName,List<String> joinTableNames, Map<String, String> joinCols, Map<String, String> whereCols) throws SQLException {
		if(selectedCols.isEmpty() || null==tableName) {
			return "";
		}
		Set<String> keys = selectedCols.keySet();
		StringBuilder sb = new StringBuilder("select ");
		for(String k : keys){
			sb.append(String.format(" %s as %s,", k, selectedCols.get(k)));
		}
		sb.deleteCharAt(sb.length()-1);
		sb.append(" from "+tableName);
		if(joinCols.isEmpty() && whereCols.isEmpty()) {
			return sb.toString();
		}
		Set<String> ks = joinCols.keySet();
		for(String k : ks){
			sb.append(String.format(" %s ='%s' and ", k, joinCols.get(k)));
		}
		sb.append(" where ");
		Set<String> whereK = whereCols.keySet();
		for(String k : whereK){
			sb.append(String.format(" %s ='%s' and ", k, whereCols.get(k)));
		}
		if(!whereK.isEmpty()) {
			sb.delete(sb.length()-4, sb.length());
		}
	    return sb.toString();
	}
	public String genSelect(Map<String, String> selectedCols, Map<String, String> whereCols, String tableName) throws SQLException {
		if(selectedCols.isEmpty() || null==tableName) {
			return "";
		}
		Set<String> keys = selectedCols.keySet();
		StringBuilder sb = new StringBuilder("select ");
		for(String k : keys){
			sb.append(String.format(" %s as %s,", k, selectedCols.get(k)));
		}
		sb.deleteCharAt(sb.length()-1);
		sb.append(" from "+tableName);
		if(selectedCols.isEmpty()) {
			return sb.toString();
		}
		sb.append(" where ");
		Set<String> whereK = whereCols.keySet();
		for(String k : whereK){
			sb.append(String.format(" %s ='%s' and ", k, whereCols.get(k)));
		}
		if(!whereK.isEmpty()) {
			sb.delete(sb.length()-4, sb.length());
		}
	    return sb.toString();
	}
	public String genSelectById(Map<String, String> selectedCols, String tableName) throws SQLException {
		Map<String, String> whereCols = this.getTableIDColumns(tableName);
		whereCols.replaceAll((k,v) -> "?");
	    return genSelect(selectedCols, whereCols, tableName);
	}
	public String genDelete(String tableName, Map<String, String> whereCols) throws SQLException {
		StringBuilder sb = new StringBuilder();
		sb.append("delete from " + tableName);
		if(whereCols.isEmpty()) {
			return sb.toString();
		}
		sb.append(" where ");
		Set<String> idk = whereCols.keySet();
		for(String k : idk){
			sb.append(String.format(" %s ='%s' and ", k, whereCols.get(k)));
		}
		if(!idk.isEmpty()) {
			sb.delete(sb.length()-4, sb.length());
		}
	    return sb.toString();
	}
	public String genDeleteById(String tableName) throws SQLException {
		Map<String, String> whereCols = this.getTableIDColumns(tableName);
		whereCols.replaceAll((k,v) -> "?");
	    return genDelete(tableName, whereCols);
	}
	public static void main(String[] args) {
	}
	public String getUrl() {
		return url;
	}
	public void setUrl(String url) {
		this.url = url;
	}
	public String getUser() {
		return user;
	}
	public void setUser(String user) {
		this.user = user;
	}
	public String getPwd() {
		return pwd;
	}
	public void setPwd(String pwd) {
		this.pwd = pwd;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\com\dgs\DragTest.java---
package com.dgs;
import javax.swing.*;
import java.awt.*;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.event.MouseMotionListener;
public class DragTest extends JFrame implements MouseMotionListener, MouseListener {
	private JPanel leftPanel = new JPanel(null);
	private JPanel rightPanel = new JPanel(null);
	JLabel dropLabel;
	public DragTest() {
		this.setLayout(new GridLayout(1, 2));
		leftPanel.setBorder(BorderFactory.createLineBorder(Color.black));
		rightPanel.setBorder(BorderFactory.createLineBorder(Color.black));
		this.add(leftPanel);
		this.add(rightPanel);
		leftPanel.addMouseListener(this);
		leftPanel.addMouseMotionListener(this);
		JTextArea area = new JTextArea();
		rightPanel.setLayout(new GridLayout(1, 1));
		rightPanel.add(area);
		dropLabel = new JLabel("drop");
		dropLabel.setTransferHandler(new TransferHandler("text"));
	}
	@Override
	public void mousePressed(MouseEvent e) {
		System.out.println("mousePressed");
		Dimension labelSize = dropLabel.getPreferredSize();
		dropLabel.setSize(labelSize);
		int x = e.getX() - labelSize.width / 2;
		int y = e.getY() - labelSize.height / 2;
		dropLabel.setLocation(x, y);
		leftPanel.add(dropLabel);
		repaint();
	}
	@Override
	public void mouseDragged(MouseEvent me) {
		System.out.println("mouseDragged");
		dropLabel.getTransferHandler().exportAsDrag(dropLabel, me, TransferHandler.COPY);
	}
	@Override
	public void mouseMoved(MouseEvent e) {
	}
	@Override
	public void mouseClicked(MouseEvent e) {
		System.out.println("mouseClicked");
	}
	@Override
	public void mouseReleased(MouseEvent e) {
		System.out.println("mouseReleased");
	}
	@Override
	public void mouseEntered(MouseEvent e) {
	}
	@Override
	public void mouseExited(MouseEvent e) {
	}
	public static void main(String[] args) {
		DragTest frame = new DragTest();
		frame.setVisible(true);
		frame.setSize(600, 400);
		frame.setResizable(false);
		frame.setLocationRelativeTo(null);
		frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\com\dgs\EPTest.java---
package com.dgs;
import javax.swing.*;
import javax.swing.event.HyperlinkListener;
import javax.swing.text.BadLocationException;
import javax.swing.text.ChangedCharSetException;
import javax.swing.text.html.HTMLDocument;
import javax.swing.text.html.HTMLEditorKit;
import javax.swing.text.html.StyleSheet;
import java.io.*;
import java.net.URL;
import java.nio.charset.Charset;
import java.util.Iterator;
import java.util.Set;
import java.util.SortedMap;
public class EPTest {
	JEditorPane pane;
	HTMLEditorKit kit;
	public EPTest() {
		kit = new HTMLEditorKit();
		pane = new JEditorPane();
		pane.setEditable(false);
		HyperlinkListener hyperlinkListener = new ActivatedHyperlinkListener(pane);
		pane.addHyperlinkListener(hyperlinkListener);
		pane.setEditorKit(kit);
		StyleSheet styleSheet = new StyleSheet();
		ClassLoader classLoader = this.getClass().getClassLoader();
		String arg0 = "css.css";
		URL uRL = classLoader.getResource(arg0);
		try {
			String rules = readAsStr(new File(uRL.getPath()));
		} catch (IOException e) {
			e.printStackTrace();
		}
		loadWithSetPage();
	}
	public static String readAsStr(File f) throws IOException {
		FileInputStream is = new FileInputStream(f);
		StringBuilder sb = new StringBuilder();
		BufferedReader in = null;
		try {
			in = new BufferedReader(new InputStreamReader(is));
			String line = null;
			while ((line = in.readLine()) != null) {
				sb.append(line).append("\r\n");
			}
		} catch (IOException e) {
			e.printStackTrace();
			throw e;
		} finally {
			if (in != null)
				try {
					in.close();
				} catch (IOException e) {
					e.printStackTrace();
				}
		}
		return sb.toString();
		}
	public static void write(File f, String fileStr) throws IOException {
		FileOutputStream fos = new FileOutputStream(f);
		fos.write(fileStr.getBytes());
		fos.flush();
		fos.close();
	}
	/**
	 * works okay with the meta tag in the html file only if the trailing/closing
	 * slash is absent ie, this '...>' instead of this '... />' // edit
	 */
	private void loadWithSetPage() {
		try {
			pane.setPage(getClass().getClassLoader().getResource("tabletest.html"));
		} catch (IOException ioe) {
			System.err.println("setPage read: " + ioe.getMessage());
		}
	}
	private void loadWithReader() {
		Object o = read(); // okay without meta statement
		if (o instanceof Charset) // we get here if file has a meta statement
		{
			String name = ((Charset) o).name();
			read((Charset) o); // cannot get this to work
		} else
			System.out.println("o = " + o.toString());
	}
	private Object read() {
		Reader fin = null;
		try {
			fin = // new BufferedReader(
					new InputStreamReader(new FileInputStream("eptest.html"));
		} catch (FileNotFoundException fnfe) {
			System.err.println("file not found: " + fnfe.getMessage());
			return Boolean.FALSE;
		}
		try {
			System.out.println(((InputStreamReader) fin).getEncoding());
			HTMLDocument doc = (HTMLDocument) pane.getDocument();
			kit.read(fin, doc, 0);
			return Boolean.TRUE;
		} catch (ChangedCharSetException ccse) {
			String s = ccse.getCharSetSpec();
			System.out.println("changed charSet " + s);
			Charset cs = Charset.forName(s.substring(s.indexOf("charset=") + 8));
			System.out.println("cs = " + cs.toString());
			return cs;
		} catch (BadLocationException ble) {
			System.err.println("location: " + ble.getMessage());
			return Boolean.FALSE;
		} catch (IOException ioe) {
			System.err.println("read: " + ioe.getMessage());
			return Boolean.FALSE;
		}
		finally {
			try {
				fin.close();
			} catch (IOException ioe) {
				System.err.println("close: " + ioe.getMessage());
				return Boolean.FALSE;
			}
		}
	}
	/**
	 * all three InputStreamReader constructor forms fail if html file contains a
	 * meta statement for content/charset otherwise they seem to work okay
	 */
	private void read(Charset cs) {
		Reader fin = null;
		try {
			fin = new BufferedReader(new InputStreamReader(new FileInputStream("eptest.html"), cs));
		} catch (FileNotFoundException fnfe) {
			System.err.println("file not found: " + fnfe.getMessage());
		}
		try {
			HTMLDocument doc = (HTMLDocument) pane.getDocument();
			kit.read(fin, doc, 0);
		} catch (BadLocationException ble) {
			System.err.println("location: " + ble.getMessage());
		} catch (IOException ioe) {
			System.err.println("read: " + ioe.getMessage());
		}
		finally {
			try {
				fin.close();
			} catch (IOException ioe) {
				System.err.println("close: " + ioe.getMessage());
			}
		}
	}
	private void showAvailableCharsets() {
		SortedMap<String, Charset> map = Charset.availableCharsets();
		Set<String> keys = map.keySet();
		Iterator it = keys.iterator();
		while (it.hasNext())
			System.out.println((Charset) map.get((String) it.next()));
	}
	public static void main(String[] args) {
		try {
			UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
		} catch (Exception ignored) {
		}
		JFrame f = new JFrame();
		f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		f.getContentPane().add(new EPTest().pane);
		f.setSize(400, 400);
		f.setLocation(200, 200);
		f.setVisible(true);
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\com\dgs\JListExample.java---
package com.dgs;
import javax.swing.*;
import javax.swing.event.ListSelectionEvent;
import javax.swing.event.ListSelectionListener;
public class JListExample extends JFrame {
	static JFrame f;
	static JList b;
	public static void main(String[] args) {
		f = new JFrame("frame");
		JListExample s = new JListExample();
		JPanel p = new JPanel();
		JLabel l = new JLabel("select the day of the week");
		String week[] = { "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday" };
		b = new JList(week);
		b.setVisibleRowCount(5);
		b.setFixedCellHeight(15);
		b.addListSelectionListener(new ListSelectionListener () {
			@Override
			public void valueChanged(ListSelectionEvent e) {
			}
		}); 
		b.setSelectedIndex(2);
		b.setSelectionMode(ListSelectionModel.MULTIPLE_INTERVAL_SELECTION);
		p.add(b);
		f.add(p);
		f.setSize(400, 400);
		try { 
			UIManager.setLookAndFeel("com.sun.java.swing.plaf.windows.WindowsLookAndFeel");
			SwingUtilities.updateComponentTreeUI(f);
	    } catch(Exception e){e.printStackTrace();}
		f.show();
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\com\dgs\jnaforwin32\App.java---
package com.dgs.jnaforwin32;
import com.sun.jna.Native;
import com.sun.jna.platform.win32.WinDef.HWND;
import com.sun.jna.win32.W32APIOptions;
import javax.swing.*;
import java.awt.*;
/**
 * Hello world!
 *
 */
public class App extends JFrame
{
    public static void main( String[] args )
    {
    	try {
			Thread.sleep(3300L);
		} catch (InterruptedException e1) {
			e1.printStackTrace();
		}
    	User32Ext INSTANCE = (User32Ext)Native.loadLibrary("user32", User32Ext.class, W32APIOptions.DEFAULT_OPTIONS);
    	HWND hwnd = INSTANCE.GetDesktopWindow();
    	hwnd = INSTANCE.GetForegroundWindow();
    	char[] chArray = new char[1000];
    	INSTANCE.GetWindowText(hwnd, chArray, 900);
    	System.out.println(new String(chArray));
    	App app = new App();
    	app.setSize(200, 200);
    	JTextField jf = new JTextField();
    	JButton btn = new JButton("ok");
    	app.getContentPane().setLayout(new BorderLayout());
    	app.getContentPane().add(jf, BorderLayout.CENTER);
    	app.getContentPane().add(btn, BorderLayout.SOUTH);
    	jf.setText(new String(chArray));
    	final HWND ecHWND = hwnd;
    	btn.addActionListener(l->{
    		try {
    			Thread.sleep(300L);
    			INSTANCE.SwitchToThisWindow(ecHWND, true);
    			INSTANCE.SetForegroundWindow(ecHWND);
    			HWND activeWinHWND = INSTANCE.GetForegroundWindow();
    			char[] chArray1 = new char[1000];
    	    	int validLen = INSTANCE.GetWindowText(activeWinHWND, chArray1, chArray1.length);
    	    	String str = new String(chArray1, 0, validLen);
    	    	jf.setText(str);
    	    	System.out.println(str);
    		} catch (InterruptedException e) {
    			e.printStackTrace();
    		}
    	});
    	app.setVisible(true);
    	HWND ecWindow = INSTANCE.FindWindow("", "");
    }
}
----strat of file D:\projects\cg\cg-min\src\main\java\com\dgs\jnaforwin32\Kernel32.java---
package com.dgs.jnaforwin32;
import com.sun.jna.Native;
import com.sun.jna.Pointer;
import com.sun.jna.win32.StdCallLibrary;
public interface Kernel32 extends StdCallLibrary {
    Kernel32 INSTANCE = (Kernel32) Native.loadLibrary("Kernel32", Kernel32.class);
    Pointer OpenProcess(int dwDesiredAccess, boolean bInheritHandle, int dwProcessId);
    boolean CloseHandle(Pointer hObject);
}
----strat of file D:\projects\cg\cg-min\src\main\java\com\dgs\jnaforwin32\User32Ext.java---
package com.dgs.jnaforwin32;
import com.sun.jna.platform.win32.User32;
import com.sun.jna.platform.win32.WinDef.HWND;
public interface User32Ext extends User32 {
	HWND FindWindowEx(HWND lpParent, HWND lpChild, String lpClassName, String lpWindowName);
	HWND GetTopWindow(HWND hwnd);
	HWND GetParent(HWND hwnd);
	HWND GetDesktopWindow();
	HWND GetForegroundWindow();
	int SendMessage(HWND hWnd, int dwFlags, byte bVk, int dwExtraInfo);
	int SendMessage(HWND hWnd, int Msg, int wParam, String lParam);
	void keybd_event(byte bVk, byte bScan, int dwFlags, int dwExtraInfo);
	void SwitchToThisWindow(HWND hWnd, boolean fAltTab);
	public HWND GetActiveWindow();
}
----strat of file D:\projects\cg\cg-min\src\main\java\com\dgs\jnaforwin32\WindowService.java---
package com.dgs.jnaforwin32;
import com.sun.jna.Native;
import com.sun.jna.platform.win32.WinDef.HWND;
import com.sun.jna.win32.W32APIOptions;
import java.util.Objects;
public class WindowService {
	public static  final  String ECLIPSE_WINDOW_TEXT_KEY_WORD = "eclipse";
	public User32Ext INSTANCE;
	{
	    try {
            INSTANCE = (User32Ext)Native.loadLibrary("user32", User32Ext.class, W32APIOptions.DEFAULT_OPTIONS);
	    }catch(Error | Exception e) {
            System.out.println("cannot loading user32 lib");
        }
	}
	public String getActiveWindowText() {
	    if(!Objects.isNull(INSTANCE)) {
    		HWND hwnd = INSTANCE.GetForegroundWindow();
    		char[] chArray = new char[1000];
        	INSTANCE.GetWindowText(hwnd, chArray, 900);
        	String text = new String(chArray);
        	if(!Objects.isNull(text)){
        		text = text.trim();
        	}
        	return text;
	    }else {
	        return "";
	    }
	}
	public String switchToWindow() {
	    return null;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\com\dgs\MD5Test.java---
package com.dgs;
import java.io.FileInputStream;
import java.io.InputStream;
import java.security.MessageDigest;
public class MD5Test {
	public static byte[] createChecksum(String filename) throws Exception {
		InputStream fis = new FileInputStream(filename);
		byte[] buffer = new byte[1024];
		MessageDigest complete = MessageDigest.getInstance("MD5");
		int numRead;
		do {
			numRead = fis.read(buffer);
			if (numRead > 0) {
				complete.update(buffer, 0, numRead);
			}
		} while (numRead != -1);
		fis.close();
		return complete.digest();
	}
	public static String getMD5Checksum(String filename) throws Exception {
		byte[] b = createChecksum(filename);
		String result = "";
		for (int i = 0; i < b.length; i++) {
			result += Integer.toString((b[i] & 0xff) + 0x100, 16).substring(1);
		}
		return result;
	}
	public static void main(String args[]) {
		try {
			System.out.println(getMD5Checksum("D:\\netprojects\\clipboardmonitorwindow\\production\\WpfApp1\\WpfApp1\\bin\\Debug\\WpfApp1.pdb"));
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\com\dgs\SplitFrame.java---
package com.dgs;
import javax.swing.*;
class SplitFrame extends JFrame {
	static JFrame f;
	static JTextArea t1, t2;
	public static void main(String[] args) {
		f = new JFrame("frame");
		SplitFrame s = new SplitFrame();
		JPanel p1 = new JPanel();
		JPanel p = new JPanel();
		t1 = new JTextArea(10, 10);
		t2 = new JTextArea(10, 10);
		t1.setText("this is first text area");
		t2.setText("this is second text area");
		p1.add(t1);
		p.add(t2);
		JSplitPane sl = new JSplitPane(SwingConstants.VERTICAL, p1, p);
		sl.setOrientation(SwingConstants.VERTICAL);
		f.add(sl);
		f.setSize(300, 300);
		f.show();
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\com\dgs\SwingFrameService.java---
package com.dgs;
import javax.swing.*;
import java.awt.*;
import java.io.File;
public class SwingFrameService extends JFrame{
	private JTextField jTextField;
	private JButton jButton;
	private JFileChooser jFileChooser;
	public SwingFrameService() {
		jTextField = new JTextField(10);
		jButton =  new JButton("open file");
		jButton.addActionListener(e -> {
            selectFile();
        });
		Container container = this.getContentPane();
		FlowLayout flowLayout = new FlowLayout(FlowLayout.LEFT);
		this.setLayout(flowLayout);
		container.add(jTextField);
		container.add(jButton);
		this.setVisible(true);
		this.setSize(200, 100);
		this.setLocation(200, 100);
	}
	public void selectFile() {
        JFileChooser chooser = new JFileChooser();
        if (chooser.showOpenDialog(this) == JFileChooser.APPROVE_OPTION) {
            File file = chooser.getSelectedFile();
            String s = file.getAbsolutePath();
            jTextField.setText(s);
        } else {
        }
    }
	public static void main(String[] args){
		SwingFrameService swingFrameService = new SwingFrameService();
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\com\dgs\SwingWorker1.java---
package com.dgs;
import javax.swing.*;
import java.util.List;
public class SwingWorker1 extends SwingWorker {
	public SwingWorker1() {
	}
	@Override
	protected Object doInBackground() throws Exception {
		return null;
	}
	@Override
	protected void process(List chunks) {
		super.process(chunks);
	}
	@Override
	protected void done() {
		super.done();
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\com\dgs\TestNetSocket.java---
package com.dgs;
import java.io.*;
import java.net.Socket;
public class TestNetSocket {
	private Socket socket;
	public TestNetSocket() {
	}
	public String sendAndReceive() {
		StringBuilder sb = new StringBuilder();
		try {
			Thread.sleep(3000L);
			socket = new Socket("localhost", 8999);
			socket.setSoTimeout(3000);
			OutputStream outputStream = socket.getOutputStream();
			outputStream.write("switchProcess\r\n".getBytes());
			outputStream.flush();
			InputStream inputStream = socket.getInputStream();
			InputStreamReader inputStreamReader = new InputStreamReader(inputStream);
			BufferedReader bufferedReader = new BufferedReader(inputStreamReader);
			String s = null;
			while((s=bufferedReader.readLine())!=null){
				sb.append(s);
			}
			outputStream.close();
			inputStream.close();
		} catch (Exception e) {
			e.printStackTrace();
		}finally {
			try {
				socket.close();
			} catch (IOException e) {
				e.printStackTrace();
			}
		}
	    return sb.toString();
	}
	public static  void main(String args[]) {
		TestNetSocket tns = new TestNetSocket();
		String s =tns.sendAndReceive();
		System.out.println(String.format("s=%s",s));
	    return ;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\com\github\gemba\artifactresolver\DependencyGraphPrinter.java---
package com.github.gemba.artifactresolver;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Stack;
import org.eclipse.aether.graph.DependencyNode;
import org.eclipse.aether.graph.DependencyVisitor;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
public class DependencyGraphPrinter implements DependencyVisitor {
	private static final Logger log = LoggerFactory.getLogger(DependencyGraphPrinter.class);
	private static final String DEFAULT_INDENT = "|   ";
	private static final String DEFAULT_BRANCH = "+---";
	private static final String DEFAULT_TERMINAL = "\\---";
	private String indent = "";
	private Stack<DependencyNode> nodes = new Stack();
	private HashMap<Integer, Integer> dependencyCounter = new HashMap();
	List<DependencyNode> nodeList = new ArrayList();
	public DependencyGraphPrinter(List<DependencyNode> nodeList) {
		this.nodeList = nodeList;
	}
	public DependencyGraphPrinter() {
	}
	public boolean visitEnter(DependencyNode node) {
		int children = node.getChildren().size();
		int parentChildren = 0;
		if (this.nodes.size() > 0) {
			parentChildren = ((DependencyNode)this.nodes.peek()).getChildren().size();
		}
		this.nodes.push(node);
		Integer count = (Integer)this.dependencyCounter.get(this.indent.length());
		if (count == null) {
			count = 1;
		} else {
			count = count + 1;
		}
		this.dependencyCounter.put(this.indent.length(), count);
		String in;
		if (count == parentChildren) {
			in = this.indent.replace("+---", "\\---");
		} else {
			in = this.indent.replace("\\---", "+---");
		}
		this.nodeList.add(node);
		log.info("  {}{}", in, node);
		if (this.indent.length() == 0) {
			this.indent = "+---";
		} else if (children == 1 && children == parentChildren) {
			this.indent = "|    " + this.indent.substring(1);
		} else {
			this.indent = "|   " + this.indent;
		}
		return true;
	}
	public boolean visitLeave(DependencyNode node) {
		this.dependencyCounter.remove(this.indent.length());
		this.nodes.pop();
		this.indent = this.indent.substring("|   ".length());
		return true;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\com\github\gemba\artifactresolver\DependencyResolver.java---
package com.github.gemba.artifactresolver;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import org.eclipse.aether.artifact.Artifact;
import org.eclipse.aether.artifact.DefaultArtifact;
import org.eclipse.aether.collection.DependencyCollectionException;
import org.eclipse.aether.graph.Dependency;
import org.eclipse.aether.graph.DependencyFilter;
import org.eclipse.aether.graph.DependencyNode;
import org.eclipse.aether.resolution.ArtifactRequest;
import org.eclipse.aether.resolution.ArtifactResult;
import org.eclipse.aether.resolution.DependencyRequest;
import org.eclipse.aether.resolution.DependencyResolutionException;
import org.eclipse.aether.resolution.DependencyResult;
import org.eclipse.aether.util.filter.DependencyFilterUtils;
import org.eclipse.aether.util.graph.visitor.FilteringDependencyVisitor;
import org.eclipse.aether.util.graph.visitor.TreeDependencyVisitor;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
public class DependencyResolver {
	private static final Logger log = LoggerFactory.getLogger(DependencyResolver.class);
	private RepositorySystemHelper repoSystemHelper;
	public DependencyResolver(RepositorySystemHelper repoSystemHelper) {
		this.repoSystemHelper = repoSystemHelper;
	}
	public List<String> getProjDepArtifactFilePath(DefaultArtifact artifact) throws DependencyCollectionException, DependencyResolutionException {
		log.info("Resolving: {} with these dependencies ...", artifact.toString());
		List<String> list = new ArrayList();
		Dependency dependency = new Dependency(artifact, "compile");
		DependencyNode jarNode = this.repoSystemHelper.collectDependencies(dependency);
		DependencyFilter classpathFilter = DependencyFilterUtils.classpathFilter(new String[]{"test"});
		List<DependencyNode> nodeList = new ArrayList();
		jarNode.accept(new TreeDependencyVisitor(new FilteringDependencyVisitor(new DependencyGraphPrinter(nodeList), classpathFilter)));
		nodeList.stream().forEach((dn) -> {
			ArtifactRequest ar = new ArtifactRequest(dn);
			try {
				ArtifactResult aresult = this.repoSystemHelper.resolveArtifact(ar);
				if (aresult.getArtifact() != null && aresult.getArtifact().getFile() != null) {
					list.add(aresult.getArtifact().getFile().getAbsolutePath());
				}
			} catch (Exception var5) {
			}
		});
		return list;
	}
	public static void main(String[] args) {
		String groupId = "brain";
		String artifactId = "knowledge";
		String version = "0.0.1-SNAPSHOT";
		String localRep = "D:\\androidMavenRepository";
		DefaultArtifact artifact = new DefaultArtifact(groupId, artifactId, "jar", version);
		RepositorySystemHelper repoSystemHelper = null;
		try {
			repoSystemHelper = new RepositorySystemHelper(localRep, new HashMap());
		} catch (Exception var10) {
			var10.printStackTrace();
		}
		DependencyResolver dependencyResolver = new DependencyResolver(repoSystemHelper);
		try {
			dependencyResolver.getProjDepArtifactFilePath(artifact);
		} catch (DependencyResolutionException | DependencyCollectionException var9) {
			var9.printStackTrace();
		}
	}
	public void downloadDependencyTree(DefaultArtifact artifact, boolean javadoc, boolean sources) throws DependencyCollectionException, DependencyResolutionException {
		log.info("Resolving: {} with these dependencies ...", artifact.toString());
		Dependency dependency = new Dependency(artifact, "compile");
		DependencyNode jarNode = this.repoSystemHelper.collectDependencies(dependency);
		DependencyFilter classpathFilter = DependencyFilterUtils.classpathFilter(new String[]{"test"});
		jarNode.accept(new TreeDependencyVisitor(new FilteringDependencyVisitor(new DependencyGraphPrinter(), classpathFilter)));
		DependencyRequest dependencyRequest = new DependencyRequest(jarNode, classpathFilter);
		DependencyResult dependencyResult = this.repoSystemHelper.resolveDependencies(dependencyRequest);
		if (javadoc) {
			this.downloadAttachments(dependencyResult, "javadoc");
		}
		if (sources) {
			this.downloadAttachments(dependencyResult, "sources");
		}
	}
	private void downloadAttachments(DependencyResult depResult, String attachment) throws DependencyCollectionException {
		Iterator var4 = depResult.getArtifactResults().iterator();
		while(var4.hasNext()) {
			ArtifactResult artifactResult = (ArtifactResult)var4.next();
			Artifact artifact = artifactResult.getArtifact();
			String artifactId = artifact.getArtifactId();
			String groupId = artifact.getGroupId();
			String extension = artifact.getExtension();
			String version = artifact.getVersion();
			log.info("Resolving {} for {}", attachment, artifact);
			try {
				DefaultArtifact extraArtifact = new DefaultArtifact(groupId, artifactId, attachment, extension, version);
				Dependency attachedDependency = new Dependency(extraArtifact, "compile");
				DependencyNode attachmentNode = this.repoSystemHelper.collectDependencies(attachedDependency);
				DependencyRequest javadocDependencyRequest = new DependencyRequest(attachmentNode, (DependencyFilter)null);
				this.repoSystemHelper.resolveDependencies(javadocDependencyRequest);
			} catch (DependencyResolutionException var14) {
				log.warn("No {} found for {}", attachment, artifact);
			}
		}
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\com\github\gemba\artifactresolver\MavenDependencyDownloader.java---
package com.github.gemba.artifactresolver;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import org.apache.commons.cli.CommandLine;
import org.apache.commons.cli.CommandLineParser;
import org.apache.commons.cli.DefaultParser;
import org.apache.commons.cli.HelpFormatter;
import org.apache.commons.cli.Option;
import org.apache.commons.cli.Options;
import org.apache.commons.cli.ParseException;
import org.apache.commons.io.IOUtils;
import org.eclipse.aether.artifact.DefaultArtifact;
import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
public class MavenDependencyDownloader {
	private static final String DEFAULT_LOCAL_DOWNLOAD_REPO = "D:\\androidMavenRepository";
	private static final String DEFAULT_DEPENDENCY_FILE = "dependencies.json";
	private static final String EXTRA_REPO_FILE = "extra-repos.json";
	private static final Logger log = LoggerFactory.getLogger(MavenDependencyDownloader.class);
	private static Options options;
	private static boolean javadoc = false;
	private static boolean sources = false;
	private static String dependencyFile;
	private static String localRepo;
	private static ArrayList<DefaultArtifact> artifacts;
	private static DependencyResolver dependencyResolver;
	private static Map<String, String> extraRepos = new HashMap();
	private MavenDependencyDownloader() {
		this.createOptions();
	}
	public static void main(String[] args) throws Exception {
		new MavenDependencyDownloader();
		parseCommandLine(args);
		readExtraRepos();
		RepositorySystemHelper repoSystemHelper = new RepositorySystemHelper(localRepo, extraRepos);
		dependencyResolver = new DependencyResolver(repoSystemHelper);
		if (artifacts.isEmpty()) {
			JSONParser jsonParser = new JSONParser();
			FileReader fileReader = new FileReader(new File(dependencyFile));
			JSONArray jsonArray = (JSONArray)jsonParser.parse(fileReader);
			fileReader.close();
			Iterator var6 = jsonArray.iterator();
			while(var6.hasNext()) {
				Object obj = var6.next();
				JSONObject jsonObj = (JSONObject)obj;
				String groupId = (String)jsonObj.get("groupId");
				String artifactId = (String)jsonObj.get("artifactId");
				String classifier = (String)jsonObj.get("classifier");
				String extension = (String)jsonObj.get("extension");
				String version = (String)jsonObj.get("version");
				DefaultArtifact artifact = new DefaultArtifact(groupId, artifactId, classifier, extension, version);
				dependencyResolver.getProjDepArtifactFilePath(artifact);
			}
		} else {
			Iterator var15 = artifacts.iterator();
			while(var15.hasNext()) {
				DefaultArtifact artifact = (DefaultArtifact)var15.next();
				dependencyResolver.downloadDependencyTree(artifact, javadoc, sources);
			}
		}
		log.info("... artifacts downloaded to \"{}\". Finished. Thank you.", localRepo);
	}
	private static void parseCommandLine(String[] args) {
		CommandLineParser parser = new DefaultParser();
		CommandLine line = null;
		try {
			line = parser.parse(options, args);
		} catch (ParseException var8) {
			System.err.println("Parsing failed: " + var8.getMessage());
			System.exit(1);
		}
		if (line.hasOption('h')) {
			HelpFormatter formatter = new HelpFormatter();
			String header = "where each [coord] is expected in the format <groupId>:<artifactId>[:<extension>[:<classifier>]]:<version>, separate multiple [coord] by a space. If [coord] is provided the JSON file will be ignored. Defaults are: <extension>=jar, <classifier>=\"\".\n\n Options are:";
			String footer = "\nAdditonal repositories to be searched for dependencies can be added in file 'extra-repos.json'";
			formatter.printHelp(MavenDependencyDownloader.class.getSimpleName() + " [coords...] [options]", header, options, footer);
			System.exit(0);
		}
		if (line.hasOption('j')) {
			javadoc = true;
		}
		if (line.hasOption('s')) {
			sources = true;
		}
		dependencyFile = line.getOptionValue('f', "dependencies.json");
		localRepo = line.getOptionValue('d', "D:\\androidMavenRepository");
		artifacts = new ArrayList();
		String[] var6;
		int var11 = (var6 = line.getArgs()).length;
		for(int var10 = 0; var10 < var11; ++var10) {
			String arg = var6[var10];
			if (arg.contains(":")) {
				DefaultArtifact artifact = new DefaultArtifact(arg);
				artifacts.add(artifact);
			}
		}
	}
	private void createOptions() {
		options = new Options();
		Option help = new Option("h", "help", false, "print this usage and exit");
		Option jsonFile = Option.builder("f").longOpt("dependency-file").desc("use this JSON dependency file (default:dependencies.json)").hasArg().argName("JSON-File").build();
		Option depDir = Option.builder("d").longOpt("dependency-dir").desc("download dependencies to this folder (default:D:\\androidMavenRepository)").hasArg().argName("Directory").build();
		Option javadoc = Option.builder("j").longOpt("with-javadoc").desc("download javadoc attachment of artifact").build();
		Option sources = Option.builder("s").longOpt("with-sources").desc("download source attachment of artifact").build();
		options.addOption(help);
		options.addOption(depDir);
		options.addOption(jsonFile);
		options.addOption(javadoc);
		options.addOption(sources);
	}
	private static void readExtraRepos() throws Exception {
		JSONParser jsonParser = new JSONParser();
		FileReader fileReader = null;
		try {
			fileReader = new FileReader(new File("extra-repos.json"));
			JSONArray jsonArray = (JSONArray)jsonParser.parse(fileReader);
			fileReader.close();
			Iterator var4 = jsonArray.iterator();
			while(var4.hasNext()) {
				Object obj = var4.next();
				JSONObject jsonObj = (JSONObject)obj;
				String id = (String)jsonObj.get("id");
				String repourl = (String)jsonObj.get("repourl");
				extraRepos.put(id, repourl);
			}
			return;
		} catch (FileNotFoundException var11) {
			log.debug("No extra repositories defined. File not found: {}.", "extra-repos.json");
		} finally {
			IOUtils.closeQuietly(fileReader);
		}
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\com\github\gemba\artifactresolver\RepositorySystemHelper.java---
package com.github.gemba.artifactresolver;
import java.util.Iterator;
import java.util.Map;
import java.util.Map.Entry;
import org.apache.maven.repository.internal.MavenRepositorySystemUtils;
import org.eclipse.aether.DefaultRepositorySystemSession;
import org.eclipse.aether.RepositorySystem;
import org.eclipse.aether.RepositorySystemSession;
import org.eclipse.aether.collection.CollectRequest;
import org.eclipse.aether.collection.DependencyCollectionException;
import org.eclipse.aether.collection.DependencySelector;
import org.eclipse.aether.connector.basic.BasicRepositoryConnectorFactory;
import org.eclipse.aether.graph.Dependency;
import org.eclipse.aether.graph.DependencyNode;
import org.eclipse.aether.impl.DefaultServiceLocator;
import org.eclipse.aether.impl.DefaultServiceLocator.ErrorHandler;
import org.eclipse.aether.repository.LocalRepository;
import org.eclipse.aether.repository.RemoteRepository;
import org.eclipse.aether.repository.RemoteRepository.Builder;
import org.eclipse.aether.resolution.ArtifactRequest;
import org.eclipse.aether.resolution.ArtifactResolutionException;
import org.eclipse.aether.resolution.ArtifactResult;
import org.eclipse.aether.resolution.DependencyRequest;
import org.eclipse.aether.resolution.DependencyResolutionException;
import org.eclipse.aether.resolution.DependencyResult;
import org.eclipse.aether.spi.connector.RepositoryConnectorFactory;
import org.eclipse.aether.spi.connector.transport.TransporterFactory;
import org.eclipse.aether.transport.file.FileTransporterFactory;
import org.eclipse.aether.transport.http.HttpTransporterFactory;
import org.eclipse.aether.util.graph.selector.AndDependencySelector;
import org.eclipse.aether.util.graph.selector.ExclusionDependencySelector;
import org.eclipse.aether.util.graph.selector.OptionalDependencySelector;
import org.eclipse.aether.util.graph.selector.ScopeDependencySelector;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
public class RepositorySystemHelper {
	private RepositorySystem repoSystem = this.newRepositorySystem();
	private RepositorySystemSession session;
	private CollectRequest collectRequest;
	private static final Logger log = LoggerFactory.getLogger(RepositorySystemHelper.class);
	public RepositorySystemHelper(String localRepoDir, Map<String, String> extraRepos) {
		this.session = this.newSession(this.repoSystem, localRepoDir);
		RemoteRepository central = (new Builder("central", "default", "http://central.maven.org/maven2/")).build();
		this.collectRequest = new CollectRequest();
		RemoteRepository repo = null;
		Entry e;
		for(Iterator iterator = extraRepos.entrySet().iterator(); iterator.hasNext(); repo = (new Builder((String)e.getKey(), "default", (String)e.getValue())).build()) {
			e = (Entry)iterator.next();
		}
	}
	public DependencyNode collectDependencies(Dependency dependency) throws DependencyCollectionException {
		this.collectRequest.setRoot(dependency);
		((DefaultRepositorySystemSession)this.session).setIgnoreArtifactDescriptorRepositories(true);
		return this.repoSystem.collectDependencies(this.session, this.collectRequest).getRoot();
	}
	public DependencyResult resolveDependencies(DependencyRequest dependencyRequest) throws DependencyResolutionException {
		return this.repoSystem.resolveDependencies(this.session, dependencyRequest);
	}
	private RepositorySystemSession newSession(RepositorySystem system, String localDownloadDir) {
		DefaultRepositorySystemSession session = MavenRepositorySystemUtils.newSession();
		session.setIgnoreArtifactDescriptorRepositories(true);
		LocalRepository localRepo = new LocalRepository(localDownloadDir);
		session.setLocalRepositoryManager(system.newLocalRepositoryManager(session, localRepo));
		DependencySelector depFilter = new AndDependencySelector(new DependencySelector[]{new ScopeDependencySelector(new String[]{"provided"}), new OptionalDependencySelector(), new ExclusionDependencySelector()});
		session.setDependencySelector(depFilter);
		return session;
	}
	private RepositorySystem newRepositorySystem() {
		DefaultServiceLocator locator = MavenRepositorySystemUtils.newServiceLocator();
		locator.addService(RepositoryConnectorFactory.class, BasicRepositoryConnectorFactory.class);
		locator.addService(TransporterFactory.class, FileTransporterFactory.class);
		locator.addService(TransporterFactory.class, HttpTransporterFactory.class);
		locator.setErrorHandler(new ErrorHandler() {
			public void serviceCreationFailed(Class<?> type, Class<?> impl, Throwable exception) {
				exception.printStackTrace();
			}
		});
		return (RepositorySystem)locator.getService(RepositorySystem.class);
	}
	public ArtifactResult resolveArtifact(ArtifactRequest ar) throws ArtifactResolutionException {
		((DefaultRepositorySystemSession)this.session).setIgnoreArtifactDescriptorRepositories(true);
		return this.repoSystem.resolveArtifact(this.session, ar);
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\objinit\ObjWithDefaultValCreator.java---
package objinit;
import codegen.complexobj.CodeGenContext;
import javax.xml.datatype.DatatypeConfigurationException;
import javax.xml.datatype.DatatypeFactory;
import javax.xml.datatype.XMLGregorianCalendar;
import java.lang.reflect.*;
import java.util.*;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import java.util.stream.Stream;
public class ObjWithDefaultValCreator {
	public static Object getDefaultVal(Class c) {
		Object defaultVal = null;
		if (c != null) {
			String typeName = c.getName();
			if (typeName.equals("java.lang.String")) {
				defaultVal = "";
			}
			if (typeName.equals("java.lang.Boolean") || typeName.equals("boolean")) {
				defaultVal = Boolean.FALSE;
			}
			if (typeName.equals("java.lang.Long") || typeName.equals("long")) {
				defaultVal = Long.valueOf(1L);
			}
			if (typeName.equals("java.lang.Double") || typeName.equals("double")) {
				defaultVal = Double.valueOf(0d);
			}
			if (typeName.equals("java.lang.Integer") || typeName.equals("int")) {
				defaultVal = Integer.valueOf(1);
			}
			if (typeName.equals("java.lang.Short") || typeName.equals("short")) {
				defaultVal = Short.valueOf((short) 1);
			}
			if (typeName.equals("java.lang.Float") || typeName.equals("float")) {
				defaultVal = Float.valueOf(1f);
			}
			if (typeName.equals("java.lang.Character") || typeName.equals("char")) {
				return 'a';
			}
			if (typeName.equals("java.util.Date")) {
				defaultVal = new Date();
			}
			if (typeName.equals("java.sql.Date")) {
				defaultVal = new java.sql.Date(new Date().getTime());
			}
			if (typeName.startsWith("java.util.Map")) {
				defaultVal = new HashMap();
			}
			if (typeName.startsWith("java.util.Set")) {
				defaultVal = new HashSet();
			}
			if (typeName.equals("java.math.BigInteger")) {
				defaultVal = java.math.BigInteger.valueOf(1);
			}
			if (typeName.equals("java.math.BigDecimal")) {
				defaultVal = java.math.BigDecimal.valueOf(0);
			}
			if (typeName.equals("javax.xml.datatype.XMLGregorianCalendar")) {
				defaultVal = toXMLGregorianCalendar(new Date());
			}
			if (c != null && c.isEnum()) {
				defaultVal = getEnum(c);
			}
		}
		return defaultVal;
	}
	private static DatatypeFactory df = null;
	static {
		try {
			df = DatatypeFactory.newInstance();
		} catch (DatatypeConfigurationException dce) {
			throw new IllegalStateException("Exception", dce);
		}
	}
	public static XMLGregorianCalendar toXMLGregorianCalendar(long timeInMillis) {
		GregorianCalendar gc = new GregorianCalendar();
		gc.setTimeInMillis(timeInMillis);
		return df.newXMLGregorianCalendar(gc);
	}
	public static XMLGregorianCalendar toXMLGregorianCalendar(Date date) {
		if (date == null) {
			return null;
		} else {
			return toXMLGregorianCalendar(date.getTime());
		}
	}
	public static boolean isComplexType(Class c) {
		boolean b = false;
		if (c.isPrimitive() || c.isEnum()) {
			return b;
		}
		/*
		 * if (c.isArray()) { c = c.getComponentType(); }
		 */
		String typeName = c.getName();
		if (typeName.equals("java.lang.String")) {
			return b;
		}
		if (typeName.equals("java.lang.Boolean") || typeName.equals("boolean")) {
			return b;
		}
		if (typeName.equals("java.lang.Character") || typeName.equals("char")) {
			return b;
		}
		if (typeName.equals("java.lang.Long") || typeName.equals("long")) {
			return b;
		}
		if (typeName.equals("java.lang.Double") || typeName.equals("double")) {
			return b;
		}
		if (typeName.equals("java.lang.Integer") || typeName.equals("int")) {
			return b;
		}
		if (typeName.equals("java.lang.Short") || typeName.equals("short")) {
			return b;
		}
		if (typeName.equals("java.lang.Float") || typeName.equals("float")) {
			return b;
		}
		if (typeName.equals("java.lang.Byte") || typeName.equals("byte")) {
			return b;
		}
		if (typeName.equals("java.util.Date")) {
			return b;
		}
		if (typeName.equals("java.math.BigInteger")) {
			return b;
		}
		if (typeName.equals("java.math.BigDecimal")) {
			return b;
		}
		if (typeName.equals("javax.xml.datatype.XMLGregorianCalendar")) {
			return b;
		}
		b = true;
		return b;
	}
	public static Object getEnum(Class c) {
		StringBuilder sb = new StringBuilder();
		String classNameForPrint = c.getName().replaceAll("\\$", "\\.");
		Object obj[] = c.getEnumConstants();
		return obj[0];
	}
	public <T> T newInstanceByConstructor(Class<T> qn) {
		T obj = null;
		if (!this.isComplexType(qn)) {
			obj = (T) getDefaultVal(qn);
			return obj;
		}
		try {
			obj = qn.newInstance();
		} catch (InstantiationException | IllegalAccessException e1) {
			Constructor<?> cts[] = qn.getConstructors();
			List<Constructor> list = Arrays.asList(cts);
			list.sort((c1, c2) -> {
				int c1ParamCount = c1.getParameterCount();
				int c2ParamCount = c1.getParameterCount();
				return c1ParamCount - c2ParamCount;
			});
			if (list.size() > 0) {
				Constructor<?> cs = list.get(0);
				Parameter pts[] = cs.getParameters();
				try {
					obj = (T) cs.newInstance();
				} catch (InstantiationException | IllegalAccessException | IllegalArgumentException
						| InvocationTargetException e) {
				}
			}
		}
		return obj;
	}
	public static boolean isAbstractOrInterface(Class clzToTest) {
		boolean abs = false;
		if (!clzToTest.isPrimitive() && (clzToTest.isInterface() || isAbstract(clzToTest))) {
			abs = true;
		}
		return abs;
	}
	public static boolean isAbstract(Class clzToTest) {
		boolean abs = false;
		if ((clzToTest.getModifiers() & Modifier.ABSTRACT) == Modifier.ABSTRACT) {
			abs = true;
		}
		return abs;
	}
	public static Class getDefaultConcreteClass(Class interfaceC) {
		Class concreteC = null;
		if (!interfaceC.isInterface() && !isAbstract(interfaceC) && !interfaceC.isArray()) {
			return interfaceC;
		}
		if (List.class.isAssignableFrom(interfaceC) || AbstractList.class.isAssignableFrom(interfaceC)
				|| Iterable.class.isAssignableFrom(interfaceC)) {
			concreteC = ArrayList.class;
		} else if (Map.class.isAssignableFrom(interfaceC) || AbstractMap.class.isAssignableFrom(interfaceC)) {
			concreteC = HashMap.class;
		} else if (Set.class.isAssignableFrom(interfaceC) || AbstractSet.class.isAssignableFrom(interfaceC)) {
			concreteC = HashSet.class;
		}
		return concreteC;
	}
	class clzRef {
		Class c;
		Class referenceC;
		AtomicInteger passByTimes = new AtomicInteger(0);
		public AtomicInteger getPassByTimes() {
			return passByTimes;
		}
		public void setPassByTimes(AtomicInteger passByTimes) {
			this.passByTimes = passByTimes;
		}
		public Class getC() {
			return c;
		}
		public void setC(Class c) {
			this.c = c;
		}
		public Class getReferenceC() {
			return referenceC;
		}
		public void setReferenceC(Class referenceC) {
			this.referenceC = referenceC;
		}
		public clzRef(Class c, Class referenceC) {
			super();
			this.c = c;
			this.referenceC = referenceC;
			this.passByTimes.getAndSet(0);
		}
		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;
			result = prime * result + getOuterType().hashCode();
			result = prime * result + ((c == null) ? 0 : c.hashCode());
			result = prime * result + ((referenceC == null) ? 0 : referenceC.hashCode());
			return result;
		}
		@Override
		public boolean equals(Object obj) {
			if (this == obj)
				return true;
			if (obj == null)
				return false;
			if (getClass() != obj.getClass())
				return false;
			clzRef other = (clzRef) obj;
			if (!getOuterType().equals(other.getOuterType()))
				return false;
			if (c == null) {
				if (other.c != null)
					return false;
			} else if (!c.equals(other.c))
				return false;
			if (referenceC == null) {
				if (other.referenceC != null)
					return false;
			} else if (!referenceC.equals(other.referenceC))
				return false;
			return true;
		}
		@Override
		public String toString() {
			StringBuilder builder = new StringBuilder();
			builder.append("clzRef [");
			builder.append(c.getSimpleName());
			builder.append("-->");
			builder.append(referenceC.getSimpleName());
			builder.append("]");
			return builder.toString();
		}
		private ObjWithDefaultValCreator getOuterType() {
			return ObjWithDefaultValCreator.this;
		}
	}
	public Map<Class, AtomicInteger> getAllCircularDependencyRelatedClz(Map<clzRef, List<clzRef>> map) {
		List<Class> list = new ArrayList<>();
		map.entrySet().forEach(e -> {
			Class keyC = e.getKey().getC();
			Class keyRefC = e.getKey().getReferenceC();
			List<clzRef> valList = e.getValue();
			if (!list.contains(keyC))
				list.add(keyC);
			if (!list.contains(keyRefC))
				list.add(keyRefC);
			valList.forEach(e1 -> {
				if (!list.contains(e1.getC()))
					list.add(e1.getC());
				if (!list.contains(e1.getReferenceC()))
					list.add(e1.getReferenceC());
			});
		});
		Map<Class, AtomicInteger> circularDependencyRelatedClzMap = list.stream()
				.collect(Collectors.toMap(e -> e, e -> {
					return new AtomicInteger(0);
				}, (e1, e2) -> e1));
		return circularDependencyRelatedClzMap;
	}
	public Map<clzRef, List<clzRef>> getCircularDependencyPath(List<clzRef> clzRefList) {
		Map<clzRef, List<clzRef>> alldependencyPath = new HashMap<>();
		Map<clzRef, List<clzRef>> selfdependencyPath = clzRefList.stream().filter(cr -> {
			return cr.getC().equals(cr.getReferenceC());
		}).collect(Collectors.toMap(e -> clzRef.class.cast(e), e -> {
			return Stream.of(clzRef.class.cast(e)).collect(Collectors.toList());
		}, (e1, e2) -> e1));
		alldependencyPath.putAll(selfdependencyPath);
		List<clzRef> notSelfDependencyList = clzRefList.stream().filter(cr -> {
			if (!cr.getC().equals(cr.getReferenceC())) {
				return true;
			} else {
				return false;
			}
		}).collect(Collectors.toList());
		List<Class> distinctReferenceClz = notSelfDependencyList.stream().map(
				clzRef::getReferenceC).distinct()
				.collect(Collectors.toList());
		List<clzRef> startPointClzRefMayContainsCircularDependency = notSelfDependencyList.stream().filter(cr -> {
			return distinctReferenceClz.contains(cr.getC());
		}).distinct().collect(Collectors.toList());
		Map<clzRef, List<clzRef>> dependencyPath = new HashMap<>();
		startPointClzRefMayContainsCircularDependency.stream().forEach(cr -> {
			List<clzRef> allPath = new ArrayList<>();
			allPath.add(cr);
			dependencyPath.put(cr, allPath);
			getCircularDepencyPath(cr, null, notSelfDependencyList, dependencyPath);
			notSelfDependencyList.stream().forEach(d -> {
				d.getPassByTimes().set(0);
			});
		});
		dependencyPath.keySet().forEach(k -> {
			List<clzRef> tmpdependencyPath = dependencyPath.get(k);
			if (tmpdependencyPath.size() >= 2) {
				clzRef startclzRef = tmpdependencyPath.get(0);
				clzRef lastclzRef = tmpdependencyPath.get(tmpdependencyPath.size() - 1);
				if (startclzRef.getC().equals(lastclzRef.getReferenceC())) {
					alldependencyPath.put(k, tmpdependencyPath);
				}
			}
		});
		return alldependencyPath;
	}
	public void getCircularDepencyPath(clzRef startClzRef, clzRef nextClzRef, List<clzRef> notSelfDependencyList,
			Map<clzRef, List<clzRef>> dependencyPath) {
		if (nextClzRef == null) {
			startClzRef.getPassByTimes().incrementAndGet();
			List<clzRef> nextClzRefList = notSelfDependencyList.stream().filter(cr -> {
				return cr.getPassByTimes().get() == 0 && cr.getC().equals(startClzRef.getReferenceC());
			}).collect(Collectors.toList());
			nextClzRefList.forEach(cr -> {
				getCircularDepencyPath(startClzRef, cr, notSelfDependencyList, dependencyPath);
			});
		} else {
			nextClzRef.getPassByTimes().incrementAndGet();
			if (dependencyPath.containsKey(startClzRef)) {
				dependencyPath.get(startClzRef).add(nextClzRef);
			}
			if (nextClzRef.getReferenceC().equals(startClzRef.getC())) {
				return;
			}
			List<clzRef> nextClzRefList = notSelfDependencyList.stream().filter(cr -> {
				return cr.getPassByTimes().get() == 0 && cr.getC().equals(nextClzRef.getReferenceC());
			}).collect(Collectors.toList());
			nextClzRefList.forEach(cr -> {
				getCircularDepencyPath(startClzRef, cr, notSelfDependencyList, dependencyPath);
			});
		}
	}
	/*
	 * public void getCircularDepencyPath(clzRef startClzRef, clzRef nextClzRef,
	 * List<clzRef> notSelfDependencyList, Map<clzRef, List<clzRef>> dependencyPath)
	 * { if (nextClzRef == null) { startClzRef.getPassByTimes().incrementAndGet();
	 * List<clzRef> nextClzRefList = notSelfDependencyList.stream().filter(cr -> {
	 * return cr.getPassByTimes().get() == 0 &&
	 * cr.getC().equals(startClzRef.getReferenceC());
	 * }).collect(Collectors.toList()); nextClzRefList.forEach(cr -> {
	 * getCircularDepencyPath(startClzRef, cr, notSelfDependencyList,
	 * dependencyPath); }); } else { nextClzRef.getPassByTimes().incrementAndGet();
	 * if (dependencyPath.containsKey(startClzRef)) {
	 * dependencyPath.get(startClzRef).add(nextClzRef); } if
	 * (nextClzRef.getReferenceC().equals(startClzRef.getC())) { return; }
	 * List<clzRef> nextClzRefList = notSelfDependencyList.stream().filter(cr -> {
	 * return cr.getPassByTimes().get() == 0 &&
	 * cr.getC().equals(nextClzRef.getReferenceC());
	 * }).collect(Collectors.toList()); nextClzRefList.forEach(cr -> {
	 * getCircularDepencyPath(startClzRef, cr, notSelfDependencyList,
	 * dependencyPath); }); } }
	 */
	public void findCircularDependcy(Class c1, List<Class<?>> alreadyWalkThrough, List<clzRef> clzRefList) {
		List<Field> list = new ArrayList<>();
		if (alreadyWalkThrough.contains(c1)) {
			return;
		}
		if (isComplexType(c1)) {
			alreadyWalkThrough.add(c1);
			list = getAllFields(c1);
			list.forEach(f -> {
				Class c = f.getType();
				if (isComplexType(c)) {
					Object complexObj = null;
					boolean isArray = c.isArray();
					boolean isAbstractOrInterface = isAbstractOrInterface(c);
					if (!isAbstractOrInterface && !isArray) {
						complexObj = newInstanceByConstructor(c);
						if (complexObj != null) {
							boolean isComplexType = isComplexType(complexObj.getClass());
							if (isComplexType) {
								clzRefList.add(new clzRef(c1, complexObj.getClass()));
								findCircularDependcy(complexObj.getClass(), alreadyWalkThrough, clzRefList);
							}
						}
					} else if (isArray) {
						complexObj = Array.newInstance(c.getComponentType(), 1);
					} else if (isAbstractOrInterface) {
						Class<?> concreteC = getDefaultConcreteClass(c);
						if (concreteC != null) {
							complexObj = this.newInstanceByConstructor(concreteC);
						}
					}
					if (complexObj != null) {
						if (isArray) {
							Class componentType = c.getComponentType();
							Class concreteC = componentType;
							if (isAbstractOrInterface(componentType)) {
								concreteC = getDefaultConcreteClass(c);
							}
							if (concreteC != null) {
								Object componentTypeObj = this.newInstanceByConstructor(concreteC);
								if (componentTypeObj != null) {
									boolean isComplexType = isComplexType(componentTypeObj.getClass());
									if (isComplexType) {
										clzRefList.add(new clzRef(c1, componentTypeObj.getClass()));
										findCircularDependcy(componentTypeObj.getClass(), alreadyWalkThrough,
												clzRefList);
									}
								}
							}
						}
						if (java.util.Collection.class.isAssignableFrom(c)) {
							String genericTypeName = f.getGenericType().getTypeName();
							String genericType = null;
							Pattern p = Pattern.compile("<(.+)>");
							Matcher m = p.matcher(genericTypeName);
							if (m.find()) {
								genericType = m.group(1);
								try {
									String javaformatgenericType = genericType;// genericType.replaceAll("\\$",
									Class genericTypeC = CodeGenContext.getInstance()
											.getReloadableDynamicClassLoaderOwner()
											.loadClass(javaformatgenericType, true);
									Class concreteC = genericTypeC;
									if (isAbstractOrInterface(genericTypeC)) {
										concreteC = getDefaultConcreteClass(c);
									}
									if (concreteC != null) {
										Object componentTypeObj = this.newInstanceByConstructor(concreteC);
										if (componentTypeObj != null) {
											boolean isComplexType = isComplexType(componentTypeObj.getClass());
											boolean at = alreadyWalkThrough.contains(componentTypeObj.getClass());
											if (isComplexType) {
												clzRefList.add(new clzRef(c1, componentTypeObj.getClass()));
												findCircularDependcy(componentTypeObj.getClass(), alreadyWalkThrough,
														clzRefList);
											}
										}
									}
								} catch (Exception e) {
								}
							}
						}
						if (Map.class.isAssignableFrom(c)) {
							String genericTypeName = f.getGenericType().getTypeName();
							String genericType = null;
							Pattern p = Pattern.compile("<(.+)>");
							Matcher m = p.matcher(genericTypeName);
							Class keyType = null;
							Class valType = null;
							if (m.find()) {
								try {
									genericType = m.group(1);
								} catch (Exception e1) {
									e1.printStackTrace();
								}
								if (genericType != null) {
									try {
										String javaformatgenericType = genericType;// genericType.replaceAll("\\$",
										String gt[] = javaformatgenericType.split(",", -1);
										keyType = CodeGenContext.getInstance().getReloadableDynamicClassLoaderOwner()
												.loadClass(gt[0].trim(), true);
										valType = CodeGenContext.getInstance().getReloadableDynamicClassLoaderOwner()
												.loadClass(gt[1].trim(), true);
									} catch (Exception e) {
									}
								}
							}
							if (keyType != null && valType != null) {
								Class concreteKeyC = keyType;
								Class concreteValC = valType;
								if (isAbstractOrInterface(keyType)) {
									concreteKeyC = getDefaultConcreteClass(keyType);
								}
								if (isAbstractOrInterface(valType)) {
									concreteValC = getDefaultConcreteClass(valType);
								}
								if (concreteKeyC != null && concreteValC != null) {
									Object keyObj = this.newInstanceByConstructor(concreteKeyC);
									Object valObj = this.newInstanceByConstructor(concreteValC);
									if (keyObj != null && valObj != null) {
										boolean isComplexType = isComplexType(keyObj.getClass());
										if (isComplexType) {
											clzRefList.add(new clzRef(c1, keyObj.getClass()));
											findCircularDependcy(keyObj.getClass(), alreadyWalkThrough, clzRefList);
										}
										boolean isvalObjComplexType = isComplexType(valObj.getClass());
										if (isvalObjComplexType) {
											clzRefList.add(new clzRef(c1, valObj.getClass()));
											findCircularDependcy(valObj.getClass(), alreadyWalkThrough, clzRefList);
										}
									}
								}
							}
						}
					}
				}
			});
		}
	}
	public Map<Class, AtomicInteger> getAllCircularDependencyClzMap(Class c) {
		List<Class<?>> alreadyWalkThrough = new ArrayList<>();
		List<clzRef> clzRefList = new ArrayList<>();
		this.findCircularDependcy(c, alreadyWalkThrough, clzRefList);
		Map<clzRef, List<clzRef>> circularDependencyMap = this.getCircularDependencyPath(clzRefList);
		Map<Class, AtomicInteger> allCircularDependencyClz = this
				.getAllCircularDependencyRelatedClz(circularDependencyMap);
		return allCircularDependencyClz;
	}
	public static boolean isExclusive(String expression, String exclusiveRegex) {
		if (exclusiveRegex == null || "".equals(exclusiveRegex)) {
			return false;
		}
		Pattern p = Pattern.compile(exclusiveRegex);
		Matcher m = p.matcher(expression);
		return m.matches();
	}
	public void newInstanceRecusively(Object tobj, List allComplexTypeObj,
			Map<Class, AtomicInteger> circularDependencyRelatedClzMap, int defaultSize, String exclusiveRegex) {
		List<Field> list = new ArrayList<>();
		Class c1 = tobj.getClass();
		if (isComplexType(c1)) {
			allComplexTypeObj.add(tobj);
			if (circularDependencyRelatedClzMap.containsKey(c1)) {
				if (circularDependencyRelatedClzMap.get(c1).get() > 0) {
					return;
				} else {
					circularDependencyRelatedClzMap.get(c1).incrementAndGet();
				}
			}
			list = getAllFields(c1, exclusiveRegex);
			list.forEach(f -> {
				Class c = f.getType();
				boolean isExclusive = isExclusive(c.getName(), exclusiveRegex);
				if (!isExclusive && isComplexType(c)) {
					Object complexObj = null;
					boolean isArray = c.isArray();
					boolean isAbstractOrInterface = isAbstractOrInterface(c);
					if (!isAbstractOrInterface && !isArray) {
						complexObj = newInstanceByConstructor(c);
						if (complexObj != null) {
							boolean isComplexType = isComplexType(complexObj.getClass());
							if (isComplexType) {
								allComplexTypeObj.add(complexObj);
								newInstanceRecusively(complexObj, allComplexTypeObj, circularDependencyRelatedClzMap,
										defaultSize, exclusiveRegex);
							}
						}
					} else if (isArray) {
						complexObj = Array.newInstance(c.getComponentType(), defaultSize);
					} else if (isAbstractOrInterface) {
						Class<?> concreteC = getDefaultConcreteClass(c);
						if (concreteC != null) {
							complexObj = this.newInstanceByConstructor(concreteC);
						}
					}
					if (complexObj != null) {
						f.setAccessible(true);
						try {
							isExclusive = isExclusive(complexObj.getClass().getName(), exclusiveRegex);
							if (!isExclusive)
								f.set(tobj, complexObj);
						} catch (Exception e) {
						}
					}
					if (isArray) {
						Class componentType = c.getComponentType();
						Class concreteC = componentType;
						if (isAbstractOrInterface(componentType)) {
							concreteC = getDefaultConcreteClass(c);
						}
						if (concreteC != null) {
							for (int i = 0; i < defaultSize; i++) {
								Object componentTypeObj = this.newInstanceByConstructor(concreteC);
								if (componentTypeObj != null) {
									Array.set(complexObj, i, componentTypeObj);
									boolean isComplexType = isComplexType(componentTypeObj.getClass());
									if (isComplexType) {
										allComplexTypeObj.add(componentTypeObj);
										newInstanceRecusively(componentTypeObj, allComplexTypeObj,
												circularDependencyRelatedClzMap, defaultSize, exclusiveRegex);
									}
								}
							}
						}
					}
					if (java.util.Collection.class.isAssignableFrom(c)) {
						String genericTypeName = f.getGenericType().getTypeName();
						String genericType = null;
						Pattern p = Pattern.compile("<(.+)>");
						Matcher m = p.matcher(genericTypeName);
						if (m.find()) {
							genericType = m.group(1);
							try {
								String javaformatgenericType = genericType;// genericType.replaceAll("\\$",
								Class genericTypeC = CodeGenContext.getInstance().getReloadableDynamicClassLoaderOwner()
										.loadClass(javaformatgenericType, true);
								Class concreteC = genericTypeC;
								if (isAbstractOrInterface(genericTypeC)) {
									concreteC = getDefaultConcreteClass(c);
								}
								isExclusive = isExclusive(concreteC.getName(), exclusiveRegex);
								if (!isExclusive && concreteC != null) {
									for (int i = defaultSize; i > 0; i--) {
										Object componentTypeObj = this.newInstanceByConstructor(concreteC);
										if (componentTypeObj != null) {
											List listTmp = (List) complexObj;
											listTmp.add(componentTypeObj);
											boolean isComplexType = isComplexType(componentTypeObj.getClass());
											if (isComplexType) {
												allComplexTypeObj.add(componentTypeObj);
												newInstanceRecusively(componentTypeObj, allComplexTypeObj,
														circularDependencyRelatedClzMap, defaultSize, exclusiveRegex);
											}
										}
									}
								}
							} catch (Exception e) {
							}
						}
					}
					if (Map.class.isAssignableFrom(c)) {
						String genericTypeName = f.getGenericType().getTypeName();
						String genericType = null;
						Pattern p = Pattern.compile("<(.+)>");
						Matcher m = p.matcher(genericTypeName);
						Class keyType = null;
						Class valType = null;
						if (m.find()) {
							try {
								genericType = m.group(1);
							} catch (Exception e1) {
								e1.printStackTrace();
							}
							if (genericType != null) {
								try {
									String javaformatgenericType = genericType;// genericType.replaceAll("\\$",
									String gt[] = javaformatgenericType.split(",", -1);
									keyType = CodeGenContext.getInstance().getReloadableDynamicClassLoaderOwner()
											.loadClass(gt[0].trim(), true);
									valType = CodeGenContext.getInstance().getReloadableDynamicClassLoaderOwner()
											.loadClass(gt[1].trim(), true);
								} catch (Exception e) {
								}
							}
						}
						if (keyType != null && valType != null) {
							Class concreteKeyC = keyType;
							Class concreteValC = valType;
							if (isAbstractOrInterface(keyType)) {
								concreteKeyC = getDefaultConcreteClass(keyType);
							}
							if (isAbstractOrInterface(valType)) {
								concreteValC = getDefaultConcreteClass(valType);
							}
							boolean isKeyConcern = isExclusive(concreteKeyC.getName(), exclusiveRegex);
							boolean isValConcern = isExclusive(concreteValC.getName(), exclusiveRegex);
							if (isKeyConcern && isValConcern && concreteKeyC != null && concreteValC != null) {
								for (int i = defaultSize; i > 0; i--) {
									Object keyObj = this.newInstanceByConstructor(concreteKeyC);
									Object valObj = this.newInstanceByConstructor(concreteValC);
									if (keyObj != null && valObj != null) {
										Map tmp = (Map) complexObj;
										tmp.put(keyObj, valObj);
										boolean isComplexType = isComplexType(keyObj.getClass());
										if (isComplexType) {
											allComplexTypeObj.add(keyObj);
											newInstanceRecusively(keyObj, allComplexTypeObj,
													circularDependencyRelatedClzMap, defaultSize, exclusiveRegex);
										}
										boolean isvalObjComplexType = isComplexType(valObj.getClass());
										if (isvalObjComplexType) {
											allComplexTypeObj.add(valObj);
											newInstanceRecusively(valObj, allComplexTypeObj,
													circularDependencyRelatedClzMap, defaultSize, exclusiveRegex);
										}
									}
								}
							}
						}
					}
				}
			});
		}
	}
	public static List<Field> getAllFields(Class c) {
		return getAllFields(c, null);
	}
	public static List<Field> getAllFields(Class c, String exclusiveRegex) {
		List<Field> allFieldList = new ArrayList<>();
		while (c != Object.class) {
			boolean isExclusive = isExclusive(c.getName(), exclusiveRegex);
			if (isExclusive) {
				break;
			}
			allFieldList.addAll(Arrays.asList(c.getDeclaredFields()));
			c = c.getSuperclass();
		}
		return allFieldList;
	}
	public void assignPrimitiveTypes(Object tobj) {
		assignPrimitiveTypes(tobj, null);
	}
	public void assignPrimitiveTypes(Object tobj, String exclusiveRegex) {
		List<Field> list = new ArrayList<>();
		Class c1 = tobj.getClass();
		list = getAllFields(c1, exclusiveRegex);
		list.forEach(f -> {
			Class c = f.getType();
			boolean isExclusive = isExclusive(c.getName(), exclusiveRegex);
			if (!isExclusive && !isComplexType(c)) {
				Object obj = null;
				f.setAccessible(true);
				/*
				 * try { obj = f.get(tobj); } catch (Exception e) { e.printStackTrace(); }
				 */
				Object value = this.getDefaultVal(c);
				try {
					f.set(tobj, value);
				} catch (Exception e) {
				}
			}
		});
	}
	public void assignComplextTypes(Object tobj, List<?> allComplexTypeObj) {
		assignComplextTypes(tobj, allComplexTypeObj, null);
	}
	public void assignComplextTypes(Object tobj, List<?> allComplexTypeObj, String exclusiveRegex) {
		List<Field> list = new ArrayList<>();
		Class c1 = tobj.getClass();
		list = getAllFields(c1, exclusiveRegex);
		list.forEach(f -> {
			try {
				f.setAccessible(true);
				Object fval = f.get(tobj);
				if (fval == null) {
					Class c = f.getType();
					Object alreadyCreatedInstance = null;
					try {
						alreadyCreatedInstance = allComplexTypeObj.stream().filter(e -> {
							return c.isInstance(e);
						}).findAny().get();
					} catch (Exception e1) {
					}
					boolean isExclusive = isExclusive(alreadyCreatedInstance.getClass().getCanonicalName(),
							exclusiveRegex) || isExclusive(c.getCanonicalName(), exclusiveRegex);
					if (alreadyCreatedInstance != null && !isExclusive) {
						try {
							f.set(tobj, alreadyCreatedInstance);
						} catch (Exception e) {
						}
					}
				}
			} catch (Exception e1) {
			}
		});
	}
	public <T> List<Class<?>> getAllReferComplexType(Class<T> t){
		List<Class<?>> allComplexTypeObj = new ArrayList<>();
		List<Class<?>> alreadyWalkThrough = new ArrayList<>();
		T obj = newInstanceByConstructor(t);
		if (obj != null) {
			List<clzRef> clzRefList = new ArrayList<>();
			this.findCircularDependcy(t, alreadyWalkThrough, clzRefList);
			for(clzRef cr : clzRefList){
				if(null!=cr.getC()){
					allComplexTypeObj.add(cr.getC());
				}
				if(null!=cr.getReferenceC()){
					allComplexTypeObj.add(cr.getReferenceC());
				}
			}
			allComplexTypeObj=allComplexTypeObj.stream().distinct().collect(Collectors.toList());
		}
		return allComplexTypeObj;
	}
	public <T> T newInstance(Class<T> t) {
		return newInstance(t, 2);
	}
	public <T> T newInstance(Class<T> t, int defaultSize) {
		return newInstance(t, defaultSize, null);
	}
	public <T> T newInstance(Class<T> t, int defaultSize, String exclusiveRegex) {
		List<?> allComplexTypeObj = new ArrayList<>();
		List<Class<?>> alreadyWalkThrough = new ArrayList<>();
		T obj = newInstanceByConstructor(t);
		if (obj != null) {
			List<clzRef> clzRefList = new ArrayList<>();
			this.findCircularDependcy(t, alreadyWalkThrough, clzRefList);
			Map<clzRef, List<clzRef>> circularDependencyMap = this.getCircularDependencyPath(clzRefList);
			Map<Class, AtomicInteger> allCircularDependencyClz = this
					.getAllCircularDependencyRelatedClz(circularDependencyMap);
			newInstanceRecusively(obj, allComplexTypeObj, allCircularDependencyClz, defaultSize, exclusiveRegex);
			allComplexTypeObj.forEach(ct -> {
				assignPrimitiveTypes(ct, exclusiveRegex);
				assignComplextTypes(ct, allComplexTypeObj, exclusiveRegex);
			});
		}
		return obj;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\objinit\ObjWithDefaultValCreatorStandAlone.java---
package objinit;
import javax.xml.datatype.DatatypeConfigurationException;
import javax.xml.datatype.DatatypeFactory;
import javax.xml.datatype.XMLGregorianCalendar;
import java.lang.reflect.*;
import java.util.*;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import java.util.stream.Stream;
public class ObjWithDefaultValCreatorStandAlone {
	public static Object getDefaultVal(Class c) {
		Object defaultVal = null;
		if (c != null) {
			String typeName = c.getName();
			if (typeName.equals("java.lang.String")) {
				defaultVal = "";
			}
			if (typeName.equals("java.lang.Boolean") || typeName.equals("boolean")) {
				defaultVal = Boolean.FALSE;
			}
			if (typeName.equals("java.lang.Long") || typeName.equals("long")) {
				defaultVal = Long.valueOf(1L);
			}
			if (typeName.equals("java.lang.Double") || typeName.equals("double")) {
				defaultVal = Double.valueOf(0d);
			}
			if (typeName.equals("java.lang.Integer") || typeName.equals("int")) {
				defaultVal = Integer.valueOf(1);
			}
			if (typeName.equals("java.lang.Short") || typeName.equals("short")) {
				defaultVal = Short.valueOf((short) 1);
			}
			if (typeName.equals("java.lang.Float") || typeName.equals("float")) {
				defaultVal = Float.valueOf(1f);
			}
			if (typeName.equals("java.lang.Character") || typeName.equals("char")) {
				return 'a';
			}
			if (typeName.equals("java.util.Date")) {
				defaultVal = new Date();
			}
			if (typeName.equals("java.sql.Date")) {
				defaultVal = new java.sql.Date(new Date().getTime());
			}
			if (typeName.startsWith("java.util.Map")) {
				defaultVal = new HashMap();
			}
			if (typeName.startsWith("java.util.Set")) {
				defaultVal = new HashSet();
			}
			if (typeName.equals("java.math.BigInteger")) {
				defaultVal = java.math.BigInteger.valueOf(1);
			}
			if (typeName.equals("java.math.BigDecimal")) {
				defaultVal = java.math.BigDecimal.valueOf(0);
			}
			if (typeName.equals("javax.xml.datatype.XMLGregorianCalendar")) {
				defaultVal = toXMLGregorianCalendar(new Date());
			}
			if (c != null && c.isEnum()) {
				defaultVal = getEnum(c);
			}
		}
		return defaultVal;
	}
	private static DatatypeFactory df = null;
	static {
		try {
			df = DatatypeFactory.newInstance();
		} catch (DatatypeConfigurationException dce) {
			throw new IllegalStateException("Exception", dce);
		}
	}
	public static XMLGregorianCalendar toXMLGregorianCalendar(long timeInMillis) {
		GregorianCalendar gc = new GregorianCalendar();
		gc.setTimeInMillis(timeInMillis);
		return df.newXMLGregorianCalendar(gc);
	}
	public static XMLGregorianCalendar toXMLGregorianCalendar(Date date) {
		if (date == null) {
			return null;
		} else {
			return toXMLGregorianCalendar(date.getTime());
		}
	}
	public static boolean isComplexType(Class c) {
		boolean b = false;
		if (c.isPrimitive() || c.isEnum()) {
			return b;
		}
		/*
		 * if (c.isArray()) { c = c.getComponentType(); }
		 */
		String typeName = c.getName();
		if (typeName.equals("java.lang.String")) {
			return b;
		}
		if (typeName.equals("java.lang.Boolean") || typeName.equals("boolean")) {
			return b;
		}
		if (typeName.equals("java.lang.Character") || typeName.equals("char")) {
			return b;
		}
		if (typeName.equals("java.lang.Long") || typeName.equals("long")) {
			return b;
		}
		if (typeName.equals("java.lang.Double") || typeName.equals("double")) {
			return b;
		}
		if (typeName.equals("java.lang.Integer") || typeName.equals("int")) {
			return b;
		}
		if (typeName.equals("java.lang.Short") || typeName.equals("short")) {
			return b;
		}
		if (typeName.equals("java.lang.Float") || typeName.equals("float")) {
			return b;
		}
		if (typeName.equals("java.lang.Byte") || typeName.equals("byte")) {
			return b;
		}
		if (typeName.equals("java.util.Date")) {
			return b;
		}
		if (typeName.equals("java.math.BigInteger")) {
			return b;
		}
		if (typeName.equals("java.math.BigDecimal")) {
			return b;
		}
		if (typeName.equals("javax.xml.datatype.XMLGregorianCalendar")) {
			return b;
		}
		b = true;
		return b;
	}
	public static Object getEnum(Class c) {
		StringBuilder sb = new StringBuilder();
		String classNameForPrint = c.getName().replaceAll("\\$", "\\.");
		Object obj[] = c.getEnumConstants();
		return obj[0];
	}
	public <T> T newInstanceByConstructor(Class<T> qn) {
		T obj = null;
		if (!this.isComplexType(qn)) {
			obj = (T) getDefaultVal(qn);
			return obj;
		}
		try {
			obj = qn.newInstance();
		} catch (InstantiationException | IllegalAccessException e1) {
			Constructor<?> cts[] = qn.getConstructors();
			List<Constructor> list = Arrays.asList(cts);
			list.sort((c1, c2) -> {
				int c1ParamCount = c1.getParameterCount();
				int c2ParamCount = c1.getParameterCount();
				return c1ParamCount - c2ParamCount;
			});
			if (list.size() > 0) {
				Constructor<?> cs = list.get(0);
				Parameter pts[] = cs.getParameters();
				try {
					obj = (T) cs.newInstance();
				} catch (InstantiationException | IllegalAccessException | IllegalArgumentException
						| InvocationTargetException e) {
				}
			}
		}
		return obj;
	}
	public static boolean isAbstractOrInterface(Class clzToTest) {
		boolean abs = false;
		if (!clzToTest.isPrimitive() && (clzToTest.isInterface() || isAbstract(clzToTest))) {
			abs = true;
		}
		return abs;
	}
	public static boolean isAbstract(Class clzToTest) {
		boolean abs = false;
		if ((clzToTest.getModifiers() & Modifier.ABSTRACT) == Modifier.ABSTRACT) {
			abs = true;
		}
		return abs;
	}
	public static Class getDefaultConcreteClass(Class interfaceC) {
		Class concreteC = null;
		if (!interfaceC.isInterface() && !isAbstract(interfaceC) && !interfaceC.isArray()) {
			return interfaceC;
		}
		if (List.class.isAssignableFrom(interfaceC) || AbstractList.class.isAssignableFrom(interfaceC)
				|| Iterable.class.isAssignableFrom(interfaceC)) {
			concreteC = ArrayList.class;
		} else if (Map.class.isAssignableFrom(interfaceC) || AbstractMap.class.isAssignableFrom(interfaceC)) {
			concreteC = HashMap.class;
		} else if (Set.class.isAssignableFrom(interfaceC) || AbstractSet.class.isAssignableFrom(interfaceC)) {
			concreteC = HashSet.class;
		}
		return concreteC;
	}
	class clzRef {
		Class c;
		Class referenceC;
		AtomicInteger passByTimes = new AtomicInteger(0);
		public AtomicInteger getPassByTimes() {
			return passByTimes;
		}
		public void setPassByTimes(AtomicInteger passByTimes) {
			this.passByTimes = passByTimes;
		}
		public Class getC() {
			return c;
		}
		public void setC(Class c) {
			this.c = c;
		}
		public Class getReferenceC() {
			return referenceC;
		}
		public void setReferenceC(Class referenceC) {
			this.referenceC = referenceC;
		}
		public clzRef(Class c, Class referenceC) {
			super();
			this.c = c;
			this.referenceC = referenceC;
			this.passByTimes.getAndSet(0);
		}
		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;
			result = prime * result + getOuterType().hashCode();
			result = prime * result + ((c == null) ? 0 : c.hashCode());
			result = prime * result + ((referenceC == null) ? 0 : referenceC.hashCode());
			return result;
		}
		@Override
		public boolean equals(Object obj) {
			if (this == obj)
				return true;
			if (obj == null)
				return false;
			if (getClass() != obj.getClass())
				return false;
			clzRef other = (clzRef) obj;
			if (!getOuterType().equals(other.getOuterType()))
				return false;
			if (c == null) {
				if (other.c != null)
					return false;
			} else if (!c.equals(other.c))
				return false;
			if (referenceC == null) {
				if (other.referenceC != null)
					return false;
			} else if (!referenceC.equals(other.referenceC))
				return false;
			return true;
		}
		@Override
		public String toString() {
			StringBuilder builder = new StringBuilder();
			builder.append("clzRef [");
			builder.append(c.getSimpleName());
			builder.append("-->");
			builder.append(referenceC.getSimpleName());
			builder.append("]");
			return builder.toString();
		}
		private ObjWithDefaultValCreatorStandAlone getOuterType() {
			return ObjWithDefaultValCreatorStandAlone.this;
		}
	}
	public Map<Class, AtomicInteger> getAllCircularDependencyRelatedClz(Map<clzRef, List<clzRef>> map) {
		List<Class> list = new ArrayList<>();
		map.entrySet().forEach(e -> {
			Class keyC = e.getKey().getC();
			Class keyRefC = e.getKey().getReferenceC();
			List<clzRef> valList = e.getValue();
			if (!list.contains(keyC))
				list.add(keyC);
			if (!list.contains(keyRefC))
				list.add(keyRefC);
			valList.forEach(e1 -> {
				if (!list.contains(e1.getC()))
					list.add(e1.getC());
				if (!list.contains(e1.getReferenceC()))
					list.add(e1.getReferenceC());
			});
		});
		Map<Class, AtomicInteger> circularDependencyRelatedClzMap = list.stream()
				.collect(Collectors.toMap(e -> e, e -> {
					return new AtomicInteger(0);
				}, (e1, e2) -> e1));
		return circularDependencyRelatedClzMap;
	}
	public Map<clzRef, List<clzRef>> getCircularDependencyPath(List<clzRef> clzRefList) {
		Map<clzRef, List<clzRef>> alldependencyPath = new HashMap<>();
		Map<clzRef, List<clzRef>> selfdependencyPath = clzRefList.stream().filter(cr -> {
			return cr.getC().equals(cr.getReferenceC());
		}).collect(Collectors.toMap(e -> clzRef.class.cast(e), e -> {
			return Stream.of(clzRef.class.cast(e)).collect(Collectors.toList());
		}, (e1, e2) -> e1));
		alldependencyPath.putAll(selfdependencyPath);
		List<clzRef> notSelfDependencyList = clzRefList.stream().filter(cr -> {
			if (!cr.getC().equals(cr.getReferenceC())) {
				return true;
			} else {
				return false;
			}
		}).collect(Collectors.toList());
		List<Class> distinctReferenceClz = notSelfDependencyList.stream().map(
				clzRef::getReferenceC).distinct()
				.collect(Collectors.toList());
		List<clzRef> startPointClzRefMayContainsCircularDependency = notSelfDependencyList.stream().filter(cr -> {
			return distinctReferenceClz.contains(cr.getC());
		}).distinct().collect(Collectors.toList());
		Map<clzRef, List<clzRef>> dependencyPath = new HashMap<>();
		startPointClzRefMayContainsCircularDependency.stream().forEach(cr -> {
			List<clzRef> allPath = new ArrayList<>();
			allPath.add(cr);
			dependencyPath.put(cr, allPath);
			getCircularDepencyPath(cr, null, notSelfDependencyList, dependencyPath);
			notSelfDependencyList.stream().forEach(d -> {
				d.getPassByTimes().set(0);
			});
		});
		dependencyPath.keySet().forEach(k -> {
			List<clzRef> tmpdependencyPath = dependencyPath.get(k);
			if (tmpdependencyPath.size() >= 2) {
				clzRef startclzRef = tmpdependencyPath.get(0);
				clzRef lastclzRef = tmpdependencyPath.get(tmpdependencyPath.size() - 1);
				if (startclzRef.getC().equals(lastclzRef.getReferenceC())) {
					alldependencyPath.put(k, tmpdependencyPath);
				}
			}
		});
		return alldependencyPath;
	}
	public void getCircularDepencyPath(clzRef startClzRef, clzRef nextClzRef, List<clzRef> notSelfDependencyList,
			Map<clzRef, List<clzRef>> dependencyPath) {
		if (nextClzRef == null) {
			startClzRef.getPassByTimes().incrementAndGet();
			List<clzRef> nextClzRefList = notSelfDependencyList.stream().filter(cr -> {
				return cr.getPassByTimes().get() == 0 && cr.getC().equals(startClzRef.getReferenceC());
			}).collect(Collectors.toList());
			nextClzRefList.forEach(cr -> {
				getCircularDepencyPath(startClzRef, cr, notSelfDependencyList, dependencyPath);
			});
		} else {
			nextClzRef.getPassByTimes().incrementAndGet();
			if (dependencyPath.containsKey(startClzRef)) {
				dependencyPath.get(startClzRef).add(nextClzRef);
			}
			if (nextClzRef.getReferenceC().equals(startClzRef.getC())) {
				return;
			}
			List<clzRef> nextClzRefList = notSelfDependencyList.stream().filter(cr -> {
				return cr.getPassByTimes().get() == 0 && cr.getC().equals(nextClzRef.getReferenceC());
			}).collect(Collectors.toList());
			nextClzRefList.forEach(cr -> {
				getCircularDepencyPath(startClzRef, cr, notSelfDependencyList, dependencyPath);
			});
		}
	}
	/*
	 * public void getCircularDepencyPath(clzRef startClzRef, clzRef nextClzRef,
	 * List<clzRef> notSelfDependencyList, Map<clzRef, List<clzRef>> dependencyPath)
	 * { if (nextClzRef == null) { startClzRef.getPassByTimes().incrementAndGet();
	 * List<clzRef> nextClzRefList = notSelfDependencyList.stream().filter(cr -> {
	 * return cr.getPassByTimes().get() == 0 &&
	 * cr.getC().equals(startClzRef.getReferenceC());
	 * }).collect(Collectors.toList()); nextClzRefList.forEach(cr -> {
	 * getCircularDepencyPath(startClzRef, cr, notSelfDependencyList,
	 * dependencyPath); }); } else { nextClzRef.getPassByTimes().incrementAndGet();
	 * if (dependencyPath.containsKey(startClzRef)) {
	 * dependencyPath.get(startClzRef).add(nextClzRef); } if
	 * (nextClzRef.getReferenceC().equals(startClzRef.getC())) { return; }
	 * List<clzRef> nextClzRefList = notSelfDependencyList.stream().filter(cr -> {
	 * return cr.getPassByTimes().get() == 0 &&
	 * cr.getC().equals(nextClzRef.getReferenceC());
	 * }).collect(Collectors.toList()); nextClzRefList.forEach(cr -> {
	 * getCircularDepencyPath(startClzRef, cr, notSelfDependencyList,
	 * dependencyPath); }); } }
	 */
	public void findCircularDependcy(Class c1, List<Class<?>> alreadyWalkThrough, List<clzRef> clzRefList) {
		List<Field> list = new ArrayList<>();
		if (alreadyWalkThrough.contains(c1)) {
			return;
		}
		if (isComplexType(c1)) {
			alreadyWalkThrough.add(c1);
			list = getAllFields(c1);
			list.forEach(f -> {
				Class c = f.getType();
				if (isComplexType(c)) {
					Object complexObj = null;
					boolean isArray = c.isArray();
					boolean isAbstractOrInterface = isAbstractOrInterface(c);
					if (!isAbstractOrInterface && !isArray) {
						complexObj = newInstanceByConstructor(c);
						if (complexObj != null) {
							boolean isComplexType = isComplexType(complexObj.getClass());
							if (isComplexType) {
								clzRefList.add(new clzRef(c1, complexObj.getClass()));
								findCircularDependcy(complexObj.getClass(), alreadyWalkThrough, clzRefList);
							}
						}
					} else if (isArray) {
						complexObj = Array.newInstance(c.getComponentType(), 1);
					} else if (isAbstractOrInterface) {
						Class<?> concreteC = getDefaultConcreteClass(c);
						if (concreteC != null) {
							complexObj = this.newInstanceByConstructor(concreteC);
						}
					}
					if (complexObj != null) {
						if (isArray) {
							Class componentType = c.getComponentType();
							Class concreteC = componentType;
							if (isAbstractOrInterface(componentType)) {
								concreteC = getDefaultConcreteClass(c);
							}
							if (concreteC != null) {
								Object componentTypeObj = this.newInstanceByConstructor(concreteC);
								if (componentTypeObj != null) {
									boolean isComplexType = isComplexType(componentTypeObj.getClass());
									if (isComplexType) {
										clzRefList.add(new clzRef(c1, componentTypeObj.getClass()));
										findCircularDependcy(componentTypeObj.getClass(), alreadyWalkThrough,
												clzRefList);
									}
								}
							}
						}
						if (java.util.Collection.class.isAssignableFrom(c)) {
							String genericTypeName = f.getGenericType().getTypeName();
							String genericType = null;
							Pattern p = Pattern.compile("<(.+)>");
							Matcher m = p.matcher(genericTypeName);
							if (m.find()) {
								genericType = m.group(1);
								try {
									String javaformatgenericType = genericType;// genericType.replaceAll("\\$",
									Class genericTypeC = this.getClass().getClassLoader().loadClass(javaformatgenericType);
									Class concreteC = genericTypeC;
									if (isAbstractOrInterface(genericTypeC)) {
										concreteC = getDefaultConcreteClass(c);
									}
									if (concreteC != null) {
										Object componentTypeObj = this.newInstanceByConstructor(concreteC);
										if (componentTypeObj != null) {
											boolean isComplexType = isComplexType(componentTypeObj.getClass());
											boolean at = alreadyWalkThrough.contains(componentTypeObj.getClass());
											if (isComplexType) {
												clzRefList.add(new clzRef(c1, componentTypeObj.getClass()));
												findCircularDependcy(componentTypeObj.getClass(), alreadyWalkThrough,
														clzRefList);
											}
										}
									}
								} catch (Exception e) {
								}
							}
						}
						if (Map.class.isAssignableFrom(c)) {
							String genericTypeName = f.getGenericType().getTypeName();
							String genericType = null;
							Pattern p = Pattern.compile("<(.+)>");
							Matcher m = p.matcher(genericTypeName);
							Class keyType = null;
							Class valType = null;
							if (m.find()) {
								try {
									genericType = m.group(1);
								} catch (Exception e1) {
									e1.printStackTrace();
								}
								if (genericType != null) {
									try {
										String javaformatgenericType = genericType;// genericType.replaceAll("\\$",
										String gt[] = javaformatgenericType.split(",", -1);
										keyType =  this.getClass().getClassLoader().loadClass(gt[0].trim());
										valType = this.getClass().getClassLoader().loadClass(gt[1].trim());
									} catch (Exception e) {
									}
								}
							}
							if (keyType != null && valType != null) {
								Class concreteKeyC = keyType;
								Class concreteValC = valType;
								if (isAbstractOrInterface(keyType)) {
									concreteKeyC = getDefaultConcreteClass(keyType);
								}
								if (isAbstractOrInterface(valType)) {
									concreteValC = getDefaultConcreteClass(valType);
								}
								if (concreteKeyC != null && concreteValC != null) {
									Object keyObj = this.newInstanceByConstructor(concreteKeyC);
									Object valObj = this.newInstanceByConstructor(concreteValC);
									if (keyObj != null && valObj != null) {
										boolean isComplexType = isComplexType(keyObj.getClass());
										if (isComplexType) {
											clzRefList.add(new clzRef(c1, keyObj.getClass()));
											findCircularDependcy(keyObj.getClass(), alreadyWalkThrough, clzRefList);
										}
										boolean isvalObjComplexType = isComplexType(valObj.getClass());
										if (isvalObjComplexType) {
											clzRefList.add(new clzRef(c1, valObj.getClass()));
											findCircularDependcy(valObj.getClass(), alreadyWalkThrough, clzRefList);
										}
									}
								}
							}
						}
					}
				}
			});
		}
	}
	public Map<Class, AtomicInteger> getAllCircularDependencyClzMap(Class c) {
		List<Class<?>> alreadyWalkThrough = new ArrayList<>();
		List<clzRef> clzRefList = new ArrayList<>();
		this.findCircularDependcy(c, alreadyWalkThrough, clzRefList);
		Map<clzRef, List<clzRef>> circularDependencyMap = this.getCircularDependencyPath(clzRefList);
		Map<Class, AtomicInteger> allCircularDependencyClz = this
				.getAllCircularDependencyRelatedClz(circularDependencyMap);
		return allCircularDependencyClz;
	}
	public static boolean isExclusive(String expression, String exclusiveRegex) {
		if (exclusiveRegex == null || "".equals(exclusiveRegex)) {
			return false;
		}
		Pattern p = Pattern.compile(exclusiveRegex);
		Matcher m = p.matcher(expression);
		return m.matches();
	}
	public void newInstanceRecusively(Object tobj, List allComplexTypeObj,
			Map<Class, AtomicInteger> circularDependencyRelatedClzMap, int defaultSize, String exclusiveRegex) {
		List<Field> list = new ArrayList<>();
		Class c1 = tobj.getClass();
		if (isComplexType(c1)) {
			allComplexTypeObj.add(tobj);
			if (circularDependencyRelatedClzMap.containsKey(c1)) {
				if (circularDependencyRelatedClzMap.get(c1).get() > 0) {
					return;
				} else {
					circularDependencyRelatedClzMap.get(c1).incrementAndGet();
				}
			}
			list = getAllFields(c1, exclusiveRegex);
			list.forEach(f -> {
				Class c = f.getType();
				boolean isExclusive = isExclusive(c.getName(), exclusiveRegex);
				if (!isExclusive && isComplexType(c)) {
					Object complexObj = null;
					boolean isArray = c.isArray();
					boolean isAbstractOrInterface = isAbstractOrInterface(c);
					if (!isAbstractOrInterface && !isArray) {
						complexObj = newInstanceByConstructor(c);
						if (complexObj != null) {
							boolean isComplexType = isComplexType(complexObj.getClass());
							if (isComplexType) {
								allComplexTypeObj.add(complexObj);
								newInstanceRecusively(complexObj, allComplexTypeObj, circularDependencyRelatedClzMap,
										defaultSize, exclusiveRegex);
							}
						}
					} else if (isArray) {
						complexObj = Array.newInstance(c.getComponentType(), defaultSize);
					} else if (isAbstractOrInterface) {
						Class<?> concreteC = getDefaultConcreteClass(c);
						if (concreteC != null) {
							complexObj = this.newInstanceByConstructor(concreteC);
						}
					}
					if (complexObj != null) {
						f.setAccessible(true);
						try {
							isExclusive = isExclusive(complexObj.getClass().getName(), exclusiveRegex);
							if (!isExclusive)
								f.set(tobj, complexObj);
						} catch (Exception e) {
						}
					}
					if (isArray) {
						Class componentType = c.getComponentType();
						Class concreteC = componentType;
						if (isAbstractOrInterface(componentType)) {
							concreteC = getDefaultConcreteClass(c);
						}
						if (concreteC != null) {
							for (int i = 0; i < defaultSize; i++) {
								Object componentTypeObj = this.newInstanceByConstructor(concreteC);
								if (componentTypeObj != null) {
									Array.set(complexObj, i, componentTypeObj);
									boolean isComplexType = isComplexType(componentTypeObj.getClass());
									if (isComplexType) {
										allComplexTypeObj.add(componentTypeObj);
										newInstanceRecusively(componentTypeObj, allComplexTypeObj,
												circularDependencyRelatedClzMap, defaultSize, exclusiveRegex);
									}
								}
							}
						}
					}
					if (java.util.Collection.class.isAssignableFrom(c)) {
						String genericTypeName = f.getGenericType().getTypeName();
						String genericType = null;
						Pattern p = Pattern.compile("<(.+)>");
						Matcher m = p.matcher(genericTypeName);
						if (m.find()) {
							genericType = m.group(1);
							try {
								String javaformatgenericType = genericType;// genericType.replaceAll("\\$",
								Class genericTypeC = this.getClass().getClassLoader().loadClass(javaformatgenericType);
								Class concreteC = genericTypeC;
								if (isAbstractOrInterface(genericTypeC)) {
									concreteC = getDefaultConcreteClass(c);
								}
								isExclusive = isExclusive(concreteC.getName(), exclusiveRegex);
								if (!isExclusive && concreteC != null) {
									for (int i = defaultSize; i > 0; i--) {
										Object componentTypeObj = this.newInstanceByConstructor(concreteC);
										if (componentTypeObj != null) {
											List listTmp = (List) complexObj;
											listTmp.add(componentTypeObj);
											boolean isComplexType = isComplexType(componentTypeObj.getClass());
											if (isComplexType) {
												allComplexTypeObj.add(componentTypeObj);
												newInstanceRecusively(componentTypeObj, allComplexTypeObj,
														circularDependencyRelatedClzMap, defaultSize, exclusiveRegex);
											}
										}
									}
								}
							} catch (Exception e) {
							}
						}
					}
					if (Map.class.isAssignableFrom(c)) {
						String genericTypeName = f.getGenericType().getTypeName();
						String genericType = null;
						Pattern p = Pattern.compile("<(.+)>");
						Matcher m = p.matcher(genericTypeName);
						Class keyType = null;
						Class valType = null;
						if (m.find()) {
							try {
								genericType = m.group(1);
							} catch (Exception e1) {
								e1.printStackTrace();
							}
							if (genericType != null) {
								try {
									String javaformatgenericType = genericType;// genericType.replaceAll("\\$",
									String gt[] = javaformatgenericType.split(",", -1);
									keyType =this.getClass().getClassLoader().loadClass(gt[0].trim());
									valType = this.getClass().getClassLoader().loadClass(gt[1].trim());
								} catch (Exception e) {
								}
							}
						}
						if (keyType != null && valType != null) {
							Class concreteKeyC = keyType;
							Class concreteValC = valType;
							if (isAbstractOrInterface(keyType)) {
								concreteKeyC = getDefaultConcreteClass(keyType);
							}
							if (isAbstractOrInterface(valType)) {
								concreteValC = getDefaultConcreteClass(valType);
							}
							boolean isKeyConcern = isExclusive(concreteKeyC.getName(), exclusiveRegex);
							boolean isValConcern = isExclusive(concreteValC.getName(), exclusiveRegex);
							if (isKeyConcern && isValConcern && concreteKeyC != null && concreteValC != null) {
								for (int i = defaultSize; i > 0; i--) {
									Object keyObj = this.newInstanceByConstructor(concreteKeyC);
									Object valObj = this.newInstanceByConstructor(concreteValC);
									if (keyObj != null && valObj != null) {
										Map tmp = (Map) complexObj;
										tmp.put(keyObj, valObj);
										boolean isComplexType = isComplexType(keyObj.getClass());
										if (isComplexType) {
											allComplexTypeObj.add(keyObj);
											newInstanceRecusively(keyObj, allComplexTypeObj,
													circularDependencyRelatedClzMap, defaultSize, exclusiveRegex);
										}
										boolean isvalObjComplexType = isComplexType(valObj.getClass());
										if (isvalObjComplexType) {
											allComplexTypeObj.add(valObj);
											newInstanceRecusively(valObj, allComplexTypeObj,
													circularDependencyRelatedClzMap, defaultSize, exclusiveRegex);
										}
									}
								}
							}
						}
					}
				}
			});
		}
	}
	public static List<Field> getAllFields(Class c) {
		return getAllFields(c, null);
	}
	public static List<Field> getAllFields(Class c, String exclusiveRegex) {
		List<Field> allFieldList = new ArrayList<>();
		while (c != Object.class) {
			boolean isExclusive = isExclusive(c.getName(), exclusiveRegex);
			if (isExclusive) {
				break;
			}
			allFieldList.addAll(Arrays.asList(c.getDeclaredFields()));
			c = c.getSuperclass();
		}
		return allFieldList;
	}
	public void assignPrimitiveTypes(Object tobj) {
		assignPrimitiveTypes(tobj, null);
	}
	public void assignPrimitiveTypes(Object tobj, String exclusiveRegex) {
		List<Field> list = new ArrayList<>();
		Class c1 = tobj.getClass();
		list = getAllFields(c1, exclusiveRegex);
		list.forEach(f -> {
			Class c = f.getType();
			boolean isExclusive = isExclusive(c.getName(), exclusiveRegex);
			if (!isExclusive && !isComplexType(c)) {
				Object obj = null;
				f.setAccessible(true);
				/*
				 * try { obj = f.get(tobj); } catch (Exception e) { e.printStackTrace(); }
				 */
				Object value = this.getDefaultVal(c);
				try {
					f.set(tobj, value);
				} catch (Exception e) {
				}
			}
		});
	}
	public void assignComplextTypes(Object tobj, List<?> allComplexTypeObj) {
		assignComplextTypes(tobj, allComplexTypeObj, null);
	}
	public void assignComplextTypes(Object tobj, List<?> allComplexTypeObj, String exclusiveRegex) {
		List<Field> list = new ArrayList<>();
		Class c1 = tobj.getClass();
		list = getAllFields(c1, exclusiveRegex);
		list.forEach(f -> {
			try {
				f.setAccessible(true);
				Object fval = f.get(tobj);
				if (fval == null) {
					Class c = f.getType();
					Object alreadyCreatedInstance = null;
					try {
						alreadyCreatedInstance = allComplexTypeObj.stream().filter(e -> {
							return c.isInstance(e);
						}).findAny().get();
					} catch (Exception e1) {
					}
					boolean isExclusive = isExclusive(alreadyCreatedInstance.getClass().getCanonicalName(),
							exclusiveRegex) || isExclusive(c.getCanonicalName(), exclusiveRegex);
					if (alreadyCreatedInstance != null && !isExclusive) {
						try {
							f.set(tobj, alreadyCreatedInstance);
						} catch (Exception e) {
						}
					}
				}
			} catch (Exception e1) {
			}
		});
	}
	public <T> List<Class<?>> getAllReferComplexType(Class<T> t){
		List<Class<?>> allComplexTypeObj = new ArrayList<>();
		List<Class<?>> alreadyWalkThrough = new ArrayList<>();
		T obj = newInstanceByConstructor(t);
		if (obj != null) {
			List<clzRef> clzRefList = new ArrayList<>();
			this.findCircularDependcy(t, alreadyWalkThrough, clzRefList);
			for(clzRef cr : clzRefList){
				if(null!=cr.getC()){
					allComplexTypeObj.add(cr.getC());
				}
				if(null!=cr.getReferenceC()){
					allComplexTypeObj.add(cr.getReferenceC());
				}
			}
			allComplexTypeObj=allComplexTypeObj.stream().distinct().collect(Collectors.toList());
		}
		return allComplexTypeObj;
	}
	public <T> T newInstance(Class<T> t) {
		return newInstance(t, 2);
	}
	public <T> T newInstance(Class<T> t, int defaultSize) {
		return newInstance(t, defaultSize, null);
	}
	public <T> T newInstance(Class<T> t, int defaultSize, String exclusiveRegex) {
		List<?> allComplexTypeObj = new ArrayList<>();
		List<Class<?>> alreadyWalkThrough = new ArrayList<>();
		T obj = newInstanceByConstructor(t);
		if (obj != null) {
			List<clzRef> clzRefList = new ArrayList<>();
			this.findCircularDependcy(t, alreadyWalkThrough, clzRefList);
			Map<clzRef, List<clzRef>> circularDependencyMap = this.getCircularDependencyPath(clzRefList);
			Map<Class, AtomicInteger> allCircularDependencyClz = this
					.getAllCircularDependencyRelatedClz(circularDependencyMap);
			newInstanceRecusively(obj, allComplexTypeObj, allCircularDependencyClz, defaultSize, exclusiveRegex);
			allComplexTypeObj.forEach(ct -> {
				assignPrimitiveTypes(ct, exclusiveRegex);
				assignComplextTypes(ct, allComplexTypeObj, exclusiveRegex);
			});
		}
		return obj;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\qj\blog\classreloading\example1\StaticInt.java---
package qj.blog.classreloading.example1;
import qj.util.ReflectUtil;
import qj.util.lang.DynamicClassLoader;
import static java.lang.System.out;
/**
 * Created by Quan on 26/10/2014.
 */
public class StaticInt {
	public static void main(String[] args) {
		Class<?> userClass1 = User.class;
		Class<?> userClass2 = new DynamicClassLoader("target/classes")
				.load("qj.blog.classreloading.example1.StaticInt$User");
		out.println("Seems to be the same class:");
		out.println(userClass1.getName());
		out.println(userClass2.getName());
		out.println();
		out.println("But why there are 2 different class loaders:");
		out.println(userClass1.getClassLoader());
		out.println(userClass2.getClassLoader());
		out.println();
		User.age = 11;
		out.println("And different age values:");
		out.println((int) ReflectUtil.getStaticFieldValue("age", userClass1));
		out.println((int) ReflectUtil.getStaticFieldValue("age", userClass2));
	}
	public static class User {
		public static int age = 10;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\qj\blog\classreloading\example2\ReloadingContinuously.java---
package qj.blog.classreloading.example2;
import qj.util.ReflectUtil;
import qj.util.ThreadUtil;
import qj.util.lang.DynamicClassLoader;
/**
 * Created by Quan on 31/10/2014.
 */
public class ReloadingContinuously {
	public static void main(String[] args) {
		for (;;) {
			Class<?> userClass = new DynamicClassLoader("target/classes")
				.load("qj.blog.classreloading.example2.ReloadingContinuously$User");
			ReflectUtil.invokeStatic("hobby", userClass);
			ThreadUtil.sleep(2000);
		}
	}
	@SuppressWarnings("UnusedDeclaration")
	public static class User {
		public static void hobby() {
			playFootball(); // Will comment during runtime
		}
		public static void playFootball() {
			System.out.println("Play Football");
		}
		public static void playBasketball() {
			System.out.println("Play Basketball");
		}
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\qj\blog\classreloading\example3\ContextReloading.java---
package qj.blog.classreloading.example3;
import qj.util.ThreadUtil;
import qj.util.lang.DynamicClassLoader;
import static qj.util.ReflectUtil.*;
/**
 * Created by Quan on 31/10/2014.
 */
public class ContextReloading {
	public static void main(String[] args) {
		for (;;) {
			Object context = createContext();
			invokeHobbyService(context);
			ThreadUtil.sleep(2000);
		}
	}
	private static Object createContext() {
		Class<?> contextClass = new DynamicClassLoader("target/classes")
				.load("qj.blog.classreloading.example3.ContextReloading$Context");
		Object context = newInstance(contextClass);
		invoke("init", context);
		return context;
	}
	private static void invokeHobbyService(Object context) {
		Object hobbyService = getFieldValue("hobbyService", context);
		invoke("hobby", hobbyService);
	}
	@SuppressWarnings("UnusedDeclaration")
	public static class Context {
		public HobbyService hobbyService = new HobbyService();
		public void init() {
			hobbyService.user = new User();
		}
	}
	public static class HobbyService {
		public User user;
		public void hobby() {
			user.hobby();
		}
	}
	public static class User {
		public static void hobby() {
			playBasketball(); // Will uncomment during runtime
		}
		public static void playBasketball() {
			System.out.println("Play Basketball");
		}
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\qj\blog\classreloading\example3\ContextReloadingTest.java---
package qj.blog.classreloading.example3;
import qj.util.ThreadUtil;
import qj.util.lang.DynamicClassLoader;
import java.io.File;
/**
 * Created by Quan on 31/10/2014.
 */
public class ContextReloadingTest {
	public static void main(String[] args) {
		for (;;) {
			try {
				Class<?> testJarClz = new DynamicClassLoader(
						new File("D:\\androidMavenRepository\\codegen\\classreloadtest\\1.0\\classreloadtest-1.0.jar")
								.toURI().toURL()).load("test.Test2");
				Class<?> clz = new DynamicClassLoader(
						"D:\\project\\codegen\\production\\classreloadtest\\target\\classes").load("test.Test");
				Class<?> clz1 = new DynamicClassLoader(
						"D:\\project\\codegen\\production\\classreloadtest\\target\\test-classes")
								.load("test.UnitTest1");
				ContextReloadingTest.printClzInfo(testJarClz);
			} catch (Exception e) {
				e.printStackTrace();
			}
		}
	}
	public static void printClzInfo(Class clz) {
		int fieldSize = clz.getDeclaredFields().length;
		int methodSize = clz.getMethods().length;
		System.out.println(
				String.format("clz=%s, fieldSize=%s, methodSize=%s", clz.getCanonicalName(), fieldSize, methodSize));
		ThreadUtil.sleep(2000);
		return;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\qj\blog\classreloading\example3\RunAppClzReloadingTest.java---
package qj.blog.classreloading.example3;
import qj.util.ThreadUtil;
import qj.util.lang.DynamicClassLoader;
import java.io.File;
import java.net.URI;
import java.net.URL;
/**
 * Created by Quan on 31/10/2014.
 */
public class RunAppClzReloadingTest {
	public static void main(String[] args) {
		for (;;) {
			try {
				File file = new File("D:\\project\\deployment\\production\\runapp\\target\\classes");
				URL uRL = null;
				if (file.exists()) {
					URI uRI = file.toURI();
					uRL = uRI.toURL();
				}
				DynamicClassLoader dc = new DynamicClassLoader(RunAppClzReloadingTest.class.getClassLoader(), uRL);
				Class<?> clz = dc.load("servlet.deployment.RunParam");
				Class clz2 = dc.load("qj.tool.web.ReloadingContext");
				Class<?> clz1 = new DynamicClassLoader(
						"D:\\project\\codegen\\production\\classreloadtest\\target\\test-classes")
								.load("test.UnitTest1");
				ContextReloadingTest.printClzInfo(clz);
			} catch (Exception e) {
				e.printStackTrace();
			}
		}
	}
	public static void printClzInfo(Class clz) {
		int fieldSize = clz.getDeclaredFields().length;
		int methodSize = clz.getMethods().length;
		System.out.println(
				String.format("clz=%s, fieldSize=%s, methodSize=%s", clz.getCanonicalName(), fieldSize, methodSize));
		ThreadUtil.sleep(2000);
		return;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\qj\blog\classreloading\example4\crossing\Connection.java---
package qj.blog.classreloading.example4.crossing;
public class Connection {
    public String getUserName() {
        return "Joe";
    }
}
----strat of file D:\projects\cg\cg-min\src\main\java\qj\blog\classreloading\example4\crossing\ConnectionPool.java---
package qj.blog.classreloading.example4.crossing;
public class ConnectionPool {
    Connection conn = new Connection();
    public Connection getConnection() {
        return conn;
    }
}
----strat of file D:\projects\cg\cg-min\src\main\java\qj\blog\classreloading\example4\KeepConnectionPool.java---
package qj.blog.classreloading.example4;
import qj.blog.classreloading.example4.crossing.ConnectionPool;
import qj.util.ThreadUtil;
import qj.util.lang.ExceptingClassLoader;
import static qj.util.ReflectUtil.*;
/**
 * Created by Quan on 01/11/2014.
 */
public class KeepConnectionPool {
	public static void main(String[] args) {
		ConnectionPool pool = new ConnectionPool();
		for (;;) {
			Object context = createContext(pool);
			invokeService(context);
			ThreadUtil.sleep(2000);
		}
	}
	private static Object createContext(ConnectionPool pool) {
		ExceptingClassLoader classLoader = new ExceptingClassLoader(
				(className) -> className.contains(".crossing."),
				"target/classes");
		Class<?> contextClass = classLoader.load("qj.blog.classreloading.example4.reloadable.Context");
		Object context = newInstance(contextClass);
		setFieldValue(pool, "pool", context);
		invoke("init", context);
		return context;
	}
	private static void invokeService(Object context) {
		Object hobbyService = getFieldValue("userService", context);
		invoke("hello", hobbyService);
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\qj\blog\classreloading\example4\reloadable\Context.java---
package qj.blog.classreloading.example4.reloadable;
import qj.blog.classreloading.example4.crossing.ConnectionPool;
@SuppressWarnings("UnusedDeclaration")
public class Context {
    public ConnectionPool pool;
    public UserService userService = new UserService();
    public void init() {
        userService.pool = pool;
    }
}
----strat of file D:\projects\cg\cg-min\src\main\java\qj\blog\classreloading\example4\reloadable\UserService.java---
package qj.blog.classreloading.example4.reloadable;
import qj.blog.classreloading.example4.crossing.ConnectionPool;
public class UserService {
    ConnectionPool pool;
    @SuppressWarnings("UnusedDeclaration")
    public void hello() {
        System.out.println("Hi " + pool.getConnection().getUserName());
    }
}
----strat of file D:\projects\cg\cg-min\src\main\java\qj\blog\classreloading\example5\LittlePhoneBookMain.java---
package qj.blog.classreloading.example5;
import org.eclipse.jetty.server.Server;
import org.eclipse.jetty.servlet.FilterHolder;
import org.eclipse.jetty.servlet.ServletContextHandler;
import org.eclipse.jetty.servlet.ServletHolder;
import qj.tool.web.ReloadingWebContext;
import qj.tool.web.ResourceFilter;
import qj.util.PropertiesUtil;
import qj.util.SystemUtil;
import qj.util.ThreadUtil;
import qj.util.funct.F0;
import qj.util.funct.P0;
import qj.util.lang.ExceptingClassLoader;
import javax.servlet.DispatcherType;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.EnumSet;
import java.util.Properties;
public class LittlePhoneBookMain {
	public static boolean development = true;
	public static String version = "1.0.0";
	public static void main(String[] args) throws Exception {
        Properties config = PropertiesUtil.loadPropertiesFromFile("data/example5/config.properties");
		startServer(config);
	}
	public static void startServer(Properties config) throws Exception {
		final ServerControl webServer = startWebServer(config);
		SystemUtil.onReturn(line -> {
			if ("exit".equals(line)) {
				System.out.print("Stopping web server...");
				webServer.closeF.run();
				System.out.print(" done.");
				System.exit(0);
			}
		});
	}
	public static ServerControl startWebServer(Properties config) throws Exception {
		int port = Integer.parseInt(config.getProperty("web.port"));
		DbPool dbPool = initDatabase(config);
		ServletContextHandler servletContext = new ServletContextHandler(ServletContextHandler.SESSIONS);
        servletContext.setContextPath("/");
		ReloadingWebContext contextLoader = new ReloadingWebContext(
				"qj.blog.classreloading.example5.reloadable.Context",
				() -> ( development ?
						new ExceptingClassLoader(
							(className) -> className.startsWith("qj.util"),
							"target/classes"
						) :
						LittlePhoneBookMain.class.getClassLoader()
				),
				development ? 
						(req) -> req.getMethod().equalsIgnoreCase("GET") && req.getRequestURI().equals("/") : 
						null
		);
		contextLoader.setField("development", development);
		contextLoader.setField("buildVersion", version);
		contextLoader.setField("connF", dbPool.connF);
		contextLoader.initWith("init", "data/example5/web");
		contextLoader.beforeClose("close");
		servletContext.addServlet( new ServletHolder(contextLoader.stubServlet("jade")), "/");
		servletContext.addServlet( new ServletHolder(wrapServlet(contextLoader.stubServlet("contact"), dbPool.closeThreadConn)),
				"/contact");
		servletContext.addServlet( new ServletHolder(contextLoader.stubServlet("jade")), "*.jade");
		ResourceFilter resourceFilter = resourceFilter("data/example5/web");
		servletContext.addFilter(
				new FilterHolder(resourceFilter),
				"/*", EnumSet.<DispatcherType>of(DispatcherType.REQUEST));
		final Server server = new Server(port);
		server.setHandler(servletContext);
		server.start();
		System.out.println("Server started on port " + port);
		final Runnable closeF = () -> {
			System.out.print("Stopping box server...");
			try {
				server.stop();
			} catch (Exception e1) {
				e1.printStackTrace();
			}
			dbPool.closePool.e();
			System.out.print(" done.");
		};
		return new ServerControl(closeF);
	}
	private static DbPool initDatabase(Properties config) throws SQLException, ClassNotFoundException {
		DbPool dbPool = new DbPool(config);
		Connection connection = dbPool.connF.e();
		initDb(connection);
		dbPool.closeThreadConn.e();
		return dbPool;
	}
	public static ResourceFilter resourceFilter(String boxWebLoc) {
		return new ResourceFilter(
				req -> null,
				boxWebLoc
				);
	}
	public static class ServerControl {
		Runnable closeF;
		public ServerControl(Runnable closeF) {
			this.closeF = closeF;
		}
	}
	/**
	 * This is pool provide only 1 shared connection to the SQLite memory database
	 */
	static class DbPool {
		public F0<Connection> connF;
		public P0 closeThreadConn;
		protected P0 closePool;
		public DbPool(Properties config) throws SQLException, ClassNotFoundException {
			Class.forName(config.getProperty("db.driver"));
            Connection connection = DriverManager.getConnection(config.getProperty("db.url"));
			ThreadUtil.ThreadLocalCache<Connection> threadLocal = ThreadUtil.threadLocalCache(() -> connection);
			connF = threadLocal.cacheF;
			closeThreadConn = () -> {
			};
			closePool = () -> {
				try {
					connection.close();
				} catch (SQLException e1) {
				}
			};
		}
	}
	/**
	 * The SQLite memory db is initialized before use
	 * @throws SQLException
	 */
	private static void initDb(Connection connection) throws SQLException {
		Statement statement = connection.createStatement();
		statement.setQueryTimeout(30);  // set timeout to 30 sec.
		statement.executeUpdate("drop table if exists contact");
		statement.executeUpdate("create table contact (id integer PRIMARY KEY AUTOINCREMENT, name string, phone string)");
		statement.executeUpdate("insert into contact values(1, 'Andrew King', '0648 6815 1654')");
		statement.executeUpdate("insert into contact values(2, 'William Shakespeare', '0234 5234 3264')");
	}
	private static HttpServlet wrapServlet(HttpServlet servlet, P0 closeThreadConn) {
		return new HttpServlet() {
			protected void service(HttpServletRequest req,
			                       HttpServletResponse resp) throws ServletException,
					IOException {
				try {
					servlet.service(req, resp);
				} finally {
					closeThreadConn.e();
				}
			}
		};
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\qj\blog\classreloading\example5\reloadable\Context.java---
package qj.blog.classreloading.example5.reloadable;
import qj.blog.classreloading.example5.reloadable.servlet.ContactServlet;
import qj.blog.classreloading.example5.reloadable.servlet.JadeServlet;
import qj.util.funct.F0;
import java.sql.Connection;
@SuppressWarnings("UnusedDeclaration")
public class Context {
	public String buildVersion;
	public boolean development;
	public F0<Connection> connF;
	public JadeServlet jadeServlet = new JadeServlet();
	public ContactServlet contactServlet = new ContactServlet();
	public void init(String webLoc) {
		jadeServlet.version = buildVersion;
		jadeServlet.init(webLoc);
		contactServlet.connF = connF;
	}
	public void close() {
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\qj\blog\classreloading\example5\reloadable\dao\ContactDAO.java---
package qj.blog.classreloading.example5.reloadable.dao;
import qj.blog.classreloading.example5.reloadable.model.Contact;
import qj.tool.sql.Builder;
import qj.tool.sql.Template;
import java.sql.Connection;
import java.util.List;
/**
 * Created by Quan on 22/12/2014.
 */
public class ContactDAO {
	static Template<Contact> template = new Builder<>(Contact.class)
			.build();
	public static List<Contact> selectAll(Connection conn) {
		return template.selectAll(conn);
	}
    public static void insert(Contact contact, Connection conn) {
        template.insert(contact, conn);
    }
    public static void delete(Long id, Connection conn) {
        template.deleteById(id, conn);
    }
}
----strat of file D:\projects\cg\cg-min\src\main\java\qj\blog\classreloading\example5\reloadable\model\Contact.java---
package qj.blog.classreloading.example5.reloadable.model;
/**
 * Created by Quan on 22/12/2014.
 */
public class Contact {
	public Long id;
	public String name;
	public String phone;
}
----strat of file D:\projects\cg\cg-min\src\main\java\qj\blog\classreloading\example5\reloadable\servlet\ContactServlet.java---
package qj.blog.classreloading.example5.reloadable.servlet;
import com.google.gson.Gson;
import qj.blog.classreloading.example5.reloadable.dao.ContactDAO;
import qj.blog.classreloading.example5.reloadable.model.Contact;
import qj.util.funct.F0;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.sql.Connection;
/**
 * Created by Quan on 22/12/2014.
 */
public class ContactServlet extends HttpServlet {
	public F0<Connection> connF;
	@Override
	protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        String action = req.getParameter("action");
        switch (action) {
            case "getAll":
                getAll(resp);
                break;
            case "add":
                add(req, resp);
                break;
            case "remove":
                remove(req, resp);
                break;
        }
	}
    private void getAll(HttpServletResponse resp) throws IOException {
        new Gson().toJson(ContactDAO.selectAll(connF.e()), resp.getWriter());
    }
    private void add(HttpServletRequest req, HttpServletResponse resp) throws IOException {
        Gson gson = new Gson();
        Contact contact = gson.fromJson(req.getReader(), Contact.class);
        ContactDAO.insert(contact, connF.e());
        gson.toJson(contact, resp.getWriter());
    }
    private void remove(HttpServletRequest req, HttpServletResponse resp) throws IOException {
        Long id = Long.valueOf(req.getParameter("id"));
        ContactDAO.delete(id, connF.e());
        resp.getWriter().write(0);
    }
}
----strat of file D:\projects\cg\cg-min\src\main\java\qj\blog\classreloading\example5\reloadable\servlet\JadeServlet.java---
package qj.blog.classreloading.example5.reloadable.servlet;
import de.neuland.jade4j.Jade4J;
import de.neuland.jade4j.model.JadeModel;
import de.neuland.jade4j.template.JadeTemplate;
import qj.util.Cols;
import qj.util.FileUtil;
import qj.util.StringUtil;
import qj.util.funct.P2;
import qj.util.math.Range;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.File;
import java.io.IOException;
import java.io.StringWriter;
import java.util.LinkedList;
public class JadeServlet extends HttpServlet {
	public String version = null;
	private String webLoc;
	@Override
	public void doGet(HttpServletRequest req, HttpServletResponse resp)
			throws ServletException, IOException {
		resp.setContentType("text/html; charset=UTF-8");
		if (StringUtil.countHappens('.', req.getServerName()) == 1) {
			resp.sendRedirect("http://www." + req.getServerName()); // Fix ui-sref urls
			return;
		}
		String requestURI = req.getRequestURI();
		if (requestURI.equals("/")) {
			requestURI = "/spa.jade";
		}
		File file = new File(webLoc + "/spa" + requestURI);
		if (!file.exists()) {
			resp.sendRedirect("/#!" + requestURI.replaceFirst("/$", "")); // Fix ui-sref urls
			return;
		}
		JadeTemplate template = Jade4J.getTemplate(file.getPath());
		if ("/spa.jade".equals(requestURI)) {
			StringWriter buffer = new StringWriter();
			template.process(new JadeModel(Cols.map(
					"version", version
					)), buffer);
			String target = "<!--spa-js-->";
			String scriptLocations = allJs();
			String content = buffer.toString();
			resp.getWriter().write(
					StringUtil.replace(scriptLocations, Range.fromlength(content.indexOf(target), target.length()), content)
			);
		} else {
			template.process(new JadeModel(null), resp.getWriter());
		}
	}
	private String allJs() {
		LinkedList<String> col = new LinkedList<>();
		P2<File,String> collect = (file, path) -> {
			if (file.getName().endsWith(".js")) {
				if (StringUtil.isEmpty(path)) {
					col.add("/" + file.getName());
				} else {
					col.add("/" + path.replaceAll("\\\\", "/") + "/" + file.getName());
				}
			}
		};
		FileUtil.eachFile(new File(webLoc + "/spa"), collect);
		return Cols.join((Iterable<String>)Cols.yield(col, s -> "<script src=\"/spa" + s + "?v=" + version + "\"></script>"), "");
	}
	public void init(String webLoc) {
		this.webLoc = webLoc;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\qj\tool\sql\Builder.java---
package qj.tool.sql;
import com.google.gson.Gson;
import qj.tool.sql.Template.Field1;
import qj.util.Cols;
import qj.util.NameCaseUtil;
import qj.util.ReflectUtil;
import qj.util.StringUtil;
import qj.util.funct.F1;
import qj.util.funct.F2;
import qj.util.funct.P1;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.lang.reflect.Type;
import java.sql.Blob;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.*;
public class Builder<M> {
	private Class<M> clazz;
	private List<String> idFields = Arrays.asList("id");
	private String tableName;
	boolean autoIncrement = true;
	public Builder(Class<M> clazz) {
		this.clazz = clazz;
		tableName = NameCaseUtil.camelToHyphen(clazz.getSimpleName());
	}
	public static void main(String[] args) {
		System.out.println(NameCaseUtil.camelToHyphen("ChatLastRead"));
	}
	public Builder<M> id(String... idFields) {
		this.idFields = Arrays.asList(idFields);
		return this;
	}
	HashSet<String> dontStore = new HashSet<>();
	public Template<M> build() {
		Template<M> template = new Template<>(clazz);
		template.idFields = Cols.yield(idFields, (fName) -> field1(ReflectUtil.getField(fName, clazz)));
		template.dataFields = new LinkedList<>();
		template.tableName = tableName;
		template.autoIncrement = autoIncrement;
		eachField(clazz, (f) -> {
			if (dontStore.contains(f.getName())) {
				return;
			}
			template.dataFields.add(field1(f));
		});
		return template;
	}
	@SuppressWarnings("UnusedDeclaration")
	public Builder<M> noId() {
		idFields = Collections.emptyList();
		return this;
	}
	public Builder<M> tableName(String tableName) {
		this.tableName = tableName;
		return this;
	}
	public Field1<M> field1(Field field) {
		Field1<M> raw = field1_raw(field);
		F1<Field1<M>, Field1<M>> decor = fieldDecors.get(field.getName());
		if (decor != null) {
			return decor.e(raw);
		}
		return raw;
	}
	public static <M> Field1<M> field1_raw(Field field) {
		Field1<M> field1 = new Field1<M>() {
			@Override
			void setValue(Object val, M m) {
				if (boolean.class.equals(field.getType())) {
					if (val == null) {
						val = Boolean.FALSE;
					}
				}
				ReflectUtil.setFieldValue(val, field, m);
			}
			@Override
			Object getValue(M m) {
				return ReflectUtil.getFieldValue(field, m);
			}
		};
		field1.type = field.getGenericType();
		field1.sqlName = NameCaseUtil.camelToHyphen(field.getName());
		field1.psSetter = SQLUtil.setter(field.getType());
		field1.rsGet = rsGet(field.getType());
		return field1;
	}
	Map<String,F1<Field1<M>,Field1<M>>> fieldDecors = new HashMap<>();
	private Builder<M> embeded(String fieldName, F1<Field1<M>,Type> convertTypeF,
			F1<Object, Object> afterDeserialized) {
		fieldDecors.put(fieldName, f1 -> {
			Field1<M> newField1 = new Field1<M>() {
				@Override
				void setValue(Object val, M m) {
					if (val == null || "null".equals(val)) {
						f1.setValue(null, m);
						return;
					}
					Object o = new Gson().fromJson(((String)val), convertTypeF.e(f1));
					Object value = afterDeserialized==null ? o : afterDeserialized.e(o);
					f1.setValue(value, m);
				}
				@Override
				Object getValue(M m) {
					Object val = f1.getValue(m);
					return new Gson().toJson(val);
				}
			};
			newField1.psSetter = SQLUtil.setter(String.class);
			newField1.rsGet = rsGet(String.class);
			newField1.sqlName = f1.sqlName;
			return newField1;
		});
		return this;
	}
	public Builder<M> embeded(String fieldName) {
		return embeded(fieldName, (f1) -> f1.type, null);
	}
	@SuppressWarnings("UnusedDeclaration")
	public Builder<M> dontStore(String fieldName) {
		dontStore.add(fieldName);
		return this;
	}
	private void eachField(Class<?> clazz, P1<Field> p1) {
		for (final Field field : clazz.getDeclaredFields()) {
			int modifiers = field.getModifiers();
			if ((modifiers & (Modifier.STATIC | Modifier.FINAL | Modifier.TRANSIENT)) > 0
					|| (modifiers & Modifier.PUBLIC) == 0
					) {
				continue;
			}
			if (idFields.contains(field.getName())) {
				continue;
			}
			p1.e(field);
		}
		if (!clazz.equals(Object.class)) {
			eachField(clazz.getSuperclass(), p1);
		}
	}
	private static F2<ResultSet,Integer,Object> rsGet(Class<?> type) {
		if (type.equals(Date.class)) {
			return (rs, index) -> {
				try {
					return rs.getTimestamp(index);
				} catch (SQLException e) {
					throw new RuntimeException(e);
				}
			};
		}
		if (type.equals(byte[].class)) {
			return (rs, index) -> {
				try {
					Blob blob = rs.getBlob(index);
					return blob.getBytes(1, (int) blob.length());
				} catch (SQLException e) {
					throw new RuntimeException(e);
				}
			};
		}
		Method methodWasNull = ReflectUtil.getMethod("wasNull", ResultSet.class);
		Method methodGet = ReflectUtil.getMethod(rsGetMethodName(type), new Class[] {int.class}, ResultSet.class);
		return (rs, index) -> {
			Object val = ReflectUtil.invoke(methodGet, rs, index);
			Boolean wasNull = ReflectUtil.invoke(methodWasNull, rs);
			return wasNull ? null : val;
		};
	}
	private static String rsGetMethodName(Class<?> type) {
		String simpleName = type.getSimpleName();
		if (simpleName.equals("Integer")) {
			simpleName = "Int";
		}
		return "get" + StringUtil.upperCaseFirstChar(simpleName);
	}
	public <MT> Builder<M> fieldConvert(String fieldName, FieldConverter<MT> converter) {
		fieldDecors.put(fieldName, (f1) -> {
			Field1<M> newField1 = new Field1<M>() {
				@Override
				void setValue(Object val, M m) {
					if (val == null) {
						f1.setValue(null, m);
						return;
					}
					f1.setValue(converter.fromDB(val),m);
				}
				@Override
				Object getValue(M m) {
					MT val = (MT) f1.getValue(m);
					return converter.toDB(val);
				}
			};
			newField1.psSetter = SQLUtil.setter(converter.dbType());
			newField1.rsGet = rsGet(converter.dbType());
			newField1.sqlName = f1.sqlName;
			return newField1;
		});
		return this;
	}
	public static interface FieldConverter<MT> {
		MT fromDB(Object val);
		Object toDB(MT val);
		Class<?> dbType();
	}
	public Builder<M> autoIncrement(boolean b) {
		autoIncrement = b;
		return this;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\qj\tool\sql\SQLUtil.java---
package qj.tool.sql;
import qj.util.IOUtil;
import qj.util.ReflectUtil;
import qj.util.StringUtil;
import qj.util.funct.P0;
import qj.util.funct.P3;
import javax.sql.rowset.serial.SerialBlob;
import java.lang.reflect.Method;
import java.sql.*;
import java.util.Date;
@SuppressWarnings("UnusedDeclaration")
public class SQLUtil {
	public static void transaction(P0 run, Connection conn) {
		try {
			conn.setAutoCommit(false);
			run.e();
			conn.commit();
			conn.setAutoCommit(true);
		} catch (SQLException e) {
			try {
				conn.rollback();
				conn.setAutoCommit(true);
			} catch (SQLException ignored) {
			}
			throw new RuntimeException(e);
		}
	}
	public static Long selectLong(Connection conn, String query, Object... params) {
		PreparedStatement ps = null;
		ResultSet rs = null;
		try {
			ps = conn.prepareStatement(query);
			psSet1(params, ps);
			rs = ps.executeQuery();
			if (rs.next()) {
				return rs.getLong(1);
			}
			return null;
		} catch (SQLException e) {
			throw new RuntimeException(e);
		} finally {
			IOUtil.close(rs);
			IOUtil.close(ps);
		}
	}
	public static void update(Connection conn, String query, Object... params) {
		PreparedStatement ps = null;
		try {
			ps = conn.prepareStatement(query);
			psSet1(params, ps);
			ps.executeUpdate();
		} catch (SQLException e) {
			throw new RuntimeException(e);
		} finally {
			IOUtil.close(ps);
		}
	}
	public static P3<PreparedStatement, Integer, Object> setter(Class<?> type) {
		if (type.equals(Date.class)) {
			return (ps, index, val) -> {
				try {
					if (val==null) {
						ps.setNull(index, Types.DATE);
					} else {
						ps.setTimestamp(index, new Timestamp(((Date)val).getTime()));
					}
				} catch (SQLException e) {
					throw new RuntimeException(e);
				}
			};
		}
		if (type.equals(boolean.class)) {
			return (ps, index, val) -> {
				try {
					ps.setInt(index, (Boolean) val ? 1 : 0);
				} catch (SQLException e) {
					throw new RuntimeException(e);
				}
			};
		}
		if (type.equals(byte[].class)) {
			return (ps, index, val) -> {
				try {
					ps.setBlob(index, new SerialBlob((byte[])val));
				} catch (SQLException e) {
					throw new RuntimeException(e);
				}
			};
		}
		String methodName = "set" + StringUtil.upperCaseFirstChar(type.getSimpleName());
		Method method = ReflectUtil.findMethod(PreparedStatement.class, (m) -> m.getName().equals(methodName) && m.getParameterCount() == 2);
		if (method == null) {
			return null;
		}
		return (ps, index, val) -> {
			if (val==null) {
				try {
					ps.setNull(index, Types.VARCHAR);
				} catch (SQLException e) {
					throw new RuntimeException(e);
				}
			} else {
				ReflectUtil.invoke(method, ps, index, val);
			}
		};
	}
	static int psSet(Object[] params, PreparedStatement ps, int index)
			throws SQLException {
		if (params == null) {
			return index;
		}
		for (Object val : params) {
			if (val == null) {
				ps.setNull(index++, Types.INTEGER);
			} else {
				P3<PreparedStatement, Integer, Object> setter = setter(val.getClass());
				setter.e(ps, index++, val);
			}
		}
		return index;
	}
	static void psSet1(Object[] params, PreparedStatement ps) throws SQLException {
		psSet(params, ps, 1);
	}
	public static int execute(String query, Connection conn) {
		PreparedStatement ps = null;
		try {
			ps = conn.prepareStatement(query);
			return ps.executeUpdate();
		} catch (SQLException e) {
			throw new RuntimeException(e);
		} finally {
			IOUtil.close(ps);
		}
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\qj\tool\sql\Template.java---
package qj.tool.sql;
import qj.util.Cols;
import qj.util.IOUtil;
import qj.util.ReflectUtil;
import qj.util.RegexUtil;
import qj.util.funct.*;
import java.lang.reflect.Type;
import java.sql.*;
import java.util.Arrays;
import java.util.Collection;
import java.util.LinkedList;
import java.util.List;
import java.util.concurrent.atomic.AtomicReference;
import java.util.regex.Matcher;
@SuppressWarnings("UnusedDeclaration")
public class Template<M> {
	Class<M> clazz;
	List<Field1<M>> idFields;
	List<Field1<M>> dataFields;
	String tableName;
	boolean autoIncrement = true;
	Template(Class<M> clazz) {
		this.clazz = clazz;
	}
	static abstract class Field1<M> {
		F2<ResultSet,Integer,Object> rsGet = null;
		P3<PreparedStatement, Integer, Object> psSetter = null;
		String sqlName = null;
		Type type;
		abstract void setValue(Object val, M m);
		abstract Object getValue(M m);
	}
	public static <M> Builder<M> builder(Class<M> clazz) {
		return new Builder<>(clazz);
	}
	public M insert(M m, Connection conn) {
		boolean hasId = getId(m) != null;
		List<Field1<M>> fields = hasId ? allFields() : dataFields;
		PreparedStatement ps = null;
		ResultSet rs = null;
		try {
			String sql = "INSERT INTO `" + tableName + "`(" + fieldNames(fields) + ") VALUES(" + fieldsPH(fields) + ")";
			ps = conn.prepareStatement(sql, Cols.isEmpty(idFields) ? Statement.NO_GENERATED_KEYS : Statement.RETURN_GENERATED_KEYS); // new String[] {"id"}
			psSet1(fields, m, ps);
			int result = ps.executeUpdate();
			if (result != 1) {
				throw new RuntimeException("Failed to insert record into " + tableName + " table");
			}
			if (!hasId && Cols.isNotEmpty(idFields)) {
				rs = ps.getGeneratedKeys();
				if (rs.next()){
					setId(m, rs.getLong(1));
				}
			}
			return m;
		} catch (SQLException e) {
			throw new RuntimeException(e);
		} finally {
			IOUtil.close(rs);
			IOUtil.close(ps);
		}
	}
	public void insert(Collection<M> col, Connection conn) {
		if (Cols.isEmpty(col)) {
			return;
		}
		List<Field1<M>> fields = allFields();
		PreparedStatement ps = null;
		try {
			String sql = "INSERT INTO `" + tableName + "`(" + fieldNames(fields) + ") VALUES(" + fieldsPH(fields) + ")";
			ps = conn.prepareStatement(sql, Cols.isEmpty(idFields) ? Statement.NO_GENERATED_KEYS : Statement.RETURN_GENERATED_KEYS); // new String[] {"id"}
			for (M m : col) {
				psSet1(fields, m, ps);
				ps.addBatch();
			}
			ps.executeBatch();
		} catch (SQLException e) {
			throw new RuntimeException(e);
		} finally {
			IOUtil.close(ps);
		}
	}
	private void setId(M m, long id) {
		Cols.getSingle(idFields).setValue(id, m);
	}
	public Object getId(M m) {
		Field1<M> idField = Cols.getSingle(idFields);
		return idField != null ? idField.getValue(m) : null;
	}
	private void psSet1(List<Field1<M>> fields, M m, PreparedStatement ps) throws SQLException {
		int index = 1;
		for (Field1 field : fields) {
			Object val = field.getValue(m);
			if (val == null) {
				ps.setNull(index++, Types.INTEGER);
			} else {
				P3<PreparedStatement, Integer, Object> setter = field.psSetter;
				setter.e(ps, index++, val);
			}
		}
	}
	private String fieldsPH(List<Field1<M>> fields) {
		return Cols.join(Cols.createList(fields.size(), () -> "?"), ",");
	}
	private String fieldNames(List<Field1<M>> fields) {
		return Cols.join((Iterable<String>) Cols.yield(fields, (f) -> "`" + f.sqlName + "`"), ",");
	}
	public int delete(Connection conn, String cond, Object... params) {
		PreparedStatement ps = null;
		try {
			ps = conn.prepareStatement("DELETE FROM `" + tableName + "` " + (cond != null ? cond : ""));
			SQLUtil.psSet1(params, ps);
			return ps.executeUpdate();
		} catch (SQLException e) {
			throw new RuntimeException(e);
		} finally {
			IOUtil.close(ps);
		}
	}
	/**
	 * SET state=? WHERE id=?
	 */
	public int update(Connection conn, String query, Object... params) {
		PreparedStatement ps = null;
		try {
			ps = conn.prepareStatement("UPDATE `" + tableName + "` " + query);
			SQLUtil.psSet1(params, ps);
			return ps.executeUpdate();
		} catch (SQLException e) {
			throw new RuntimeException(e);
		} finally {
			IOUtil.close(ps);
		}
	}
	public int update(M m, Connection conn, String cond, Object... params) {
		return update(m, allFields(), conn, cond, params);
	}
	public int update(M m, List<Field1<M>> fields, Connection conn, String cond, Object... params) {
		PreparedStatement ps = null;
		try {
			ps = conn.prepareStatement("UPDATE `" + tableName + "` SET " + psSetUpdate(fields) + " " + cond);
			psSet1(fields, m, ps);
			SQLUtil.psSet(params, ps, fields.size() + 1);
			return ps.executeUpdate();
		} catch (SQLException e) {
			throw new RuntimeException(e);
		} finally {
			IOUtil.close(ps);
		}
	}
	private String psSetUpdate(List<Field1<M>> fields) {
		return Cols.join((Iterable<String>)Cols.yield(fields, (f) -> "`" + f.sqlName + "`=?"), ",");
	}
	public M selectById(Object id, Connection conn) {
		if (id == null) {
			return null;
		}
		return select(conn, "WHERE `" + Cols.getSingle(idFields).sqlName + "`=?", id);
	}
	public M select(Connection conn, String query, Object... params) {
		Query<M> parseQuery = parseSelectQuery(query);
		AtomicReference<M> ret = new AtomicReference<>();
		F1<M, Boolean> f1 = Fs.f1(Fs.setter(ret), true);
		String cond = (parseQuery.cond != null ? parseQuery.cond : "") + " LIMIT 1";
		each(f1, conn, parseQuery.fields, cond, params);
		return ret.get();
	}
	public List<M> selectAll(Connection conn) {
		List<Field1<M>> fields = allFields();
		String cond = "";
		return selectList(conn, fields, cond, null);
	}
	private List<M> selectList(Connection conn, List<Field1<M>> fields,
	                           String cond, Object[] params) {
		LinkedList<M> list = new LinkedList<>();
		each(Fs.store(list), conn, fields, cond, params);
		return list;
	}
	private void each(P1<M> p1, Connection conn, List<Field1<M>> fields,
			String cond, Object[] params) {
		each(Fs.f1(p1, false), conn, fields, cond, params);
	}
	private void each(F1<M,Boolean> f1, Connection conn, List<Field1<M>> fields,
			String cond, Object[] params) {
		PreparedStatement ps = null;
		ResultSet rs = null;
		String sql = "SELECT " + fieldNames(fields) + " FROM `" + tableName + "`" + (cond == null ? "" : " " + cond);
		try {
			ps = conn.prepareStatement(sql);
			SQLUtil.psSet1(params, ps);
			rs = ps.executeQuery();
			while (rs.next()) {
				M m = ReflectUtil.newInstance(clazz);
				rsSet(fields, m, rs);
				if (f1.e(m)) {
					break;
				}
			}
		} catch (SQLException e) {
			throw new RuntimeException(e + ", sql=" + sql, e);
		} finally {
			IOUtil.close(rs);
			IOUtil.close(ps);
		}
	}
	private void rsSet(List<Field1<M>> fields, M m, ResultSet rs) {
		int index = 1;
		for (Field1 field : fields) {
			field.setValue(field.rsGet.e(rs, index++), m);
		}
	}
	private List<Field1<M>> allFields() {
		LinkedList<Field1<M>> ret = new LinkedList<>();
		ret.addAll(idFields);
		ret.addAll(dataFields);
		return ret;
	}
	public List<M> selectList(Connection conn, String query, Object... params) {
		Query<M> parseQuery = parseSelectQuery(query);
		return selectList(conn, parseQuery.fields, parseQuery.cond, params);
	}
	private Query<M> parseSelectQuery(String query) {
		if (query == null) {
			return new Query<>(allFields(), null);
		}
		Matcher matcher = RegexUtil.matcher("^(?i)(?:SELECT (.+?) *)?(?:FROM .+? *)?((?:WHERE .+)?(?:ORDER BY .+)?)$", query);
		if (!matcher.matches()) {
			throw new RuntimeException("Can not parse this query: " + query);
		}
		return new Query<>(parseFields(matcher.group(1)), matcher.group(2));
	}
	private List<Field1<M>> parseFields(String fields) {
		if (fields == null) {
			return allFields();
		}
		LinkedList<Field1<M>> ret = new LinkedList<>();
		for (String sqlName : fields.split("\\s*,\\s*")) {
			ret.add(getField(sqlName));
		}
		return ret;
	}
	private Field1<M> getField(String sqlName) {
		for (Field1<M> field1 : idFields) {
			if (field1.sqlName.equals(sqlName)) {
				return field1;
			}
		}
		for (Field1<M> field1 : dataFields) {
			if (field1.sqlName.equals(sqlName)) {
				return field1;
			}
		}
		throw new RuntimeException("Can not find this field: " + sqlName);
	}
	static class Query<M> {
		List<Field1<M>> fields;
		String cond;
		public Query(List<Field1<M>> fields, String cond) {
			this.fields = fields;
			this.cond = cond;
		}
	}
	public boolean exists(Connection conn, String cond, Object... params) {
		PreparedStatement ps = null;
		ResultSet rs = null;
		try {
			ps = conn.prepareStatement("SELECT 1 FROM `" + tableName + "` " + cond + " LIMIT 1");
			SQLUtil.psSet1(params, ps);
			rs = ps.executeQuery();
			return rs.next();
		} catch (SQLException e) {
			throw new RuntimeException(e);
		} finally {
			IOUtil.close(rs);
			IOUtil.close(ps);
		}
	}
	public void save(M m, Connection conn) {
		Object id = getId(m);
		if (id != null) {
			int result = update(m, allFields(), conn, "WHERE " + Cols.getSingle(idFields).sqlName + "=?", id);
			if (result != 1) {
				throw new RuntimeException("Failed to update record into " + tableName + " table");
			}
		} else {
			insert(m, conn);
		}
	}
	public void each(P1<M> p1, Connection conn) {
		each(p1, conn, null);
	}
	public void each(P1<M> p1, Connection conn,
			String query, Object... params) {
		Query<M> parseQuery = parseSelectQuery(query);
		each(p1, conn, parseQuery.fields, parseQuery.cond, params);
	}
	public <IDT> F1<IDT, M> selectByIdF(Connection conn) {
		return id -> selectById(id, conn);
	}
	public void update(M m, Connection conn) {
		int result = update(m, allFields(), conn, "WHERE " + Cols.getSingle(idFields).sqlName + "=?", getId(m));
		if (result != 1) {
			throw new RuntimeException("Failed to update record into " + tableName + " table");
		}
	}
	/**
	 * 
	 * @param fields SET name, age
	 */
	public void update(M m, String fields, Connection conn) {
		List<Field1<M>> fields1 = Cols.yield(Arrays.asList(fields.replaceFirst("(?i)^SET ","").split(",\\s*")), this::getField);
		int result = update(m, fields1, conn, "WHERE " + Cols.getSingle(idFields).sqlName + "=?", getId(m));
		if (result != 1) {
			throw new RuntimeException("Failed to update record into " + tableName + " table");
		}
	}
	public void delete(M m, Connection conn) {
		delete(conn, "WHERE " + Cols.getSingle(idFields).sqlName + "=?", getId(m));
	}
	public void deleteById(Object id, Connection conn) {
		delete(conn, "WHERE " + Cols.getSingle(idFields).sqlName + "=?", id);
	}
	public void deleteAll(Connection conn) {
		delete(conn, null);
	}
	public String tableName() {
		return tableName;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\qj\tool\web\ReloadingContext.java---
package qj.tool.web;
import qj.util.ReflectUtil;
import qj.util.funct.F0;
import qj.util.funct.Fs;
import qj.util.funct.P0;
import qj.util.funct.P1;
import qj.util.lang.DynamicClassLoader;
import java.lang.reflect.Field;
import java.util.LinkedList;
@SuppressWarnings("UnusedDeclaration")
public class ReloadingContext {
	protected String contextClassName;
	protected Object contextO;
	F0<ClassLoader> classLoaderF;
	LinkedList<P1<Object>> afterCreateContext = new LinkedList<>();
	LinkedList<P1<Object>> beforeCloseContext = new LinkedList<>();
	@SuppressWarnings("UnusedDeclaration")
	public ReloadingContext(String contextClass, final String... classpaths) {
		this.contextClassName = contextClass;
		classLoaderF = () -> new DynamicClassLoader(classpaths);
	}
	public ReloadingContext(String contextClass, F0<ClassLoader> classLoaderF) {
		this.contextClassName = contextClass;
		this.classLoaderF = classLoaderF;
	}
	public void reload() {
		close();
		contextO = createContextObj();
		Fs.invokeAll(afterCreateContext, contextO);
	}
	public void close() {
		if (contextO!= null) {
			Fs.invokeAll(beforeCloseContext, contextO);
			contextO = null;
		}
	}
	private Object createContextObj() {
		try {
			Class<?> contextClass = classLoaderF.e().loadClass(contextClassName);
			return ReflectUtil.newInstance(contextClass);
		} catch (ClassNotFoundException e) {
			throw new RuntimeException(e);
		}
	}
	public void initWith(final String methodName, Object... params) {
		afterCreateContext.add(obj -> {
			ReflectUtil.invoke(methodName, obj, params);
		});
	}
	public void beforeClose(final String methodName, Object... params) {
		beforeCloseContext.add(obj -> {
			ReflectUtil.invoke(methodName, obj, params);
		});
	}
	@SuppressWarnings("UnusedDeclaration")
	public void setField(final String fieldName, Object value) {
		afterCreateContext.add(obj -> ReflectUtil.setFieldValue(value, fieldName, obj));
	}
	public <A> A get(String fieldName) {
		if (contextO == null) {
			reload();
		}
		Field field = ReflectUtil.getField(fieldName, contextO.getClass());
		return ReflectUtil.getFieldValue(field, contextO);
	}
	public void initWith(P0 afterCreateContext) {
		this.afterCreateContext.add(Fs.p1(afterCreateContext));
	}
	public void beforeClose(P0 beforeClose) {
		this.beforeCloseContext.add(Fs.p1(beforeClose));
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\qj\tool\web\ReloadingWebContext.java---
package qj.tool.web;
import qj.util.funct.F0;
import qj.util.funct.F1;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
@SuppressWarnings("UnusedDeclaration")
public class ReloadingWebContext extends ReloadingContext {
	F1<HttpServletRequest, Boolean> shouldReload;
	@SuppressWarnings("UnusedDeclaration")
	public ReloadingWebContext(String contextClass, final String... classpaths) {
		super(contextClass, classpaths);
		shouldReload = req -> req.getMethod().equalsIgnoreCase("GET") && "true".equals(req.getParameter("rc"));
	}
	public ReloadingWebContext(String contextClass, F0<ClassLoader> classLoaderF, F1<HttpServletRequest, Boolean> shouldReload) {
		super(contextClass, classLoaderF);
		this.shouldReload = shouldReload;
	}
	public HttpServlet stubServlet(final String servletName) {
		return new HttpServlet() {
			protected void service(HttpServletRequest req,
			                       HttpServletResponse resp) throws ServletException,
					IOException {
				if (shouldReload != null && shouldReload.e(req)) {
					reload();
				}
				((HttpServlet)get(servletName + "Servlet")).service(req, resp);
			}
		};
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\qj\tool\web\ResourceFilter.java---
package qj.tool.web;
import qj.util.FileUtil;
import qj.util.IOUtil;
import qj.util.funct.F1;
import javax.servlet.*;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.File;
import java.io.IOException;
import java.nio.charset.Charset;
import java.util.LinkedList;
import java.util.concurrent.TimeoutException;
public class ResourceFilter implements Filter {
	private F1<HttpServletRequest, String> rootRedirect;
	LinkedList<F1<String, File>> locationFs = new LinkedList<>();
	public ResourceFilter(F1<HttpServletRequest,String> rootRedirect, String... locations) {
		this.rootRedirect = rootRedirect;
		for (final String loc : locations) {
			if (loc != null) {
				locationFs.add(locF(loc));
			}
		}
	}
	@Override
	public void destroy() {
	}
	@Override
	public void init(FilterConfig filterConfig) throws ServletException {
	}
	@Override
	public void doFilter(ServletRequest req1, ServletResponse resp1,
			FilterChain chain) throws IOException, ServletException {
		HttpServletRequest req = (HttpServletRequest) req1;
		HttpServletResponse resp = (HttpServletResponse) resp1;
		String uri = req.getRequestURI();
		String redirectLocation;
		if (uri.equals("/") && (redirectLocation = rootRedirect.e(req)) != null) {
			resp.sendRedirect(redirectLocation);
			return;
		}
		File file = getFile(uri);
		if (file != null) {
			serve((HttpServletResponse) resp1, file, uri);
		} else if (uri.endsWith(".js") || uri.endsWith(".css") || uri.endsWith(".jpg") || uri.endsWith(".png")) {
			resp.sendError(404);
		} else {
			chain.doFilter(req1, resp1);
		}
	}
	private void serve(HttpServletResponse resp, File file, String uri) throws IOException {
		resp.setContentType(
					uri.endsWith(".js" ) ? "application/javascript" : 
					uri.endsWith(".css") ? "text/css" :
					uri.endsWith(".svg") ? "image/svg+xml" :
					uri.endsWith(".ttf") ? "application/octet-stream" :
					uri.endsWith(".woff") ? "font/woff" :
					null
				);
		F1<String, String> contentFilter = getContentFilter(uri);
		if (contentFilter != null) {
			String content = contentFilter.e(IOUtil.toString(FileUtil.fileInputStream(file), "UTF-8"));
			resp.getOutputStream().write(content.getBytes(Charset.forName("UTF-8")));
		} else {
			ServletOutputStream out = resp.getOutputStream();
			try {
				IOUtil.connect(FileUtil.fileInputStream(file), out);
			} catch (IOException e) {
				if (e.getCause() != null && e.getCause() instanceof TimeoutException) {
					;
				} else {
					throw e;
				}
			}
		}
	}
	LinkedList<ContentFilterHolder> filters = new LinkedList<>();
	@SuppressWarnings("UnusedDeclaration")
	public void addContentFilter(F1<String,Boolean> uriCheck, F1<String,String> contentFilter) {
		filters.add(new ContentFilterHolder(uriCheck, contentFilter));
	}
	public F1<String,String> getContentFilter(String uri) {
		for (ContentFilterHolder filter : filters) {
			if (filter.uriCheck.e(uri)) {
				return filter.contentFilter;
			}
		}
		return null;
	}
	public static F1<String, Boolean> js = uri -> uri.endsWith(".js" );
	static class ContentFilterHolder {
		F1<String,Boolean> uriCheck;
		F1<String,String> contentFilter;
		public ContentFilterHolder(
				F1<String, Boolean> uriCheck,
				F1<String, String> contentFilter
				) {
			this.uriCheck = uriCheck;
			this.contentFilter = contentFilter;
		}
	}
	private File getFile(String uri) {
		if (uri.contains("//") || uri.contains("..") || uri.contains("./") || uri.contains("\\")) {
			return null;
		}
		for (F1<String, File> locF : locationFs) {
			File file = locF.e(uri);
			if (file != null) {
				return file;
			}
		}
		return null;
	}
	public F1<String, File> locF(final String loc) {
		return uri -> {
			File file = new File(loc + uri);
			if (file.exists() && file.isFile()) {
				return file;
			}
			return null;
		};
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\qj\util\Cols.java---
package qj.util;
import qj.util.funct.F0;
import qj.util.funct.F1;
import java.util.*;
/**
 * Created by QuanLA
 * Date: Mar 2, 2006
 * Time: 9:10:49 AM
 */
@SuppressWarnings({"rawtypes","unchecked"})
public class Cols {
	/**
	 * If a collection is empty
	 * @param objs
	 * @return
	 */
	public static boolean isEmpty(Collection<?> objs) {
		return objs == null || objs.isEmpty();
	}
	/**
	 * If a collection is not empty
	 * @param col
	 * @return
	 */
    public static boolean isNotEmpty(Collection<?> col) {
        return !isEmpty(col);
    }
    /**
     * Get single element, or null if Col is empty
     * @param collection
     * @return
     */
    public static <A> A getSingle(
            Collection<A> collection) {
    	if (collection == null) {
    		return null;
    	}
        for (A a : collection) {
            return a;
        }
        return null;
    }
    public static <A> List<A> createList(int size, F0<A> f) {
        ArrayList<A> list = new ArrayList<A>(size);
        for (int i = 0; i < size; i++) {
            list.add(f.e());
        }
        return list;
    }
    /**
     * Create a string connecting all values in collection, separated with delimiter
     * @param objs
     * @param delimiter
     * @return
     */
	public static <A> String join(Iterable<A> objs, String delimiter) {
        if (objs == null) {
            return "";
        }
		StringBuilder sb = new StringBuilder();
		for (A a : objs) {
			sb.append(a).append(delimiter);
		}
		if (sb.length() > 0) {
			sb.setLength(sb.length() - delimiter.length());
		}
		return sb.toString();
	}
	public static <A,T> List<T> yield(List<A> col, F1<A, T> f1) {
        if (col!=null) {
            return yield(col, new ArrayList<T>(col.size()), f1);
        } else {
            return null;
        }
    }
	/**
	 * Apply function on every elements to get new collection of returned value
	 * @param <A>
	 * @param <T>
	 * @param <C>
	 * @param inputs
	 * @param col
	 * @param f1
	 * @return
	 */
	public static <A,T,C extends Collection<T>> C yield(Iterable<A> inputs, C col, F1<A, T> f1) {
		if (inputs!=null) {
            for (A a : inputs) {
                T e = f1.e(a);
				if (e != null) {
					col.add(e);
				}
            }
		}
		return col;
	}
	/**
     * Create a map based on the Object... param. Each 2 values is an entry
     * which is a pair of key then value
     * @param objects The params that will be converted to map.
     * 					Format: [key1, value1, key2, value2]
     * @return The map after converted from param objects
     */
    public static <A, B> Map<A, B> map(Object... objects) {
    	if (objects==null) {
    		return null;
    	}
        Map<A, B> map = new LinkedHashMap<A, B>(objects.length / 2);
        for (int i = 0; i < objects.length; i+=2) {
            map.put((A)objects[i], (B)objects[i + 1]);
        }
        return map;
    }
}
----strat of file D:\projects\cg\cg-min\src\main\java\qj\util\FileUtil.java---
package qj.util;
import qj.util.funct.F1;
import qj.util.funct.F2;
import qj.util.funct.Fs;
import qj.util.funct.P2;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Enumeration;
import java.util.List;
import java.util.jar.JarEntry;
import java.util.jar.JarFile;
@SuppressWarnings("UnusedDeclaration")
public class FileUtil {
	/**
	 * 
	 * @param fileToRead
	 * @return
	 * @throws IOException
	 */
	public static byte[] readFileToBytes(File fileToRead) {
		try {
			return IOUtil.readData(new FileInputStream(fileToRead));
		} catch (IOException e) {
			throw new RuntimeException(e);
		}
	}
	public static FileInputStream fileInputStream(File file) {
		try {
			return new FileInputStream(file);
		} catch (FileNotFoundException e) {
			throw new RuntimeException(e);
		}
	}
	public static FileInputStream fileInputStream(String file) {
		try {
			return new FileInputStream(file);
		} catch (FileNotFoundException e) {
			throw new RuntimeException(e);
		}
	}
	public static void eachFile(File path, P2<File, String> f) {
		eachFile(path, f, null);
	}
	public static void eachFile(File path, P2<File, String> f, F1<File, Boolean> exclude) {
		eachFile(path, Fs.f2(f, true), exclude);
	}
	public static void eachFile(File path, F2<File, String, Boolean> f, F1<File, Boolean> exclude) {
		ArrayList<String> relPath = new ArrayList<>();
		if (path.isFile()) {
			f.e(path, Cols.join(relPath, File.separator));
		} else {
			if (!eachFileInDir(path, f, relPath, exclude))
				return;
		}
	}
	private static boolean eachFileInDir(File path, F2<File, String, Boolean> f, ArrayList<String> relPath,
			F1<File, Boolean> exclude) {
		if (!path.exists() || !path.isDirectory()) {
			throw new RuntimeException("Invalid path: " + path);
		}
		for (File child : path.listFiles()) {
			if (exclude != null && exclude.e(child)) {
				continue;
			}
			if (child.isFile()) {
				if (!f.e(child, Cols.join(relPath, File.separator)))
					return false;
			} else {
				relPath.add(child.getName());
				if (!eachFileInDir(child, f, relPath, exclude))
					return false;
				relPath.remove(relPath.size() - 1);
			}
		}
		return true;
	}
	public static List<String> getJarFileClassNames(JarFile jarFile) {
		List<String> list = new ArrayList<>();
		if (jarFile != null) {
			Enumeration<JarEntry> e = jarFile.entries();
			while (e.hasMoreElements()) {
				JarEntry entry = e.nextElement();
				String name = entry.getName();
				if (name.endsWith(".class")) {
					name = name.replace(".class", "");
					name = name.replace("/", ".");
					if ("junit.framework.TestCase".equals(name)) {
						System.out.println("***");
					}
					list.add(name);
				}
			}
		}
		return list;
	}
	public static String getPathRegex() {
		String pathRegex = File.separator;
		if ("\\".equals(pathRegex)) {
			pathRegex = "\\\\";
		}
		return pathRegex;
	}
	public static void listAllFiles(File dir, String fileNameRegex, List<File> allFiles) {
		File fileArray[] = dir.listFiles();
		for (File file : fileArray) {
			if (file.isFile()) {
				String s = file.getName();
				boolean b = s.matches(fileNameRegex);
				if (b) {
					allFiles.add(file);
				}
			} else {
				listAllFiles(file, fileNameRegex, allFiles);
			}
		}
	}
	public static List<String> getClassNamesUnderDir(File dir) {
		String pathRegex = getPathRegex();
		List<String> list = new ArrayList<>();
		String folderPath = dir.getAbsolutePath() + File.separator;
		List<File> classFileList = new ArrayList<>();
		listAllFiles(dir, "[\\w\\$]+\\.class", classFileList);
		for (File classFile : classFileList) {
			String clzFilePath;
			try {
				clzFilePath = classFile.getCanonicalPath();
				clzFilePath = clzFilePath.replace(folderPath, "");
				clzFilePath = clzFilePath.replaceAll(pathRegex, "\\.");
				clzFilePath = clzFilePath.replaceAll(".class", "");
				list.add(clzFilePath);
			} catch (IOException e2) {
				e2.printStackTrace();
			}
		}
		return list;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\qj\util\funct\F0.java---
package qj.util.funct;
/**
 * Represent a function that accept no parameter and return value
 * @param <T> The return value
 */
public interface F0<T> {
    /**
     * Evaluate or execute the function
     * @return Result of execution
     */
    T e();
}
----strat of file D:\projects\cg\cg-min\src\main\java\qj\util\funct\F1.java---
package qj.util.funct;
/**
 * Represent a function that accept one parameter and return value
 * @param <A> The only parameter
 * @param <T> The return value
 */
public interface F1<A, T> {
    /**
     * Evaluate or execute the function
     * @param obj The parameter
     * @return Result of execution
     */
	T e(A obj);
}
----strat of file D:\projects\cg\cg-min\src\main\java\qj\util\funct\F2.java---
package qj.util.funct;
public interface F2<A, B, T>{
	T e(A a, B b);
}
----strat of file D:\projects\cg\cg-min\src\main\java\qj\util\funct\Fs.java---
package qj.util.funct;
import java.util.Collection;
import java.util.concurrent.atomic.AtomicReference;
/**
 * The utility that employ idea of functional programming
 *
 */
@SuppressWarnings({"unchecked", "rawtypes"})
public class Fs extends FsGenerated {
    public static Runnable runnable(final P0 action) {
        return new Runnable() {
            public void run() {
                action.e();
            }
        };
    }
	/**
	 * Just store the object to collection
	 * @param col
	 * @return
	 */
    public static <A> P1<A> store(final Collection<A> col) {
        return new P1<A>() {public void e(A a) {
            col.add(a);
        }};
    }
	public static <A> P1<A> setter(
			final AtomicReference<A> ref) {
		return new P1<A>() {public void e(A obj) {
			ref.set(obj);
		}};
	}
	public static <A> void invokeAll(final Collection<P1<A>> col, A a) {
		for (P1<A> p1 : col) {
			p1.e(a);
		}
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\qj\util\funct\FsGenerated.java---
package qj.util.funct;
public class FsGenerated {
	/**
	 * Convert from a p0 to p1
	 * @return p1
	 */
	public static <A> P1<A> p1(final P0 p0) {
		return new P1<A>(){public void e(final A a) {
			p0.e();
		}};
	}
	/**
	 * Call to p and return fixed value
	 * @param p1 the function to call before return value
	 * @param ret the fixed value to return
	 * @return ret
	 */
	public static <A, R> F1<A, R> f1(final P1<A> p1, final R ret) {
		return new F1<A, R>(){public R e(final A a) {
			p1.e(a);
			return ret;
		}};
	}
	/**
	 * Call to p and return fixed value
	 * @param p2 the function to call before return value
	 * @param ret the fixed value to return
	 * @return ret
	 */
	public static <A, B, R> F2<A, B, R> f2(final P2<A, B> p2, final R ret) {
		return new F2<A, B, R>(){public R e(final A a, final B b) {
			p2.e(a, b);
			return ret;
		}};
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\qj\util\funct\P0.java---
package qj.util.funct;
public interface P0 {
	void e();
}
----strat of file D:\projects\cg\cg-min\src\main\java\qj\util\funct\P1.java---
package qj.util.funct;
/**
 * Function that accept 1 objects and return nothing
 * @author QuanLA
 *
 * @param <A>
 */
public interface P1<A> {
	void e(A obj);
}
----strat of file D:\projects\cg\cg-min\src\main\java\qj\util\funct\P2.java---
package qj.util.funct;
/**
 * Function that accept 2 objects and return nothing
 * @author QuanLA
 *
 * @param <A>
 * @param <B>
 */
public interface P2<A, B> {
	void e(A a, B b);
}
----strat of file D:\projects\cg\cg-min\src\main\java\qj\util\funct\P3.java---
package qj.util.funct;
public interface P3<A, B, C> {
	void e(A a, B b, C c);
}
----strat of file D:\projects\cg\cg-min\src\main\java\qj\util\IOUtil.java---
package qj.util;
import java.io.*;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
/**
 * Created by Quan on 22/12/2014.
 */
public class IOUtil {
	/**
	 * Read the stream into byte array
	 * @param inputStream
	 * @return
	 * @throws IOException
	 */
    public static byte[] readData(InputStream inputStream) {
        try {
			return readDataNice(inputStream);
		} finally {
        	close(inputStream);
		}
    }
    public static byte[] readDataNice(InputStream inputStream) {
		ByteArrayOutputStream boTemp = null;
        byte[] buffer = null;
        try {
            int read;
			buffer = new byte[8192];
            boTemp = new ByteArrayOutputStream();
            while ((read=inputStream.read(buffer, 0, 8192)) > -1) {
                boTemp.write(buffer, 0, read);
            }
            return boTemp.toByteArray();
        } catch (IOException e) {
			throw new RuntimeException(e);
        }
	}
    /**
     * Close streams (in or out)
     * @param stream
     */
    public static void close(Closeable stream) {
        if (stream != null) {
            try {
                if (stream instanceof Flushable) {
                    ((Flushable)stream).flush();
                }
                stream.close();
            } catch (IOException e) {
            }
        }
    }
	public static void close(Connection conn) {
        if (conn != null) {
            try {
                conn.close();
            } catch (SQLException e) {
			}
        }
	}
    public static void close(ResultSet rs) {
    	if (rs != null) {
    		try {
    			rs.close();
    		} catch (SQLException e) {
    		}
    	}
    }
    public static void close(PreparedStatement ps) {
    	if (ps != null) {
    		try {
    			ps.close();
    		} catch (SQLException e) {
    		}
    	}
    }
	/**
	 * Will close stream
	 * @param in
	 * @param charSet
	 * @return
	 */
	public static String toString(InputStream in, String charSet) {
		return inputStreamToString_force(in, charSet);
	}
	/**
	 * Will close stream
	 * @param in
	 * @param charSet
	 * @return
	 */
	public static String inputStreamToString_force(InputStream in, String charSet) {
		try {
			return inputStreamToString(in, charSet);
		} catch (IOException e) {
			return null;
		}
	}
    /**
     * Reads in whole input stream and returns as a string<br>
     * Will close stream
     * @param in The input stream to read in, will be closed 
     * 				by this method at finish
     * @param charSet charset to convert the input bytes into string
     * @return the result string
     * @throws IOException
     */
	public static String inputStreamToString(InputStream in, String charSet) throws IOException {
		InputStreamReader inputStreamReader = null;
		try {
			inputStreamReader = charSet == null? new InputStreamReader(in) : new InputStreamReader(in, charSet);
			return toString(inputStreamReader);
		} catch (UnsupportedEncodingException e1) {
			throw new RuntimeException(e1);
		} finally {
			close(in);
		}
	}
    /**
     * Reads in whole input stream and returns as a string
     * @param reader The input reader to read in, will be closed 
     * 				by this method at finish
     * @return the result string
     * @throws IOException
     */
	public static String toString(Reader reader) {
		try {
			StringBuilder sb = new StringBuilder();
			char[] buffer = new char[4096];
			for (int read; (read = reader.read(buffer)) > -1;) {
				sb.append(buffer, 0, read);
			}
			return sb.toString();
		} catch (IOException e) {
			throw new RuntimeException(e);
		} finally {
			close(reader);
		}
	}
	/**
	 * Read the input stream and write to output stream
	 * @param inputStream
	 * @param out
	 * @return
	 * @throws IOException
	 */
    public static long connect(InputStream inputStream, OutputStream out) throws IOException {
        try {
            return dump(inputStream, out);
        } finally {
            close(inputStream);
        }
    }
    private static long dump(InputStream inputStream, OutputStream out) throws IOException {
        long total = 0;
        int read;
        int bufferSize = 8192;
        byte[] buffer = new byte[bufferSize];
        while ((read=inputStream.read(buffer, 0, bufferSize)) > -1) {
            out.write(buffer, 0, read);
            total+=read;
        }
        out.flush();
        return total;
    }
}
----strat of file D:\projects\cg\cg-min\src\main\java\qj\util\lang\AggressiveClassLoader.java---
package qj.util.lang;
import java.util.HashSet;
import java.util.Set;
/**
 * Load all classes it can, leave the rest to the Parent ClassLoader
 */
public abstract class AggressiveClassLoader extends ClassLoader {
	Set<String> loadedClasses = new HashSet<>();
	Set<String> unavaiClasses = new HashSet<>();
	public AggressiveClassLoader() {
		super();
	}
	public AggressiveClassLoader(ClassLoader parent) {
		super(parent);
	}
	@Override
	public Class<?> loadClass(String name) throws ClassNotFoundException {
		if (loadedClasses.contains(name) || unavaiClasses.contains(name)) {
			return super.loadClass(name); // Use default CL cache
		}
		byte[] newClassData = loadNewClass(name);
		if (newClassData != null) {
			loadedClasses.add(name);
			return loadClass(newClassData, name);
		} else {
			unavaiClasses.add(name);
			return super.loadClass(name, true);
		}
	}
	@Override
	public Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {
		if (loadedClasses.contains(name) || unavaiClasses.contains(name)) {
			return super.loadClass(name, resolve); // Use default CL cache
		}
		byte[] newClassData = loadNewClass(name);
		if (newClassData != null) {
			loadedClasses.add(name);
			return loadClass(newClassData, name);
		} else {
			unavaiClasses.add(name);
			return super.loadClass(name, true);
		}
	}
	/**
	 * Handle exception
	 * 
	 * @param name
	 * @return
	 */
	public Class<?> load(String name) {
		try {
			return loadClass(name);
		} catch (ClassNotFoundException e) {
			throw new RuntimeException(e);
		}
	}
	/**
	 * Handle exception
	 * 
	 * @param name
	 * @return
	 */
	public Class<?> load(String name, boolean resolve) {
		try {
			return loadClass(name, resolve);
		} catch (ClassNotFoundException e) {
			throw new RuntimeException(e);
		}
	}
	protected abstract byte[] loadNewClass(String name);
	public Class<?> loadClass(byte[] classData, String name) {
		Class<?> clazz = defineClass(name, classData, 0, classData.length);
		if (clazz != null) {
			if (clazz.getPackage() == null) {
				definePackage(name.replaceAll("\\.\\w+$", ""), null, null, null, null, null, null, null);
			}
			resolveClass(clazz);
		}
		return clazz;
	}
	public Set<String> getLoadedClasses() {
		return loadedClasses;
	}
	public Set<String> getUnavaiClasses() {
		return unavaiClasses;
	}
	public static String toFilePath(String name) {
		return name.replaceAll("\\.", "/") + ".class";
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\qj\util\lang\DynamicClassLoader.java---
package qj.util.lang;
import qj.util.FileUtil;
import qj.util.IOUtil;
import qj.util.funct.F1;
import java.io.File;
import java.io.IOException;
import java.lang.reflect.Method;
import java.net.URL;
import java.util.ArrayList;
import java.util.Collection;
import java.util.LinkedList;
import java.util.List;
import java.util.jar.JarFile;
import java.util.zip.ZipEntry;
public class DynamicClassLoader extends AggressiveClassLoader {
	LinkedList<F1<String, byte[]>> loaders = new LinkedList<>();
	private List<String> allClassNamesInJar = new ArrayList<>();
	private List<String> allClassNamesInDir = new ArrayList<>();
	public DynamicClassLoader(URL... urls) {
		String[] paths = new String[urls.length];
		for (int i = 0; i < urls.length; i++) {
			if (null != urls[i]) {
				paths[i] = urls[i].getPath();
			}
		}
		for (String path : paths) {
			if (null != path) {
				File file = new File(path);
				F1<String, byte[]> loader = loader(file);
				if (loader == null) {
					throw new RuntimeException("Path not exists " + path);
				}
				loaders.add(loader);
			}
		}
	}
	public DynamicClassLoader(ClassLoader parent, URL... urls) {
		super(parent);
		String[] paths = new String[urls.length];
		for (int i = 0; i < urls.length; i++) {
			if (null != urls[i]) {
				paths[i] = urls[i].getPath();
			}
		}
		for (String path : paths) {
			if (null != path) {
				File file = new File(path);
				F1<String, byte[]> loader = loader(file);
				if (loader == null) {
					throw new RuntimeException("Path not exists " + path);
				}
				loaders.add(loader);
			}
		}
	}
	public DynamicClassLoader(String... paths) {
		for (String path : paths) {
			if (null != path) {
				File file = new File(path);
				F1<String, byte[]> loader = loader(file);
				if (loader == null) {
					throw new RuntimeException("Path not exists " + path);
				}
				loaders.add(loader);
			}
		}
	}
	public DynamicClassLoader(ClassLoader parent, String... paths) {
		super(parent);
		for (String path : paths) {
			if (null != path) {
				File file = new File(path);
				F1<String, byte[]> loader = loader(file);
				if (loader == null) {
					throw new RuntimeException("Path not exists " + path);
				}
				loaders.add(loader);
			}
		}
	}
	@SuppressWarnings("UnusedDeclaration")
	public DynamicClassLoader(Collection<File> paths) {
		for (File file : paths) {
			F1<String, byte[]> loader = loader(file);
			if (loader == null) {
				throw new RuntimeException("Path not exists " + file.getPath());
			}
			loaders.add(loader);
		}
	}
	public F1<String, byte[]> loader(File file) {
		if (!file.exists()) {
			return null;
		} else if (file.isDirectory()) {
			allClassNamesInDir.addAll(FileUtil.getClassNamesUnderDir(file));
			return dirLoader(file);
		} else {
			try {
				final JarFile jarFile = new JarFile(file);
				allClassNamesInJar.addAll(FileUtil.getJarFileClassNames(jarFile));
				return jarLoader(jarFile);
			} catch (IOException e) {
				throw new RuntimeException(e);
			}
		}
	}
	private static File findFile(String filePath, File classPath) {
		File file = new File(classPath, filePath);
		return file.exists() ? file : null;
	}
	public static F1<String, byte[]> dirLoader(final File dir) {
		return filePath -> {
			File file = findFile(filePath, dir);
			if (file == null) {
				return null;
			}
			return FileUtil.readFileToBytes(file);
		};
	}
	private static F1<String, byte[]> jarLoader(final JarFile jarFile) {
		return new F1<String, byte[]>() {
			public byte[] e(String filePath) {
				ZipEntry entry = jarFile.getJarEntry(filePath);
				if (entry == null) {
					return null;
				}
				try {
					return IOUtil.readData(jarFile.getInputStream(entry));
				} catch (IOException e) {
					throw new RuntimeException(e);
				}
			}
			@Override
			protected void finalize() throws Throwable {
				IOUtil.close(jarFile);
				super.finalize();
			}
		};
	}
	@Override
	protected byte[] loadNewClass(String name) {
		for (F1<String, byte[]> loader : loaders) {
			String path = AggressiveClassLoader.toFilePath(name);
			byte[] data = loader.e(path);
			if (data != null) {
				return data;
			}
		}
		return null;
	}
	public LinkedList<F1<String, byte[]>> getLoaders() {
		return loaders;
	}
	public List<String> getAllClassNamesInJar() {
		return allClassNamesInJar;
	}
	public List<String> getAllClassNamesInDir() {
		return allClassNamesInDir;
	}
	public static void main(String[] args) {
		for (;;) {
			String[] sa = new String[] { "D:\\project\\codegen\\production\\winSTSRobot\\target\\classes",
					"D:\\androidMavenRepository\\deployment\\common\\1.0\\common-1.0.jar",
					"D:\\androidMavenRepository\\com\\dgs\\customobfuscator\\1.0\\customobfuscator-1.0.jar" };
			DynamicClassLoader dynamicClassLoader = new DynamicClassLoader(sa);
			try {
				Class<?> clz = dynamicClassLoader.loadClass("ui.UI");
				Method methodArray[] = clz.getDeclaredMethods();
				System.out.println(methodArray.length);
				Thread.sleep(2000L);
			} catch (ClassNotFoundException | InterruptedException e) {
				e.printStackTrace();
			}
		}
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\qj\util\lang\ExceptingClassLoader.java---
package qj.util.lang;
import qj.util.funct.F1;
/**
 * This class loader will not load certain classes, instead delegate to parent
 * class loader to do the job
 */
@SuppressWarnings("UnusedDeclaration")
public class ExceptingClassLoader extends DynamicClassLoader {
	private F1<String, Boolean> except;
	public ExceptingClassLoader(F1<String, Boolean> except, String... paths) {
		super(paths);
		this.except = except;
	}
	@Override
	protected byte[] loadNewClass(String name) {
		if (except.e(name)) {
            return null;
		}
		return super.loadNewClass(name);
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\qj\util\lang\ReloadableDynamicClassLoaderOwner.java---
package qj.util.lang;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.*;
public class ReloadableDynamicClassLoaderOwner {
	ClassLoader parent;// both classloader's parent
	private Set<URL> jarUrls = new HashSet<>();
	private Set<URL> dirUrls = new HashSet<>();
	private DynamicClassLoader dirDynamicClassLoader;// by default, dirDynamicClassLoader should has its parent as
	private DynamicClassLoader jarDynamicClassLoader;
	public void addJarUrl(URL... jarUrlArray) {
		for (URL url : jarUrlArray) {
			jarUrls.add(url);
		}
	}
	public DynamicClassLoader loadAllJar(ClassLoader parent, URL... urlArray) {
		for (URL url : urlArray) {
			jarUrls.add(url);
		}
		jarDynamicClassLoader = new DynamicClassLoader(parent, jarUrls.toArray(new URL[this.jarUrls.size()]));
		return jarDynamicClassLoader;
	}
	public DynamicClassLoader reloadAllJar() throws Exception {
		if (null == this.jarUrls) {
			throw new Exception("urls cannot be null");
		}
		return loadAllJar(parent, this.jarUrls.toArray(new URL[this.jarUrls.size()]));
	}
	public void addDirUrl(URL... urlArray) {
		for (URL url : urlArray) {
			dirUrls.add(url);
		}
	}
	public DynamicClassLoader loadAllClzInDirectory(ClassLoader parent, URL... dirArray) {
		for (URL url : dirArray) {
			dirUrls.add(url);
		}
		dirDynamicClassLoader = new DynamicClassLoader(parent, dirUrls.toArray(new URL[this.dirUrls.size()]));
		return dirDynamicClassLoader;
	}
	public DynamicClassLoader reloadAllClzInDirectory() throws Exception {
		if (null == this.dirUrls) {
			throw new Exception("urls cannot be null");
		}
		if (null != jarDynamicClassLoader) {
			return loadAllClzInDirectory(jarDynamicClassLoader, this.dirUrls.toArray(new URL[this.dirUrls.size()]));
		} else {
			return loadAllClzInDirectory(parent, this.dirUrls.toArray(new URL[this.dirUrls.size()]));
		}
	}
	public void loadAllClzIntervallyInDirectory(int interval, ClassLoader parent, URL... dirArray) {
		Timer timer = new Timer("loaddirintervally");
		timer.scheduleAtFixedRate(new TimerTask() {
			@Override
			public void run() {
				loadAllClzInDirectory(parent, dirArray);
			}
		}, 0, interval);
	}
	public void reloadAll() {
		loadAllJar(parent);
		loadAllClzInDirectory(parent);
	}
	public DynamicClassLoader getDirDynamicClassLoader() {
		return dirDynamicClassLoader;
	}
	public DynamicClassLoader getJarDynamicClassLoader() {
		return jarDynamicClassLoader;
	}
	public ClassLoader getParent() {
		return parent;
	}
	public void clear() {
		this.jarUrls.clear();
		this.dirUrls.clear();
	}
	public Class<?> loadClassFromDirURLs(String name, boolean resolve) throws ClassNotFoundException {
		Class<?> c = null;
		if (null != dirDynamicClassLoader) {
			try {
				c = dirDynamicClassLoader.loadClass(name, resolve);
			} catch (Exception e) {
				throw new ClassNotFoundException();
			}
		}
		if (null == c) {
			throw new ClassNotFoundException();
		}
		return c;
	}
	public Class<?> loadClassFromJarURLs(String name, boolean resolve) throws ClassNotFoundException {
		Class<?> c = null;
		try {
			if (null != jarDynamicClassLoader) {
				c = jarDynamicClassLoader.loadClass(name, resolve);
			}
		} catch (Exception e) {
			throw new ClassNotFoundException();
		}
		if (null == c) {
			throw new ClassNotFoundException();
		}
		return c;
	}
	public Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {
		Class<?> c = loadClassFromDirURLs(name, resolve);
		if (null == c) {
			c = loadClassFromJarURLs(name, resolve);
		}
		if (null == c) {
			throw new ClassNotFoundException();
		}
		return c;
	}
	public Set<URL> getJarUrls() {
		return jarUrls;
	}
	public Set<URL> getDirUrls() {
		return dirUrls;
	}
	public static void main(String[] args) throws MalformedURLException {
		URL[] urls = new URL[] {
			new URL("file://D:/Java/openjdk-12.0.2_windows-x64_bin/jdk-12.0.2/lib/jrt-fs.jar"),
		};
		ReloadableDynamicClassLoaderOwner rdcl = new ReloadableDynamicClassLoaderOwner();
		rdcl.loadAllJar(ReloadableDynamicClassLoaderOwner.class.getClassLoader(), urls);
		List<String> list = rdcl.getJarDynamicClassLoader().getAllClassNamesInJar();
		List<String> list2 = rdcl.getJarDynamicClassLoader().getAllClassNamesInDir();
		for(String str : list) {
			System.out.println(str);
		}
		System.out.print("*************");
		for(String str : list2) {
			System.out.println(str);
		}
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\qj\util\math\Range.java---
package qj.util.math;
import qj.util.ObjectUtil;
/**
 */
public class Range implements Comparable<Range> {
	private Integer from;
	private Integer to;
    public Range() {
    }
    public Range(Integer from, Integer to) {
        this.from = from;
        this.to = to;
        if (to != null && to < from) {
        	throw new RuntimeException("to(" + to + ") < from(" + from + ")");
        }
    }
    public Range(Long start, Long end) {
        this.from 	= start	== null ? null : start.intValue();
        this.to 	= end   == null ? null : end.intValue();
        if (to != null && to < from) {
        	throw new RuntimeException();
        }
	}
	public Integer getFrom() {
        return from;
    }
    public void setFrom(Integer from) {
        this.from = from;
    }
    public Integer getTo() {
        return to;
    }
    public void setTo(Integer to) {
        this.to = to;
    }
    public String toString() {
        return from + "-" + to;
    }
    @Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + ((from == null) ? 0 : from.hashCode());
		result = prime * result + ((to == null) ? 0 : to.hashCode());
		return result;
	}
    @Override
    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }
        if (!(obj instanceof Range)) {
            return false;
        }
        Range o2 = (Range) obj;
        return ObjectUtil.equals(from, o2.from)
                && ObjectUtil.equals(to, o2.to);
    }
    public int length() {
        return to - from;
    }
    public boolean isEmpty() {
        return to.equals(from);
    }
    public boolean isNotEmpty() {
        return !isEmpty();
    }
    public int compareTo(Range o) {
        return from.compareTo(((Range)o).getFrom());
    }
	public static Range fromlength(int from, int length) {
		return new Range(from, from + length);
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\qj\util\NameCaseUtil.java---
package qj.util;
import qj.util.funct.F1;
import java.util.regex.Matcher;
public class NameCaseUtil {
	public static String camelToHyphen(String name) {
		return RegexUtil.replaceAll(name, "[A-Z]|[0-9]+", new F1<Matcher, String>() {public String e(Matcher m) {
			return (m.start() == 0 ? "" : "_") + m.group().toLowerCase();
		}});
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\qj\util\ObjectUtil.java---
package qj.util;
/**
 * Created by QuanLA
 * Date: Apr 5, 2006
 * Time: 5:46:44 PM
 */
public class ObjectUtil {
	public static boolean equals(Object o1, Object o2) {
		return o1==null ? o2 == null : (o1 == o2 || o1.equals(o2));
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\qj\util\PropertiesUtil.java---
package qj.util;
import java.io.*;
import java.util.Properties;
public class PropertiesUtil {
	public static Properties loadPropertiesFromFile(String fileName) {
        return loadPropertiesFromFile(new File(fileName));
	}
	/**
	 * 
	 * @param file
	 * @return
	 */
    public static Properties loadPropertiesFromFile(File file) {
    	if (!file.exists()) {
    		return null;
    	}
		FileInputStream fis;
		try {
			fis = new FileInputStream(file);
			return load(fis);
		} catch (FileNotFoundException e) {
			throw new RuntimeException(e);
		}
    }
    /**
     * Load a Properties object from inputstream. Close the stream afterward
     * @param is
     * @return
     */
	public static Properties load(InputStream is) {
		Properties properties = new Properties();
        try {
            properties.load(is);
        } catch (IOException e) {
            throw new RuntimeException(e);
        } finally {
	        try {
		        is.close();
	        } catch (IOException e) {
		        ;
	        }
        }
		return properties;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\qj\util\ReflectUtil.java---
package qj.util;
import qj.util.funct.F1;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.concurrent.atomic.AtomicReference;
/**
 * Created by Quan on 22/12/2014.
 */
public class ReflectUtil {
	public static <A> A newInstance(Class<A> cla) {
        return (A) newInstance4(cla);
	}
    public static Object newInstance4(Class clazz) {
		try {
			return clazz.newInstance();
		} catch (InstantiationException e) {
            Throwable cause = e.getCause();
            if (cause==null) {
            	cause = e;
            }
			throw new RuntimeException(cause);
		} catch (IllegalAccessException e) {
			throw new RuntimeException(e);
		}
    }
    public static Method getMethod(String methodName, Class clazz) {
		for (Method method : clazz.getMethods()) {
			if (method.getName().equals(methodName)) {
				return method;
			}
		}
		if (!clazz.equals(Object.class)) {
			Class superclass = clazz.getSuperclass();
			if (superclass != null) {
				return getMethod(methodName, superclass);
			} else {
				return null;
			}
		} else {
			return null;
		}
	}
    public static Method getMethod(String methodName, Class[] paramClasses, Class<?> clazz) {
        try {
            return clazz.getMethod(methodName, paramClasses);
        } catch (NoSuchMethodException e) {
            if (!clazz.equals(Object.class)) {
				Class<?> superclass = clazz.getSuperclass();
				if (superclass != null) {
					return getMethod(methodName, paramClasses, superclass);
				}
				return null;
			} else {
				return null;
			}
        }
    }
	/**
	 * Invoke the method with given params
	 * @param method
	 * @param o
	 * @param params
	 * @return
	 */
    public static <T> T invoke(Method method, Object o, Object... params) {
        try {
            return (T) method.invoke(o, params);
        } catch (IllegalAccessException e) {
            throw new RuntimeException(e);
        } catch (InvocationTargetException e) {
            throw new RuntimeException(e.getCause());
        }
    }
    public static void setFieldValue(Object value, Field field, Object obj) {
        try {
            field.set(obj, value);
        } catch (IllegalAccessException e) {
            throw new RuntimeException(e);
        }
    }
	public static <A> A getFieldValue(String field, Object obj) {
		return getFieldValue(getField(field, obj.getClass()), obj);
	}
    public static <A> A getFieldValue(Field field, Object obj) {
        try {
            return (A) field.get(obj);
        } catch (IllegalAccessException e) {
            throw new RuntimeException(e);
        }
    }
    public static Field getField(String name, Class<?> clazz) {
        try {
            return clazz.getDeclaredField(name);
        } catch (NoSuchFieldException e) {
            Class<?> superClass = clazz.getSuperclass();
            if (Object.class.equals(superClass)) {
                return null;
            } else {
                return getField(name, superClass);
            }
        }
    }
	public static Method findMethod(Class clazz, F1<Method,Boolean> f1) {
		AtomicReference<Method> m = new AtomicReference<>();
		eachMethod(clazz, (Method obj) -> {
			if (f1.e(obj)) {
				m.set(obj);
				return true;
			}
			return false;
		});
		return m.get();
	}
	public static void eachMethod(Class clazz, F1<Method,Boolean> f1) {
		for (Method method : clazz.getMethods()) {
			if (f1.e(method)) {
				return;
			}
		}
		if (!clazz.equals(Object.class)) {
			Class superclass = clazz.getSuperclass();
			if (superclass != null) {
				eachMethod(superclass, f1);
			}
		}
	}
	/**
	 * Invoke the method with given params
	 */
	public static Object invoke(String methodName, Object o, Object... params) {
		return invoke(getMethod(methodName, o.getClass()), o, params);
	}
    public static void setFieldValue(Object value, String field, Object obj) {
        try {
            setFieldValue(value, obj.getClass().getDeclaredField(field), obj);
        } catch (NoSuchFieldException e) {
            throw new RuntimeException(e);
        }
    }
	public static void invokeStatic(String methodName, Class<?> clazz) {
		invoke(getMethod(methodName, clazz), null, null);
	}
    public static <A> A getStaticFieldValue(String field, Class clazz) {
        try {
            return (A) getFieldValue(clazz.getDeclaredField(field), null);
        } catch (NoSuchFieldException e) {
            throw new RuntimeException(e);
        }
    }
}
----strat of file D:\projects\cg\cg-min\src\main\java\qj\util\RegexUtil.java---
package qj.util;
import qj.util.funct.F1;
import java.util.ArrayList;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
public class RegexUtil {
    public static F1<Object,Pattern> compileF = new F1<Object, Pattern>() {
        public Pattern e(Object obj) {
            return Pattern.compile(obj.toString());
        }
    };
	public static boolean matches(String key, String ptn) {
		return compileF.e(ptn).matcher(key).matches();		
	}
	public static Matcher matcher(String regex, String str) {
		return compileF.e(regex).matcher(str);
	}
	public static String replaceAll(String text,String ptn, F1<Matcher, String> f1) {
		return StringChange.apply(replaceAll(f1, compileF.e(ptn), text), text);
	}
	public static List<StringChange> replaceAll(
			F1<Matcher, String> f1, 
			Pattern ptn,
			String text) {
		return replaceAll(f1, ptn, text, 0, -1);
	}
	public static List<StringChange> replaceAll(
			F1<Matcher, String> f1, 
			Pattern ptn,
			String text,
			int from,
			int to) {
		Matcher matcher = ptn.matcher(text);
		ArrayList<StringChange> changes = new ArrayList<>();
		if (matcher.find(from)) {
			do {
				changes.add(StringChange.replace(matcher.start(), matcher.end(), f1.e(matcher)));
			} while (matcher.find() && (to==-1 || matcher.start() < to));
		}
		return changes;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\qj\util\StringChange.java---
package qj.util;
import qj.util.math.Range;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.LinkedList;
public abstract class StringChange implements Comparable<StringChange> {
	int priority = 0;
	public static StringChange replace(int start, int end, String replace) {
		return new ReplaceStringChange(start, end, replace);
	}
	public static StringChange replace(Range range, String replace) {
		return new ReplaceStringChange(range.getFrom(), range.getTo(), replace);
	}
	public abstract int pos();
	public abstract void apply(StringBuilder sb);
	public int compareTo(StringChange o) {
		int ret = pos() - o.pos();
		if (ret==0
		) {
			if (this instanceof ReplaceStringChange) {
				return 1;
			} else {
				return -this.priority + o.priority;
			}
		}
		return ret;
	}
	public static class ReplaceStringChange extends StringChange {
		private final int start;
		private final int end;
		private final String replace;
		public ReplaceStringChange(int start, int end, String replace) {
			this.start = start;
			this.end = end;
			this.replace = replace;
		}
		public int pos() {
			return start;
		}
		public void apply(StringBuilder sb) {
			sb.replace(start, end, replace);
		}
	}
	public static class InsertStringChange extends StringChange {
		private final int pos;
		private final String value;
		public InsertStringChange(int pos, String value) {
			this.pos = pos;
			this.value = value;
		}
		public InsertStringChange(int pos, String value, int priority) {
			this.pos = pos;
			this.value = value;
			this.priority = priority;
		}
		public int pos() {
			return pos;
		}
		public void apply(StringBuilder sb) {
			sb.insert(pos, value);
		}
	}
	/**
	 * @param replaces
	 * @param text No need to sort first
	 * @return
	 */
	public static String apply(Collection<StringChange> replaces, String text) {
		ArrayList<StringChange> list = new ArrayList<StringChange>(replaces);
		Collections.sort(list);
		StringBuilder sb = new StringBuilder(text);
		for (int i = list.size() - 1; i > -1; i--) {
			StringChange change = list.get(i);
			change.apply(sb);
		}
		return sb.toString();
	}
	public static StringChange insert(String string, int pos, int priority) {
		return new InsertStringChange(pos, string, priority);
	}
	public static StringChange insert(String string, int pos) {
		return new InsertStringChange(pos, string);
	}
	public static StringChange delete(final Range selection) {
		return new StringChange() {
			public int pos() {
				return selection.getFrom();
			}
			@Override
			public void apply(StringBuilder sb) {
				sb.replace(selection.getFrom(), selection.getTo(), "");
			}
		};
	}
	public static LinkedList<StringChange> replaceAll(String replaceFrom, String replaceTo,
			String to) {
		LinkedList<StringChange> ret = new LinkedList<StringChange>();
		for (int indexOf=0; (indexOf = to.indexOf(replaceFrom, indexOf)) > -1;) {
			ret.add(replace(indexOf, indexOf + replaceFrom.length(), replaceTo));
			indexOf+=replaceFrom.length();
		}
		return ret;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\qj\util\StringUtil.java---
package qj.util;
import qj.util.math.Range;
/**
 * Created by Quan on 22/12/2014.
 */
public class StringUtil {
	/**
	 * Trim the source and uppercase it's first character
	 *
	 * @param source -
	 *            The string to be malnipulated
	 * @return The result String, null if the source String is null
	 */
	public static String upperCaseFirstChar(String source) {
		if (source == null)
			return null;
		source = source.trim();
		if (source.length() == 0)
			return "";
		else
			return Character.toUpperCase(source.charAt(0)) + source.substring(1, source.length());
	}
	/**
	 *
	 * @return count
	 */
	public static int countHappens(char chr, CharSequence string) {
		if (string==null) {
			return 0;
		}
		int length = string.length();
		int count = 0;
		for (int i = 0; i < length; i++) {
			if (string.charAt(i) == chr)
				count++;
		}
		return count;
	}
	public static boolean isEmpty(String str) {
		return str == null || str.length() == 0;
	}
	public static String replace(String replace, Range range, String text) {
		return text.substring(0, range.getFrom()) + replace + text.substring(range.getTo());
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\qj\util\SystemUtil.java---
package qj.util;
import qj.util.funct.P0;
import qj.util.funct.P1;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
public class SystemUtil {
	static BufferedReader br;
	public static String readLine() {
		if (br==null) {
			br = new BufferedReader(new InputStreamReader(System.in));
		}
		try {
			return br.readLine();
		} catch (IOException e) {
			throw new RuntimeException(e);
		}
	}
	public static void onReturn(final P1<String> p1) {
		ThreadUtil.runStrong(new P0() {
			public void e() {
				while (true) {
					try {
						String readLine = readLine();
						p1.e(readLine);
					} catch (Exception e1) {
						return;
					}
				}
			}
		});
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\qj\util\ThreadUtil.java---
package qj.util;
import qj.util.funct.F0;
import qj.util.funct.Fs;
import qj.util.funct.P0;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
public class ThreadUtil {
	private static final ExecutorService executorService = Executors.newCachedThreadPool();
	public static void runStrong(final P0 p0) {
		executorService.execute(Fs.runnable(p0));
	}
	public static <A> ThreadLocalCache<A> threadLocalCache(final F0<A> f) {
		final ThreadLocal<A> threadLocal = new ThreadLocal<A>();
		ThreadLocalCache<A> ret = new ThreadLocalCache<A>();
		ret.cacheF = new F0<A>() {public A e() {
			A a = threadLocal.get();
			if (a==null) {
				a = f.e();
				threadLocal.set(a);
			}
			return a;
		}};
		ret.removeF = new F0<A>() {public A e() {
			A a = threadLocal.get();
			threadLocal.set(null);
			return a;
		}};
		return ret;
	}
	public static class ThreadLocalCache <A> {
		public F0<A> cacheF;
		public F0<A> removeF;
	}
	/**
	 * Sleep and wake on InterruptedException
	 * @param timeToSleep in milliseconds
	 */
	public static void sleep(long timeToSleep) {
		if (timeToSleep <=0)
			return;
		try {
			Thread.sleep(timeToSleep);
		} catch (InterruptedException e) {
		}
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\ui\ActivatedHyperlinkListener.java---
package ui;
import codegen.eclipseRobot.DataModel;
import javax.swing.*;
import javax.swing.event.HyperlinkEvent;
import javax.swing.event.HyperlinkListener;
import java.net.URL;
public class ActivatedHyperlinkListener implements HyperlinkListener {
	HtmlEditorPane editorPane;
	DataModel model;
	public ActivatedHyperlinkListener(DataModel model, HtmlEditorPane editorPane) {
		this.model = model;
		this.editorPane = editorPane;
	}
	public void hyperlinkUpdate(HyperlinkEvent hyperlinkEvent) {
		HyperlinkEvent.EventType type = hyperlinkEvent.getEventType();
		final URL url = hyperlinkEvent.getURL();
		if (type == HyperlinkEvent.EventType.ENTERED) {
			System.out.println("URL: " + url);
		} else if (type == HyperlinkEvent.EventType.ACTIVATED) {
			System.out.println("Activated");
			if (url.toString().endsWith("action=clear")) {
				Runnable runner = new Runnable() {
					public void run() {
						editorPane.loadWithSetPage();
					}
				};
				SwingUtilities.invokeLater(runner);
			}
			if (url.toString().endsWith("action=reload")) {
				model.setEventObject(hyperlinkEvent);
			}
		}
	}
	public DataModel getModel() {
		return model;
	}
	public void setModel(DataModel model) {
		this.model = model;
	}
	public HtmlEditorPane getEditorPane() {
		return editorPane;
	}
	public void setEditorPane(HtmlEditorPane editorPane) {
		this.editorPane = editorPane;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\ui\ArraySupportClassCombBoxpane.java---
package ui;
import javax.swing.*;
import java.awt.*;
import java.util.List;
public class ArraySupportClassCombBoxpane extends ParamPane {
	ClassCombBox classCombBox;
	public ArraySupportClassCombBoxpane(List<String> strList) {
		super();
		this.classCombBox = new ClassCombBox((List)strList);
		FlowLayout fl = new FlowLayout(FlowLayout.LEFT);
		this.setLayout(fl);
		this.add(paramLabel);
		this.add(tipLabel);
		this.add(classCombBox);
	}
	@Override
	public JComponent getInputComponent() {
		return classCombBox;
	}
	public ClassCombBox getClassCombBox() {
		return classCombBox;
	}
	public void cleanModelData() {
		classCombBox.cleanModelData();
		super.cleanModelData();
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\ui\ArraySupportReturnTypeCombBoxPane.java---
package ui;
import javax.swing.*;
import java.awt.*;
public class ArraySupportReturnTypeCombBoxPane extends ParamPane {
	ReturnTypeCombBox classCombBox;
	public ArraySupportReturnTypeCombBoxPane() {
		super();
		this.classCombBox = new ReturnTypeCombBox();
		FlowLayout fl = new FlowLayout(FlowLayout.LEFT);
		this.setLayout(fl);
		this.add(paramLabel);
		this.add(tipLabel);
		this.add(classCombBox);
	}
	@Override
	public JComponent getInputComponent() {
		return classCombBox;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\ui\CheckBoxPane.java---
package ui;
import javax.swing.*;
public class CheckBoxPane extends ParamPane {
	public JCheckBox checkBox;
	public CheckBoxPane() {
		checkBox = new JCheckBox();
		this.addComponent(paramLabel);
		this.addComponent(tipLabel);
		this.addComponent(checkBox);
	}
	public JCheckBox getCheckBox() {
		return checkBox;
	}
	public void setCheckBox(JCheckBox checkBox) {
		this.checkBox = checkBox;
	}
	@Override
	public JComponent getInputComponent() {
		return checkBox;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\ui\ClassCombBox.java---
package ui;
import codegen.eclipseRobot.FilterCombBox;
import java.util.List;
public class ClassCombBox extends FilterCombBox {
	public ClassCombBox(List<Object> classNameList) {
		super(classNameList);
	}
	public void cleanModelData() {
		super.cleanModelData();
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\ui\ClassCombBoxpane.java---
package ui;
import javax.swing.*;
import java.util.List;
public class ClassCombBoxpane extends ParamPane {
	ClassCombBox classCombBox;
	public ClassCombBoxpane(List<Object> strList) {
		super();
		this.classCombBox = new ClassCombBox(strList);
		this.addComponent(paramLabel);
		this.addComponent(tipLabel);
		this.addComponent(classCombBox);
	}
	@Override
	public JComponent getInputComponent() {
		return classCombBox;
	}
	public static void main(String args[]) {
		Class<JComponent>[] cs = new Class[] { ClassCombBox.class };
		Class c = cs.getClass();
		boolean b = c.isArray();
		System.out.println(String.format("c", c.getCanonicalName()));
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\ui\CollectionOfStringPane.java---
package ui;
import javax.swing.*;
import java.util.List;
public class CollectionOfStringPane  extends ParamPane{
	private static final long serialVersionUID = -5719340230240065218L;
	private JList<String> jList;
	private DefaultListModel<String> listModel;
	public CollectionOfStringPane(List<String> list) {
		listModel = new DefaultListModel<>();
		jList = new JList<>(listModel);
	}
	@Override
	public JComponent getInputComponent() {
		return jList;
	}
	public void addItem(int index, String item) {
		listModel.add(index, item);
	}
	public void addItem(String item) {
		listModel.addElement(item);
	}
	public void removeItem(String item) {
		listModel.removeElement(item);
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\ui\ColNamePickerPane.java---
package ui;
import codegen.eclipseRobot.FilterCombBox;
import java.util.Map;
public class ColNamePickerPane extends MapTextFieldPane {
	private static final long serialVersionUID = -7511088985813056672L;
	FilterCombBox tableNameCombBox;
	public ColNamePickerPane(Map<String, String> map) {
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\ui\CombBoxPane.java---
package ui;
import javax.swing.*;
public class CombBoxPane extends ParamPane {
	public JComboBox combBox;
	public CombBoxPane() {
		init();
	}
	public void init() {
		combBox = new JComboBox();
		this.addComponent(paramLabel);
		this.addComponent(tipLabel);
		this.addComponent(combBox);
	}
	public JComboBox getCombBox() {
		return combBox;
	}
	public void setCombBox(JComboBox combBox) {
		this.combBox = combBox;
	}
	@Override
	public JComponent getInputComponent() {
		return combBox;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\ui\CustomComboBoxEditor.java---
package ui;
import ui.model.CustomCombboxItem;
import javax.swing.plaf.basic.BasicComboBoxEditor;
import java.util.Objects;
public class CustomComboBoxEditor extends BasicComboBoxEditor {
	@Override
	public void setItem(Object anObject) {
		super.setItem(anObject);
		if (anObject instanceof CustomCombboxItem) {
			CustomCombboxItem item = (CustomCombboxItem) anObject;
			editor.setText(item.getItemText());
		} else if(!Objects.isNull(anObject)){
		    editor.setText(anObject.toString());
		}
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\ui\DefaultParamConverter.java---
package ui;
import codegen.complexobj.CodeGenContext;
import codegen.eclipseRobot.Converter;
import codegen.eclipseRobot.DataModel;
import codegen.eclipseRobot.FilterCombBox;
import ui.validation.ValidatablePane;
import ui.validation.ViolationResultItem;
import javax.swing.*;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.List;
public class DefaultParamConverter {
	public void convert(DataModel model, ParamPane[] pps, JComponent paramComps[]) {
		Method m = model.getSelectedMethod();
		System.out.println("gonna exec method " + m.getName());
		List<Object> list = new ArrayList<>();
		Class mp[] = m.getParameterTypes();
		boolean isValidInput = true;
		for (int i = 0; i < pps.length; i++) {
			ParamPane pp = pps[i];
			if (pp instanceof ValidatablePane) {
				ValidatablePane ppv = (ValidatablePane) pp;
				ViolationResultItem ri = ppv.validateVal();
				if (ri != null) {
					ppv.markInvaidInput();
					isValidInput = ri.isPass();
					break;
				}
			}
		}
		if (isValidInput) {
			for (int i = 0; i < paramComps.length; i++) {
				if (mp[i] != CodeGenContext.class) {
					if (paramComps[i] instanceof JCheckBox) {
						JCheckBox tf = (JCheckBox) paramComps[i];
						list.add(tf.isSelected());
					} else {
						if (paramComps[i] instanceof JTextField) {
							JTextField tf = (JTextField) paramComps[i];
							try {
								list.add(Converter.convert(tf.getText().trim(), mp[i]));
							} catch (Exception e1) {
								e1.printStackTrace();
							}
						} else if (paramComps[i] instanceof JTextArea) {
							JTextArea ta = (JTextArea) paramComps[i];
							try {
								list.add(Converter.convert(ta.getText().trim(), mp[i], "\n"));
							} catch (Exception e1) {
								e1.printStackTrace();
							}
						} else if (paramComps[i] instanceof ModifierPanel) {
							ModifierPanel modifierPanel = (ModifierPanel) paramComps[i];
							try {
								list.add(Converter.convert(modifierPanel.getVal(), mp[i], "\n"));
							} catch (Exception e1) {
								e1.printStackTrace();
							}
						} else if (paramComps[i] instanceof FilterCombBox) {
							FilterCombBox fc = (FilterCombBox) paramComps[i];
							try {
								list.add(Converter.convert(fc.getSelectedItem().toString(), mp[i]));
							} catch (Exception e1) {
								e1.printStackTrace();
							}
						}
					}
				} else {
					JTextField tf = (JTextField) paramComps[i];
					CodeGenContext context = null;
					try {
						context = (CodeGenContext) Converter.convert(tf.getText().trim(), mp[i]);
					} catch (Exception e1) {
						e1.printStackTrace();
					}
					if (context == null)
						list.add(model.getContext());
					else
						list.add(context);
				}
			}
			model.setParams(list.toArray(new Object[] {}));
		}
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\ui\FilePane.java---
package ui;
import javax.swing.*;
import java.io.File;
public class FilePane extends ParamPane {
	private JTextField textField;
	private JButton jButton = new JButton("browse");
	boolean chooseDirOnly = false;
	public FilePane() {
		init(-1, false);
	}
	public FilePane(int fieldSize) {
		init(fieldSize, false);
	}
	public FilePane(int fieldSize, boolean chooseDirOnly) {
		init(fieldSize, chooseDirOnly);
	}
	public void init(int fieldSize, boolean chooseDirOnly) {
		if (fieldSize == -1) {
			textField = new JTextField();
		} else {
			textField = new JTextField(fieldSize);
		}
		this.chooseDirOnly = chooseDirOnly;
		this.addComponent(paramLabel);
		this.addComponent(tipLabel);
		this.addComponent(textField);
		this.jButton.addActionListener(l -> {
			JFileChooser jFileChooser = new JFileChooser("./");
			if (chooseDirOnly) {
				jFileChooser.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);
			}
			this.addComponent(jFileChooser);
			int val = jFileChooser.showOpenDialog(jFileChooser);
			if (val == JFileChooser.APPROVE_OPTION) {
				File file = jFileChooser.getSelectedFile();
				String s = file.getAbsolutePath();
				textField.setText(s);
			}
			if (val == JFileChooser.CANCEL_OPTION) {
			}
		});
		this.addComponent(jButton);
	}
	@Override
	public JComponent getInputComponent() {
		return this.textField;
	}
	public JTextField getTextField() {
		return textField;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\ui\FilterCombBoxPane.java---
package ui;
import codegen.eclipseRobot.FilterCombBox;
import javax.swing.*;
import java.util.ArrayList;
import java.util.List;
public class FilterCombBoxPane extends ParamPane {
	FilterCombBox filterCombBox;
	public FilterCombBoxPane() {
		super();
		List<String> list = new ArrayList<>();
		this.filterCombBox = new FilterCombBox((List)list);
		this.addComponent(paramLabel);
		this.addComponent(tipLabel);
		this.addComponent(filterCombBox);
	}
	public FilterCombBoxPane(List<String> strList) {
		super();
		this.filterCombBox = new FilterCombBox((List)strList);
		this.addComponent(paramLabel);
		this.addComponent(tipLabel);
		this.addComponent(filterCombBox);
	}
	@Override
	public JComponent getInputComponent() {
		return filterCombBox;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\ui\GenAnnotationPane.java---
package ui;
import codegen.complexobj.CodeGenContext;
import javax.swing.*;
import java.util.List;
public class GenAnnotationPane extends TablePane {
	private ClassCombBox classCombBox;
	private TablePane tablePane;
	private JButton jButton;
	public GenAnnotationPane() {
		initView(CodeGenContext.getInstance().getLoadedClassesName());
		this.showData();
	}
	void initView(List<String> list) {
		classCombBox = new ClassCombBox((List)list);
		jButton = new JButton("gen annotation");
		tablePane = new TablePane();
		this.addComponent(new JLabel("Annotation"), classCombBox);
		this.newRow();
		this.addComponent(tablePane);
		this.newRow();
		this.addComponent(jButton);
		this.showData();
	}
	public GenAnnotationPane(int defaultHAlign, int defaultVAlign) {
		super(defaultHAlign, defaultVAlign);
	}
	public ClassCombBox getClassCombBox() {
		return classCombBox;
	}
	public JButton getjButton() {
		return jButton;
	}
	public TablePane getTablePane() {
		return tablePane;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\ui\GenCodePane.java---
package ui;
import codegen.complexobj.CodeGenContext;
import codegen.eclipseRobot.FilterCombBox;
import javax.swing.*;
import java.util.ArrayList;
import java.util.List;
public class GenCodePane extends TablePane{
	private ClassCombBox classCombBox;
	private FilterCombBox methodCombBox;
	private JButton gen;
	private JTextArea codeLine;
	private JCheckBox initClzByConstructor;
	private JCheckBox omitReturn;
	private JCheckBox arroundTryCatch;
	private JButton dump;
	public GenCodePane() {
		initView(CodeGenContext.getInstance().getLoadedClassesName());
		this.showData();
	}
	void initView(List<String> list) {
		classCombBox = new ClassCombBox((List)list);
		methodCombBox = new FilterCombBox(new ArrayList<>());
		gen = new JButton("gen code");
		codeLine = new JTextArea(10, 35);
		initClzByConstructor = new JCheckBox();
		omitReturn = new JCheckBox();
		arroundTryCatch = new JCheckBox();
		dump = new JButton("dump to IDE");
		JScrollPane jScrollPane = new JScrollPane(codeLine, ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS,
				ScrollPaneConstants.HORIZONTAL_SCROLLBAR_AS_NEEDED);
		this.addComponent(new JLabel("Class"), classCombBox);
		this.newRow();
		this.addComponent(new JLabel("Method"), methodCombBox);
		this.newRow();
		this.newRow();
		this.addComponent(new JLabel("omit return"), omitReturn);
		this.newRow();
		this.newRow();
		this.addComponent(gen);
		this.newRow();
		this.addComponent(jScrollPane);
		this.newRow();
		this.addComponent(dump);
	}
	public ClassCombBox getClassCombBox() {
		return classCombBox;
	}
	public JCheckBox getInitClzByConstructor() {
		return initClzByConstructor;
	}
	public JCheckBox getOmitReturn() {
		return omitReturn;
	}
	public JCheckBox getArroundTryCatch() {
		return arroundTryCatch;
	}
	public FilterCombBox getMethodCombBox() {
		return methodCombBox;
	}
	public JButton getGen() {
		return gen;
	}
	public JTextArea getCodeLine() {
		return codeLine;
	}
	public JButton getDump() {
		return dump;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\ui\HtmlEditorPane.java---
package ui;
import codegen.eclipseRobot.DataModel;
import javax.swing.*;
import javax.swing.event.HyperlinkListener;
import javax.swing.text.BadLocationException;
import javax.swing.text.ChangedCharSetException;
import javax.swing.text.Document;
import javax.swing.text.Element;
import javax.swing.text.html.HTMLDocument;
import javax.swing.text.html.HTMLEditorKit;
import java.io.*;
import java.nio.charset.Charset;
import java.util.Iterator;
import java.util.Set;
import java.util.SortedMap;
public class HtmlEditorPane extends JEditorPane {
	private HTMLEditorKit kit;
	private HyperlinkListener hyperlinkListener;
	public HtmlEditorPane(DataModel model) {
		kit = new HTMLEditorKit();
		this.setEditable(false);
		this.setEditorKit(kit);
		loadWithSetPage();
	}
	public void addRow(String s) {
		HTMLDocument doc = (HTMLDocument) this.getDocument();
		Element e = doc.getElement("trstart");
		try {
			doc.insertAfterEnd(e, String.format("<tr><td>%s</td></tr>", s));
		} catch (BadLocationException | IOException e1) {
			e1.printStackTrace();
		}
		return;
	}
	public static String readAsStr(File f) throws IOException {
		FileInputStream is = new FileInputStream(f);
		StringBuilder sb = new StringBuilder();
		BufferedReader in = null;
		try {
			in = new BufferedReader(new InputStreamReader(is));
			String line = null;
			while ((line = in.readLine()) != null) {
				sb.append(line).append("\r\n");
			}
		} catch (IOException e) {
			e.printStackTrace();
			throw e;
		} finally {
			if (in != null)
				try {
					in.close();
				} catch (IOException e) {
					e.printStackTrace();
				}
		}
		return sb.toString();
	}
	public static void write(File f, String fileStr) throws IOException {
		FileOutputStream fos = new FileOutputStream(f);
		fos.write(fileStr.getBytes());
		fos.flush();
		fos.close();
	}
	/**
	 * works okay with the meta tag in the html file only if the trailing/closing
	 * slash is absent ie, this '...>' instead of this '... />' // edit
	 */
	public void loadWithSetPage() {
		try {
			Document doc = this.getDocument();
			doc.putProperty(Document.StreamDescriptionProperty, null);
			this.setPage(getClass().getClassLoader().getResource("tableforpanel.html"));
		} catch (IOException ioe) {
			System.err.println("setPage read: " + ioe.getMessage());
		}
	}
	private void loadWithReader() {
		Object o = read(); // okay without meta statement
		if (o instanceof Charset) // we get here if file has a meta statement
		{
			String name = ((Charset) o).name();
			read((Charset) o); // cannot get this to work
		} else
			System.out.println("o = " + o.toString());
	}
	private Object read() {
		Reader fin = null;
		try {
			fin = // new BufferedReader(
					new InputStreamReader(new FileInputStream("eptest.html"));
		} catch (FileNotFoundException fnfe) {
			System.err.println("file not found: " + fnfe.getMessage());
			return Boolean.FALSE;
		}
		try {
			System.out.println(((InputStreamReader) fin).getEncoding());
			HTMLDocument doc = (HTMLDocument) this.getDocument();
			kit.read(fin, doc, 0);
			return Boolean.TRUE;
		} catch (ChangedCharSetException ccse) {
			String s = ccse.getCharSetSpec();
			System.out.println("changed charSet " + s);
			Charset cs = Charset.forName(s.substring(s.indexOf("charset=") + 8));
			System.out.println("cs = " + cs.toString());
			return cs;
		} catch (BadLocationException ble) {
			System.err.println("location: " + ble.getMessage());
			return Boolean.FALSE;
		} catch (IOException ioe) {
			System.err.println("read: " + ioe.getMessage());
			return Boolean.FALSE;
		}
		finally {
			try {
				fin.close();
			} catch (IOException ioe) {
				System.err.println("close: " + ioe.getMessage());
				return Boolean.FALSE;
			}
		}
	}
	/**
	 * all three InputStreamReader constructor forms fail if html file contains a
	 * meta statement for content/charset otherwise they seem to work okay
	 */
	private void read(Charset cs) {
		Reader fin = null;
		try {
			fin = new BufferedReader(new InputStreamReader(new FileInputStream("eptest.html"), cs));
		} catch (FileNotFoundException fnfe) {
			System.err.println("file not found: " + fnfe.getMessage());
		}
		try {
			HTMLDocument doc = (HTMLDocument) this.getDocument();
			kit.read(fin, doc, 0);
		} catch (BadLocationException ble) {
			System.err.println("location: " + ble.getMessage());
		} catch (IOException ioe) {
			System.err.println("read: " + ioe.getMessage());
		} finally {
			try {
				fin.close();
			} catch (IOException ioe) {
				System.err.println("close: " + ioe.getMessage());
			}
		}
	}
	private void showAvailableCharsets() {
		SortedMap<String, Charset> map = Charset.availableCharsets();
		Set<String> keys = map.keySet();
		Iterator it = keys.iterator();
		while (it.hasNext())
			System.out.println((Charset) map.get((String) it.next()));
	}
	public HTMLEditorKit getKit() {
		return kit;
	}
	public void setKit(HTMLEditorKit kit) {
		this.kit = kit;
	}
	public HyperlinkListener getHyperlinkListener() {
		return hyperlinkListener;
	}
	public void setHyperlinkListener(HyperlinkListener hyperlinkListener) {
		this.hyperlinkListener = hyperlinkListener;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\ui\HtmlEditorPane2.java---
package ui;
import codegen.eclipseRobot.DataModel;
import javax.swing.*;
import javax.swing.event.HyperlinkListener;
import javax.swing.text.BadLocationException;
import javax.swing.text.ChangedCharSetException;
import javax.swing.text.Document;
import javax.swing.text.Element;
import javax.swing.text.html.HTMLDocument;
import javax.swing.text.html.HTMLEditorKit;
import java.io.*;
import java.nio.charset.Charset;
import java.util.Iterator;
import java.util.Set;
import java.util.SortedMap;
public class HtmlEditorPane2 extends JEditorPane {
	private HTMLEditorKit kit;
	private HyperlinkListener hyperlinkListener;
	public HtmlEditorPane2(DataModel model) {
		kit = new HTMLEditorKit();
		this.setEditable(false);
		this.addHyperlinkListener(hyperlinkListener);
		this.setEditorKit(kit);
		loadWithSetPage();
	}
	public void addRow(String s) {
		HTMLDocument doc = (HTMLDocument) this.getDocument();
		Element e = doc.getElement("trstart");
		try {
			doc.insertAfterEnd(e, String.format("<tr><td>%s</td></tr>", s));
		} catch (BadLocationException | IOException e1) {
			e1.printStackTrace();
		}
		return;
	}
	public static String readAsStr(File f) throws IOException {
		FileInputStream is = new FileInputStream(f);
		StringBuilder sb = new StringBuilder();
		BufferedReader in = null;
		try {
			in = new BufferedReader(new InputStreamReader(is));
			String line = null;
			while ((line = in.readLine()) != null) {
				sb.append(line).append("\r\n");
			}
		} catch (IOException e) {
			e.printStackTrace();
			throw e;
		} finally {
			if (in != null)
				try {
					in.close();
				} catch (IOException e) {
					e.printStackTrace();
				}
		}
		return sb.toString();
	}
	public static void write(File f, String fileStr) throws IOException {
		FileOutputStream fos = new FileOutputStream(f);
		fos.write(fileStr.getBytes());
		fos.flush();
		fos.close();
	}
	/**
	 * works okay with the meta tag in the html file only if the trailing/closing
	 * slash is absent ie, this '...>' instead of this '... />' // edit
	 */
	public void loadWithSetPage() {
		try {
			Document doc = this.getDocument();
			doc.putProperty(Document.StreamDescriptionProperty, null);
			this.setPage(getClass().getClassLoader().getResource("tableforpanel.html"));
		} catch (IOException ioe) {
			System.err.println("setPage read: " + ioe.getMessage());
		}
	}
	private void loadWithReader() {
		Object o = read(); // okay without meta statement
		if (o instanceof Charset) // we get here if file has a meta statement
		{
			String name = ((Charset) o).name();
			read((Charset) o); // cannot get this to work
		} else
			System.out.println("o = " + o.toString());
	}
	private Object read() {
		Reader fin = null;
		try {
			fin = // new BufferedReader(
					new InputStreamReader(new FileInputStream("eptest.html"));
		} catch (FileNotFoundException fnfe) {
			System.err.println("file not found: " + fnfe.getMessage());
			return Boolean.FALSE;
		}
		try {
			System.out.println(((InputStreamReader) fin).getEncoding());
			HTMLDocument doc = (HTMLDocument) this.getDocument();
			kit.read(fin, doc, 0);
			return Boolean.TRUE;
		} catch (ChangedCharSetException ccse) {
			String s = ccse.getCharSetSpec();
			System.out.println("changed charSet " + s);
			Charset cs = Charset.forName(s.substring(s.indexOf("charset=") + 8));
			System.out.println("cs = " + cs.toString());
			return cs;
		} catch (BadLocationException ble) {
			System.err.println("location: " + ble.getMessage());
			return Boolean.FALSE;
		} catch (IOException ioe) {
			System.err.println("read: " + ioe.getMessage());
			return Boolean.FALSE;
		}
		finally {
			try {
				fin.close();
			} catch (IOException ioe) {
				System.err.println("close: " + ioe.getMessage());
				return Boolean.FALSE;
			}
		}
	}
	/**
	 * all three InputStreamReader constructor forms fail if html file contains a
	 * meta statement for content/charset otherwise they seem to work okay
	 */
	private void read(Charset cs) {
		Reader fin = null;
		try {
			fin = new BufferedReader(new InputStreamReader(new FileInputStream("eptest.html"), cs));
		} catch (FileNotFoundException fnfe) {
			System.err.println("file not found: " + fnfe.getMessage());
		}
		try {
			HTMLDocument doc = (HTMLDocument) this.getDocument();
			kit.read(fin, doc, 0);
		} catch (BadLocationException ble) {
			System.err.println("location: " + ble.getMessage());
		} catch (IOException ioe) {
			System.err.println("read: " + ioe.getMessage());
		} finally {
			try {
				fin.close();
			} catch (IOException ioe) {
				System.err.println("close: " + ioe.getMessage());
			}
		}
	}
	private void showAvailableCharsets() {
		SortedMap<String, Charset> map = Charset.availableCharsets();
		Set<String> keys = map.keySet();
		Iterator it = keys.iterator();
		while (it.hasNext())
			System.out.println((Charset) map.get((String) it.next()));
	}
	public HTMLEditorKit getKit() {
		return kit;
	}
	public void setKit(HTMLEditorKit kit) {
		this.kit = kit;
	}
	public HyperlinkListener getHyperlinkListener() {
		return hyperlinkListener;
	}
	public void setHyperlinkListener(HyperlinkListener hyperlinkListener) {
		this.hyperlinkListener = hyperlinkListener;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\ui\IParamPane.java---
package ui;
import javax.swing.*;
public interface IParamPane {
	public JComponent getInputComponent();
	public JLabel getParamLabel() ;
	public JLabel getTipLabel() ;
}
----strat of file D:\projects\cg\cg-min\src\main\java\ui\MapStringPane.java---
package ui;
import javax.swing.*;
import java.util.Map;
import java.util.Map.Entry;
public class MapStringPane extends ParamPane {
	private static final long serialVersionUID = 1577312452259818734L;
	private JList<String> jList;
	private DefaultListModel<String> listModel;
	public MapStringPane(Map<String, String> map) {
		listModel = new DefaultListModel<>();
		for(Entry<String, String> en : map.entrySet()){
			listModel.addElement(getKVPair(en.getKey(), en.getValue()));
		}
		jList = new JList<>(listModel);
	}
	private String getKVPair( String key, String value) {
		String kvPairStr =String.format("%s=%s",key,value);
		return kvPairStr;
	}
	@Override
	public JComponent getInputComponent() {
		return jList;
	}
	public void addItem(int index, String key, String value) {
		listModel.add(index, getKVPair(key, value));
	}
	public void addItem( String key, String value) {
		listModel.addElement(getKVPair(key, value));
	}
	public void removeItem( String key, String value) {
		listModel.removeElement(getKVPair(key, value));
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\ui\MapTextFieldPane.java---
package ui;
import javax.swing.*;
public class MapTextFieldPane extends ParamPane {
	private JTextField keyField;
	private JTextField valueField;
	private JButton addBtn;
	public MapTextFieldPane() {
	}
	@Override
	public JComponent getInputComponent() {
		return null;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\ui\MemoryPane.java---
package ui;
import codegen.Const;
import codegen.complexobj.CodeGenContext;
import codegen.eclipseRobot.DataModel;
import ui.model.CustomCombItemRenderer;
import ui.model.UIMemoryItemKey;
import javax.swing.*;
import java.util.ArrayList;
import java.util.List;
public class MemoryPane extends TablePane {
    private ClassCombBoxpane tableCombBoxPane;
	private ClassCombBoxpane keywordsCombBoxPane;
	private JButton dumpJButton;
	private JButton updateJButton;
	private JButton deleteJButton;
	private JTextField newKeyWords;
	private JTextArea contentArea;
	public MemoryPane() {
		super();
		DataModel model = (DataModel) CodeGenContext.getInstance().getUiModelMap().get(DataModel.class);
		initView(model);
	}
	@SuppressWarnings("unchecked")
	private void initView(DataModel model) {
	    List<String> tableNames = CodeGenContext.getMemoryAreas();
        tableCombBoxPane = new ClassCombBoxpane((List)tableNames);
        ClassCombBox tableCcb = (ClassCombBox) tableCombBoxPane.getInputComponent();
        tableCcb.setEditor(new CustomComboBoxEditor());
        tableCcb.addEditorListener();
        tableCombBoxPane.showData();
        this.addComponent(new JLabel("table"), tableCombBoxPane);
	    List<UIMemoryItemKey> keywordsList;
	    if(CodeGenContext.getInstance().getParamPossibleValsMap().containsKey(Const.MEMORY_KEYWORD_MAPPING_KEY)) {
	        keywordsList = (List<UIMemoryItemKey>) CodeGenContext.getInstance().getParamPossibleValsMap().get(Const.MEMORY_KEYWORD_MAPPING_KEY);
	    }else {
	        keywordsList = new ArrayList<>();
	    }
		keywordsCombBoxPane = new ClassCombBoxpane((List)keywordsList);
		ClassCombBox ccb = (ClassCombBox) keywordsCombBoxPane.getInputComponent();
		ccb.setRenderer(new CustomCombItemRenderer());
		ccb.setEditor(new CustomComboBoxEditor());
		ccb.addEditorListener();
		keywordsCombBoxPane.showData();
		contentArea = new JTextArea(10, 25);
		JScrollPane jScrollPane = new JScrollPane(contentArea, ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS,
				ScrollPaneConstants.HORIZONTAL_SCROLLBAR_ALWAYS);
		newKeyWords = new JTextField(25);
		dumpJButton = new JButton("dump");
		updateJButton = new JButton("update");
		deleteJButton = new JButton("delete");
		this.addInNextRow(new JLabel("keywords"), keywordsCombBoxPane);
		this.addInNextRow(new JLabel("content"),jScrollPane);
		this.addInNextRow(new JLabel("new keywords"),newKeyWords);
		this.addInNextRow(dumpJButton, updateJButton, deleteJButton);
		this.showData();
	}
	public static void main(String[] args) {
	}
	public ClassCombBoxpane getKeywordsCombBoxPane() {
		return keywordsCombBoxPane;
	}
	public JButton getDumpJButton() {
		return dumpJButton;
	}
	public void setDumpJButton(JButton dumpJButton) {
		this.dumpJButton = dumpJButton;
	}
	public JButton getUpdateJButton() {
		return updateJButton;
	}
	public void setUpdateJButton(JButton updateJButton) {
		this.updateJButton = updateJButton;
	}
	public JButton getDeleteJButton() {
		return deleteJButton;
	}
	public void setDeleteJButton(JButton deleteJButton) {
		this.deleteJButton = deleteJButton;
	}
	public JTextArea getContentArea() {
		return contentArea;
	}
	public JTextField getNewKeyWords() {
		return newKeyWords;
	}
	public void setNewKeyWords(JTextField newKeyWords) {
		this.newKeyWords = newKeyWords;
	}
	public void setContentArea(JTextArea contentArea) {
		this.contentArea = contentArea;
	}
    public ClassCombBoxpane getTableCombBoxPane() {
        return tableCombBoxPane;
    }
}
----strat of file D:\projects\cg\cg-min\src\main\java\ui\MethodTypePane.java---
package ui;
import clipboardclient.IClipboardObserver;
import codegen.complexobj.CodeGenContext;
import codegen.eclipseRobot.DataModel;
import codegen.eclipseRobot.EclipseService;
import codegen.eclipseRobot.FilterCombBox;
import codegen.eclipseRobot.QualifierName;
import codegen.util.Common;
import com.dgs.annotation.FileChooserAnnotation;
import com.dgs.annotation.ParamAnno;
import com.dgs.annotation.UIAnno;
import ui.model.TextAreaPaneModel;
import ui.validation.*;
import javax.swing.*;
import javax.swing.event.DocumentEvent;
import javax.swing.event.DocumentListener;
import javax.swing.text.DefaultCaret;
import java.awt.*;
import java.awt.event.*;
import java.io.File;
import java.lang.annotation.Annotation;
import java.lang.reflect.Constructor;
import java.lang.reflect.Method;
import java.lang.reflect.Parameter;
import java.util.Arrays;
import java.util.Date;
import java.util.List;
public class MethodTypePane extends TablePane implements IClipboardObserver, SubmitBtnPane{
	JComponent paramComps[];
	ParamPane pps[];
	DataModel model;
	JComponent componentWhichSwitchProcess;
	private JButton okBtn;
	public MethodTypePane() {
		DataModel model = (DataModel) CodeGenContext.getInstance().getUiModelMap().get(DataModel.class);
		initView(model);
	}
	public void removeAllFocusListener(Component c) {
		FocusListener ls[] = c.getFocusListeners();
		for (FocusListener l : ls) {
			c.removeFocusListener(l);
		}
	}
	@Override
	public void onUpdate(String content) {
		QualifierName qn = model.extractQualifierName(content);
		if (qn == null || qn.getClassQualifierName() == null) {
			return;
		}
		Method m = model.getSelectedMethod();
		if (m != null) {
			SwingUtilities.invokeLater(new Runnable() {
				@Override
				public void run() {
					Class mp[] = m.getParameterTypes();
					int paramCount = m.getParameterCount();
					Parameter[] ps = m.getParameters();
					boolean isClzSwitchProcess = false;
					for (int i = 0; i < paramCount; i++) {
						boolean switchProcess = false;
						switchProcess = componentWhichSwitchProcess == paramComps[i];
						if (switchProcess && (mp[i] == Class.class || mp[i] == CodeGenContext.class)
								&& paramComps[i] instanceof JTextField) {
							JTextField jf = ((JTextField) paramComps[i]);
							if (jf.getText().trim().equals("")) {
								jf.setText(qn.getClassQualifierName());
								isClzSwitchProcess = true;
								removeAllFocusListener(jf);
							}
						} else if (switchProcess && (mp[i] == Class.class) && paramComps[i] instanceof FilterCombBox) {
							FilterCombBox jf = ((FilterCombBox) paramComps[i]);
							String addedItem = qn.getClassQualifierName();
							if (!jf.getArray().contains(addedItem))
								jf.addCustomItem(addedItem);
							ParamPane panel = (ParamPane) paramComps[i].getParent();
							if (panel.getClass().isAssignableFrom(ArraySupportClassCombBoxpane.class)
									|| panel.getClass().isAssignableFrom(ArraySupportReturnTypeCombBoxPane.class)) {
								String addedItemArray = qn.getClassQualifierName() + "[]";
								if (!jf.getArray().contains(addedItemArray)) {
									jf.addCustomItem(addedItemArray);
								}
							}
							jf.setSelectedItem(addedItem);
							isClzSwitchProcess = true;
						} else if (("fieldName".equalsIgnoreCase(ps[i].getName())
								|| "field".equalsIgnoreCase(ps[i].getName())) && paramComps[i] instanceof JTextField) {
							JTextField jf = ((JTextField) paramComps[i]);
							if (jf.getText().trim().equals("")) {
								jf.setText(qn.getFieldName());
							}
							if (isClzSwitchProcess && "".equals(jf.getText()) && qn.getClz() != null) {
								jf.setText(Common.getInstanceName(qn.getClz()));
							}
						} else if ("objName".equalsIgnoreCase(ps[i].getName())
								|| "instanceName".equalsIgnoreCase(ps[i].getName())
										&& paramComps[i] instanceof JTextField) {
							if (qn.getMethodName() != null) {
								JTextField jf = ((JTextField) paramComps[i]);
								if (jf.getText().trim().equals("")) {
									Method m = QualifierName.getMethodByQualifierName(qn);
									if (Common.isStatic(m)) {
										jf.setText(m.getDeclaringClass().getSimpleName());
									} else {
										jf.setText(Common.getInstanceName(m.getDeclaringClass()));
									}
								}
							}
						} else if ("methodName".equalsIgnoreCase(ps[i].getName())
								&& paramComps[i] instanceof JTextField) {
							JTextField jf = ((JTextField) paramComps[i]);
							if (jf.getText().trim().equals("")) {
								jf.setText(qn.getMethodName());
							}
						} else if (switchProcess && "params".equalsIgnoreCase(ps[i].getName())
								&& paramComps[i] instanceof JTextField) {
							JTextField jf = ((JTextField) paramComps[i]);
							StringBuilder sb = new StringBuilder(jf.getText());
							if (jf.getText().trim().equals("")) {
								if (jf.getText().trim().equals("")) {
									Method m = QualifierName.getMethodByQualifierName(qn);
									if (m != null) {
										Parameter pts[] = m.getParameters();
										for (Parameter p : pts) {
											sb.append(p.getName()).append(", ");
										}
										if (sb.length() > 0) {
											sb.delete(sb.length() - 2, sb.length());
										}
									}
								}
							}
							if (null != qn.getClassQualifierName() && !"".equals(qn.getClassQualifierName())) {
								if (sb.length() > 0) {
									sb.append(", ");
								}
								sb.append(qn.getClassQualifierName()).append(", ");
							}
							if (sb.length() > 0) {
								sb.delete(sb.length() - 2, sb.length());
							}
							jf.setText(sb.toString());
						} else if (switchProcess && Common.isClassArray(mp[i]) && paramComps[i] instanceof JTextField) {
							if (qn.getClassQualifierName() != null) {
								JTextField jf = ((JTextField) paramComps[i]);
								String text = jf.getText();
								if (!"".equals(text.trim()) && !text.contains(qn.getClassQualifierName())) {
									text = text + ", " + qn.getClassQualifierName();
								} else if ("".equals(text.trim())) {
									text = qn.getClassQualifierName();
								}
								jf.setText(text);
								removeAllFocusListener(jf);
							}
						}
					}
				}
			});
		}
	}
	private void initView(DataModel model) {
		if (model.getMethods() == null || model.getMethods().length == 0) {
			return;
		}
		Method m = model.getSelectedMethod();
		if (m != null) {
			Class mp[] = m.getParameterTypes();
			int paramCount = m.getParameterCount();
			paramComps = new JComponent[paramCount];
			pps = new ParamPane[paramCount];
			{
				for (int i = 0; i < paramCount; i++) {
					Parameter[] ps = m.getParameters();
					ParamPane pp = getParamPaneByParamType(mp[i], m, ps[i], model);
					JComponent jc = pp.getInputComponent();
					if (mp[i] == Class.class || "qualifierNames".equals(ps[i].getName()) || Common.isClassArray(mp[i])) {
						if (jc instanceof JTextArea) {
							((JTextArea) jc).getDocument().addDocumentListener(new DocumentListener() {
								private void validate() {
									if (pp instanceof ValidatablePane) {
										ValidatablePane vpp = (ValidatablePane) pp;
										ViolationResultItem vr = vpp.validateVal();
										if (vr.isPass()) {
											vpp.removeMark();
										} else {
											vpp.markInvaidInput();
										}
									}
								}
								@Override
								public void insertUpdate(DocumentEvent e) {
									validate();
								}
								@Override
								public void removeUpdate(DocumentEvent e) {
									validate();
								}
								@Override
								public void changedUpdate(DocumentEvent e) {
									validate();
								}
							});
						}
						jc.addFocusListener(new FocusAdapter() {
							public void focusLost(FocusEvent e) {
								if (pp instanceof ValidatablePane) {
									ValidatablePane vpp = (ValidatablePane) pp;
									ViolationResultItem vr = vpp.validateVal();
									if (vr.isPass()) {
										vpp.removeMark();
									} else {
										vpp.markInvaidInput();
									}
								}
							}
						});
					} else {
						jc.addFocusListener(new FocusAdapter() {
							public void focusLost(FocusEvent e) {
								if (pp instanceof ValidatablePane) {
									ValidatablePane vpp = (ValidatablePane) pp;
									ViolationResultItem vr = vpp.validateVal();
									if (vr.isPass()) {
										vpp.removeMark();
									} else {
										vpp.markInvaidInput();
									}
								}
							}
						});
						jc.addKeyListener(new KeyAdapter() {
							public void keyReleased(KeyEvent e) {
								if (e.getKeyChar() == KeyEvent.VK_ENTER
										&& !jc.getClass().isAssignableFrom(JTextArea.class)) {
									System.out.println("JTextArea enter trigger method call at " + new Date());
								} else {
									if (pp instanceof ValidatablePane) {
										ValidatablePane vpp = (ValidatablePane) pp;
										ViolationResultItem vr = vpp.validateVal();
										if (vr.isPass()) {
											vpp.removeMark();
										} else {
											vpp.markInvaidInput();
										}
									}
								}
							}
						});
					}
					paramComps[i] = jc;
					pps[i] = pp;
					this.newRow();
					pps[i].showData();
					this.addComponent(pps[i]);
				}
			}
		}
		okBtn = new JButton("ok");
		this.addInNextRow(okBtn);
	}
	public ParamPane getParamPaneByParamType(Class c, Method m, Parameter param, DataModel model2) {
		String paramName = param.getName();
		ParamPane jc = null;
		boolean isMandatory = false;
		Class c1 = EclipseService.class;
		Validation v = null;
		Method m1;
		try {
			m1 = m;
			Annotation panns1[] = param.getAnnotations();
			for (Annotation an : panns1) {
				try {
					if (an instanceof ValidationAnn) {
						ValidationAnn va = (ValidationAnn) an;
						Class[] vs = Common.getClassByName(va.validations());
						if (vs != null) {
							for (Class<? extends Validation> vc : vs) {
								if (vc.isAssignableFrom(MandatoryCheck.class)) {
									isMandatory = true;
									v = new MandatoryCheck();
								} else if (vc.isAssignableFrom(ModifierCheck.class)) {
									isMandatory = true;
									v = new ModifierCheck();
								}
							}
						}
					} else if (an instanceof UIAnno) {
						UIAnno uiAnno = (UIAnno) an;
						Class[] uiClzz = Common.getClassByName(uiAnno.uiClz());
						if(uiClzz.length>0) {
							Class uiClz = uiClzz[0];
							if(ParamPane.class.isAssignableFrom(uiClz)) {
								Constructor[] cts = uiClz.getConstructors();
								Constructor defaultCt = null;
								for(Constructor ct : cts) {
									if(ct.getParameterCount()==0) {
										defaultCt = ct;
										break;
									}else if(ct.getParameters().length==1){
									    jc= new ClassCombBoxpane(Arrays.asList(model2.getParamPossibleVals()));
									}
								}
								if(null!=defaultCt) {
									jc = (ParamPane) defaultCt.newInstance();
								}
							}
						}
					}
				} catch (Exception e) {
				}
			}
		} catch (Exception e1) {
		}
		if (Boolean.class == c || boolean.class == c) {
			jc = new CheckBoxPane();
		} else {
			int size = 8;
			if (Common.isClassArray(c)) {
				size = size * 4;
				jc = new ArraySupportClassCombBoxpane(CodeGenContext.getInstance().getLoadedClassesName());
			} else if (c.isArray() && paramName.equals("qualifierNames")) {
				size = size * 3;
				TextAreaPaneModel model = new TextAreaPaneModel();
				model.setRows(codegen.eclipseRobot.DataModel.DEFAULT_TEXTAREA_ROWS);
				model.setColumns(codegen.eclipseRobot.DataModel.DEFAULT_TEXTAREA_COLS);
				model.setHowManyRowsInTextArea(0);
				TextAreaPane ja = isMandatory ? new ValidatableTextAreaPane(v, model) : new TextAreaPane(model);
				jc = ja;
				DefaultCaret dc = (DefaultCaret) ja.getTextArea().getCaret();
				dc.setUpdatePolicy(DefaultCaret.NEVER_UPDATE);
			} else if (paramName.equals("modifier") && c == int.class) {
				jc = isMandatory ? new ValidatableModifierPanel(v) : new ModifierPanel();
			} else if (paramName.equals("content") && c == String.class) {
				int areaSize = 100;
				TextAreaPaneModel model = new TextAreaPaneModel();
				model.setRows(codegen.eclipseRobot.DataModel.DEFAULT_TEXTAREA_ROWS);
				model.setColumns(areaSize);
				model.setHowManyRowsInTextArea(0);
				TextAreaPane ja = isMandatory ? new ValidatableTextAreaPane(v, model) : new TextAreaPane(model);
				jc = ja;
			} else if (paramName.equals("keyword") && c == String.class
					&& ("showCodeSyntaxMemory".equalsIgnoreCase(m.getName())
					|| "showMiscAreaMemory".equalsIgnoreCase(m.getName())
					|| "showCommandMemory".equalsIgnoreCase(m.getName())
					|| "showConfigMemory".equalsIgnoreCase(m.getName()))) {
				ClassCombBoxpane ccp = new ClassCombBoxpane((List<Object>) model2.getParamPossibleVals()[0]);
				jc = ccp;
			} else if (c == File.class) {
				boolean chooseDirOnly = false;
				FileChooserAnnotation fca = Common.getParameterAnnotationByType(FileChooserAnnotation.class, param);
				if (fca != null) {
					chooseDirOnly = fca.chooseDirOnly();
				}
				jc = isMandatory ? new ValidatableFilePane(v, size, chooseDirOnly) : new FilePane(size, chooseDirOnly);
			} else if (c == Class.class) {
				ParamAnno fca = Common.getParameterAnnotationByType(ParamAnno.class, param);
				if (fca != null) {
					jc = new ClassCombBoxpane((List)CodeGenContext.getInstance().getLoadedClassesName());
				} else if (paramName.equalsIgnoreCase("returntype")) {
					jc = isMandatory ? new ValidatableArraySupportReturnTypeCombBoxPane()
							: new ArraySupportReturnTypeCombBoxPane();
				} else {
					jc = isMandatory
							? new ValidatableArraySupportClassCombBoxpane(
									CodeGenContext.getInstance().getLoadedClassesName())
							: new ArraySupportClassCombBoxpane(CodeGenContext.getInstance().getLoadedClassesName());
				}
				if (jc instanceof IParamPane) {
					IParamPane ipp = jc;
					FilterCombBox fc = (FilterCombBox) ipp.getInputComponent();
				}
			} else if(null==jc){
				jc = isMandatory ? new ValidatableTextFieldPane(v, size) : new TextFieldPane(size);
			}
		}
		if (isMandatory && jc instanceof ValidatablePane) {
			ValidatablePane vp = (ValidatablePane) jc;
			vp.markInvaidInput();
		}
		ParamAnno annotation = param.getAnnotation(ParamAnno.class);
		String labelText = annotation != null && !Common.isBlank(annotation.description()) ? annotation.description()
				: paramName;
		jc.getParamLabel().setText(labelText);
		jc.getTipLabel().setText("");
		jc.getInputComponent().setName(paramName);
		return jc;
	}
	public JComponent[] getParamComps() {
		return paramComps;
	}
	public void setParamComps(JComponent[] paramComps) {
		this.paramComps = paramComps;
	}
	public ParamPane[] getPps() {
		return pps;
	}
	public void setPps(ParamPane[] pps) {
		this.pps = pps;
	}
	public JComponent getComponentWhichSwitchProcess() {
		return componentWhichSwitchProcess;
	}
	public void setComponentWhichSwitchProcess(JComponent componentWhichSwitchProcess) {
		this.componentWhichSwitchProcess = componentWhichSwitchProcess;
	}
	@Override
	public JButton getSubmitBtn() {
		return okBtn;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\ui\model\ComponentAndLayoutConstraints.java---
package ui.model;
import javax.swing.*;
import java.awt.*;
public class ComponentAndLayoutConstraints {
	private GridBagConstraints gbc;
	private JComponent[] components;
	public GridBagConstraints getGbc() {
		return gbc;
	}
	public void setGbc(GridBagConstraints gbc) {
		this.gbc = gbc;
	}
	public JComponent[] getComponents() {
		return components;
	}
	public void setComponents(JComponent... components) {
		this.components = components;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\ui\model\CustomCombboxItem.java---
package ui.model;
public interface CustomCombboxItem {
	public String getItemText();
	public String toString();
}
----strat of file D:\projects\cg\cg-min\src\main\java\ui\model\CustomCombItemRenderer.java---
package ui.model;
import javax.swing.*;
import javax.swing.plaf.basic.BasicComboBoxRenderer;
import java.awt.*;
public class CustomCombItemRenderer extends BasicComboBoxRenderer {
	public Component getListCellRendererComponent(
            JList list, Object value, int index,
            boolean isSelected, boolean cellHasFocus)
        {
            super.getListCellRendererComponent(list, value, index,
                isSelected, cellHasFocus);
            if (value != null)
            {
            	CustomCombboxItem item = (CustomCombboxItem)value;
                setText( item.getItemText() );
            }
			if (index == -1) {
				CustomCombboxItem item = (CustomCombboxItem)value;
                setText( item.getItemText() );
			}
            return this;
        }
}
----strat of file D:\projects\cg\cg-min\src\main\java\ui\model\TextAreaPaneModel.java---
package ui.model;
public class TextAreaPaneModel {
	int rows;
	int columns;
	private int howManyRowsInTextArea;
	public int getRows() {
		return rows;
	}
	public void setRows(int rows) {
		this.rows = rows;
	}
	public int getColumns() {
		return columns;
	}
	public void setColumns(int columns) {
		this.columns = columns;
	}
	public int getHowManyRowsInTextArea() {
		return howManyRowsInTextArea;
	}
	public void setHowManyRowsInTextArea(int howManyRowsInTextArea) {
		this.howManyRowsInTextArea = howManyRowsInTextArea;
	}
	public int increasehowManyRowsInTextArea() {
		howManyRowsInTextArea++;
		return howManyRowsInTextArea;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\ui\model\UIMemoryItemKey.java---
package ui.model;
import codegen.eclipseRobot.model.MemoryItemKey;
public class UIMemoryItemKey extends MemoryItemKey  implements CustomCombboxItem{
	public UIMemoryItemKey(MemoryItemKey parentObj) {
		super();
		setId(parentObj.getId());
		setKeywords(parentObj.getKeywords());
		setTable(parentObj.getTable());
	}
	@Override
	public String getItemText() {
		return getKeywords();
	}
	@Override
	public String toString() {
		return getKeywords();
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\ui\ModifierPanel.java---
package ui;
import javax.swing.*;
import java.awt.*;
public class ModifierPanel extends ParamPane {
	private JCheckBox staticBox;
	private JCheckBox abstractBox;
	private JCheckBox finalBox;
	private JCheckBox volatileBox;
	private JCheckBox syncBox;
	private JRadioButton privateButton;
	private JRadioButton protectedButton;
	private JRadioButton publicButton;
	private ButtonGroup bg;
	public ModifierPanel() {
		staticBox = new JCheckBox("static");
		abstractBox = new JCheckBox("abstract");
		finalBox = new JCheckBox("final");
		volatileBox = new JCheckBox("volatile");
		syncBox = new JCheckBox("synchronized");
		privateButton = new JRadioButton("private");
		publicButton = new JRadioButton("public");
		protectedButton = new JRadioButton("protected");
		bg = new ButtonGroup();
		bg.add(privateButton);
		bg.add(publicButton);
		bg.add(protectedButton);
		this.addComponent(paramLabel, tipLabel);
		this.newRow();
		JPanel jp = newJPanelWithLeftFlowLayout();
		this.addComponent( publicButton);
		JPanel jp2 = newJPanelWithLeftFlowLayout();
		this.addComponent( protectedButton);
		this.addComponent( privateButton);
		this.newRow();
		this.addComponent( staticBox);
		this.addComponent( abstractBox);
		this.addComponent( finalBox);
		this.addComponent(volatileBox);
		this.addComponent( syncBox);
		this.newRow();
		this.showData();
	}
	public JPanel newJPanelWithLeftFlowLayout() {
		JPanel jp = new JPanel();
		FlowLayout fl = new FlowLayout(FlowLayout.LEFT);
		jp.setLayout(fl);
		return jp;
	}
	public int getModifier() {
		int m = 0;
		if (publicButton.isSelected()) {
			m = m | java.lang.reflect.Modifier.PUBLIC;
		}
		if (protectedButton.isSelected()) {
			m = m | java.lang.reflect.Modifier.PROTECTED;
		}
		if (privateButton.isSelected()) {
			m = m | java.lang.reflect.Modifier.PRIVATE;
		}
		if (staticBox.isSelected()) {
			m = m | java.lang.reflect.Modifier.STATIC;
		}
		if (abstractBox.isSelected()) {
			m = m | java.lang.reflect.Modifier.ABSTRACT;
		}
		if (finalBox.isSelected()) {
			m = m | java.lang.reflect.Modifier.FINAL;
		}
		if (volatileBox.isSelected()) {
			m = m | java.lang.reflect.Modifier.VOLATILE;
		}
		if (syncBox.isSelected()) {
			m = m | java.lang.reflect.Modifier.SYNCHRONIZED;
		}
		return m;
	}
	public int getVal() {
		return getModifier();
	}
	@Override
	public JComponent getInputComponent() {
		return this;
	}
	public static void main(String[] args) {
		/*
		 * int i = 1; BitSet bitSet = new BitSet(6); bitSet.set(0); int m =
		 * getModifier(); System.out.println(m);
		 * System.out.println(Modifier.isPrivate(m));
		 * System.out.println(Modifier.isProtected(m));
		 * System.out.println(Modifier.isPublic(m));
		 * System.out.println(Modifier.isAbstract(m));
		 * System.out.println(Modifier.isFinal(m));
		 * System.out.println(Modifier.isStatic(m));
		 * System.out.println(Modifier.isSynchronized(m));
		 * System.out.println(Modifier.isVolatile(m));
		 */
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\ui\ParamPane.java---
package ui;
import javax.swing.*;
public abstract class ParamPane extends TablePane implements IParamPane{
	public JLabel paramLabel;
	public JLabel tipLabel;
	public ParamPane() {
		init();
	}
	public void init() {
		paramLabel = new JLabel();
		tipLabel = new JLabel();
	}
	public JLabel getParamLabel() {
		return paramLabel;
	}
	public void setParamLabel(JLabel paramLabel) {
		this.paramLabel = paramLabel;
	}
	public JLabel getTipLabel() {
		return tipLabel;
	}
	public void setTipLabel(JLabel tipLabel) {
		this.tipLabel = tipLabel;
	}
	public void cleanModelData() {
		this.removeAll();
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\ui\ReturnTypeCombBox.java---
package ui;
import codegen.eclipseRobot.FilterCombBox;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Set;
public class ReturnTypeCombBox extends FilterCombBox {
	private static List<String> list = new ArrayList<>();
	static {
		List<Class<?>> clist = codegen.eclipseRobot.Const.returnTypePrimitiveClz;
		list.add(" ");
		list.add(codegen.Const.SPECIFY_CLASS);
		for (Class c : clist) {
			list.add(c.getCanonicalName());
			if (void.class != c) {
				list.add(c.getCanonicalName() + "[]");
			}
		}
		list.add(Map.class.getCanonicalName());
		list.add(Map.class.getCanonicalName() + "[]");
		list.add(List.class.getCanonicalName());
		list.add(List.class.getCanonicalName() + "[]");
		list.add(Set.class.getCanonicalName());
		list.add(Set.class.getCanonicalName() + "[]");
	}
	public ReturnTypeCombBox() {
		super((List)list);
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\ui\ReturnTypeCombBoxPane.java---
package ui;
import javax.swing.*;
public class ReturnTypeCombBoxPane extends ParamPane {
	ReturnTypeCombBox classCombBox;
	public ReturnTypeCombBoxPane() {
		super();
		this.classCombBox = new ReturnTypeCombBox();
		this.addComponent(paramLabel);
		this.addComponent(tipLabel);
		this.addComponent(classCombBox);
	}
	@Override
	public JComponent getInputComponent() {
		return classCombBox;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\ui\StringTypesPane.java---
package ui;
public class StringTypesPane extends TablePane {
}
----strat of file D:\projects\cg\cg-min\src\main\java\ui\SubmitBtnPane.java---
package ui;
import javax.swing.*;
public interface SubmitBtnPane {
	public JButton getSubmitBtn();
}
----strat of file D:\projects\cg\cg-min\src\main\java\ui\TablePane.java---
package ui;
import ui.model.ComponentAndLayoutConstraints;
import javax.swing.*;
import javax.swing.border.Border;
import java.awt.*;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
public class TablePane extends JPanel {
	private List<ComponentAndLayoutConstraints> componentAndLayoutConstraintsList = new ArrayList<>();
	public static final int ALIGN_LEFT = 0;
	public static final int ALIGN_CENTER = 1;
	public static final int ALIGN_RIGHT = 2;
	public static int DEFAULT_HORIZONTAL_ALIGN = ALIGN_CENTER;
	public static final int ALIGN_TOP = 0;
	public static final int ALIGN_MIDDLE = 1;
	public static final int ALIGN_BUTTOM = 2;
	public static int DEFAULT_VERTICAL_ALIGN = ALIGN_MIDDLE;
	private int currentGridX = 0;
	private int currentGridY = 0;
	public TablePane() {
		super();
		GridBagLayout gridBagLayout = new GridBagLayout();
		this.setLayout(gridBagLayout);
	}
	public TablePane(int defaultHAlign, int defaultVAlign) {
		super();
		setDefaultAlign(defaultHAlign, defaultVAlign);
		GridBagLayout gridBagLayout = new GridBagLayout();
		this.setLayout(gridBagLayout);
	}
	/**
	 * it doesn't affect the align of added cells align
	 * @param defaultHAlign
	 * @param defaultVAlign
	 */
	public void setDefaultAlign(int defaultHAlign, int defaultVAlign) {
		switch(defaultHAlign){
			case ALIGN_LEFT:
				DEFAULT_HORIZONTAL_ALIGN = ALIGN_LEFT;
			break;
			case  ALIGN_CENTER:
				DEFAULT_HORIZONTAL_ALIGN = ALIGN_CENTER;
			break;
			case ALIGN_RIGHT:
				DEFAULT_HORIZONTAL_ALIGN = ALIGN_RIGHT;
			break;
			default :
			break;
		}
		switch(defaultVAlign){
			case ALIGN_TOP:
				DEFAULT_VERTICAL_ALIGN = ALIGN_TOP;
			break;
			case  ALIGN_MIDDLE:
				DEFAULT_VERTICAL_ALIGN = ALIGN_MIDDLE;
			break;
			case  ALIGN_BUTTOM:
				DEFAULT_VERTICAL_ALIGN = ALIGN_BUTTOM;
			break;
			default :
			break;
		}
	}
	private void setDefaultAlign() {
		setAlign(DEFAULT_HORIZONTAL_ALIGN, DEFAULT_VERTICAL_ALIGN);
	}
	/***
	 * set last added ComponentAndLayoutConstraints's GridBagConstraints anchor
	 * @param halign
	 * @param valign
	 */
	private void setAlign(int halign, int valign) {
		if(componentAndLayoutConstraintsList.isEmpty()) {
			return;
		}
		ComponentAndLayoutConstraints calc = componentAndLayoutConstraintsList.get(componentAndLayoutConstraintsList.size()-1);
		switch(DEFAULT_HORIZONTAL_ALIGN){
			case ALIGN_LEFT:
				switch(DEFAULT_VERTICAL_ALIGN){
					case ALIGN_TOP:
						calc.getGbc().anchor = GridBagConstraints.NORTHWEST;
					break;
					case  ALIGN_MIDDLE:
						calc.getGbc().anchor = GridBagConstraints.WEST;
					break;
					case  ALIGN_BUTTOM:
						calc.getGbc().anchor = GridBagConstraints.SOUTHWEST;
					break;
					default :
					break;
				}
			break;
			case  ALIGN_CENTER:
				switch(DEFAULT_VERTICAL_ALIGN){
					case ALIGN_TOP:
						calc.getGbc().anchor = GridBagConstraints.NORTH;
					break;
					case  ALIGN_MIDDLE:
						calc.getGbc().anchor = GridBagConstraints.CENTER;
					break;
					case  ALIGN_BUTTOM:
						calc.getGbc().anchor = GridBagConstraints.SOUTH;
					break;
					default :
					break;
				}
			break;
			case ALIGN_RIGHT:
				switch(DEFAULT_VERTICAL_ALIGN){
					case ALIGN_TOP:
						calc.getGbc().anchor = GridBagConstraints.NORTHEAST;
					break;
					case  ALIGN_MIDDLE:
						calc.getGbc().anchor = GridBagConstraints.EAST;
					break;
					case  ALIGN_BUTTOM:
						calc.getGbc().anchor = GridBagConstraints.SOUTHEAST;
					break;
					default :
					break;
				}
			break;
			default :
			break;
		}
	}
	public GridBagConstraints addComponent(JComponent... component) {
		GridBagConstraints gbc = new GridBagConstraints();
		gbc.gridy = currentGridY;
		gbc.gridx = currentGridX++;
		gbc.ipadx = 0;
		gbc.ipady = 0;
		ComponentAndLayoutConstraints calc = new ComponentAndLayoutConstraints();
		calc.setComponents(component);
		calc.setGbc(gbc);
		componentAndLayoutConstraintsList.add(calc);
		setDefaultAlign();
		return gbc;
	}
	public GridBagConstraints addInNextRow(JComponent... component) {
		newRow();
		return this.addComponent(component);
	}
	public void newRow() {
		if(currentGridX==0) {
			return;
		}
		currentGridX = 0;
		currentGridY++;
	}
	public void swithToRow(int gridY) {
		currentGridY = gridY;
	}
	public GridBagConstraints add(JComponent component, int gridX, int gridY) {
		GridBagConstraints gbc = new GridBagConstraints();
		gbc.gridy = gridY;
		gbc.gridx = gridX;
		gbc.ipadx = 0;
		gbc.ipady = 0;
		ComponentAndLayoutConstraints calc = new ComponentAndLayoutConstraints();
		calc.setComponents(component);
		calc.setGbc(gbc);
		componentAndLayoutConstraintsList.add(calc);
		setDefaultAlign();
		return gbc;
	}
	public GridBagConstraints add(JComponent component, int gridX, int gridY, int gridheight, int gridwidth) {
		GridBagConstraints gbc = new GridBagConstraints();
		gbc.gridy = gridY;
		gbc.gridx = gridX;
		gbc.gridheight = gridheight;
		gbc.gridwidth = gridwidth;
		if (gridwidth > 1 || gridheight > 1) {
			gbc.fill = GridBagConstraints.BOTH;
		}
		ComponentAndLayoutConstraints calc = new ComponentAndLayoutConstraints();
		calc.setComponents(component);
		calc.setGbc(gbc);
		componentAndLayoutConstraintsList.add(calc);
		setDefaultAlign();
		return gbc;
	}
	public GridBagConstraints add(JComponent component, int gridX, int gridY, int gridheight, int gridwidth, int weightX,
			int weightY) {
		GridBagConstraints gbc = new GridBagConstraints();
		gbc.gridy = gridY;
		gbc.gridx = gridX;
		gbc.weightx = weightX;
		gbc.weighty = weightY;
		gbc.gridheight = gridheight;
		gbc.gridwidth = gridwidth;
		if (gridwidth > 1 || gridheight > 1) {
			gbc.fill = GridBagConstraints.BOTH;
		}
		ComponentAndLayoutConstraints calc = new ComponentAndLayoutConstraints();
		calc.setComponents(component);
		calc.setGbc(gbc);
		componentAndLayoutConstraintsList.add(calc);
		setDefaultAlign();
		return gbc;
	}
	public GridBagConstraints add(JComponent component, int gridX, int gridY, int gridheight, int gridwidth, int weightX, int weightY,
			Border border) {
		GridBagConstraints gbc = new GridBagConstraints();
		gbc.gridy = gridY;
		gbc.gridx = gridX;
		gbc.weightx = weightX;
		gbc.weighty = weightY;
		gbc.gridheight = gridheight;
		gbc.gridwidth = gridwidth;
		if (gridwidth > 1 || gridheight > 1) {
			gbc.fill = GridBagConstraints.BOTH;
		}
		component.setBorder(border);
		ComponentAndLayoutConstraints calc = new ComponentAndLayoutConstraints();
		calc.setComponents(component);
		calc.setGbc(gbc);
		componentAndLayoutConstraintsList.add(calc);
		setDefaultAlign();
		return gbc;
	}
	public Optional<ComponentAndLayoutConstraints> get(int gridX, int gridY) {
		Optional<ComponentAndLayoutConstraints> calc = componentAndLayoutConstraintsList.stream().filter(e->(e.getGbc().gridx==gridX && e.getGbc().gridy==gridY )).findFirst();
		return calc;
	}
	public boolean removeIf(int gridX, int gridY) {
		return componentAndLayoutConstraintsList.removeIf(e->e.getGbc().gridx==gridX && e.getGbc().gridy==gridY);
	}
	public void alignCol(int gridX, int halign, int valign) {
		componentAndLayoutConstraintsList.stream().filter(e->(e.getGbc().gridx==gridX)).forEach(e->{
			setAlign(halign, valign);
		});
	}
	public void alignRow(int gridY, int halign, int valign) {
		componentAndLayoutConstraintsList.stream().filter(e->(e.getGbc().gridy==gridY)).forEach(e->{
			setAlign(halign, valign);
		});
	}
	public void alignCell(int gridX, int gridY, int halign, int valign) {
		componentAndLayoutConstraintsList.stream().filter(e->(e.getGbc().gridy==gridY && e.getGbc().gridx==gridX)).forEach(e->{
			setAlign(halign, valign);
		});
	}
	public void showAllLineBorder(Border border) {
		componentAndLayoutConstraintsList.stream().forEach(e->{
			for(JComponent jc : e.getComponents()) {
				jc.setBorder(border);
			}
		});
	}
	public JPanel newJPanelWithFlowLayout(int flowLayoutAlign) {
		JPanel jp = new JPanel();
		FlowLayout fl;
		switch(FlowLayout.LEFT){
		case FlowLayout.LEFT:
			fl = new FlowLayout(FlowLayout.LEFT);
		break;
		case  FlowLayout.CENTER:
			fl = new FlowLayout(FlowLayout.CENTER);
		break;
		case  FlowLayout.RIGHT:
			fl = new FlowLayout(FlowLayout.RIGHT);
		break;
		default :
			fl = new FlowLayout(FlowLayout.CENTER);
		break;
		}
		jp.setLayout(fl);
		return jp;
	}
	public JPanel newJPanelWithDefaultFlowLayout() {
		JPanel jp = new JPanel();
		FlowLayout fl;
		switch(DEFAULT_HORIZONTAL_ALIGN){
			case ALIGN_LEFT:
				fl = new FlowLayout(FlowLayout.LEFT);
			break;
			case ALIGN_CENTER:
				fl = new FlowLayout(FlowLayout.CENTER);
			break;
			case ALIGN_RIGHT:
				fl = new FlowLayout(FlowLayout.RIGHT);
			break;
			default :
				fl = new FlowLayout(FlowLayout.LEFT);
			break;
		}
		jp.setLayout(fl);
		return jp;
	}
	public void showData() {
		for (ComponentAndLayoutConstraints calc : componentAndLayoutConstraintsList) {
			if(calc.getComponents().length==1) {
				this.add(calc.getComponents()[0], calc.getGbc());
			}else if(calc.getComponents().length>1) {
				JPanel jp = newJPanelWithDefaultFlowLayout();
				for(JComponent jc : calc.getComponents()) {
					jp.add(jc);
				}
				this.add(jp, calc.getGbc());
			}
		}
	}
	public void cleanModelData() {
		componentAndLayoutConstraintsList.clear();
		this.removeAll();
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\ui\TablePane4Test.java---
package ui;
import javax.swing.*;
import java.awt.*;
public class TablePane4Test extends JFrame {
	public void init() {
		Container pane = getContentPane();
		BorderLayout bl = new BorderLayout();
		pane.setLayout(bl);
		JPanel jp = new JPanel();
		jp.setLayout(new FlowLayout(FlowLayout.CENTER));
		ModifierPanel tp = new ModifierPanel();
		pane.add(tp, BorderLayout.CENTER);
		tp.showData();
		setSize(640, 480);
		this.pack();
		this.setVisible(true);
		this.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
	    return ;
	}
	public static void main(String[] args) {
		TablePane4Test gt = new TablePane4Test();
		gt.init();
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\ui\TextAreaPane.java---
package ui;
import ui.model.TextAreaPaneModel;
import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.AdjustmentEvent;
import java.awt.event.AdjustmentListener;
public class TextAreaPane extends ParamPane {
	JScrollPane jScrollPane;
	public JTextArea textArea;
	private JPanel addtionalJpanel;
	private JButton removeOneBtn;
	private JButton clearAll;
	TextAreaPaneModel model;
	public TextAreaPane(TextAreaPaneModel model) {
		this.model = model;
		textArea = new JTextArea(model.getRows(), model.getColumns());
		FlowLayout fl = new FlowLayout(FlowLayout.LEFT);
		this.setLayout(fl);
		this.addComponent(paramLabel);
		this.addComponent(tipLabel);
		jScrollPane = new JScrollPane(textArea, ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS,
				ScrollPaneConstants.HORIZONTAL_SCROLLBAR_AS_NEEDED);
		this.addComponent(jScrollPane);
		addAdjustmentValueChangedListener();
		addtionalJpanel = new JPanel();
		BoxLayout bl = new BoxLayout(addtionalJpanel, BoxLayout.Y_AXIS);
		addtionalJpanel.setLayout(bl);
		removeOneBtn = new JButton("remove item");
		clearAll = new JButton("clear all");
		addtionalJpanel.add(clearAll);
		addtionalJpanel.add(removeOneBtn);
		clearAll.addActionListener(new ActionListener() {
			@Override
			public void actionPerformed(ActionEvent e) {
				textArea.setText("");
				model.setHowManyRowsInTextArea(0);
			}
		});
		removeOneBtn.addActionListener(new ActionListener() {
			@Override
			public void actionPerformed(ActionEvent e) {
			}
		});
		this.addComponent(addtionalJpanel);
	}
	public void addAdjustmentValueChangedListener() {
		JScrollBar vScrollBar = jScrollPane.getVerticalScrollBar();
		AdjustmentListener listener = new AdjustmentListener() {
			@Override
			public void adjustmentValueChanged(AdjustmentEvent e) {
				if (model.getHowManyRowsInTextArea() >= model.getRows()) {
					Adjustable adjustable = e.getAdjustable();
					int max = adjustable.getMaximum();
					adjustable.setValue(max);
				}
				vScrollBar.removeAdjustmentListener(this);
			}
		};
		vScrollBar.addAdjustmentListener(listener);
	}
	public JTextArea getTextArea() {
		return textArea;
	}
	public void setTextArea(JTextArea textArea) {
		this.textArea = textArea;
	}
	public JScrollPane getjScrollPane() {
		return jScrollPane;
	}
	@Override
	public JComponent getInputComponent() {
		return textArea;
	}
	public TextAreaPaneModel getModel() {
		return model;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\ui\TextFieldPane.java---
package ui;
import javax.swing.*;
public class TextFieldPane extends ParamPane {
	public JTextField textField;
	public TextFieldPane() {
		init(-1);
	}
	public TextFieldPane(int fieldSize) {
		init(fieldSize);
	}
	public void init(int fieldSize) {
		if(fieldSize == -1){
			textField= new JTextField();
		}else{
			textField= new JTextField(fieldSize);
		}
		this.addComponent(paramLabel);
		this.addComponent(tipLabel);
		this.addComponent(textField);
	}
	public JTextField getTextField() {
		return textField;
	}
	public void setTextField(JTextField textField) {
		this.textField = textField;
	}
	@Override
	public JComponent getInputComponent() {
		return textField;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\ui\UI.java---
package ui;
import codegen.eclipseRobot.DataModel;
import codegen.eclipseRobot.FilterCombBox;
import codegen.eclipseRobot.UIContext;
import codegen.util.Common;
import com.dgs.annotation.UIAnno;
import javax.swing.*;
import javax.swing.text.html.HTMLEditorKit;
import java.awt.*;
import java.awt.event.AdjustmentEvent;
import java.awt.event.AdjustmentListener;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.awt.image.BufferedImage;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.List;
public class UI extends WindowAdapter  {
	private JFrame frame;
	TablePane tablePane;
	private FilterCombBox jComboBox;
	private JPanel northPanel;
	private JPanel inputPanel;
	private JPanel centerPanel;
	private DataModel model;
	JScrollPane jScrollPane;
	HtmlEditorPane editorPane;
	HTMLEditorKit kit;
	public UI(DataModel model) {
		super();
		this.model = model;
	}
	public void initView() {
		frame = new JFrame();
		frame.addWindowListener(this);
		Dimension d = Toolkit.getDefaultToolkit().getScreenSize();
		double width = d.getWidth();
		double height = d.getHeight();
		int frameWidth = 400;
		int taskBarTopY = tryGetTaskBarTopY(height);
		if (taskBarTopY == -1) {
			taskBarTopY = 80;
		}
		int frameHeight = taskBarTopY - 1;
		int frameX = (int) (width - frameWidth);
		int frameY = 0;
		frame.setSize(frameWidth, frameHeight);
		frame.setLocation(frameX, frameY);
		UIContext.frameX = frameX;
		UIContext.frameY = frameY;
		frame.getContentPane().setLayout(new BorderLayout());
		jComboBox = new FilterCombBox((List)this.model.getItems());
		jComboBox.setEditable(true);
		northPanel = new JPanel();
		northPanel.setLayout(new BorderLayout());
		tablePane = new TablePane(TablePane.ALIGN_LEFT, TablePane.ALIGN_MIDDLE);
		inputPanel = new JPanel();
		inputPanel.setLayout(new BorderLayout());
		frame.getContentPane().add(northPanel, BorderLayout.NORTH);
		northPanel.add(jComboBox, BorderLayout.NORTH);
		northPanel.add(inputPanel, BorderLayout.CENTER);
		centerPanel = new JPanel();
		centerPanel.setLayout(new BorderLayout());
		/*
		 * centerPanel.setLayout(new FlowLayout(FlowLayout.LEFT)); JPanel contentPanel =
		 * new JPanel(); contentPanel.setLayout(new
		 * BoxLayout(contentPanel,BoxLayout.X_AXIS)); centerPanel.add(contentPanel);
		 */
		kit = new HTMLEditorKit();
		editorPane = new HtmlEditorPane(this.model);
		editorPane.setEditable(false);
		jScrollPane = new JScrollPane(editorPane, ScrollPaneConstants.VERTICAL_SCROLLBAR_AS_NEEDED,
				ScrollPaneConstants.HORIZONTAL_SCROLLBAR_AS_NEEDED);
		System.out.println("going to create ActivatedHyperlinkListener ");
		editorPane.setContentType("text/html");
		editorPane.setEditorKit(kit);
		System.out.println("end create editorPane ");
		centerPanel.add(jScrollPane, BorderLayout.CENTER);
		frame.getContentPane().add(centerPanel, BorderLayout.CENTER);
		this.frame.setDefaultCloseOperation(WindowConstants.DO_NOTHING_ON_CLOSE);
		this.frame.setVisible(true);
		this.frame.setAlwaysOnTop(true);
		this.frame.toFront();
		this.frame.requestFocus();
	}
	public void addRowInHtmlEditorPane(String s) {
		this.editorPane.addRow(s);
	}
	public void addAdjustmentValueChangedListener(JScrollPane jScrollPane) {
		JScrollBar vScrollBar = jScrollPane.getVerticalScrollBar();
		AdjustmentListener listener = new AdjustmentListener() {
			@Override
			public void adjustmentValueChanged(AdjustmentEvent e) {
				Adjustable adjustable = e.getAdjustable();
				int max = adjustable.getMaximum();
				adjustable.setValue(max);
				vScrollBar.removeAdjustmentListener(this);
			}
		};
		vScrollBar.addAdjustmentListener(listener);
	}
	public void refeedFilterCombBox() {
		this.jComboBox.resetArray((List)this.model.getItems());
		return;
	}
	public Integer tryGetTaskBarTopY(double screenHeight) {
		Integer taskBarTopY = 1000;
		return taskBarTopY;
	}
	public void show(DataModel model) {
		if (model.getMethods() == null || model.getMethods().length == 0) {
			return;
		}
		Method m = model.getSelectedMethod();
		if (m != null) {
			inputPanel.removeAll();
			if(null!=tablePane) {
				tablePane.cleanModelData();
			}
		}
		UIAnno[] uiAnno = m.getAnnotationsByType(UIAnno.class);
		if(uiAnno.length>0) {
			try {
				Class[] vs = Common.getClassByName(uiAnno[0].uiClz());
				if(vs.length>0) {
					Constructor[] cts = vs[0].getConstructors();
					Constructor defaultCt = null;
					for(Constructor ct : cts) {
						if(ct.getParameterCount()==0) {
							defaultCt = ct;
							break;
						}
					}
					if(null!=defaultCt) {
						JPanel jp = (JPanel) defaultCt.newInstance();
						tablePane.newRow();
						tablePane.addComponent(jp);
					}
				}
			} catch (InstantiationException | IllegalAccessException | IllegalArgumentException
					| InvocationTargetException | SecurityException e) {
				e.printStackTrace();
			}
		}else {
			MethodTypePane tp = new MethodTypePane();
			tp.showData();
			tablePane.newRow();
			tablePane.addComponent(tp);
		}
		tablePane.showData();
		JPanel jp = new JPanel();
		jp.setLayout(new FlowLayout(FlowLayout.LEFT));
		jp.add(tablePane);
		inputPanel.add(jp);
		inputPanel.updateUI();
		return;
	}
	public String getSeletedItem() {
		return (String) jComboBox.getSelectedItem();
	}
	@Override
	public void windowClosing(WindowEvent e) {
		this.frame.dispose();
		System.exit(0);
	}
	public DataModel getModel() {
		return model;
	}
	public void setModel(DataModel model) {
		this.model = model;
	}
	public FilterCombBox getjComboBox() {
		return jComboBox;
	}
	public HtmlEditorPane getEditorPane() {
		return editorPane;
	}
	public HTMLEditorKit getKit() {
		return kit;
	}
	public TablePane getTablePane() {
		return tablePane;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\ui\validation\MandatoryCheck.java---
package ui.validation;
public class MandatoryCheck implements Validation{
	public ViolationResultItem check(ValidatablePane component, Object val) {
		ViolationResultItem vri = new ViolationResultItem();
		if(val==null || "".equals(val.toString().trim())){
			vri.setTip(component.getComponentName() +" cannot be blank");
		}else{
			vri.setPass(true);
		}
		return vri;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\ui\validation\ModifierCheck.java---
package ui.validation;
import java.util.BitSet;
public class ModifierCheck  implements Validation{
	public ModifierCheck() {
	}
	@Override
	public ViolationResultItem check(ValidatablePane validatablePane, Object val) {
		ViolationResultItem vri = new ViolationResultItem();
		BitSet bs = (BitSet) val;
		if(bs.isEmpty()){
			vri.setTip(validatablePane.getParamLabel().getText() +" cannot be blank");
		}else{
			vri.setPass(true);
		}
		return vri;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\ui\validation\NotVisibleInUI.java---
package ui.validation;
import java.lang.annotation.Documented;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Deprecated
public @interface NotVisibleInUI {
}
----strat of file D:\projects\cg\cg-min\src\main\java\ui\validation\ValidatableArraySupportClassCombBoxpane.java---
package ui.validation;
import ui.ArraySupportClassCombBoxpane;
import java.util.List;
public class ValidatableArraySupportClassCombBoxpane extends ArraySupportClassCombBoxpane implements ValidatablePane {
	public ValidatableArraySupportClassCombBoxpane(List<String> strList) {
		super(strList);
	}
	@Override
	public Validation getValidation() {
		return null;
	}
	@Override
	public String getComponentName() {
		return null;
	}
	@Override
	public ViolationResultItem validateVal() {
		return null;
	}
	@Override
	public void removeMark() {
	}
	@Override
	public void markInvaidInput() {
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\ui\validation\ValidatableArraySupportReturnTypeCombBoxPane.java---
package ui.validation;
import ui.ArraySupportReturnTypeCombBoxPane;
import javax.swing.*;
public class ValidatableArraySupportReturnTypeCombBoxPane extends ArraySupportReturnTypeCombBoxPane
		implements ValidatablePane {
	@Override
	public JComponent getInputComponent() {
		return null;
	}
	@Override
	public JLabel getParamLabel() {
		return null;
	}
	@Override
	public JLabel getTipLabel() {
		return null;
	}
	@Override
	public Validation getValidation() {
		return null;
	}
	@Override
	public String getComponentName() {
		return null;
	}
	@Override
	public ViolationResultItem validateVal() {
		return null;
	}
	@Override
	public void removeMark() {
	}
	@Override
	public void markInvaidInput() {
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\ui\validation\ValidatableFilePane.java---
package ui.validation;
import ui.FilePane;
import javax.swing.*;
import javax.swing.border.Border;
import java.awt.*;
public class ValidatableFilePane extends FilePane implements ValidatablePane {
	Validation va;
	public ValidatableFilePane(Validation va, int fieldSize, boolean chooseDirOnly) {
		super(fieldSize, chooseDirOnly);
		this.va = va;
	}
	@Override
	public Validation getValidation() {
		return va;
	}
	@Override
	public String getComponentName() {
		return this.getName();
	}
	@Override
	public ViolationResultItem validateVal() {
		return va.check(this, this.getTextField().getText().trim());
	}
	@Override
	public void removeMark() {
		this.setBorder(null);
	}
	@Override
	public void markInvaidInput() {
		Border b = BorderFactory.createLineBorder(Color.red);
		this.setBorder(b);
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\ui\validation\ValidatableModifierPanel.java---
package ui.validation;
import ui.ModifierPanel;
import javax.swing.*;
import javax.swing.border.Border;
import java.awt.*;
public class ValidatableModifierPanel extends ModifierPanel  implements ValidatablePane{
	Validation va;
	public ValidatableModifierPanel(Validation va) {
		super();
		this.va = va;
	}
	@Override
	public Validation getValidation() {
		return va;
	}
	@Override
	public String getComponentName() {
		return this.getName();
	}
	@Override
	public ViolationResultItem validateVal() {
		return va.check(this, this.getVal());
	}
	@Override
	public void removeMark() {
		this.setBorder(null);
	}
	@Override
	public void markInvaidInput() {
		Border b = BorderFactory.createLineBorder(Color.red);
		this.setBorder(b);
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\ui\validation\ValidatablePane.java---
package ui.validation;
import ui.IParamPane;
public interface ValidatablePane extends IParamPane {
	public Validation getValidation();
	public String getComponentName();
	public ViolationResultItem validateVal();
	public void removeMark();
	public void markInvaidInput();
}
----strat of file D:\projects\cg\cg-min\src\main\java\ui\validation\ValidatableTextAreaPane.java---
package ui.validation;
import ui.TextAreaPane;
import ui.model.TextAreaPaneModel;
import javax.swing.*;
import javax.swing.border.Border;
import java.awt.*;
public class ValidatableTextAreaPane extends TextAreaPane implements ValidatablePane {
	public ValidatableTextAreaPane(Validation va, TextAreaPaneModel model) {
		super(model);
		this.va = va;
	}
	Validation va;
	public void removeMark() {
		this.textArea.setBorder(null);
	}
	public void markInvaidInput() {
		Border b = BorderFactory.createLineBorder(Color.red);
		this.textArea.setBorder(b);
	}
	public ViolationResultItem validateVal() {
		return va.check(this, textArea.getText());
	}
	@Override
	public String getComponentName() {
		return this.getName();
	}
	@Override
	public Validation getValidation() {
		return va;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\ui\validation\ValidatableTextFieldPane.java---
package ui.validation;
import ui.TextFieldPane;
import javax.swing.*;
import javax.swing.border.Border;
import java.awt.*;
public class ValidatableTextFieldPane extends TextFieldPane implements ValidatablePane {
	Validation va;
	public ValidatableTextFieldPane(Validation va, int fieldSize) {
		super(fieldSize);
		this.va = va;
	}
	public ViolationResultItem validateVal() {
		return va.check(this, textField.getText());
	}
	public void removeMark() {
		textField.setBorder(null);
	}
	public void markInvaidInput() {
		Border b = BorderFactory.createLineBorder(Color.red);
		textField.setBorder(b);
	}
	@Override
	public String getComponentName() {
		return textField.getName();
	}
	@Override
	public Validation getValidation() {
		return va;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\ui\validation\Validation.java---
package ui.validation;
public interface Validation {
	public ViolationResultItem check(ValidatablePane validatablePane, Object val);
}
----strat of file D:\projects\cg\cg-min\src\main\java\ui\validation\ValidationAnn.java---
package ui.validation;
import java.lang.annotation.Documented;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface ValidationAnn {
	String[] validations() default {};;
}
----strat of file D:\projects\cg\cg-min\src\main\java\ui\validation\ValidationResult.java---
package ui.validation;
import java.util.ArrayList;
import java.util.List;
public class ValidationResult {
	List<ViolationResultItem> validationViolations = new ArrayList<>();
	public List<ViolationResultItem> getValidationViolations() {
		return validationViolations;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\ui\validation\ValidationViolation.java---
package ui.validation;
public class ValidationViolation {
	public ValidationViolation() {
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\ui\validation\ValueCheck.java---
package ui.validation;
public class ValueCheck implements Validation{
	public ViolationResultItem check(ValidatablePane component, Object val) {
		ViolationResultItem vri = new ViolationResultItem();
		if(val==null || "".equals(val.toString().trim())){
			vri.setTip(component.getParamLabel().getText() +" cannot be blank");
		}else{
			vri.setPass(true);
		}
		return vri;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\ui\validation\VdalidatableCreateAnnotationPanel.java---
package ui.validation;
import ui.ParamPane;
import javax.swing.*;
public class VdalidatableCreateAnnotationPanel extends ParamPane implements ValidatablePane {
	private JCheckBox document;
	private JCheckBox retention;
	private JCheckBox finalBox;
	@Override
	public JComponent getInputComponent() {
		return null;
	}
	@Override
	public Validation getValidation() {
		return null;
	}
	@Override
	public String getComponentName() {
		return null;
	}
	@Override
	public ViolationResultItem validateVal() {
		return null;
	}
	@Override
	public void removeMark() {
	}
	@Override
	public void markInvaidInput() {
	}
}
----strat of file D:\projects\cg\cg-min\src\main\java\ui\validation\ViolationResultItem.java---
package ui.validation;
public class ViolationResultItem {
	private boolean pass;
	private String tip;
	private Object obj;
	public ViolationResultItem() {
	}
	public String getTip() {
		return tip;
	}
	public void setTip(String tip) {
		this.tip = tip;
	}
	public Object getObj() {
		return obj;
	}
	public void setObj(Object obj) {
		this.obj = obj;
	}
	public boolean isPass() {
		return pass;
	}
	public void setPass(boolean pass) {
		this.pass = pass;
	}
}
----strat of file D:\projects\cg\cg-min\src\main\resources\application.yml---
## Development configuration
server:
  port: 8082
  servlet:
    contextPath: /test
spring:
  main:
    allow-bean-definition-overriding: true
  application:
    name: example
  security:
    enabled: false
  mvc:
    view:
      prefix: /WEB-INF/jsp/
      suffix: .jsp
  datasource:
    #platform: oracle
    #url: jdbc:oracle:thin:@hostname:1521:dbname
    #username:
    ##password: ''
    #password:
    #driver-class-name: oracle.jdbc.OracleDriver
    #type: com.zaxxer.hikari.HikariDataSource
    #hikari:
    #minimumIdle: 1
    #maximumPoolSize: 20
    #idleTimeout: 60000
    #poolName: SpringBootJPAHikariCP
    #maxLifetime: 2000000
    #connectionTimeout: 30000
    driver-class-name: org.h2.Driver
    username:
    password:
    url: jdbc:h2:file:D:/bb
    #url: jdbc:h2:mem:test_db
    #url: jdbc:h2:tcp://dbserv:8084/~/test_db
  h2:
    console:
      enabled: true
      #access h2-console via link http://localhost:8080/test/h2-console/
      path: /h2-console
----strat of file D:\projects\cg\cg-min\src\main\resources\tableforpanel.html---
<html>
<head>
<!-- <link rel="stylesheet" type="text/css" href="css.css" > -->
<style>
.divTable {
  display: table;         
  width: auto;         
  background-color: #eee;         
  border: 1px solid #666666;         
  border-spacing: 5px; /* cellspacing:poor IE support for  this */
}
</style>
</head>
<body>
	<form id="form1">
		<table>
			<tr id="trstart">
			<td><a href="?action=clear">clear</a>&nbsp;<a href="?action=reload">reload</a></td>
			</tr>
		</table>
	</form>
</body>
</html>
----strat of file D:\projects\cg\cg-min\src\pom.xml---
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>
  <groupId>cg</groupId>
  <artifactId>cgm</artifactId>
  <version>1.0</version>
  <packaging>jar</packaging>
  <properties>
    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
<!--    <org.apache.maven.plugins.maven-assembly-plugin.version>2.6</org.apache.maven.plugins.maven-assembly-plugin.version>-->
     <maven.compiler.source>1.8</maven.compiler.source>
    <maven.compiler.target>1.8</maven.compiler.target>
      <aetherVersion>1.1.0</aetherVersion>
      <mavenVersion>3.3.9</mavenVersion>
<!--    <junit.jupiter.version>5.5.2</junit.jupiter.version>-->
<!--    <junit.platform.version>1.5.2</junit.platform.version>-->
  </properties>
  <dependencies>
      <!-- maven realted -->
      <dependency>
          <groupId>com.jcabi</groupId>
          <artifactId>jcabi-aether</artifactId>
          <version>0.10.1</version>
      </dependency>
      <dependency>
          <groupId>org.codehaus.plexus</groupId>
          <artifactId>plexus-utils</artifactId>
          <version>3.0.15</version>
      </dependency>
      <dependency>
          <groupId>org.apache.maven</groupId>
          <artifactId>maven-model</artifactId>
          <version>3.0.4</version>
      </dependency>
      <dependency>
          <groupId>org.apache.maven</groupId>
          <version>3.0.4</version>
          <artifactId>maven-core</artifactId>
      </dependency>
<!--      <dependency>-->
<!--          <groupId>com.github.artifactresolver</groupId>-->
<!--          <version>0.3</version>-->
<!--          <artifactId>mvn-dependency-downloader</artifactId>-->
<!--          <exclusions>-->
<!--              <exclusion>-->
<!--                  <groupId>org.eclipse.aether</groupId>-->
<!--                  <artifactId>aether-impl</artifactId>-->
<!--              </exclusion>-->
<!--          </exclusions>-->
<!--      </dependency>-->
<!--      <dependency>-->
<!--          <groupId>org.eclipse.aether</groupId>-->
<!--          <artifactId>aether-impl-custom</artifactId>-->
<!--          <version>${aetherVersion}</version>-->
<!--      </dependency>-->
      <dependency>
          <groupId>org.eclipse.aether</groupId>
          <artifactId>aether-api</artifactId>
          <version>${aetherVersion}</version>
      </dependency>
      <dependency>
          <groupId>org.eclipse.aether</groupId>
          <artifactId>aether-util</artifactId>
          <version>${aetherVersion}</version>
      </dependency>
      <dependency>
          <groupId>org.eclipse.aether</groupId>
          <artifactId>aether-connector-basic</artifactId>
          <version>${aetherVersion}</version>
      </dependency>
      <dependency>
          <groupId>org.eclipse.aether</groupId>
          <artifactId>aether-transport-file</artifactId>
          <version>${aetherVersion}</version>
      </dependency>
      <dependency>
          <groupId>org.eclipse.aether</groupId>
          <artifactId>aether-transport-http</artifactId>
          <version>${aetherVersion}</version>
      </dependency>
      <dependency>
          <groupId>org.eclipse.aether</groupId>
          <artifactId>aether-transport-wagon</artifactId>
          <version>${aetherVersion}</version>
      </dependency>
      <dependency>
          <groupId>org.apache.maven</groupId>
          <artifactId>maven-aether-provider</artifactId>
          <version>${mavenVersion}</version>
          <exclusions>
              <exclusion>
                  <groupId>org.eclipse.aether</groupId>
                  <artifactId>aether-impl</artifactId>
              </exclusion>
          </exclusions>
      </dependency>
      <dependency>
          <groupId>com.h2database</groupId>
          <artifactId>h2</artifactId>
          <version>1.4.200</version>
      </dependency>
<!--      <dependency>-->
<!--          <groupId>qj.blog</groupId>-->
<!--          <artifactId>classreloading</artifactId>-->
<!--          <version>1.0-SNAPSHOT</version>-->
<!--      </dependency>-->
      <dependency>
          <groupId>org.apache.maven</groupId>
          <artifactId>maven-model</artifactId>
          <version>3.3.9</version>
      </dependency>
	  <dependency>
		  <groupId>net.java.dev.jna</groupId>
		  <artifactId>jna</artifactId>
		  <version>5.5.0</version>
	  </dependency>
	  <dependency>
		  <groupId>net.java.dev.jna</groupId>
		  <artifactId>jna-platform</artifactId>
		  <version>5.5.0</version>
	  </dependency>
      <!--below is for class loading-->
      <dependency>
          <groupId>de.neuland-bfi</groupId>
          <artifactId>jade4j</artifactId>
          <version>0.4.0</version>
      </dependency>
      <dependency>
          <groupId>javax</groupId>
          <artifactId>javaee-api</artifactId>
          <version>7.0</version>
      </dependency>
      <dependency>
          <groupId>org.eclipse.jetty</groupId>
          <artifactId>jetty-server</artifactId>
          <version>9.2.2.v20140723</version>
      </dependency>
      <dependency>
          <groupId>org.eclipse.jetty</groupId>
          <artifactId>jetty-servlet</artifactId>
          <version>9.2.2.v20140723</version>
      </dependency>
      <dependency>
          <groupId>org.eclipse.jetty</groupId>
          <artifactId>jetty-webapp</artifactId>
          <version>9.2.2.v20140723</version>
          <scope>test</scope>
      </dependency>
      <dependency>
          <groupId>org.xerial</groupId>
          <artifactId>sqlite-jdbc</artifactId>
          <version>3.8.7</version>
      </dependency>
      <dependency>
          <groupId>com.google.code.gson</groupId>
          <artifactId>gson</artifactId>
          <version>2.3</version>
      </dependency>
      <!--for replace mvn-dependency-downloader artifactor-->
      <dependency>
          <groupId>org.eclipse.aether</groupId>
          <artifactId>aether-api</artifactId>
          <version>${aetherVersion}</version>
      </dependency>
      <dependency>
          <groupId>org.eclipse.aether</groupId>
          <artifactId>aether-util</artifactId>
          <version>${aetherVersion}</version>
      </dependency>
      <dependency>
          <groupId>org.eclipse.aether</groupId>
          <artifactId>aether-impl</artifactId>
          <version>${aetherVersion}</version>
      </dependency>
      <dependency>
          <groupId>org.eclipse.aether</groupId>
          <artifactId>aether-connector-basic</artifactId>
          <version>${aetherVersion}</version>
      </dependency>
      <dependency>
          <groupId>org.eclipse.aether</groupId>
          <artifactId>aether-transport-file</artifactId>
          <version>${aetherVersion}</version>
      </dependency>
      <dependency>
          <groupId>org.eclipse.aether</groupId>
          <artifactId>aether-transport-http</artifactId>
          <version>${aetherVersion}</version>
      </dependency>
      <dependency>
          <groupId>org.eclipse.aether</groupId>
          <artifactId>aether-transport-wagon</artifactId>
          <version>${aetherVersion}</version>
      </dependency>
      <dependency>
          <groupId>org.apache.maven</groupId>
          <artifactId>maven-aether-provider</artifactId>
          <version>${mavenVersion}</version>
      </dependency>
      <dependency>
          <groupId>com.googlecode.json-simple</groupId>
          <artifactId>json-simple</artifactId>
          <version>1.1.1</version>
      </dependency>
      <dependency>
          <groupId>commons-cli</groupId>
          <artifactId>commons-cli</artifactId>
          <version>1.3.1</version>
      </dependency>
      <dependency>
          <groupId>commons-io</groupId>
          <artifactId>commons-io</artifactId>
          <version>2.4</version>
      </dependency>
      <dependency>
          <groupId>ch.qos.logback</groupId>
          <artifactId>logback-classic</artifactId>
          <version>1.1.6</version>
      </dependency>
      <dependency>
          <groupId>org.slf4j</groupId>
          <artifactId>slf4j-api</artifactId>
          <version>1.7.18</version>
      </dependency>
<!--    <dependency>-->
<!--      <groupId>com.github.javafaker</groupId>-->
<!--      <artifactId>javafaker</artifactId>-->
<!--      <version>1.0.2</version>-->
<!--      <scope>test</scope>-->
<!--    </dependency>-->
<!--    <dependency>-->
<!--      <groupId>uk.co.jemos.podam</groupId>-->
<!--      <artifactId>podam</artifactId>-->
<!--      <version>7.2.3.RELEASE</version>-->
<!--      <scope>test</scope>-->
<!--    </dependency>-->
  </dependencies>
<!--  <build>-->
<!--  	<plugins>-->
<!--  		<plugin>-->
<!--  			<groupId>org.apache.maven.plugins</groupId>-->
<!--			  <artifactId>maven-assembly-plugin</artifactId>-->
<!--			  <version>${org.apache.maven.plugins.maven-assembly-plugin.version}</version>-->
<!--			  <configuration>-->
<!--			  	<descriptorRefs>-->
<!--			  		<descriptorRef>jar-with-dependencies</descriptorRef>-->
<!--			  	</descriptorRefs>-->
<!--			  </configuration>-->
<!--			  <executions>-->
<!--			  	<execution>-->
<!--			  		<id>make-assembly</id>-->
<!--			  		<phase>package</phase>-->
<!--			  		<goals>-->
<!--			  			<goal>single</goal>-->
<!--			  		</goals>-->
<!--			  	</execution>-->
<!--			  </executions>-->
<!--  		</plugin>-->
<!--  		<plugin>-->
<!--	  		<artifactId>maven-source-plugin</artifactId>-->
<!--	  		<executions>-->
<!--	  			<execution>-->
<!--	  				<id>attach-source</id>-->
<!--	  				<phase>verify</phase>-->
<!--	  				<goals>-->
<!--	  					<goal>jar</goal>-->
<!--	  				</goals>-->
<!--	  			</execution>-->
<!--	  		</executions>-->
<!--  		</plugin>-->
<!--  	</plugins>-->
<!--  </build>-->
</project>
